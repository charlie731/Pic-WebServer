CCS PCH C Compiler, Version 5.048, 5967               06-oct-15 10:23

               Filename:   D:\Users\CHARLY\Desktop\Pic WebServer\server.lst

               ROM used:   64042 bytes (98%)
                           Largest free fragment is 1490
               RAM used:   1461 (37%) at main() level
                           1630 (41%) worst case
               Stack used: 9 locations (8 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   AF2C
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   0134
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVFF  15,FF5
0009A:  MOVFF  16,FF6
0009E:  MOVFF  17,FF7
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
.................... #include <server.h> 
.................... #include <18F4620.h> 
.................... //////////// Standard Header file for the PIC18F4620 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4620 
000AE:  CLRF   FF7
000B0:  ADDLW  BE
000B2:  MOVWF  FF6
000B4:  MOVLW  00
000B6:  ADDWFC FF7,F
000B8:  TBLRD*+
000BA:  MOVF   FF5,W
000BC:  RETURN 0
000BE:  DATA 62,75
000C0:  DATA 74,74
000C2:  DATA 6F,6E
000C4:  DATA 30,30
000C6:  DATA 00,00
000C8:  CLRF   FF7
000CA:  ADDLW  D8
000CC:  MOVWF  FF6
000CE:  MOVLW  00
000D0:  ADDWFC FF7,F
000D2:  TBLRD*+
000D4:  MOVF   FF5,W
000D6:  RETURN 0
000D8:  DATA 62,75
000DA:  DATA 74,74
000DC:  DATA 6F,6E
000DE:  DATA 30,31
000E0:  DATA 00,00
000E2:  CLRF   FF7
000E4:  ADDLW  F2
000E6:  MOVWF  FF6
000E8:  MOVLW  00
000EA:  ADDWFC FF7,F
000EC:  TBLRD*+
000EE:  MOVF   FF5,W
000F0:  RETURN 0
000F2:  DATA 62,75
000F4:  DATA 74,74
000F6:  DATA 6F,6E
000F8:  DATA 30,32
000FA:  DATA 00,00
000FC:  CLRF   FF7
000FE:  ADDLW  0C
00100:  MOVWF  FF6
00102:  MOVLW  01
00104:  ADDWFC FF7,F
00106:  TBLRD*+
00108:  MOVF   FF5,W
0010A:  RETURN 0
0010C:  DATA 62,75
0010E:  DATA 74,74
00110:  DATA 6F,6E
00112:  DATA 30,33
00114:  DATA 00,00
*
0013A:  DATA 48,54
0013C:  DATA 54,50
0013E:  DATA 2F,31
00140:  DATA 2E,31
00142:  DATA 20,25
00144:  DATA 4C,55
00146:  DATA 20,00
00148:  DATA 41,75
0014A:  DATA 74,68
0014C:  DATA 6F,72
0014E:  DATA 69,7A
00150:  DATA 61,74
00152:  DATA 69,6F
00154:  DATA 6E,20
00156:  DATA 52,65
00158:  DATA 71,75
0015A:  DATA 69,72
0015C:  DATA 65,64
0015E:  DATA 00,00
00160:  DATA 4E,6F
00162:  DATA 74,20
00164:  DATA 46,6F
00166:  DATA 75,6E
00168:  DATA 64,00
0016A:  DATA 53,65
0016C:  DATA 72,76
0016E:  DATA 65,72
00170:  DATA 20,45
00172:  DATA 72,72
00174:  DATA 6F,72
00176:  DATA 00,00
00178:  DATA 57,57
0017A:  DATA 57,2D
0017C:  DATA 41,75
0017E:  DATA 74,68
00180:  DATA 65,6E
00182:  DATA 74,69
00184:  DATA 63,61
00186:  DATA 74,65
00188:  DATA 3A,20
0018A:  DATA 42,61
0018C:  DATA 73,69
0018E:  DATA 63,20
00190:  DATA 72,65
00192:  DATA 61,6C
00194:  DATA 6D,3D
00196:  DATA 22,41
00198:  DATA 75,74
0019A:  DATA 68,6F
0019C:  DATA 72,69
0019E:  DATA 7A,61
001A0:  DATA 74,69
001A2:  DATA 6F,6E
001A4:  DATA 20,52
001A6:  DATA 65,71
001A8:  DATA 75,69
001AA:  DATA 72,65
001AC:  DATA 64,22
001AE:  DATA 0D,0A
001B0:  DATA 00,00
001B2:  DATA 43,6F
001B4:  DATA 6E,74
001B6:  DATA 65,6E
001B8:  DATA 74,2D
001BA:  DATA 54,79
001BC:  DATA 70,65
001BE:  DATA 3A,20
001C0:  DATA 00,00
001C2:  DATA 4C,61
001C4:  DATA 73,74
001C6:  DATA 2D,4D
001C8:  DATA 6F,64
001CA:  DATA 69,66
001CC:  DATA 69,65
001CE:  DATA 64,3A
001D0:  DATA 20,54
001D2:  DATA 75,65
001D4:  DATA 2C,20
001D6:  DATA 31,35
001D8:  DATA 20,4E
001DA:  DATA 6F,76
001DC:  DATA 20,31
001DE:  DATA 39,39
001E0:  DATA 34,20
001E2:  DATA 31,32
001E4:  DATA 3A,34
001E6:  DATA 35,3A
001E8:  DATA 32,36
001EA:  DATA 20,47
001EC:  DATA 4D,54
001EE:  DATA 0D,0A
001F0:  DATA 00,00
001F2:  DATA 43,61
001F4:  DATA 63,68
001F6:  DATA 65,2D
001F8:  DATA 43,6F
001FA:  DATA 6E,74
001FC:  DATA 72,6F
001FE:  DATA 6C,3A
00200:  DATA 20,6E
00202:  DATA 6F,2D
00204:  DATA 63,61
00206:  DATA 63,68
00208:  DATA 65,0D
0020A:  DATA 0A,00
0020C:  DATA 43,6F
0020E:  DATA 6E,6E
00210:  DATA 65,63
00212:  DATA 74,69
00214:  DATA 6F,6E
00216:  DATA 3A,20
00218:  DATA 63,6C
0021A:  DATA 6F,73
0021C:  DATA 65,0D
0021E:  DATA 0A,00
00220:  DATA 65,72
00222:  DATA 72,6F
00224:  DATA 72,35
00226:  DATA 30,30
00228:  DATA 2E,68
0022A:  DATA 74,6D
0022C:  DATA 00,00
0022E:  DATA 3C,68
00230:  DATA 74,6D
00232:  DATA 6C,3E
00234:  DATA 3C,62
00236:  DATA 6F,64
00238:  DATA 79,3E
0023A:  DATA 3C,68
0023C:  DATA 31,3E
0023E:  DATA 35,30
00240:  DATA 30,20
00242:  DATA 45,72
00244:  DATA 72,6F
00246:  DATA 72,3C
00248:  DATA 2F,68
0024A:  DATA 31,3E
0024C:  DATA 3C,68
0024E:  DATA 72,3E
00250:  DATA 3C,70
00252:  DATA 3E,49
00254:  DATA 6E,74
00256:  DATA 65,72
00258:  DATA 6E,61
0025A:  DATA 6C,20
0025C:  DATA 73,65
0025E:  DATA 72,76
00260:  DATA 65,72
00262:  DATA 20,65
00264:  DATA 72,72
00266:  DATA 6F,72
00268:  DATA 2E,3C
0026A:  DATA 2F,70
0026C:  DATA 3E,3C
0026E:  DATA 2F,62
00270:  DATA 6F,64
00272:  DATA 79,3E
00274:  DATA 3C,2F
00276:  DATA 68,74
00278:  DATA 6D,6C
0027A:  DATA 3E,00
0027C:  DATA 69,6E
0027E:  DATA 64,65
00280:  DATA 78,2E
00282:  DATA 68,74
00284:  DATA 6D,00
00286:  DATA 65,72
00288:  DATA 72,6F
0028A:  DATA 72,34
0028C:  DATA 30,34
0028E:  DATA 2E,68
00290:  DATA 74,6D
00292:  DATA 00,00
00294:  DATA 65,72
00296:  DATA 72,6F
00298:  DATA 72,35
0029A:  DATA 30,30
0029C:  DATA 2E,68
0029E:  DATA 74,6D
002A0:  DATA 00,00
002A2:  DATA 65,72
002A4:  DATA 72,6F
002A6:  DATA 72,35
002A8:  DATA 30,30
002AA:  DATA 2E,68
002AC:  DATA 74,6D
002AE:  DATA 00,00
002B0:  DATA 65,72
002B2:  DATA 72,6F
002B4:  DATA 72,35
002B6:  DATA 30,30
002B8:  DATA 2E,68
002BA:  DATA 74,6D
002BC:  DATA 00,00
*
00A5A:  TSTFSZ 01
00A5C:  BRA    0A64
00A5E:  TSTFSZ 02
00A60:  BRA    0A66
00A62:  BRA    0A72
00A64:  INCF   02,F
00A66:  MOVFF  00,FEE
00A6A:  DECFSZ 01,F
00A6C:  BRA    0A66
00A6E:  DECFSZ 02,F
00A70:  BRA    0A66
00A72:  RETURN 0
*
01856:  MOVLB  6
01858:  CLRF   x21
0185A:  CLRF   x22
0185C:  MOVLW  01
0185E:  MOVWF  x23
01860:  CLRF   FDA
01862:  CLRF   FD9
01864:  MOVLW  06
01866:  MOVWF  x26
01868:  MOVLW  19
0186A:  MOVWF  x25
0186C:  MOVLW  06
0186E:  MOVWF  FEA
01870:  MOVLW  1D
01872:  MOVWF  FE9
01874:  MOVFF  626,FE2
01878:  MOVFF  625,FE1
0187C:  MOVFF  623,624
01880:  BCF    FD8.0
01882:  MOVF   FE5,W
01884:  MULWF  FEE
01886:  MOVF   FF3,W
01888:  ADDWFC x21,F
0188A:  MOVF   FF4,W
0188C:  ADDWFC x22,F
0188E:  DECFSZ x24,F
01890:  BRA    1880
01892:  MOVFF  621,FDE
01896:  MOVFF  622,621
0189A:  CLRF   x22
0189C:  BTFSC  FD8.0
0189E:  INCF   x22,F
018A0:  INCF   x25,F
018A2:  BTFSC  FD8.2
018A4:  INCF   x26,F
018A6:  INCF   x23,F
018A8:  MOVF   x23,W
018AA:  SUBLW  05
018AC:  BNZ   186C
018AE:  MOVLB  0
018B0:  RETURN 0
018B2:  CLRF   01
018B4:  CLRF   02
018B6:  CLRF   00
018B8:  CLRF   03
018BA:  MOVLB  5
018BC:  MOVF   xCC,W
018BE:  BNZ   18C4
018C0:  MOVF   xCB,W
018C2:  BZ    18F4
018C4:  MOVLW  10
018C6:  MOVWF  xCD
018C8:  BCF    FD8.0
018CA:  RLCF   xC9,F
018CC:  RLCF   xCA,F
018CE:  RLCF   00,F
018D0:  RLCF   03,F
018D2:  MOVF   xCC,W
018D4:  SUBWF  03,W
018D6:  BNZ   18DC
018D8:  MOVF   xCB,W
018DA:  SUBWF  00,W
018DC:  BNC   18EC
018DE:  MOVF   xCB,W
018E0:  SUBWF  00,F
018E2:  BTFSS  FD8.0
018E4:  DECF   03,F
018E6:  MOVF   xCC,W
018E8:  SUBWF  03,F
018EA:  BSF    FD8.0
018EC:  RLCF   01,F
018EE:  RLCF   02,F
018F0:  DECFSZ xCD,F
018F2:  BRA    18C8
018F4:  MOVLB  0
018F6:  GOTO   1960 (RETURN)
*
02F58:  ADDWF  FE8,W
02F5A:  CLRF   FF7
02F5C:  RLCF   FF7,F
02F5E:  ADDLW  73
02F60:  MOVWF  FF6
02F62:  MOVLW  2F
02F64:  ADDWFC FF7,F
02F66:  TBLRD*-
02F68:  MOVF   FF5,W
02F6A:  MOVWF  FFA
02F6C:  TBLRD*
02F6E:  MOVF   FF5,W
02F70:  MOVWF  FF9
02F72:  DATA 74,2A
02F74:  DATA 78,2A
02F76:  DATA A8,2A
02F78:  DATA 5A,2B
02F7A:  DATA EE,2B
02F7C:  DATA 72,2C
02F7E:  DATA 74,2D
02F80:  DATA 26,2E
02F82:  DATA 7A,2E
02F84:  DATA 26,2E
02F86:  DATA 7A,2E
02F88:  DATA 26,2E
02F8A:  DATA 7A,2E
*
02FC2:  MOVLB  5
02FC4:  MOVF   xF3,W
02FC6:  MULWF  xF5
02FC8:  MOVFF  FF3,01
02FCC:  MOVFF  FF4,00
02FD0:  MULWF  xF6
02FD2:  MOVF   FF3,W
02FD4:  ADDWF  00,F
02FD6:  MOVF   xF4,W
02FD8:  MULWF  xF5
02FDA:  MOVF   FF3,W
02FDC:  ADDWFC 00,W
02FDE:  MOVWF  02
02FE0:  MOVLB  0
02FE2:  RETURN 0
*
0796A:  MOVFF  55F,FEA
0796E:  MOVFF  55E,FE9
07972:  MOVLB  5
07974:  MOVFF  5F9,FEF
07978:  INCF   FE9,F
0797A:  BTFSC  FD8.2
0797C:  INCF   FEA,F
0797E:  CLRF   FEF
07980:  INCF   x5E,F
07982:  BTFSC  FD8.2
07984:  INCF   x5F,F
07986:  MOVLB  0
07988:  RETURN 0
0798A:  TBLRD*+
0798C:  MOVF   FF5,F
0798E:  BZ    79A8
07990:  MOVFF  FF6,5D7
07994:  MOVFF  FF7,5D8
07998:  MOVFF  FF5,5F9
0799C:  RCALL  796A
0799E:  MOVFF  5D7,FF6
079A2:  MOVFF  5D8,FF7
079A6:  BRA    798A
079A8:  RETURN 0
*
07A24:  MOVFF  657,01
07A28:  MOVFF  656,00
07A2C:  TSTFSZ 00
07A2E:  INCF   01,F
07A30:  TBLRD*+
07A32:  MOVFF  FF5,FEE
07A36:  DECFSZ 00,F
07A38:  BRA    7A30
07A3A:  DECFSZ 01,F
07A3C:  BRA    7A30
07A3E:  CLRF   FF8
07A40:  RETURN 0
*
08CCE:  TBLRD*+
08CD0:  MOVFF  FF6,5D8
08CD4:  MOVFF  FF7,5D9
08CD8:  MOVFF  FF5,5EC
08CDC:  RCALL  8CBC
08CDE:  MOVFF  5D8,FF6
08CE2:  MOVFF  5D9,FF7
08CE6:  MOVLB  5
08CE8:  DECFSZ xD7,F
08CEA:  BRA    8CEE
08CEC:  BRA    8CF2
08CEE:  MOVLB  0
08CF0:  BRA    8CCE
08CF2:  MOVLB  0
08CF4:  GOTO   99F4 (RETURN)
08CF8:  MOVFF  FEA,5DF
08CFC:  MOVFF  FE9,5DE
08D00:  MOVLB  5
08D02:  SWAPF  xD8,W
08D04:  IORLW  F0
08D06:  MOVWF  xDA
08D08:  ADDWF  xDA,F
08D0A:  ADDLW  E2
08D0C:  MOVWF  xDB
08D0E:  ADDLW  32
08D10:  MOVWF  xDD
08D12:  MOVF   xD8,W
08D14:  ANDLW  0F
08D16:  ADDWF  xDB,F
08D18:  ADDWF  xDB,F
08D1A:  ADDWF  xDD,F
08D1C:  ADDLW  E9
08D1E:  MOVWF  xDC
08D20:  ADDWF  xDC,F
08D22:  ADDWF  xDC,F
08D24:  SWAPF  xD7,W
08D26:  ANDLW  0F
08D28:  ADDWF  xDC,F
08D2A:  ADDWF  xDD,F
08D2C:  RLCF   xDC,F
08D2E:  RLCF   xDD,F
08D30:  COMF   xDD,F
08D32:  RLCF   xDD,F
08D34:  MOVF   xD7,W
08D36:  ANDLW  0F
08D38:  ADDWF  xDD,F
08D3A:  RLCF   xDA,F
08D3C:  MOVLW  07
08D3E:  MOVWF  xD9
08D40:  MOVLW  0A
08D42:  DECF   xDC,F
08D44:  ADDWF  xDD,F
08D46:  BNC   8D42
08D48:  DECF   xDB,F
08D4A:  ADDWF  xDC,F
08D4C:  BNC   8D48
08D4E:  DECF   xDA,F
08D50:  ADDWF  xDB,F
08D52:  BNC   8D4E
08D54:  DECF   xD9,F
08D56:  ADDWF  xDA,F
08D58:  BNC   8D54
08D5A:  MOVLW  05
08D5C:  MOVWF  FEA
08D5E:  MOVLW  D9
08D60:  MOVWF  FE9
08D62:  MOVLW  07
08D64:  ANDWF  xDE,W
08D66:  BCF    xDE.6
08D68:  ADDWF  FE9,F
08D6A:  MOVLW  00
08D6C:  ADDWFC FEA,F
08D6E:  MOVF   FE9,W
08D70:  SUBLW  DD
08D72:  BNZ   8D7C
08D74:  MOVF   FEA,W
08D76:  SUBLW  05
08D78:  BNZ   8D7C
08D7A:  BSF    xDE.6
08D7C:  MOVF   FEF,W
08D7E:  MOVWF  00
08D80:  BNZ   8D92
08D82:  BTFSC  xDE.6
08D84:  BRA    8D92
08D86:  BTFSC  xDE.4
08D88:  BRA    8DB4
08D8A:  BTFSC  xDE.3
08D8C:  BRA    8D92
08D8E:  MOVLW  20
08D90:  BRA    8D98
08D92:  BSF    xDE.3
08D94:  BCF    xDE.4
08D96:  MOVLW  30
08D98:  ADDWF  00,F
08D9A:  MOVFF  FEA,5D8
08D9E:  MOVFF  FE9,5D7
08DA2:  MOVFF  00,5EC
08DA6:  MOVLB  0
08DA8:  RCALL  8CBC
08DAA:  MOVFF  5D8,FEA
08DAE:  MOVFF  5D7,FE9
08DB2:  MOVLB  5
08DB4:  MOVF   FEE,W
08DB6:  BTFSS  xDE.6
08DB8:  BRA    8D6E
08DBA:  MOVLB  0
08DBC:  GOTO   9A04 (RETURN)
08DC0:  TBLRD*+
08DC2:  MOVF   FF5,F
08DC4:  BZ    8DDE
08DC6:  MOVFF  FF6,5D7
08DCA:  MOVFF  FF7,5D8
08DCE:  MOVFF  FF5,5EC
08DD2:  RCALL  8CBC
08DD4:  MOVFF  5D7,FF6
08DD8:  MOVFF  5D8,FF7
08DDC:  BRA    8DC0
08DDE:  RETURN 0
08DE0:  MOVF   FEF,F
08DE2:  BZ    8E02
08DE4:  MOVFF  FEA,5DA
08DE8:  MOVFF  FE9,5D9
08DEC:  MOVFF  FEF,5EC
08DF0:  RCALL  8CBC
08DF2:  MOVFF  5DA,FEA
08DF6:  MOVFF  5D9,FE9
08DFA:  INCF   FE9,F
08DFC:  BTFSC  FD8.2
08DFE:  INCF   FEA,F
08E00:  BRA    8DE0
08E02:  GOTO   9B62 (RETURN)
*
09818:  MOVLB  5
0981A:  BTFSC  xF8.7
0981C:  BRA    9842
0981E:  MOVLW  0F
09820:  MOVWF  00
09822:  SWAPF  xF7,W
09824:  ANDWF  00,F
09826:  MOVLW  0A
09828:  SUBWF  00,W
0982A:  BC    9832
0982C:  MOVLW  30
0982E:  ADDWF  00,F
09830:  BRA    9836
09832:  MOVF   xF8,W
09834:  ADDWF  00,F
09836:  MOVFF  00,5F9
0983A:  MOVLB  0
0983C:  CALL   796A
09840:  MOVLB  5
09842:  MOVLW  0F
09844:  ANDWF  xF7,F
09846:  MOVLW  0A
09848:  SUBWF  xF7,W
0984A:  BC    9850
0984C:  MOVLW  30
0984E:  BRA    9854
09850:  BCF    xF8.7
09852:  MOVF   xF8,W
09854:  ADDWF  xF7,F
09856:  MOVFF  5F7,5F9
0985A:  MOVLB  0
0985C:  CALL   796A
09860:  GOTO   98C6 (RETURN)
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... /* 
.................... TCP/IP Stack enabled. 
.................... Many TCP/IP configuration settings (servers enabled, ports used, 
.................... etc) are defined in TCPIPConfig.h. 
.................... Many hardware configuration settings (SPI port and GPIO pins used) 
.................... are defined in HardwareProfile.h. 
.................... */ 
....................  
.................... #include "tcpip/p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
....................  
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
....................  
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F97J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFD 
.................... #byte TOSH = 0xFFE 
.................... #byte TOSL = 0xFFD 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int STKPTR0:5; 
....................          unsigned int :1; 
....................          unsigned int STKUNF:1; 
....................          unsigned int STKFUL:1; 
....................       }; 
....................       struct { 
....................          unsigned int STKPTR:5; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int STKOVF:1; 
....................       }; 
....................    }; 
.................... } STKPTRBITS; 
.................... STKPTRBITS STKPTRbits; 
.................... #byte STKPTRbits = 0xFFC 
.................... #byte STKPTR = 0xFFC 
....................  
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int TBLPTRU0:5; 
....................          unsigned int ACSS:1; 
....................       }; 
....................       struct { 
....................          unsigned int TBLPTRU:5; 
....................       }; 
.................... } TBLPTRUBITS; 
.................... TBLPTRUBITS TBLPTRUbits; 
.................... #byte TBLPTRUbits = 0xFF8 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF6 
.................... #byte TBLPTRH = 0xFF7 
.................... #byte TBLPTRL = 0xFF6 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF3 
.................... #byte PRODH = 0xFF4 
.................... #byte PRODL = 0xFF3 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int RBIF:1; 
....................          unsigned int INT0IF:1; 
....................          unsigned int TMR0IF:1; 
....................          unsigned int RBIE:1; 
....................          unsigned int INT0IE:1; 
....................          unsigned int TMR0IE:1; 
....................          unsigned int PEIE_GIEL:1; 
....................          unsigned int GIE_GIEH:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int INT0F:1; 
....................          unsigned int T0IF:1; 
....................          unsigned int :1; 
....................          unsigned int INT0E:1; 
....................          unsigned int T0IE:1; 
....................          unsigned int GIEL:1; 
....................          unsigned int GIEH:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int PEIE:1; 
....................          unsigned int GIE:1; 
....................       }; 
....................    }; 
.................... } INTCONBITS; 
.................... INTCONBITS INTCONbits; 
.................... #byte INTCONbits = 0xFF2 
.................... #byte INTCON = 0xFF2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RBIP:1; 
....................          unsigned int :1; 
....................          unsigned int TMR0IP:1; 
....................          unsigned int :1; 
....................          unsigned int INTEDG2:1; 
....................          unsigned int INTEDG1:1; 
....................          unsigned int INTEDG0:1; 
....................          unsigned int RBPU:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int INTEDG:3; 
....................       }; 
.................... } INTCON2BITS; 
.................... INTCON2BITS INTCON2bits; 
.................... #byte INTCON2bits = 0xFF1 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int INT1F:1; 
....................          unsigned int INT2F:1; 
....................          unsigned int :1; 
....................          unsigned int INT1E:1; 
....................          unsigned int INT2E:1; 
....................          unsigned int :1; 
....................          unsigned int INT1P:1; 
....................          unsigned int INT2P:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int INT1IF:1; 
....................          unsigned int INT2IF:1; 
....................          unsigned int :1; 
....................          unsigned int INT1IE:1; 
....................          unsigned int INT2IE:1; 
....................          unsigned int :1; 
....................          unsigned int INT1IP:1; 
....................          unsigned int INT2IP:1; 
....................       }; 
....................    }; 
.................... } INTCON3BITS; 
.................... INTCON3BITS INTCON3bits; 
.................... #byte INTCON3bits = 0xFF0 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... #word FSR0 = 0xFE9 
.................... #byte FSR0H = 0xFEA 
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... #word FSR1 = 0xFE1 
.................... #byte FSR1H = 0xFE2 
.................... #byte FSR1L = 0xFE1 
....................  
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... #word FSR2 = 0xFD9 
.................... #byte FSR2H = 0xFDA 
.................... #byte FSR2L = 0xFD9 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUSBITS; 
.................... STATUSBITS STATUSbits; 
.................... #byte STATUSbits = 0xFD8 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD6 
.................... #byte TMR0H = 0xFD7 
.................... #byte TMR0L = 0xFD6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int T016BIT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int T0PS0:3; 
....................          unsigned int PSA:1; 
....................          unsigned int T0SE:1; 
....................          unsigned int T0CS:1; 
....................          unsigned int T08BIT:1; 
....................          unsigned int TMR0ON:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int T0PS:3; 
....................       }; 
.................... } T0CONBITS; 
.................... T0CONBITS T0CONbits; 
.................... #byte T0CONbits = 0xFD5 
.................... #byte T0CON = 0xFD5 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SCS0:2; 
....................          unsigned int IOFS:1; 
....................          unsigned int OSTS:1; 
....................          unsigned int IRCF0:3; 
....................          unsigned int IDLEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int SCS:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int IRCF:3; 
....................       }; 
.................... } OSCCONBITS; 
.................... OSCCONBITS OSCCONbits; 
.................... #byte OSCCONbits = 0xFD3 
.................... #byte OSCCON = 0xFD3 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int LVDL0:4; 
....................          unsigned int LVDEN:1; 
....................          unsigned int IRVST:1; 
....................       }; 
....................       struct { 
....................          unsigned int LVDL:4; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int HLVDL0:4; 
....................          unsigned int HLVDEN:1; 
....................          unsigned int IVRST:1; 
....................          unsigned int :1; 
....................          unsigned int VDIRMAG:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int HLVDL:4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int LVV0:4; 
....................          unsigned int :1; 
....................          unsigned int BGST:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int LVV:4; 
....................       }; 
.................... } HLVDCONBITS; 
.................... HLVDCONBITS HLVDCONbits; 
.................... #byte HLVDCONbits = 0xFD2 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SWDTE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SWDTEN:1; 
....................       }; 
....................    }; 
.................... } WDTCONBITS; 
.................... WDTCONBITS WDTCONbits; 
.................... #byte WDTCONbits = 0xFD1 
.................... #byte WDTCON = 0xFD1 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCONBITS; 
.................... RCONBITS RCONbits; 
.................... #byte RCONbits = 0xFD0 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCE 
.................... #byte TMR1H = 0xFCF 
.................... #byte TMR1L = 0xFCE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int TMR1ON:1; 
....................          unsigned int TMR1CS:1; 
....................          unsigned int T1SYNC:1; 
....................          unsigned int T1OSCEN:1; 
....................          unsigned int T1CKPS0:2; 
....................          unsigned int T1RUN:1; 
....................          unsigned int RD16:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int T1CKPS:2; 
....................       }; 
.................... } T1CONBITS; 
.................... T1CONBITS T1CONbits; 
.................... #byte T1CONbits = 0xFCD 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int T2OUTPS0:4; 
....................       }; 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int T2OUTPS:4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int T2CKPS0:2; 
....................          unsigned int TMR2ON:1; 
....................          unsigned int TOUTPS0:4; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int T2CKPS:2; 
....................          unsigned int :1; 
....................          unsigned int TOUTPS:4; 
....................       }; 
.................... } T2CONBITS; 
.................... T2CONBITS T2CONbits; 
.................... #byte T2CONbits = 0xFCA 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int WRITE:1; 
....................          unsigned int :2; 
....................          unsigned int ADDRESS:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int BF:1; 
....................          unsigned int UA:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int W:1; 
....................          unsigned int :2; 
....................          unsigned int A:1; 
....................       }; 
....................    }; 
.................... } SSPSTATBITS; 
.................... SSPSTATBITS SSPSTATbits; 
.................... #byte SSPSTATbits = 0xFC7 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SSPM0:4; 
....................          unsigned int CKP:1; 
....................          unsigned int SSPEN:1; 
....................          unsigned int SSPOV:1; 
....................          unsigned int WCOL:1; 
....................       }; 
....................       struct { 
....................          unsigned int SSPM:4; 
....................       }; 
.................... } SSPCON1BITS; 
.................... SSPCON1BITS SSPCON1bits; 
.................... #byte SSPCON1bits = 0xFC6 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2BITS; 
.................... SSPCON2BITS SSPCON2bits; 
.................... #byte SSPCON2bits = 0xFC5 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC3 
.................... #byte ADRESH = 0xFC4 
.................... #byte ADRESL = 0xFC3 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int DONE:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int GO_DONE:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int ADON:1; 
....................          unsigned int GO:1; 
....................          unsigned int CHS0:4; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int CHS:4; 
....................       }; 
.................... } ADCON0BITS; 
.................... ADCON0BITS ADCON0bits; 
.................... #byte ADCON0bits = 0xFC2 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PCFG0:4; 
....................          unsigned int VCFG0:2; 
....................       }; 
....................       struct { 
....................          unsigned int PCFG:4; 
....................          unsigned int VCFG:2; 
....................       }; 
.................... } ADCON1BITS; 
.................... ADCON1BITS ADCON1bits; 
.................... #byte ADCON1bits = 0xFC1 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ADCS0:3; 
....................          unsigned int ACQT0:3; 
....................          unsigned int :1; 
....................          unsigned int ADFM:1; 
....................       }; 
....................       struct { 
....................          unsigned int ADCS:3; 
....................          unsigned int ACQT:3; 
....................       }; 
.................... } ADCON2BITS; 
.................... ADCON2BITS ADCON2bits; 
.................... #byte ADCON2bits = 0xFC0 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBE 
.................... #byte CCPR1H = 0xFBF 
.................... #byte CCPR1L = 0xFBE 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CCP1Y:1; 
....................          unsigned int CCP1X:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int CCP1M0:4; 
....................          unsigned int DC1B0:2; 
....................          unsigned int P1M0:2; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int CCP1M:4; 
....................          unsigned int DC1B:2; 
....................          unsigned int P1M:2; 
....................       }; 
.................... } CCP1CONBITS; 
.................... CCP1CONBITS CCP1CONbits; 
.................... #byte CCP1CONbits = 0xFBD 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word CCPR2 = 0xFBB 
.................... #byte CCPR2H = 0xFBC 
.................... #byte CCPR2L = 0xFBB 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CCP2Y:1; 
....................          unsigned int CCP2X:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int CCP2M0:4; 
....................          unsigned int DC2B0:2; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int CCP2M:4; 
....................          unsigned int DC2B:2; 
....................       }; 
.................... } CCP2CONBITS; 
.................... CCP2CONBITS CCP2CONbits; 
.................... #byte CCP2CONbits = 0xFBA 
.................... #byte CCP2CON = 0xFBA 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SCKP:1; 
....................          unsigned int RXCKP:1; 
....................          unsigned int RCMT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int ABDEN:1; 
....................          unsigned int WUE:1; 
....................          unsigned int :1; 
....................          unsigned int BRG16:1; 
....................          unsigned int TXCKP:1; 
....................          unsigned int RXDTP:1; 
....................          unsigned int RCIDL:1; 
....................          unsigned int ABDOVF:1; 
....................       }; 
....................    }; 
.................... } BAUDCONBITS; 
.................... BAUDCONBITS BAUDCONbits; 
.................... #byte BAUDCONbits = 0xFB8 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PDC0:7; 
....................          unsigned int PRSEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int PDC:7; 
....................       }; 
.................... } PWM1CONBITS; 
.................... PWM1CONBITS PWM1CONbits; 
.................... #byte PWM1CONbits = 0xFB7 
.................... #byte PWM1CON = 0xFB7 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PSSBD0:2; 
....................          unsigned int PSSAC0:2; 
....................          unsigned int ECCPAS0:3; 
....................          unsigned int ECCPASE:1; 
....................       }; 
....................       struct { 
....................          unsigned int PSSBD:2; 
....................          unsigned int PSSAC:2; 
....................          unsigned int ECCPAS:3; 
....................       }; 
.................... } ECCP1ASBITS; 
.................... ECCP1ASBITS ECCP1ASbits; 
.................... #byte ECCP1ASbits = 0xFB6 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CVR0:4; 
....................          unsigned int CVRSS:1; 
....................          unsigned int CVRR:1; 
....................          unsigned int CVROE:1; 
....................          unsigned int CVREN:1; 
....................       }; 
....................       struct { 
....................          unsigned int CVR:4; 
....................       }; 
.................... } CVRCONBITS; 
.................... CVRCONBITS CVRCONbits; 
.................... #byte CVRCONbits = 0xFB5 
.................... #byte CVRCON = 0xFB5 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CM0:3; 
....................          unsigned int CIS:1; 
....................          unsigned int C1INV:1; 
....................          unsigned int C2INV:1; 
....................          unsigned int C1OUT:1; 
....................          unsigned int C2OUT:1; 
....................       }; 
....................       struct { 
....................          unsigned int CM:3; 
....................       }; 
.................... } CMCONBITS; 
.................... CMCONBITS CMCONbits; 
.................... #byte CMCONbits = 0xFB4 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB2 
.................... #byte TMR3H = 0xFB3 
.................... #byte TMR3L = 0xFB2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int TMR3ON:1; 
....................          unsigned int TMR3CS:1; 
....................          unsigned int T3SYNC:1; 
....................          unsigned int T3CCP1:1; 
....................          unsigned int T3CKPS0:2; 
....................          unsigned int T3CCP2:1; 
....................          unsigned int RD16:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int T3CKPS:2; 
....................       }; 
.................... } T3CONBITS; 
.................... T3CONBITS T3CONbits; 
.................... #byte T3CONbits = 0xFB1 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX9:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTABITS; 
.................... TXSTABITS TXSTAbits; 
.................... #byte TXSTAbits = 0xFAC 
.................... #byte TXSTA = 0xFAC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int ADEN:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int RX9D:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int CREN:1; 
....................          unsigned int SREN:1; 
....................          unsigned int RX9:1; 
....................          unsigned int SPEN:1; 
....................       }; 
....................    }; 
.................... } RCSTABITS; 
.................... RCSTABITS RCSTAbits; 
.................... #byte RCSTAbits = 0xFAB 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1BITS; 
.................... EECON1BITS EECON1bits; 
.................... #byte EECON1bits = 0xFA6 
.................... #byte EECON1 = 0xFA6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCP2IP:1; 
....................          unsigned int TMR3IP:1; 
....................          unsigned int HLVDIP:1; 
....................          unsigned int BCLIP:1; 
....................          unsigned int EEIP:1; 
....................          unsigned int :1; 
....................          unsigned int CMIP:1; 
....................          unsigned int OSCFIP:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int LVDIP:1; 
....................       }; 
....................    }; 
.................... } IPR2BITS; 
.................... IPR2BITS IPR2bits; 
.................... #byte IPR2bits = 0xFA2 
.................... #byte IPR2 = 0xFA2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCP2IF:1; 
....................          unsigned int TMR3IF:1; 
....................          unsigned int HLVDIF:1; 
....................          unsigned int BCLIF:1; 
....................          unsigned int EEIF:1; 
....................          unsigned int :1; 
....................          unsigned int CMIF:1; 
....................          unsigned int OSCFIF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int LVDIF:1; 
....................       }; 
....................    }; 
.................... } PIR2BITS; 
.................... PIR2BITS PIR2bits; 
.................... #byte PIR2bits = 0xFA1 
.................... #byte PIR2 = 0xFA1 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCP2IE:1; 
....................          unsigned int TMR3IE:1; 
....................          unsigned int HLVDIE:1; 
....................          unsigned int BCLIE:1; 
....................          unsigned int EEIE:1; 
....................          unsigned int :1; 
....................          unsigned int CMIE:1; 
....................          unsigned int OSCFIE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int LVDIE:1; 
....................       }; 
....................    }; 
.................... } PIE2BITS; 
.................... PIE2BITS PIE2bits; 
.................... #byte PIE2bits = 0xFA0 
.................... #byte PIE2 = 0xFA0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TMR1IP:1; 
....................    unsigned int TMR2IP:1; 
....................    unsigned int CCP1IP:1; 
....................    unsigned int SSPIP:1; 
....................    unsigned int TXIP:1; 
....................    unsigned int RCIP:1; 
....................    unsigned int ADIP:1; 
....................    unsigned int PSPIP:1; 
.................... } IPR1BITS; 
.................... IPR1BITS IPR1bits; 
.................... #byte IPR1bits = 0xF9F 
.................... #byte IPR1 = 0xF9F 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1BITS; 
.................... PIR1BITS PIR1bits; 
.................... #byte PIR1bits = 0xF9E 
.................... #byte PIR1 = 0xF9E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1BITS; 
.................... PIE1BITS PIE1bits; 
.................... #byte PIE1bits = 0xF9D 
.................... #byte PIE1 = 0xF9D 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int TUN0:5; 
....................          unsigned int :1; 
....................          unsigned int PLLEN:1; 
....................          unsigned int INTSRC:1; 
....................       }; 
....................       struct { 
....................          unsigned int TUN:5; 
....................       }; 
.................... } OSCTUNEBITS; 
.................... OSCTUNEBITS OSCTUNEbits; 
.................... #byte OSCTUNEbits = 0xF9B 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISEBITS; 
.................... TRISEBITS TRISEbits; 
.................... #byte TRISEbits = 0xF96 
.................... #byte TRISE = 0xF96 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISDBITS; 
.................... TRISDBITS TRISDbits; 
.................... #byte TRISDbits = 0xF95 
.................... #byte TRISD = 0xF95 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISCBITS; 
.................... TRISCBITS TRISCbits; 
.................... #byte TRISCbits = 0xF94 
.................... #byte TRISC = 0xF94 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISBBITS; 
.................... TRISBBITS TRISBbits; 
.................... #byte TRISBbits = 0xF93 
.................... #byte TRISB = 0xF93 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISABITS; 
.................... TRISABITS TRISAbits; 
.................... #byte TRISAbits = 0xF92 
.................... #byte TRISA = 0xF92 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATEBITS; 
.................... LATEBITS LATEbits; 
.................... #byte LATEbits = 0xF8D 
.................... #byte LATE = 0xF8D 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATDBITS; 
.................... LATDBITS LATDbits; 
.................... #byte LATDbits = 0xF8C 
.................... #byte LATD = 0xF8C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATCBITS; 
.................... LATCBITS LATCbits; 
.................... #byte LATCbits = 0xF8B 
.................... #byte LATC = 0xF8B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATBBITS; 
.................... LATBBITS LATBbits; 
.................... #byte LATBbits = 0xF8A 
.................... #byte LATB = 0xF8A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATABITS; 
.................... LATABITS LATAbits; 
.................... #byte LATAbits = 0xF89 
.................... #byte LATA = 0xF89 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTEBITS; 
.................... PORTEBITS PORTEbits; 
.................... #byte PORTEbits = 0xF84 
.................... #byte PORTE = 0xF84 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTDBITS; 
.................... PORTDBITS PORTDbits; 
.................... #byte PORTDbits = 0xF83 
.................... #byte PORTD = 0xF83 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTCBITS; 
.................... PORTCBITS PORTCbits; 
.................... #byte PORTCbits = 0xF82 
.................... #byte PORTC = 0xF82 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTBBITS; 
.................... PORTBBITS PORTBbits; 
.................... #byte PORTBbits = 0xF81 
.................... #byte PORTB = 0xF81 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTABITS; 
.................... PORTABITS PORTAbits; 
.................... #byte PORTAbits = 0xF80 
.................... #byte PORTA = 0xF80 
....................  
....................  
.................... #else 
....................  #include "PIC18F4620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1) 
....................  
.................... #define __CCS__ 
....................  
.................... signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... rom char *strchrpgm(rom char* s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, rom char * s2); 
.................... __ADDRESS__ strlenpgm(rom char *s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, rom char *s); 
.................... signed int8 strcmppgm2ram(char *s1, rom char *s2); 
.................... #endif 
....................  
.................... #use delay(internal=32MHz) 
*
0057A:  MOVLW  05
0057C:  MOVWF  FEA
0057E:  MOVLW  B7
00580:  MOVWF  FE9
00582:  MOVF   FEF,W
00584:  BZ    05A0
00586:  MOVLW  0A
00588:  MOVWF  01
0058A:  CLRF   00
0058C:  DECFSZ 00,F
0058E:  BRA    058C
00590:  DECFSZ 01,F
00592:  BRA    058A
00594:  MOVLW  5F
00596:  MOVWF  00
00598:  DECFSZ 00,F
0059A:  BRA    0598
0059C:  DECFSZ FEF,F
0059E:  BRA    0586
005A0:  RETURN 0
*
097F2:  MOVLW  02
097F4:  MOVLB  5
097F6:  SUBWF  xF7,F
097F8:  BNC   9812
097FA:  MOVLW  05
097FC:  MOVWF  FEA
097FE:  MOVLW  F7
09800:  MOVWF  FE9
09802:  MOVF   FEF,W
09804:  BZ    9812
09806:  BRA    980E
09808:  BRA    980A
0980A:  BRA    980C
0980C:  NOP   
0980E:  DECFSZ FEF,F
09810:  BRA    9808
09812:  MOVLB  0
09814:  GOTO   988E (RETURN)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=TERMINAL) 
....................  
....................  
.................... #define MIN(a,b)  ((a > b) ? b : a) 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk2.h" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
....................  
.................... #ifndef __CCS_STACKTSK2_H__ 
.................... #define __CCS_STACKTSK2_H__ 
....................  
.................... #if !defined(debug_mpfs) 
....................  #define debug_mpfs(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) 
.................... #else 
....................  #define __DO_DEBUG_MPFS 
.................... #endif 
....................  
.................... #if defined(__PCH__) && !defined(__18CXX) 
....................  #define __18CXX 
.................... #endif 
....................  
.................... #define SIZEOF_MAC_HEADER 14 
....................  
.................... // override delay.c/delay.h with CCS compatible code 
.................... #define __DELAY_H 
.................... #define Delay10us(x) delay_us((uint16_t)10*(uint16_t)x) 
.................... #define DelayMs(x)   delay_ms(x) 
....................  
.................... #define __WF_DEBUG_STRINGS_H  //don't include this file 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
*
07636:  MOVFF  5FA,600
0763A:  MOVFF  5F9,5FF
....................    sc2=s2; 
0763E:  MOVFF  5FC,602
07642:  MOVFF  5FB,601
....................    if(sc2<sc1 && sc1 <sc2 +n) 
07646:  MOVLB  6
07648:  MOVF   x02,W
0764A:  SUBWF  x00,W
0764C:  BNC   76FA
0764E:  BNZ   765A
07650:  MOVLB  5
07652:  MOVF   xFF,W
07654:  MOVLB  6
07656:  SUBWF  x01,W
07658:  BC    76FA
0765A:  MOVLB  5
0765C:  MOVF   xFD,W
0765E:  MOVLB  6
07660:  ADDWF  x01,W
07662:  MOVWF  01
07664:  MOVLB  5
07666:  MOVF   xFE,W
07668:  MOVLB  6
0766A:  ADDWFC x02,W
0766C:  MOVWF  03
0766E:  MOVF   x00,W
07670:  SUBWF  03,W
07672:  BNC   76FA
07674:  BNZ   7686
07676:  MOVF   01,W
07678:  MOVLB  5
0767A:  SUBWF  xFF,W
0767C:  BTFSS  FD8.0
0767E:  BRA    7684
07680:  MOVLB  6
07682:  BRA    76FA
07684:  MOVLB  6
....................       for(sc1+=n,sc2+=n;0<n;--n) 
07686:  MOVLB  5
07688:  MOVF   xFD,W
0768A:  ADDWF  xFF,F
0768C:  MOVF   xFE,W
0768E:  MOVLB  6
07690:  ADDWFC x00,F
07692:  MOVLB  5
07694:  MOVF   xFD,W
07696:  MOVLB  6
07698:  ADDWF  x01,F
0769A:  MOVLB  5
0769C:  MOVF   xFE,W
0769E:  MOVLB  6
076A0:  ADDWFC x02,F
076A2:  MOVLB  5
076A4:  MOVF   xFE,F
076A6:  BNZ   76AE
076A8:  MOVF   xFD,W
076AA:  SUBLW  00
076AC:  BC    76F6
....................          *--sc1=*--sc2; 
076AE:  MOVF   xFF,W
076B0:  BTFSS  FD8.2
076B2:  BRA    76BA
076B4:  MOVLB  6
076B6:  DECF   x00,F
076B8:  MOVLB  5
076BA:  DECF   xFF,F
076BC:  MOVFF  600,604
076C0:  MOVLB  6
076C2:  MOVFF  5FF,603
076C6:  MOVF   x01,W
076C8:  BTFSC  FD8.2
076CA:  DECF   x02,F
076CC:  DECF   x01,F
076CE:  MOVFF  602,03
076D2:  MOVFF  601,FE9
076D6:  MOVFF  602,FEA
076DA:  MOVFF  FEF,605
076DE:  MOVFF  600,FEA
076E2:  MOVFF  5FF,FE9
076E6:  MOVFF  605,FEF
076EA:  MOVLB  5
076EC:  MOVF   xFD,W
076EE:  BTFSC  FD8.2
076F0:  DECF   xFE,F
076F2:  DECF   xFD,F
076F4:  BRA    76A4
076F6:  BRA    774E
076F8:  MOVLB  6
....................    else 
....................       for(;0<n;--n) 
076FA:  MOVLB  5
076FC:  MOVF   xFE,F
076FE:  BNZ   7706
07700:  MOVF   xFD,W
07702:  SUBLW  00
07704:  BC    774E
....................          *sc1++=*sc2++; 
07706:  MOVFF  600,03
0770A:  MOVLB  5
0770C:  MOVF   xFF,W
0770E:  INCF   xFF,F
07710:  BTFSS  FD8.2
07712:  BRA    7718
07714:  MOVLB  6
07716:  INCF   x00,F
07718:  MOVLB  6
0771A:  MOVWF  x03
0771C:  MOVFF  03,604
07720:  MOVFF  602,03
07724:  MOVF   x01,W
07726:  INCF   x01,F
07728:  BTFSC  FD8.2
0772A:  INCF   x02,F
0772C:  MOVWF  FE9
0772E:  MOVFF  03,FEA
07732:  MOVFF  FEF,605
07736:  MOVFF  604,FEA
0773A:  MOVFF  603,FE9
0773E:  MOVFF  605,FEF
07742:  MOVLB  5
07744:  MOVF   xFD,W
07746:  BTFSC  FD8.2
07748:  DECF   xFE,F
0774A:  DECF   xFD,F
0774C:  BRA    76FC
....................   return s1; 
0774E:  MOVFF  5F9,01
07752:  MOVFF  5FA,02
07756:  MOVLB  0
07758:  RETURN 0
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
07CA8:  MOVFF  5F8,5FE
07CAC:  MOVFF  5F7,5FD
07CB0:  MOVLB  5
07CB2:  MOVF   xFB,F
07CB4:  BNZ   7CBA
07CB6:  MOVF   xFC,F
07CB8:  BZ    7D06
07CBA:  MOVFF  5FA,03
07CBE:  MOVFF  5F9,FE9
07CC2:  MOVFF  5FA,FEA
07CC6:  MOVF   FEF,F
07CC8:  BZ    7D06
....................      *s++ = *s2++; 
07CCA:  MOVFF  5FE,600
07CCE:  MOVF   xFD,W
07CD0:  INCF   xFD,F
07CD2:  BTFSC  FD8.2
07CD4:  INCF   xFE,F
07CD6:  MOVWF  xFF
07CD8:  MOVFF  5FA,03
07CDC:  MOVF   xF9,W
07CDE:  INCF   xF9,F
07CE0:  BTFSC  FD8.2
07CE2:  INCF   xFA,F
07CE4:  MOVWF  FE9
07CE6:  MOVFF  03,FEA
07CEA:  MOVFF  FEF,601
07CEE:  MOVFF  600,FEA
07CF2:  MOVFF  5FF,FE9
07CF6:  MOVFF  601,FEF
07CFA:  MOVLB  5
07CFC:  MOVF   xFB,W
07CFE:  BTFSC  FD8.2
07D00:  DECF   xFC,F
07D02:  DECF   xFB,F
07D04:  BRA    7CB2
....................   for (; n > 0; n--) 
07D06:  MOVF   xFB,F
07D08:  BNZ   7D0E
07D0A:  MOVF   xFC,F
07D0C:  BZ    7D2C
....................      *s++ = '\0'; 
07D0E:  MOVFF  5FE,03
07D12:  MOVF   xFD,W
07D14:  INCF   xFD,F
07D16:  BTFSC  FD8.2
07D18:  INCF   xFE,F
07D1A:  MOVWF  FE9
07D1C:  MOVFF  03,FEA
07D20:  CLRF   FEF
07D22:  MOVF   xFB,W
07D24:  BTFSC  FD8.2
07D26:  DECF   xFC,F
07D28:  DECF   xFB,F
07D2A:  BRA    7D06
....................  
....................   return(s1); 
07D2C:  MOVFF  5F7,01
07D30:  MOVFF  5F8,02
07D34:  MOVLB  0
07D36:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
07A62:  MOVFF  651,657
07A66:  MOVFF  650,656
07A6A:  MOVFF  653,659
07A6E:  MOVFF  652,658
07A72:  MOVLB  6
07A74:  MOVF   x55,F
07A76:  BNZ   7A7E
07A78:  MOVF   x54,W
07A7A:  SUBLW  00
07A7C:  BC    7ADE
.................... { 
....................    if(*su1!=*su2) 
07A7E:  MOVFF  656,FE9
07A82:  MOVFF  657,FEA
07A86:  MOVFF  FEF,65A
07A8A:  MOVFF  659,03
07A8E:  MOVFF  658,FE9
07A92:  MOVFF  659,FEA
07A96:  MOVF   FEF,W
07A98:  SUBWF  x5A,W
07A9A:  BZ    7AC8
....................       return ((*su1<*su2)?-1:1); 
07A9C:  MOVFF  657,03
07AA0:  MOVFF  656,FE9
07AA4:  MOVFF  03,FEA
07AA8:  MOVFF  FEF,65A
07AAC:  MOVFF  659,03
07AB0:  MOVFF  658,FE9
07AB4:  MOVFF  659,FEA
07AB8:  MOVF   FEF,W
07ABA:  SUBWF  x5A,W
07ABC:  BC    7AC2
07ABE:  MOVLW  FF
07AC0:  BRA    7AC4
07AC2:  MOVLW  01
07AC4:  MOVWF  01
07AC6:  BRA    7AE2
07AC8:  INCF   x56,F
07ACA:  BTFSC  FD8.2
07ACC:  INCF   x57,F
07ACE:  INCF   x58,F
07AD0:  BTFSC  FD8.2
07AD2:  INCF   x59,F
07AD4:  MOVF   x54,W
07AD6:  BTFSC  FD8.2
07AD8:  DECF   x55,F
07ADA:  DECF   x54,F
07ADC:  BRA    7A74
.................... } 
.................... return 0; 
07ADE:  MOVLW  00
07AE0:  MOVWF  01
07AE2:  MOVLB  0
07AE4:  GOTO   7BA0 (RETURN)
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0715C:  MOVLB  6
0715E:  MOVFF  632,FE9
07162:  MOVFF  633,FEA
07166:  MOVFF  FEF,636
0716A:  MOVFF  635,03
0716E:  MOVFF  634,FE9
07172:  MOVFF  635,FEA
07176:  MOVF   FEF,W
07178:  SUBWF  x36,W
0717A:  BNZ   71A6
....................       if (*s1 == '\0') 
0717C:  MOVFF  633,03
07180:  MOVFF  632,FE9
07184:  MOVFF  03,FEA
07188:  MOVF   FEF,F
0718A:  BNZ   7192
....................          return(0); 
0718C:  MOVLW  00
0718E:  MOVWF  01
07190:  BRA    71D0
07192:  MOVFF  633,03
07196:  MOVF   x32,W
07198:  INCF   x32,F
0719A:  BTFSC  FD8.2
0719C:  INCF   x33,F
0719E:  INCF   x34,F
071A0:  BTFSC  FD8.2
071A2:  INCF   x35,F
071A4:  BRA    715E
....................    return((*s1 < *s2) ? -1: 1); 
071A6:  MOVFF  633,03
071AA:  MOVFF  632,FE9
071AE:  MOVFF  633,FEA
071B2:  MOVFF  FEF,636
071B6:  MOVFF  635,03
071BA:  MOVFF  634,FE9
071BE:  MOVFF  635,FEA
071C2:  MOVF   FEF,W
071C4:  SUBWF  x36,W
071C6:  BC    71CC
071C8:  MOVLW  FF
071CA:  BRA    71CE
071CC:  MOVLW  01
071CE:  MOVWF  01
071D0:  MOVLB  0
071D2:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
071D4:  MOVFF  618,61B
....................    for(su=s;0<n;++su,--n) 
071D8:  MOVFF  617,61D
071DC:  MOVFF  616,61C
071E0:  MOVLB  6
071E2:  MOVF   x1A,F
071E4:  BNZ   71EC
071E6:  MOVF   x19,W
071E8:  SUBLW  00
071EA:  BC    7218
....................       if(*su==uc) 
071EC:  MOVFF  61D,03
071F0:  MOVFF  61C,FE9
071F4:  MOVFF  61D,FEA
071F8:  MOVF   x1B,W
071FA:  SUBWF  FEF,W
071FC:  BNZ   7208
....................       return su; 
071FE:  MOVFF  61C,01
07202:  MOVFF  61D,02
07206:  BRA    721E
07208:  INCF   x1C,F
0720A:  BTFSC  FD8.2
0720C:  INCF   x1D,F
0720E:  MOVF   x19,W
07210:  BTFSC  FD8.2
07212:  DECF   x1A,F
07214:  DECF   x19,F
07216:  BRA    71E2
....................    return NULL; 
07218:  MOVLW  00
0721A:  MOVWF  01
0721C:  MOVWF  02
0721E:  MOVLB  0
07220:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
08926:  MOVFF  5D7,03
0892A:  MOVLB  5
0892C:  MOVFF  5D6,FE9
08930:  MOVFF  5D7,FEA
08934:  MOVF   xD8,W
08936:  SUBWF  FEF,W
08938:  BZ    895E
....................       if (*s == '\0') 
0893A:  MOVFF  5D7,03
0893E:  MOVFF  5D6,FE9
08942:  MOVFF  5D7,FEA
08946:  MOVF   FEF,F
08948:  BNZ   8952
....................          return(0); 
0894A:  MOVLW  00
0894C:  MOVWF  01
0894E:  MOVWF  02
08950:  BRA    8966
08952:  INCF   xD6,F
08954:  BTFSC  FD8.2
08956:  INCF   xD7,F
08958:  MOVLB  0
0895A:  BRA    8926
0895C:  MOVLB  5
....................    return(s); 
0895E:  MOVFF  5D6,01
08962:  MOVFF  5D7,02
08966:  MOVLB  0
08968:  RETURN 0
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
06FEE:  MOVFF  63B,63F
06FF2:  MOVFF  63A,63E
06FF6:  MOVFF  63F,03
06FFA:  MOVLB  6
06FFC:  MOVFF  63E,FE9
07000:  MOVFF  63F,FEA
07004:  MOVF   FEF,F
07006:  BZ    705C
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
07008:  MOVFF  63D,641
0700C:  MOVFF  63C,640
07010:  MOVFF  641,03
07014:  MOVFF  640,FE9
07018:  MOVFF  641,FEA
0701C:  MOVF   FEF,F
0701E:  BZ    7050
....................          if (*sc1 == *sc2) 
07020:  MOVFF  63E,FE9
07024:  MOVFF  63F,FEA
07028:  MOVFF  FEF,642
0702C:  MOVFF  641,03
07030:  MOVFF  640,FE9
07034:  MOVFF  641,FEA
07038:  MOVF   FEF,W
0703A:  SUBWF  x42,W
0703C:  BNZ   7048
....................             return(sc1); 
0703E:  MOVFF  63E,01
07042:  MOVFF  63F,02
07046:  BRA    7062
07048:  INCF   x40,F
0704A:  BTFSC  FD8.2
0704C:  INCF   x41,F
0704E:  BRA    7010
07050:  INCF   x3E,F
07052:  BTFSC  FD8.2
07054:  INCF   x3F,F
07056:  MOVLB  0
07058:  BRA    6FF6
0705A:  MOVLB  6
....................    return(0); 
0705C:  MOVLW  00
0705E:  MOVWF  01
07060:  MOVWF  02
07062:  MOVLB  0
07064:  GOTO   710A (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
06F5E:  MOVFF  63B,63F
06F62:  MOVFF  63A,63E
06F66:  MOVFF  63F,03
06F6A:  MOVLB  6
06F6C:  MOVFF  63E,FE9
06F70:  MOVFF  63F,FEA
06F74:  MOVF   FEF,F
06F76:  BZ    6FD8
....................       for (sc2 = s2; ; sc2++) 
06F78:  MOVFF  63D,641
06F7C:  MOVFF  63C,640
....................     if (*sc2 == '\0') 
06F80:  MOVFF  641,03
06F84:  MOVFF  640,FE9
06F88:  MOVFF  641,FEA
06F8C:  MOVF   FEF,F
06F8E:  BNZ   6FA4
....................        return(sc1 - s1); 
06F90:  MOVF   x3A,W
06F92:  SUBWF  x3E,W
06F94:  MOVWF  00
06F96:  MOVF   x3B,W
06F98:  SUBWFB x3F,W
06F9A:  MOVWF  03
06F9C:  MOVFF  00,01
06FA0:  BRA    6FE8
06FA2:  BRA    6FC4
....................          else if (*sc1 == *sc2) 
06FA4:  MOVFF  63E,FE9
06FA8:  MOVFF  63F,FEA
06FAC:  MOVFF  FEF,642
06FB0:  MOVFF  641,03
06FB4:  MOVFF  640,FE9
06FB8:  MOVFF  641,FEA
06FBC:  MOVF   FEF,W
06FBE:  SUBWF  x42,W
06FC0:  BNZ   6FC4
....................             break; 
06FC2:  BRA    6FCC
06FC4:  INCF   x40,F
06FC6:  BTFSC  FD8.2
06FC8:  INCF   x41,F
06FCA:  BRA    6F80
06FCC:  INCF   x3E,F
06FCE:  BTFSC  FD8.2
06FD0:  INCF   x3F,F
06FD2:  MOVLB  0
06FD4:  BRA    6F66
06FD6:  MOVLB  6
....................    return(sc1 - s1); 
06FD8:  MOVF   x3A,W
06FDA:  SUBWF  x3E,W
06FDC:  MOVWF  00
06FDE:  MOVF   x3B,W
06FE0:  SUBWFB x3F,W
06FE2:  MOVWF  03
06FE4:  MOVFF  00,01
06FE8:  MOVLB  0
06FEA:  GOTO   70D4 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
0820E:  MOVFF  633,03
08212:  MOVLB  6
08214:  MOVFF  632,FE9
08218:  MOVFF  633,FEA
0821C:  MOVF   FEF,F
0821E:  BZ    8292
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
08220:  MOVFF  633,637
08224:  MOVFF  632,636
08228:  MOVFF  635,639
0822C:  MOVFF  634,638
08230:  MOVFF  639,03
08234:  MOVFF  638,FE9
08238:  MOVFF  639,FEA
0823C:  MOVF   FEF,F
0823E:  BZ    826C
08240:  MOVFF  636,FE9
08244:  MOVFF  637,FEA
08248:  MOVFF  FEF,63A
0824C:  MOVFF  639,03
08250:  MOVFF  638,FE9
08254:  MOVFF  639,FEA
08258:  MOVF   FEF,W
0825A:  SUBWF  x3A,W
0825C:  BNZ   826C
0825E:  INCF   x36,F
08260:  BTFSC  FD8.2
08262:  INCF   x37,F
08264:  INCF   x38,F
08266:  BTFSC  FD8.2
08268:  INCF   x39,F
0826A:  BRA    8230
....................  
....................       if (*t == '\0') 
0826C:  MOVFF  639,03
08270:  MOVFF  638,FE9
08274:  MOVFF  03,FEA
08278:  MOVF   FEF,F
0827A:  BNZ   8286
....................          return s1; 
0827C:  MOVFF  632,01
08280:  MOVFF  633,02
08284:  BRA    8298
....................       ++s1; 
08286:  INCF   x32,F
08288:  BTFSC  FD8.2
0828A:  INCF   x33,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0828C:  MOVLB  0
0828E:  BRA    820E
08290:  MOVLB  6
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
08292:  MOVLW  00
08294:  MOVWF  01
08296:  MOVWF  02
08298:  MOVLB  0
0829A:  GOTO   85C8 (RETURN)
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
07068:  MOVFF  64F,651
0706C:  MOVFF  64E,650
07070:  MOVFF  651,03
07074:  MOVLB  6
07076:  MOVFF  650,FE9
0707A:  MOVFF  651,FEA
0707E:  MOVF   FEF,F
07080:  BZ    708E
07082:  INCF   x50,F
07084:  BTFSC  FD8.2
07086:  INCF   x51,F
07088:  MOVLB  0
0708A:  BRA    7070
0708C:  MOVLB  6
....................    return(sc - s); 
0708E:  MOVF   x4E,W
07090:  SUBWF  x50,W
07092:  MOVWF  00
07094:  MOVF   x4F,W
07096:  SUBWFB x51,W
07098:  MOVWF  03
0709A:  MOVFF  00,01
0709E:  MOVWF  02
070A0:  MOVLB  0
070A2:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
070A4:  MOVLB  6
070A6:  MOVF   x32,W
070A8:  IORWF  x33,W
070AA:  BZ    70B4
070AC:  MOVFF  633,03
070B0:  MOVF   x32,W
070B2:  BRA    70BA
070B4:  MOVFF  1A,03
070B8:  MOVF   19,W
070BA:  MOVWF  x36
070BC:  MOVFF  03,637
....................    beg += strspn(beg, s2); 
070C0:  MOVFF  637,63B
070C4:  MOVFF  636,63A
070C8:  MOVFF  635,63D
070CC:  MOVFF  634,63C
070D0:  MOVLB  0
070D2:  BRA    6F5E
070D4:  MOVF   01,W
070D6:  MOVLB  6
070D8:  ADDWF  x36,F
070DA:  MOVLW  00
070DC:  ADDWFC x37,F
....................    if (*beg == '\0') 
070DE:  MOVFF  637,03
070E2:  MOVFF  636,FE9
070E6:  MOVFF  637,FEA
070EA:  MOVF   FEF,F
070EC:  BNZ   70F6
....................       return(0); 
070EE:  MOVLW  00
070F0:  MOVWF  01
070F2:  MOVWF  02
070F4:  BRA    7158
....................        
....................    end = strpbrk(beg, s2); 
070F6:  MOVFF  637,63B
070FA:  MOVFF  636,63A
070FE:  MOVFF  635,63D
07102:  MOVFF  634,63C
07106:  MOVLB  0
07108:  BRA    6FEE
0710A:  MOVFF  02,639
0710E:  MOVFF  01,638
....................    if (end != '\0') 
07112:  MOVLB  6
07114:  MOVF   x38,F
07116:  BNZ   711C
07118:  MOVF   x39,F
0711A:  BZ    7136
....................    { 
....................       *end = '\0'; 
0711C:  MOVFF  638,FE9
07120:  MOVFF  639,FEA
07124:  CLRF   FEF
....................       end++; 
07126:  INCF   x38,F
07128:  BTFSC  FD8.2
0712A:  INCF   x39,F
....................       save = end; 
0712C:  MOVFF  639,1A
07130:  MOVFF  638,19
....................    } 
07134:  BRA    7150
....................    else 
....................       save = beg + strlen(beg); 
07136:  MOVFF  637,64F
0713A:  MOVFF  636,64E
0713E:  MOVLB  0
07140:  RCALL  7068
07142:  MOVF   01,W
07144:  MOVLB  6
07146:  ADDWF  x36,W
07148:  MOVWF  19
0714A:  MOVF   02,W
0714C:  ADDWFC x37,W
0714E:  MOVWF  1A
....................     
....................    return(beg); 
07150:  MOVFF  636,01
07154:  MOVFF  637,02
07158:  MOVLB  0
0715A:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
07846:  MOVLB  6
07848:  MOVFF  638,FE9
0784C:  MOVFF  639,FEA
07850:  MOVFF  FEF,63C
07854:  MOVFF  63B,03
07858:  MOVFF  63A,FE9
0785C:  MOVFF  63B,FEA
07860:  MOVF   FEF,W
07862:  SUBWF  x3C,W
07864:  BZ    7912
07866:  MOVFF  639,03
0786A:  MOVFF  638,FE9
0786E:  MOVFF  639,FEA
07872:  MOVFF  FEF,63C
07876:  MOVF   x3C,W
07878:  SUBLW  40
0787A:  BC    7882
0787C:  MOVF   x3C,W
0787E:  SUBLW  5A
07880:  BC    788E
07882:  MOVF   x3C,W
07884:  SUBLW  60
07886:  BC    793C
07888:  MOVF   x3C,W
0788A:  SUBLW  7A
0788C:  BNC   793C
0788E:  MOVFF  63B,03
07892:  MOVFF  63A,FE9
07896:  MOVFF  63B,FEA
0789A:  MOVFF  FEF,63C
0789E:  MOVF   x3C,W
078A0:  SUBLW  40
078A2:  BC    78AA
078A4:  MOVF   x3C,W
078A6:  SUBLW  5A
078A8:  BC    78B6
078AA:  MOVF   x3C,W
078AC:  SUBLW  60
078AE:  BC    793C
078B0:  MOVF   x3C,W
078B2:  SUBLW  7A
078B4:  BNC   793C
078B6:  MOVFF  638,FE9
078BA:  MOVFF  639,FEA
078BE:  MOVFF  FEF,63C
078C2:  MOVFF  63B,03
078C6:  MOVFF  63A,FE9
078CA:  MOVFF  63B,FEA
078CE:  MOVLW  20
078D0:  ADDWF  FEF,W
078D2:  MOVWF  01
078D4:  CLRF   03
078D6:  BTFSC  FD8.0
078D8:  INCF   03,F
078DA:  MOVF   01,W
078DC:  SUBWF  x3C,W
078DE:  BNZ   78E4
078E0:  MOVF   03,F
078E2:  BZ    7912
078E4:  MOVFF  63A,FE9
078E8:  MOVFF  63B,FEA
078EC:  MOVFF  FEF,63C
078F0:  MOVFF  639,03
078F4:  MOVFF  638,FE9
078F8:  MOVFF  639,FEA
078FC:  MOVLW  20
078FE:  ADDWF  FEF,W
07900:  MOVWF  01
07902:  CLRF   03
07904:  BTFSC  FD8.0
07906:  INCF   03,F
07908:  MOVF   01,W
0790A:  SUBWF  x3C,W
0790C:  BNZ   793C
0790E:  MOVF   03,F
07910:  BNZ   793C
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
07912:  MOVFF  639,03
07916:  MOVFF  638,FE9
0791A:  MOVFF  639,FEA
0791E:  MOVF   FEF,F
07920:  BNZ   7928
....................        return(0); 
07922:  MOVLW  00
07924:  MOVWF  01
07926:  BRA    7966
07928:  MOVFF  639,03
0792C:  MOVF   x38,W
0792E:  INCF   x38,F
07930:  BTFSC  FD8.2
07932:  INCF   x39,F
07934:  INCF   x3A,F
07936:  BTFSC  FD8.2
07938:  INCF   x3B,F
0793A:  BRA    7848
....................  return((*s1 < *s2) ? -1: 1); 
0793C:  MOVFF  639,03
07940:  MOVFF  638,FE9
07944:  MOVFF  639,FEA
07948:  MOVFF  FEF,63C
0794C:  MOVFF  63B,03
07950:  MOVFF  63A,FE9
07954:  MOVFF  63B,FEA
07958:  MOVF   FEF,W
0795A:  SUBWF  x3C,W
0795C:  BC    7962
0795E:  MOVLW  FF
07960:  BRA    7964
07962:  MOVLW  01
07964:  MOVWF  01
07966:  MOVLB  0
07968:  RETURN 0
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
*
079BC:  MOVFF  64F,651
079C0:  MOVFF  64E,650
079C4:  MOVFF  651,03
079C8:  MOVLB  6
079CA:  MOVFF  650,FE9
079CE:  MOVFF  651,FEA
079D2:  MOVF   FEF,F
079D4:  BZ    7A18
....................       if (*p >= 'a' && *p <='z') 
079D6:  MOVFF  651,03
079DA:  MOVFF  650,FE9
079DE:  MOVFF  651,FEA
079E2:  MOVF   FEF,W
079E4:  SUBLW  60
079E6:  BC    7A0C
079E8:  MOVFF  651,03
079EC:  MOVFF  650,FE9
079F0:  MOVFF  651,FEA
079F4:  MOVF   FEF,W
079F6:  SUBLW  7A
079F8:  BNC   7A0C
....................          *p -= 'a' - 'A'; 
079FA:  MOVFF  651,03
079FE:  MOVFF  650,FE9
07A02:  MOVFF  651,FEA
07A06:  MOVLW  20
07A08:  SUBWF  FEF,W
07A0A:  MOVWF  FEF
07A0C:  INCF   x50,F
07A0E:  BTFSC  FD8.2
07A10:  INCF   x51,F
07A12:  MOVLB  0
07A14:  BRA    79C4
07A16:  MOVLB  6
....................    return(s); 
07A18:  MOVFF  64E,01
07A1C:  MOVFF  64F,02
07A20:  MOVLB  0
07A22:  RETURN 0
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
07D80:  MOVLB  5
07D82:  CLRF   xD0
07D84:  CLRF   xCF
....................    sign = 0; 
07D86:  CLRF   xCC
07D88:  CLRF   xCB
....................    base = 10; 
07D8A:  CLRF   xCE
07D8C:  MOVLW  0A
07D8E:  MOVWF  xCD
....................    result = 0; 
07D90:  CLRF   xCA
07D92:  CLRF   xC9
07D94:  CLRF   xC8
07D96:  CLRF   xC7
....................  
....................    if (!s) 
07D98:  MOVF   xC5,W
07D9A:  IORWF  xC6,W
07D9C:  BNZ   7DA8
....................       return 0; 
07D9E:  CLRF   00
07DA0:  CLRF   01
07DA2:  CLRF   02
07DA4:  CLRF   03
07DA6:  BRA    80C4
....................    c = s[index++]; 
07DA8:  MOVFF  5D0,03
07DAC:  MOVF   xCF,W
07DAE:  INCF   xCF,F
07DB0:  BTFSC  FD8.2
07DB2:  INCF   xD0,F
07DB4:  MOVWF  xD2
07DB6:  MOVF   xC5,W
07DB8:  ADDWF  xD2,W
07DBA:  MOVWF  FE9
07DBC:  MOVF   xC6,W
07DBE:  ADDWFC 03,W
07DC0:  MOVWF  FEA
07DC2:  MOVFF  FEF,5D1
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
07DC6:  MOVF   xD1,W
07DC8:  SUBLW  2D
07DCA:  BNZ   7DF2
....................    { 
....................       sign = 1;         // Set the sign to negative 
07DCC:  CLRF   xCC
07DCE:  MOVLW  01
07DD0:  MOVWF  xCB
....................       c = s[index++]; 
07DD2:  MOVFF  5D0,03
07DD6:  MOVF   xCF,W
07DD8:  INCF   xCF,F
07DDA:  BTFSC  FD8.2
07DDC:  INCF   xD0,F
07DDE:  MOVWF  xD2
07DE0:  MOVF   xC5,W
07DE2:  ADDWF  xD2,W
07DE4:  MOVWF  FE9
07DE6:  MOVF   xC6,W
07DE8:  ADDWFC 03,W
07DEA:  MOVWF  FEA
07DEC:  MOVFF  FEF,5D1
....................    } 
07DF0:  BRA    7E16
....................    else if (c == '+') 
07DF2:  MOVF   xD1,W
07DF4:  SUBLW  2B
07DF6:  BNZ   7E16
....................    { 
....................       c = s[index++]; 
07DF8:  MOVFF  5D0,03
07DFC:  MOVF   xCF,W
07DFE:  INCF   xCF,F
07E00:  BTFSC  FD8.2
07E02:  INCF   xD0,F
07E04:  MOVWF  xD2
07E06:  MOVF   xC5,W
07E08:  ADDWF  xD2,W
07E0A:  MOVWF  FE9
07E0C:  MOVF   xC6,W
07E0E:  ADDWFC 03,W
07E10:  MOVWF  FEA
07E12:  MOVFF  FEF,5D1
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
07E16:  BTFSC  xD1.7
07E18:  BRA    808C
07E1A:  MOVF   xD1,W
07E1C:  SUBLW  2F
07E1E:  BTFSC  FD8.0
07E20:  BRA    808C
07E22:  BTFSC  xD1.7
07E24:  BRA    7E2E
07E26:  MOVF   xD1,W
07E28:  SUBLW  39
07E2A:  BTFSS  FD8.0
07E2C:  BRA    808C
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
07E2E:  MOVF   xD1,W
07E30:  SUBLW  30
07E32:  BNZ   7E82
07E34:  MOVF   xC5,W
07E36:  ADDWF  xCF,W
07E38:  MOVWF  FE9
07E3A:  MOVF   xC6,W
07E3C:  ADDWFC xD0,W
07E3E:  MOVWF  FEA
07E40:  MOVF   FEF,W
07E42:  SUBLW  78
07E44:  BZ    7E58
07E46:  MOVF   xC5,W
07E48:  ADDWF  xCF,W
07E4A:  MOVWF  FE9
07E4C:  MOVF   xC6,W
07E4E:  ADDWFC xD0,W
07E50:  MOVWF  FEA
07E52:  MOVF   FEF,W
07E54:  SUBLW  58
07E56:  BNZ   7E82
....................       { 
....................          base = 16; 
07E58:  CLRF   xCE
07E5A:  MOVLW  10
07E5C:  MOVWF  xCD
....................          index++; 
07E5E:  INCF   xCF,F
07E60:  BTFSC  FD8.2
07E62:  INCF   xD0,F
....................          c = s[index++]; 
07E64:  MOVFF  5D0,03
07E68:  MOVF   xCF,W
07E6A:  INCF   xCF,F
07E6C:  BTFSC  FD8.2
07E6E:  INCF   xD0,F
07E70:  MOVWF  xD2
07E72:  MOVF   xC5,W
07E74:  ADDWF  xD2,W
07E76:  MOVWF  FE9
07E78:  MOVF   xC6,W
07E7A:  ADDWFC 03,W
07E7C:  MOVWF  FEA
07E7E:  MOVFF  FEF,5D1
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
07E82:  MOVF   xCD,W
07E84:  SUBLW  0A
07E86:  BNZ   7F24
07E88:  MOVF   xCE,F
07E8A:  BNZ   7F24
....................       { 
....................          while (c >= '0' && c <= '9') 
07E8C:  BTFSC  xD1.7
07E8E:  BRA    7F22
07E90:  MOVF   xD1,W
07E92:  SUBLW  2F
07E94:  BC    7F22
07E96:  BTFSC  xD1.7
07E98:  BRA    7EA0
07E9A:  MOVF   xD1,W
07E9C:  SUBLW  39
07E9E:  BNC   7F22
....................          { 
....................             result = 10*result + (c - '0'); 
07EA0:  MOVLB  6
07EA2:  CLRF   x1C
07EA4:  CLRF   x1B
07EA6:  CLRF   x1A
07EA8:  MOVLW  0A
07EAA:  MOVWF  x19
07EAC:  MOVFF  5CA,620
07EB0:  MOVFF  5C9,61F
07EB4:  MOVFF  5C8,61E
07EB8:  MOVFF  5C7,61D
07EBC:  MOVLB  0
07EBE:  CALL   1856
07EC2:  MOVFF  03,5D5
07EC6:  MOVFF  02,5D4
07ECA:  MOVFF  01,5D3
07ECE:  MOVFF  00,5D2
07ED2:  MOVLW  30
07ED4:  MOVLB  5
07ED6:  SUBWF  xD1,W
07ED8:  MOVWF  00
07EDA:  CLRF   01
07EDC:  CLRF   02
07EDE:  CLRF   03
07EE0:  BTFSS  FE8.7
07EE2:  BRA    7EEA
07EE4:  DECF   01,F
07EE6:  DECF   02,F
07EE8:  DECF   03,F
07EEA:  MOVF   00,W
07EEC:  ADDWF  xD2,W
07EEE:  MOVWF  xC7
07EF0:  MOVF   01,W
07EF2:  ADDWFC xD3,W
07EF4:  MOVWF  xC8
07EF6:  MOVF   02,W
07EF8:  ADDWFC xD4,W
07EFA:  MOVWF  xC9
07EFC:  MOVF   03,W
07EFE:  ADDWFC xD5,W
07F00:  MOVWF  xCA
....................             c = s[index++]; 
07F02:  MOVFF  5D0,5D3
07F06:  MOVF   xCF,W
07F08:  INCF   xCF,F
07F0A:  BTFSC  FD8.2
07F0C:  INCF   xD0,F
07F0E:  MOVWF  xD2
07F10:  MOVF   xC5,W
07F12:  ADDWF  xD2,W
07F14:  MOVWF  FE9
07F16:  MOVF   xC6,W
07F18:  ADDWFC xD3,W
07F1A:  MOVWF  FEA
07F1C:  MOVFF  FEF,5D1
07F20:  BRA    7E8C
....................          } 
....................       } 
07F22:  BRA    808C
....................       else if (base == 16)    // The number is a hexa number 
07F24:  MOVF   xCD,W
07F26:  SUBLW  10
07F28:  BTFSS  FD8.2
07F2A:  BRA    808C
07F2C:  MOVF   xCE,F
07F2E:  BTFSS  FD8.2
07F30:  BRA    808C
....................       { 
....................          c = toupper(c); 
07F32:  BTFSC  xD1.7
07F34:  BRA    7F4C
07F36:  MOVF   xD1,W
07F38:  SUBLW  60
07F3A:  BC    7F4C
07F3C:  BTFSC  xD1.7
07F3E:  BRA    7F46
07F40:  MOVF   xD1,W
07F42:  SUBLW  7A
07F44:  BNC   7F4C
07F46:  MOVF   xD1,W
07F48:  ANDLW  DF
07F4A:  BRA    7F4E
07F4C:  MOVF   xD1,W
07F4E:  MOVWF  xD1
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
07F50:  BTFSC  xD1.7
07F52:  BRA    7F64
07F54:  MOVF   xD1,W
07F56:  SUBLW  2F
07F58:  BC    7F64
07F5A:  BTFSC  xD1.7
07F5C:  BRA    7F7C
07F5E:  MOVF   xD1,W
07F60:  SUBLW  39
07F62:  BC    7F7C
07F64:  BTFSC  xD1.7
07F66:  BRA    808C
07F68:  MOVF   xD1,W
07F6A:  SUBLW  40
07F6C:  BTFSC  FD8.0
07F6E:  BRA    808C
07F70:  BTFSC  xD1.7
07F72:  BRA    7F7C
07F74:  MOVF   xD1,W
07F76:  SUBLW  46
07F78:  BTFSS  FD8.0
07F7A:  BRA    808C
....................          { 
....................             if (c >= '0' && c <= '9') 
07F7C:  BTFSC  xD1.7
07F7E:  BRA    7FEC
07F80:  MOVF   xD1,W
07F82:  SUBLW  2F
07F84:  BC    7FEC
07F86:  BTFSC  xD1.7
07F88:  BRA    7F90
07F8A:  MOVF   xD1,W
07F8C:  SUBLW  39
07F8E:  BNC   7FEC
....................                result = (result << 4) + (c - '0'); 
07F90:  RLCF   xC7,W
07F92:  MOVWF  xD3
07F94:  RLCF   xC8,W
07F96:  MOVWF  xD4
07F98:  RLCF   xC9,W
07F9A:  MOVWF  xD5
07F9C:  RLCF   xCA,W
07F9E:  MOVWF  xD6
07FA0:  RLCF   xD3,F
07FA2:  RLCF   xD4,F
07FA4:  RLCF   xD5,F
07FA6:  RLCF   xD6,F
07FA8:  RLCF   xD3,F
07FAA:  RLCF   xD4,F
07FAC:  RLCF   xD5,F
07FAE:  RLCF   xD6,F
07FB0:  RLCF   xD3,F
07FB2:  RLCF   xD4,F
07FB4:  RLCF   xD5,F
07FB6:  RLCF   xD6,F
07FB8:  MOVLW  F0
07FBA:  ANDWF  xD3,F
07FBC:  MOVLW  30
07FBE:  SUBWF  xD1,W
07FC0:  MOVWF  00
07FC2:  CLRF   01
07FC4:  CLRF   02
07FC6:  CLRF   03
07FC8:  BTFSS  FE8.7
07FCA:  BRA    7FD2
07FCC:  DECF   01,F
07FCE:  DECF   02,F
07FD0:  DECF   03,F
07FD2:  MOVF   00,W
07FD4:  ADDWF  xD3,W
07FD6:  MOVWF  xC7
07FD8:  MOVF   01,W
07FDA:  ADDWFC xD4,W
07FDC:  MOVWF  xC8
07FDE:  MOVF   02,W
07FE0:  ADDWFC xD5,W
07FE2:  MOVWF  xC9
07FE4:  MOVF   03,W
07FE6:  ADDWFC xD6,W
07FE8:  MOVWF  xCA
07FEA:  BRA    804A
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
07FEC:  RLCF   xC7,W
07FEE:  MOVWF  xD3
07FF0:  RLCF   xC8,W
07FF2:  MOVWF  xD4
07FF4:  RLCF   xC9,W
07FF6:  MOVWF  xD5
07FF8:  RLCF   xCA,W
07FFA:  MOVWF  xD6
07FFC:  RLCF   xD3,F
07FFE:  RLCF   xD4,F
08000:  RLCF   xD5,F
08002:  RLCF   xD6,F
08004:  RLCF   xD3,F
08006:  RLCF   xD4,F
08008:  RLCF   xD5,F
0800A:  RLCF   xD6,F
0800C:  RLCF   xD3,F
0800E:  RLCF   xD4,F
08010:  RLCF   xD5,F
08012:  RLCF   xD6,F
08014:  MOVLW  F0
08016:  ANDWF  xD3,F
08018:  MOVLW  41
0801A:  SUBWF  xD1,W
0801C:  ADDLW  0A
0801E:  MOVWF  01
08020:  CLRF   03
08022:  BTFSC  FD8.0
08024:  INCF   03,F
08026:  MOVF   01,W
08028:  ADDWF  xD3,W
0802A:  MOVWF  00
0802C:  MOVF   03,W
0802E:  ADDWFC xD4,W
08030:  MOVWF  01
08032:  MOVLW  00
08034:  ADDWFC xD5,W
08036:  MOVWF  02
08038:  MOVLW  00
0803A:  ADDWFC xD6,W
0803C:  MOVWF  xCA
0803E:  MOVFF  02,5C9
08042:  MOVFF  01,5C8
08046:  MOVFF  00,5C7
....................  
....................             c = s[index++];c = toupper(c); 
0804A:  MOVFF  5D0,03
0804E:  MOVF   xCF,W
08050:  INCF   xCF,F
08052:  BTFSC  FD8.2
08054:  INCF   xD0,F
08056:  MOVWF  xD2
08058:  MOVFF  03,5D3
0805C:  MOVF   xC5,W
0805E:  ADDWF  xD2,W
08060:  MOVWF  FE9
08062:  MOVF   xC6,W
08064:  ADDWFC 03,W
08066:  MOVWF  FEA
08068:  MOVFF  FEF,5D1
0806C:  BTFSC  xD1.7
0806E:  BRA    8086
08070:  MOVF   xD1,W
08072:  SUBLW  60
08074:  BC    8086
08076:  BTFSC  xD1.7
08078:  BRA    8080
0807A:  MOVF   xD1,W
0807C:  SUBLW  7A
0807E:  BNC   8086
08080:  MOVF   xD1,W
08082:  ANDLW  DF
08084:  BRA    8088
08086:  MOVF   xD1,W
08088:  MOVWF  xD1
0808A:  BRA    7F50
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0808C:  MOVF   xCD,W
0808E:  SUBLW  0A
08090:  BNZ   80B4
08092:  MOVF   xCE,F
08094:  BNZ   80B4
08096:  DECFSZ xCB,W
08098:  BRA    80B4
0809A:  MOVF   xCC,F
0809C:  BNZ   80B4
....................       result = -result; 
0809E:  COMF   xC7,F
080A0:  COMF   xC8,F
080A2:  COMF   xC9,F
080A4:  COMF   xCA,F
080A6:  INCF   xC7,F
080A8:  BTFSC  FD8.2
080AA:  INCF   xC8,F
080AC:  BTFSC  FD8.2
080AE:  INCF   xC9,F
080B0:  BTFSC  FD8.2
080B2:  INCF   xCA,F
....................  
....................    return(result); 
080B4:  MOVFF  5C7,00
080B8:  MOVFF  5C8,01
080BC:  MOVFF  5C9,02
080C0:  MOVFF  5CA,03
080C4:  MOVLB  0
080C6:  GOTO   A530 (RETURN)
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
07222:  MOVLB  5
07224:  CLRF   xEA
07226:  CLRF   xE9
07228:  CLRF   xE8
0722A:  CLRF   xE7
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
0722C:  MOVLW  30
0722E:  MOVWF  xEC
07230:  MOVLW  31
07232:  MOVWF  xED
07234:  MOVLW  32
07236:  MOVWF  xEE
07238:  MOVLW  33
0723A:  MOVWF  xEF
0723C:  MOVLW  34
0723E:  MOVWF  xF0
07240:  MOVLW  35
07242:  MOVWF  xF1
07244:  MOVLW  36
07246:  MOVWF  xF2
07248:  MOVLW  37
0724A:  MOVWF  xF3
0724C:  MOVLW  38
0724E:  MOVWF  xF4
07250:  MOVLW  39
07252:  MOVWF  xF5
07254:  MOVLW  61
07256:  MOVWF  xF6
07258:  MOVLW  62
0725A:  MOVWF  xF7
0725C:  MOVLW  63
0725E:  MOVWF  xF8
07260:  MOVLW  64
07262:  MOVWF  xF9
07264:  MOVLW  65
07266:  MOVWF  xFA
07268:  MOVLW  66
0726A:  MOVWF  xFB
0726C:  MOVLW  67
0726E:  MOVWF  xFC
07270:  MOVLW  68
07272:  MOVWF  xFD
07274:  MOVLW  69
07276:  MOVWF  xFE
07278:  MOVLW  6A
0727A:  MOVWF  xFF
0727C:  MOVLW  6B
0727E:  MOVLB  6
07280:  MOVWF  x00
07282:  MOVLW  6C
07284:  MOVWF  x01
07286:  MOVLW  6D
07288:  MOVWF  x02
0728A:  MOVLW  6E
0728C:  MOVWF  x03
0728E:  MOVLW  6F
07290:  MOVWF  x04
07292:  MOVLW  70
07294:  MOVWF  x05
07296:  MOVLW  71
07298:  MOVWF  x06
0729A:  MOVLW  73
0729C:  MOVWF  x07
0729E:  MOVLW  74
072A0:  MOVWF  x08
072A2:  MOVLW  75
072A4:  MOVWF  x09
072A6:  MOVLW  76
072A8:  MOVWF  x0A
072AA:  MOVLW  77
072AC:  MOVWF  x0B
072AE:  MOVLW  78
072B0:  MOVWF  x0C
072B2:  MOVLW  79
072B4:  MOVWF  x0D
072B6:  MOVLW  7A
072B8:  MOVWF  x0E
072BA:  CLRF   x0F
....................    for(sc=s;isspace(*sc);++sc); 
072BC:  MOVFF  5DC,5E2
072C0:  MOVFF  5DB,5E1
072C4:  MOVFF  5E2,03
072C8:  MOVLB  5
072CA:  MOVFF  5E1,FE9
072CE:  MOVFF  5E2,FEA
072D2:  MOVF   FEF,W
072D4:  SUBLW  20
072D6:  BNZ   72E4
072D8:  INCF   xE1,F
072DA:  BTFSC  FD8.2
072DC:  INCF   xE2,F
072DE:  MOVLB  6
072E0:  BRA    72C4
072E2:  MOVLB  5
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
072E4:  MOVFF  5E2,03
072E8:  MOVFF  5E1,FE9
072EC:  MOVFF  5E2,FEA
072F0:  MOVF   FEF,W
072F2:  SUBLW  2D
072F4:  BZ    7308
072F6:  MOVFF  5E2,03
072FA:  MOVFF  5E1,FE9
072FE:  MOVFF  5E2,FEA
07302:  MOVF   FEF,W
07304:  SUBLW  2B
07306:  BNZ   731E
07308:  MOVFF  5E2,03
0730C:  MOVF   xE1,W
0730E:  INCF   xE1,F
07310:  BTFSC  FD8.2
07312:  INCF   xE2,F
07314:  MOVWF  FE9
07316:  MOVFF  03,FEA
0731A:  MOVF   FEF,W
0731C:  BRA    7320
0731E:  MOVLW  2B
07320:  MOVWF  xEB
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
07322:  MOVF   xEB,W
07324:  SUBLW  2D
07326:  BZ    7342
07328:  BTFSC  xE0.7
0732A:  BRA    7342
0732C:  DECFSZ xDF,W
0732E:  BRA    7334
07330:  MOVF   xE0,F
07332:  BZ    7342
07334:  BTFSC  xE0.7
07336:  BRA    7346
07338:  MOVF   xE0,F
0733A:  BNZ   7342
0733C:  MOVF   xDF,W
0733E:  SUBLW  24
07340:  BC    7346
....................    goto StrtoulGO; 
07342:  BRA    75E6
07344:  BRA    7464
....................  
....................    else if (base) 
07346:  MOVF   xDF,W
07348:  IORWF  xE0,W
0734A:  BZ    73F0
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
0734C:  MOVF   xDF,W
0734E:  SUBLW  10
07350:  BNZ   7394
07352:  MOVF   xE0,F
07354:  BNZ   7394
07356:  MOVFF  5E2,03
0735A:  MOVFF  5E1,FE9
0735E:  MOVFF  5E2,FEA
07362:  MOVF   FEF,W
07364:  SUBLW  30
07366:  BNZ   7394
07368:  MOVLW  01
0736A:  ADDWF  xE1,W
0736C:  MOVWF  FE9
0736E:  MOVLW  00
07370:  ADDWFC xE2,W
07372:  MOVWF  FEA
07374:  MOVF   FEF,W
07376:  SUBLW  78
07378:  BZ    738C
0737A:  MOVLW  01
0737C:  ADDWF  xE1,W
0737E:  MOVWF  FE9
07380:  MOVLW  00
07382:  ADDWFC xE2,W
07384:  MOVWF  FEA
07386:  MOVF   FEF,W
07388:  SUBLW  58
0738A:  BNZ   7394
....................          sc+=2; 
0738C:  MOVLW  02
0738E:  ADDWF  xE1,F
07390:  MOVLW  00
07392:  ADDWFC xE2,F
....................       if(base==8 && *sc =='0') 
07394:  MOVF   xDF,W
07396:  SUBLW  08
07398:  BNZ   73B8
0739A:  MOVF   xE0,F
0739C:  BNZ   73B8
0739E:  MOVFF  5E2,03
073A2:  MOVFF  5E1,FE9
073A6:  MOVFF  5E2,FEA
073AA:  MOVF   FEF,W
073AC:  SUBLW  30
073AE:  BNZ   73B8
....................          sc+=1; 
073B0:  MOVLW  01
073B2:  ADDWF  xE1,F
073B4:  MOVLW  00
073B6:  ADDWFC xE2,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
073B8:  MOVF   xDF,W
073BA:  SUBLW  02
073BC:  BNZ   73EE
073BE:  MOVF   xE0,F
073C0:  BNZ   73EE
073C2:  MOVFF  5E2,03
073C6:  MOVFF  5E1,FE9
073CA:  MOVFF  5E2,FEA
073CE:  MOVF   FEF,W
073D0:  SUBLW  30
073D2:  BNZ   73EE
073D4:  MOVLW  01
073D6:  ADDWF  xE1,W
073D8:  MOVWF  FE9
073DA:  MOVLW  00
073DC:  ADDWFC xE2,W
073DE:  MOVWF  FEA
073E0:  MOVF   FEF,W
073E2:  SUBLW  62
073E4:  BNZ   73EE
....................          sc+=2; 
073E6:  MOVLW  02
073E8:  ADDWF  xE1,F
073EA:  MOVLW  00
073EC:  ADDWFC xE2,F
....................  
....................    } 
073EE:  BRA    7464
....................    else if(*sc!='0') // base is 0, find base 
073F0:  MOVFF  5E2,03
073F4:  MOVFF  5E1,FE9
073F8:  MOVFF  5E2,FEA
073FC:  MOVF   FEF,W
073FE:  SUBLW  30
07400:  BZ    740A
....................       base=10; 
07402:  CLRF   xE0
07404:  MOVLW  0A
07406:  MOVWF  xDF
07408:  BRA    7464
....................    else if (sc[1]=='x' || sc[1]=='X') 
0740A:  MOVLW  01
0740C:  ADDWF  xE1,W
0740E:  MOVWF  FE9
07410:  MOVLW  00
07412:  ADDWFC xE2,W
07414:  MOVWF  FEA
07416:  MOVF   FEF,W
07418:  SUBLW  78
0741A:  BZ    742E
0741C:  MOVLW  01
0741E:  ADDWF  xE1,W
07420:  MOVWF  FE9
07422:  MOVLW  00
07424:  ADDWFC xE2,W
07426:  MOVWF  FEA
07428:  MOVF   FEF,W
0742A:  SUBLW  58
0742C:  BNZ   743E
....................       base =16,sc+=2; 
0742E:  CLRF   xE0
07430:  MOVLW  10
07432:  MOVWF  xDF
07434:  MOVLW  02
07436:  ADDWF  xE1,F
07438:  MOVLW  00
0743A:  ADDWFC xE2,F
0743C:  BRA    7464
....................    else if(sc[1]=='b') 
0743E:  MOVLW  01
07440:  ADDWF  xE1,W
07442:  MOVWF  FE9
07444:  MOVLW  00
07446:  ADDWFC xE2,W
07448:  MOVWF  FEA
0744A:  MOVF   FEF,W
0744C:  SUBLW  62
0744E:  BNZ   745E
....................       base=2,sc+=2; 
07450:  CLRF   xE0
07452:  MOVLW  02
07454:  MOVWF  xDF
07456:  ADDWF  xE1,F
07458:  MOVLW  00
0745A:  ADDWFC xE2,F
0745C:  BRA    7464
....................    else 
....................       base=8; 
0745E:  CLRF   xE0
07460:  MOVLW  08
07462:  MOVWF  xDF
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
07464:  MOVFF  5E2,5E4
07468:  MOVFF  5E1,5E3
0746C:  MOVFF  5E2,03
07470:  MOVFF  5E1,FE9
07474:  MOVFF  5E2,FEA
07478:  MOVF   FEF,W
0747A:  SUBLW  30
0747C:  BNZ   7486
0747E:  INCF   xE1,F
07480:  BTFSC  FD8.2
07482:  INCF   xE2,F
07484:  BRA    746C
....................    sd=memchr(digits,tolower(*sc),base); 
07486:  MOVFF  5E2,03
0748A:  MOVFF  5E1,FE9
0748E:  MOVFF  5E2,FEA
07492:  MOVFF  FEF,610
07496:  MOVLB  6
07498:  BTFSC  x10.7
0749A:  BRA    74B2
0749C:  MOVF   x10,W
0749E:  SUBLW  40
074A0:  BC    74B2
074A2:  BTFSC  x10.7
074A4:  BRA    74AC
074A6:  MOVF   x10,W
074A8:  SUBLW  5A
074AA:  BNC   74B2
074AC:  MOVF   x10,W
074AE:  IORLW  20
074B0:  BRA    74B4
074B2:  MOVF   x10,W
074B4:  MOVWF  x10
074B6:  MOVLW  05
074B8:  MOVWF  x17
074BA:  MOVLW  EC
074BC:  MOVWF  x16
074BE:  MOVFF  610,618
074C2:  MOVFF  5E0,61A
074C6:  MOVFF  5DF,619
074CA:  MOVLB  0
074CC:  RCALL  71D4
074CE:  MOVFF  02,5E6
074D2:  MOVFF  01,5E5
....................    for(; sd!=0; ) 
074D6:  MOVLB  5
074D8:  MOVF   xE5,F
074DA:  BNZ   74E2
074DC:  MOVF   xE6,F
074DE:  BTFSC  FD8.2
074E0:  BRA    75DA
....................    { 
....................       x=x*base+(int16)(sd-digits); 
074E2:  MOVFF  5DF,00
074E6:  MOVFF  5E0,01
074EA:  CLRF   02
074EC:  CLRF   03
074EE:  BTFSS  xE0.7
074F0:  BRA    74F6
074F2:  DECF   02,F
074F4:  DECF   03,F
074F6:  MOVFF  03,613
074FA:  MOVFF  02,612
074FE:  MOVFF  01,611
07502:  MOVFF  00,610
07506:  MOVFF  5EA,61C
0750A:  MOVFF  5E9,61B
0750E:  MOVFF  5E8,61A
07512:  MOVFF  5E7,619
07516:  MOVFF  03,620
0751A:  MOVFF  02,61F
0751E:  MOVFF  01,61E
07522:  MOVFF  00,61D
07526:  MOVLB  0
07528:  CALL   1856
0752C:  MOVFF  03,613
07530:  MOVFF  02,612
07534:  MOVFF  01,611
07538:  MOVFF  00,610
0753C:  MOVLW  EC
0753E:  MOVLB  5
07540:  SUBWF  xE5,W
07542:  MOVWF  00
07544:  MOVLW  05
07546:  SUBWFB xE6,W
07548:  MOVWF  03
0754A:  MOVF   00,W
0754C:  MOVFF  03,01
07550:  CLRF   02
07552:  CLRF   03
07554:  BTFSS  01.7
07556:  BRA    755C
07558:  DECF   02,F
0755A:  DECF   03,F
0755C:  MOVLB  6
0755E:  MOVF   x10,W
07560:  ADDWF  00,F
07562:  MOVF   x11,W
07564:  ADDWFC 01,F
07566:  MOVF   x12,W
07568:  ADDWFC 02,F
0756A:  MOVF   x13,W
0756C:  ADDWFC 03,F
0756E:  MOVFF  03,5EA
07572:  MOVFF  02,5E9
07576:  MOVFF  01,5E8
0757A:  MOVFF  00,5E7
....................       ++sc; 
0757E:  MOVLB  5
07580:  INCF   xE1,F
07582:  BTFSC  FD8.2
07584:  INCF   xE2,F
....................       sd=memchr(digits,tolower(*sc),base); 
07586:  MOVFF  5E2,03
0758A:  MOVFF  5E1,FE9
0758E:  MOVFF  5E2,FEA
07592:  MOVFF  FEF,610
07596:  MOVLB  6
07598:  BTFSC  x10.7
0759A:  BRA    75B2
0759C:  MOVF   x10,W
0759E:  SUBLW  40
075A0:  BC    75B2
075A2:  BTFSC  x10.7
075A4:  BRA    75AC
075A6:  MOVF   x10,W
075A8:  SUBLW  5A
075AA:  BNC   75B2
075AC:  MOVF   x10,W
075AE:  IORLW  20
075B0:  BRA    75B4
075B2:  MOVF   x10,W
075B4:  MOVWF  x10
075B6:  MOVLW  05
075B8:  MOVWF  x17
075BA:  MOVLW  EC
075BC:  MOVWF  x16
075BE:  MOVFF  610,618
075C2:  MOVFF  5E0,61A
075C6:  MOVFF  5DF,619
075CA:  MOVLB  0
075CC:  RCALL  71D4
075CE:  MOVFF  02,5E6
075D2:  MOVFF  01,5E5
075D6:  BRA    74D6
075D8:  MOVLB  5
....................    } 
....................    if(s1==sc) 
075DA:  MOVF   xE1,W
075DC:  SUBWF  xE3,W
075DE:  BNZ   7608
075E0:  MOVF   xE2,W
075E2:  SUBWF  xE4,W
075E4:  BNZ   7608
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
075E6:  MOVF   xDD,W
075E8:  IORWF  xDE,W
075EA:  BZ    75FE
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
075EC:  MOVFF  5DD,FE9
075F0:  MOVFF  5DE,FEA
075F4:  MOVFF  5DC,FEC
075F8:  MOVF   FED,F
075FA:  MOVFF  5DB,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
075FE:  CLRF   00
07600:  CLRF   01
07602:  CLRF   02
07604:  CLRF   03
07606:  BRA    7630
....................    } 
....................    if (endptr) 
07608:  MOVF   xDD,W
0760A:  IORWF  xDE,W
0760C:  BZ    7620
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
0760E:  MOVFF  5DD,FE9
07612:  MOVFF  5DE,FEA
07616:  MOVFF  5E2,FEC
0761A:  MOVF   FED,F
0761C:  MOVFF  5E1,FEF
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
07620:  MOVFF  5E7,00
07624:  MOVFF  5E8,01
07628:  MOVFF  5E9,02
0762C:  MOVFF  5EA,03
07630:  MOVLB  0
07632:  GOTO   77D2 (RETURN)
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
*
0934E:  MOVLB  5
09350:  CLRF   xEF
09352:  CLRF   xEE
09354:  CLRF   xED
09356:  CLRF   xEC
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
09358:  MOVLW  30
0935A:  MOVWF  xF1
0935C:  MOVLW  31
0935E:  MOVWF  xF2
09360:  MOVLW  32
09362:  MOVWF  xF3
09364:  MOVLW  33
09366:  MOVWF  xF4
09368:  MOVLW  34
0936A:  MOVWF  xF5
0936C:  MOVLW  35
0936E:  MOVWF  xF6
09370:  MOVLW  36
09372:  MOVWF  xF7
09374:  MOVLW  37
09376:  MOVWF  xF8
09378:  MOVLW  38
0937A:  MOVWF  xF9
0937C:  MOVLW  39
0937E:  MOVWF  xFA
09380:  MOVLW  61
09382:  MOVWF  xFB
09384:  MOVLW  62
09386:  MOVWF  xFC
09388:  MOVLW  63
0938A:  MOVWF  xFD
0938C:  MOVLW  64
0938E:  MOVWF  xFE
09390:  MOVLW  65
09392:  MOVWF  xFF
09394:  MOVLW  66
09396:  MOVLB  6
09398:  MOVWF  x00
0939A:  MOVLW  67
0939C:  MOVWF  x01
0939E:  MOVLW  68
093A0:  MOVWF  x02
093A2:  MOVLW  69
093A4:  MOVWF  x03
093A6:  MOVLW  6A
093A8:  MOVWF  x04
093AA:  MOVLW  6B
093AC:  MOVWF  x05
093AE:  MOVLW  6C
093B0:  MOVWF  x06
093B2:  MOVLW  6D
093B4:  MOVWF  x07
093B6:  MOVLW  6E
093B8:  MOVWF  x08
093BA:  MOVLW  6F
093BC:  MOVWF  x09
093BE:  MOVLW  70
093C0:  MOVWF  x0A
093C2:  MOVLW  71
093C4:  MOVWF  x0B
093C6:  MOVLW  73
093C8:  MOVWF  x0C
093CA:  MOVLW  74
093CC:  MOVWF  x0D
093CE:  MOVLW  75
093D0:  MOVWF  x0E
093D2:  MOVLW  76
093D4:  MOVWF  x0F
093D6:  MOVLW  77
093D8:  MOVWF  x10
093DA:  MOVLW  78
093DC:  MOVWF  x11
093DE:  MOVLW  79
093E0:  MOVWF  x12
093E2:  MOVLW  7A
093E4:  MOVWF  x13
093E6:  CLRF   x14
....................    for(sc=s;isspace(*sc);++sc); 
093E8:  MOVFF  5E1,5E7
093EC:  MOVFF  5E0,5E6
093F0:  MOVFF  5E7,03
093F4:  MOVLB  5
093F6:  MOVFF  5E6,FE9
093FA:  MOVFF  5E7,FEA
093FE:  MOVF   FEF,W
09400:  SUBLW  20
09402:  BNZ   9410
09404:  INCF   xE6,F
09406:  BTFSC  FD8.2
09408:  INCF   xE7,F
0940A:  MOVLB  6
0940C:  BRA    93F0
0940E:  MOVLB  5
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
09410:  MOVFF  5E7,03
09414:  MOVFF  5E6,FE9
09418:  MOVFF  5E7,FEA
0941C:  MOVF   FEF,W
0941E:  SUBLW  2D
09420:  BZ    9434
09422:  MOVFF  5E7,03
09426:  MOVFF  5E6,FE9
0942A:  MOVFF  5E7,FEA
0942E:  MOVF   FEF,W
09430:  SUBLW  2B
09432:  BNZ   944A
09434:  MOVFF  5E7,03
09438:  MOVF   xE6,W
0943A:  INCF   xE6,F
0943C:  BTFSC  FD8.2
0943E:  INCF   xE7,F
09440:  MOVWF  FE9
09442:  MOVFF  03,FEA
09446:  MOVF   FEF,W
09448:  BRA    944C
0944A:  MOVLW  2B
0944C:  MOVWF  xF0
....................    if (base <0 || base ==1|| base >36) // invalid base 
0944E:  BTFSC  xE5.7
09450:  BRA    9468
09452:  DECFSZ xE4,W
09454:  BRA    945A
09456:  MOVF   xE5,F
09458:  BZ    9468
0945A:  BTFSC  xE5.7
0945C:  BRA    946C
0945E:  MOVF   xE5,F
09460:  BNZ   9468
09462:  MOVF   xE4,W
09464:  SUBLW  24
09466:  BC    946C
....................    goto StrtolGO; 
09468:  BRA    9714
0946A:  BRA    958A
....................    else if (base) 
0946C:  MOVF   xE4,W
0946E:  IORWF  xE5,W
09470:  BZ    9516
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
09472:  MOVF   xE4,W
09474:  SUBLW  10
09476:  BNZ   94BA
09478:  MOVF   xE5,F
0947A:  BNZ   94BA
0947C:  MOVFF  5E7,03
09480:  MOVFF  5E6,FE9
09484:  MOVFF  5E7,FEA
09488:  MOVF   FEF,W
0948A:  SUBLW  30
0948C:  BNZ   94BA
0948E:  MOVLW  01
09490:  ADDWF  xE6,W
09492:  MOVWF  FE9
09494:  MOVLW  00
09496:  ADDWFC xE7,W
09498:  MOVWF  FEA
0949A:  MOVF   FEF,W
0949C:  SUBLW  78
0949E:  BZ    94B2
094A0:  MOVLW  01
094A2:  ADDWF  xE6,W
094A4:  MOVWF  FE9
094A6:  MOVLW  00
094A8:  ADDWFC xE7,W
094AA:  MOVWF  FEA
094AC:  MOVF   FEF,W
094AE:  SUBLW  58
094B0:  BNZ   94BA
....................          sc+=2; 
094B2:  MOVLW  02
094B4:  ADDWF  xE6,F
094B6:  MOVLW  00
094B8:  ADDWFC xE7,F
....................       if(base==8 && *sc =='0') 
094BA:  MOVF   xE4,W
094BC:  SUBLW  08
094BE:  BNZ   94DE
094C0:  MOVF   xE5,F
094C2:  BNZ   94DE
094C4:  MOVFF  5E7,03
094C8:  MOVFF  5E6,FE9
094CC:  MOVFF  5E7,FEA
094D0:  MOVF   FEF,W
094D2:  SUBLW  30
094D4:  BNZ   94DE
....................          sc+=1; 
094D6:  MOVLW  01
094D8:  ADDWF  xE6,F
094DA:  MOVLW  00
094DC:  ADDWFC xE7,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
094DE:  MOVF   xE4,W
094E0:  SUBLW  02
094E2:  BNZ   9514
094E4:  MOVF   xE5,F
094E6:  BNZ   9514
094E8:  MOVFF  5E7,03
094EC:  MOVFF  5E6,FE9
094F0:  MOVFF  5E7,FEA
094F4:  MOVF   FEF,W
094F6:  SUBLW  30
094F8:  BNZ   9514
094FA:  MOVLW  01
094FC:  ADDWF  xE6,W
094FE:  MOVWF  FE9
09500:  MOVLW  00
09502:  ADDWFC xE7,W
09504:  MOVWF  FEA
09506:  MOVF   FEF,W
09508:  SUBLW  62
0950A:  BNZ   9514
....................          sc+=2; 
0950C:  MOVLW  02
0950E:  ADDWF  xE6,F
09510:  MOVLW  00
09512:  ADDWFC xE7,F
....................  
....................    } 
09514:  BRA    958A
....................    else if(*sc!='0') // base is 0, find base 
09516:  MOVFF  5E7,03
0951A:  MOVFF  5E6,FE9
0951E:  MOVFF  5E7,FEA
09522:  MOVF   FEF,W
09524:  SUBLW  30
09526:  BZ    9530
....................       base=10; 
09528:  CLRF   xE5
0952A:  MOVLW  0A
0952C:  MOVWF  xE4
0952E:  BRA    958A
....................    else if (sc[1]=='x' || sc[1]=='X') 
09530:  MOVLW  01
09532:  ADDWF  xE6,W
09534:  MOVWF  FE9
09536:  MOVLW  00
09538:  ADDWFC xE7,W
0953A:  MOVWF  FEA
0953C:  MOVF   FEF,W
0953E:  SUBLW  78
09540:  BZ    9554
09542:  MOVLW  01
09544:  ADDWF  xE6,W
09546:  MOVWF  FE9
09548:  MOVLW  00
0954A:  ADDWFC xE7,W
0954C:  MOVWF  FEA
0954E:  MOVF   FEF,W
09550:  SUBLW  58
09552:  BNZ   9564
....................       base =16,sc+=2; 
09554:  CLRF   xE5
09556:  MOVLW  10
09558:  MOVWF  xE4
0955A:  MOVLW  02
0955C:  ADDWF  xE6,F
0955E:  MOVLW  00
09560:  ADDWFC xE7,F
09562:  BRA    958A
....................    else if(sc[1]=='b') 
09564:  MOVLW  01
09566:  ADDWF  xE6,W
09568:  MOVWF  FE9
0956A:  MOVLW  00
0956C:  ADDWFC xE7,W
0956E:  MOVWF  FEA
09570:  MOVF   FEF,W
09572:  SUBLW  62
09574:  BNZ   9584
....................       base=2,sc+=2; 
09576:  CLRF   xE5
09578:  MOVLW  02
0957A:  MOVWF  xE4
0957C:  ADDWF  xE6,F
0957E:  MOVLW  00
09580:  ADDWFC xE7,F
09582:  BRA    958A
....................    else 
....................       base=8; 
09584:  CLRF   xE5
09586:  MOVLW  08
09588:  MOVWF  xE4
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
0958A:  MOVFF  5E7,5E9
0958E:  MOVFF  5E6,5E8
09592:  MOVFF  5E7,03
09596:  MOVFF  5E6,FE9
0959A:  MOVFF  5E7,FEA
0959E:  MOVF   FEF,W
095A0:  SUBLW  30
095A2:  BNZ   95AC
095A4:  INCF   xE6,F
095A6:  BTFSC  FD8.2
095A8:  INCF   xE7,F
095AA:  BRA    9592
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
095AC:  MOVFF  5E7,03
095B0:  MOVFF  5E6,FE9
095B4:  MOVFF  5E7,FEA
095B8:  MOVFF  FEF,615
095BC:  MOVLB  6
095BE:  BTFSC  x15.7
095C0:  BRA    95D8
095C2:  MOVF   x15,W
095C4:  SUBLW  40
095C6:  BC    95D8
095C8:  BTFSC  x15.7
095CA:  BRA    95D2
095CC:  MOVF   x15,W
095CE:  SUBLW  5A
095D0:  BNC   95D8
095D2:  MOVF   x15,W
095D4:  IORLW  20
095D6:  BRA    95DA
095D8:  MOVF   x15,W
095DA:  MOVWF  x15
095DC:  MOVLW  05
095DE:  MOVWF  x17
095E0:  MOVLW  F1
095E2:  MOVWF  x16
095E4:  MOVFF  615,618
095E8:  MOVFF  5E5,61A
095EC:  MOVFF  5E4,619
095F0:  MOVLB  0
095F2:  CALL   71D4
095F6:  MOVFF  02,5EB
095FA:  MOVFF  01,5EA
....................    for(;sd!=0;) 
095FE:  MOVLB  5
09600:  MOVF   xEA,F
09602:  BNZ   960A
09604:  MOVF   xEB,F
09606:  BTFSC  FD8.2
09608:  BRA    9708
....................    { 
....................       x=x*base+(int16)(sd-digits); 
0960A:  MOVFF  5E4,00
0960E:  MOVFF  5E5,01
09612:  CLRF   02
09614:  CLRF   03
09616:  BTFSS  xE5.7
09618:  BRA    961E
0961A:  DECF   02,F
0961C:  DECF   03,F
0961E:  MOVFF  03,618
09622:  MOVFF  02,617
09626:  MOVFF  01,616
0962A:  MOVFF  00,615
0962E:  MOVFF  5EF,61C
09632:  MOVFF  5EE,61B
09636:  MOVFF  5ED,61A
0963A:  MOVFF  5EC,619
0963E:  MOVFF  03,620
09642:  MOVFF  02,61F
09646:  MOVFF  01,61E
0964A:  MOVFF  00,61D
0964E:  MOVLB  0
09650:  CALL   1856
09654:  MOVFF  03,618
09658:  MOVFF  02,617
0965C:  MOVFF  01,616
09660:  MOVFF  00,615
09664:  MOVLW  F1
09666:  MOVLB  5
09668:  SUBWF  xEA,W
0966A:  MOVWF  00
0966C:  MOVLW  05
0966E:  SUBWFB xEB,W
09670:  MOVWF  03
09672:  MOVF   00,W
09674:  MOVFF  03,01
09678:  CLRF   02
0967A:  CLRF   03
0967C:  BTFSS  01.7
0967E:  BRA    9684
09680:  DECF   02,F
09682:  DECF   03,F
09684:  MOVF   00,W
09686:  MOVLB  6
09688:  ADDWF  x15,W
0968A:  MOVLB  5
0968C:  MOVWF  xEC
0968E:  MOVF   01,W
09690:  MOVLB  6
09692:  ADDWFC x16,W
09694:  MOVLB  5
09696:  MOVWF  xED
09698:  MOVF   02,W
0969A:  MOVLB  6
0969C:  ADDWFC x17,W
0969E:  MOVLB  5
096A0:  MOVWF  xEE
096A2:  MOVF   03,W
096A4:  MOVLB  6
096A6:  ADDWFC x18,W
096A8:  MOVLB  5
096AA:  MOVWF  xEF
....................       ++sc; 
096AC:  INCF   xE6,F
096AE:  BTFSC  FD8.2
096B0:  INCF   xE7,F
....................       sd=memchr(digits,tolower(*sc),base); 
096B2:  MOVFF  5E7,03
096B6:  MOVFF  5E6,FE9
096BA:  MOVFF  5E7,FEA
096BE:  MOVFF  FEF,615
096C2:  MOVLB  6
096C4:  BTFSC  x15.7
096C6:  BRA    96DE
096C8:  MOVF   x15,W
096CA:  SUBLW  40
096CC:  BC    96DE
096CE:  BTFSC  x15.7
096D0:  BRA    96D8
096D2:  MOVF   x15,W
096D4:  SUBLW  5A
096D6:  BNC   96DE
096D8:  MOVF   x15,W
096DA:  IORLW  20
096DC:  BRA    96E0
096DE:  MOVF   x15,W
096E0:  MOVWF  x15
096E2:  MOVLW  05
096E4:  MOVWF  x17
096E6:  MOVLW  F1
096E8:  MOVWF  x16
096EA:  MOVFF  615,618
096EE:  MOVFF  5E5,61A
096F2:  MOVFF  5E4,619
096F6:  MOVLB  0
096F8:  CALL   71D4
096FC:  MOVFF  02,5EB
09700:  MOVFF  01,5EA
09704:  BRA    95FE
09706:  MOVLB  5
....................    } 
....................    if(s1==sc) 
09708:  MOVF   xE6,W
0970A:  SUBWF  xE8,W
0970C:  BNZ   9736
0970E:  MOVF   xE7,W
09710:  SUBWF  xE9,W
09712:  BNZ   9736
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
09714:  MOVF   xE2,W
09716:  IORWF  xE3,W
09718:  BZ    972C
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
0971A:  MOVFF  5E2,FE9
0971E:  MOVFF  5E3,FEA
09722:  MOVFF  5E1,FEC
09726:  MOVF   FED,F
09728:  MOVFF  5E0,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
0972C:  CLRF   00
0972E:  CLRF   01
09730:  CLRF   02
09732:  CLRF   03
09734:  BRA    977A
....................    } 
....................    if(sign=='-') 
09736:  MOVF   xF0,W
09738:  SUBLW  2D
0973A:  BNZ   9752
....................       x  =-x; 
0973C:  COMF   xEC,F
0973E:  COMF   xED,F
09740:  COMF   xEE,F
09742:  COMF   xEF,F
09744:  INCF   xEC,F
09746:  BTFSC  FD8.2
09748:  INCF   xED,F
0974A:  BTFSC  FD8.2
0974C:  INCF   xEE,F
0974E:  BTFSC  FD8.2
09750:  INCF   xEF,F
....................    if (endptr) 
09752:  MOVF   xE2,W
09754:  IORWF  xE3,W
09756:  BZ    976A
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
09758:  MOVFF  5E2,FE9
0975C:  MOVFF  5E3,FEA
09760:  MOVFF  5E7,FEC
09764:  MOVF   FED,F
09766:  MOVFF  5E6,FEF
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
0976A:  MOVFF  5EC,00
0976E:  MOVFF  5ED,01
09772:  MOVFF  5EE,02
09776:  MOVFF  5EF,03
0977A:  MOVLB  0
0977C:  GOTO   97C6 (RETURN)
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
018FA:  MOVFF  1E,61C
018FE:  MOVFF  1D,61B
01902:  MOVFF  1C,61A
01906:  MOVFF  1B,619
0190A:  MOVLW  41
0190C:  MOVLB  6
0190E:  MOVWF  x20
01910:  MOVLW  C6
01912:  MOVWF  x1F
01914:  MOVLW  4E
01916:  MOVWF  x1E
01918:  MOVLW  6D
0191A:  MOVWF  x1D
0191C:  MOVLB  0
0191E:  RCALL  1856
01920:  MOVLW  39
01922:  MOVLB  5
01924:  ADDWF  00,W
01926:  MOVWF  1B
01928:  MOVLW  30
0192A:  ADDWFC 01,W
0192C:  MOVWF  1C
0192E:  MOVLW  00
01930:  ADDWFC 02,W
01932:  MOVWF  1D
01934:  MOVLW  00
01936:  ADDWFC 03,W
01938:  MOVWF  1E
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0193A:  MOVFF  1D,00
0193E:  MOVFF  1E,01
01942:  CLRF   02
01944:  CLRF   03
01946:  MOVFF  1E,5C8
0194A:  MOVFF  1D,5C7
0194E:  MOVFF  1E,5CA
01952:  MOVFF  1D,5C9
01956:  MOVLW  7F
01958:  MOVWF  xCC
0195A:  SETF   xCB
0195C:  MOVLB  0
0195E:  BRA    18B2
01960:  MOVFF  00,01
01964:  MOVFF  03,02
01968:  RETURN 0
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "../Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
....................  
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
....................  
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F97J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................  #include "PIC18F4620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1) 
....................  
.................... #define __CCS__ 
....................  
.................... signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... rom char *strchrpgm(rom char* s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, rom char * s2); 
.................... __ADDRESS__ strlenpgm(rom char *s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, rom char *s); 
.................... signed int8 strcmppgm2ram(char *s1, rom char *s2); 
.................... #endif 
....................  
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "../HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATBbits.LATB2 
.................... #define ENC_CS_TRIS      TRISBbits.TRISB2 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATBbits.LATB3 
.................... #define ENC_RST_TRIS     TRISBbits.TRISB3 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
.................... #include <string.h> 
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define STACK_USE_ICMP_SERVER    1 
.................... #define STACK_USE_TCP            1 
.................... #define STACK_USE_DHCP_CLIENT    1 
....................  
.................... #define STACK_CCS_SMTP_TX_SIZE    0 
.................... #define STACK_CCS_SMTP_RX_SIZE    0 
....................  
.................... #define STACK_USE_CCS_HTTP2_SERVER 
.................... #define STACK_CCS_HTTP2_SERVER_TX_SIZE    1500 
.................... #define STACK_CCS_HTTP2_SERVER_RX_SIZE    500 
.................... #define HTTP_NUM_SOCKETS                  1 
.................... #define HTTP_PORT                         (80u) 
.................... #define HTTP_USE_DOUBLE_ESCAPE            1 
.................... #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................  
.................... #define STACK_MY_TELNET_SERVER_TX_SIZE    0 
.................... #define STACK_MY_TELNET_SERVER_RX_SIZE    0 
....................  
.................... #define STACK_MY_HTTPC_RX_SIZE    0 
.................... #define STACK_MY_HTTPC_TX_SIZE    0 
....................  
.................... #define MY_DEFAULT_HOST_NAME      "CCS_EXAMPLES" 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1      (0x0) 
.................... #define MY_DEFAULT_MAC_BYTE2      (0x8) 
.................... #define MY_DEFAULT_MAC_BYTE3      (0xdc) 
.................... #define MY_DEFAULT_MAC_BYTE4      (0x18) 
.................... #define MY_DEFAULT_MAC_BYTE5      (0x7c) 
.................... #define MY_DEFAULT_MAC_BYTE6      (0x6) 
....................  
.................... #define MY_DEFAULT_IP_ADDR_BYTE1  (10ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2  (2ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3  (10ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4  (200ul) 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1     (10ul) 
.................... #define MY_DEFAULT_GATE_BYTE2     (2ul) 
.................... #define MY_DEFAULT_GATE_BYTE3     (10ul) 
.................... #define MY_DEFAULT_GATE_BYTE4     (1ul) 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE2     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE3     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE4     (0ul) 
....................  
.................... #define TCP_CONFIGURATION      1 
....................  
.................... #define TCP_ETH_RAM_SIZE (STACK_CCS_SMTP_TX_SIZE + \ 
....................                           STACK_CCS_SMTP_RX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_TX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_RX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_TX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_RX_SIZE + \ 
....................                           STACK_MY_HTTPC_TX_SIZE + \ 
....................                           STACK_MY_HTTPC_RX_SIZE + \ 
....................                           100*TCP_CONFIGURATION) 
....................  
.................... // Define names of socket types 
.................... #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
.................... #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
.................... #define TCP_PURPOSE_TELNET             2 
.................... #define TCP_PURPOSE_FTP_COMMAND        3 
.................... #define TCP_PURPOSE_FTP_DATA           4 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
.................... #define TCP_PURPOSE_UART_2_TCP_BRIDGE  7 
.................... #define TCP_PURPOSE_HTTP_SERVER        8 
.................... #define TCP_PURPOSE_DEFAULT            9 
.................... #define TCP_PURPOSE_BERKELEY_SERVER    10 
.................... #define TCP_PURPOSE_BERKELEY_CLIENT    11 
.................... #define TCP_PURPOSE_CCS_SMTP           0x40 
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,  
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,  
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook/CCS      WIFI networkType added to AppConfig, hopefully 
....................  *                         this doesn't conflict with EZ_CONFIG_STORE.  
....................  *                      WIFI adhocBehavior added to AppConfig. 
....................  ********************************************************************/ 
.................... #ifndef __STACK_TSK_H 
.................... #define __STACK_TSK_H 
....................  
.................... #if defined (WF_CS_TRIS) 
....................     #include "../WF_Config.h"      
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 ) 
.................... #error Invalid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_HTTP_CONNECTIONS <= 0 || MAX_HTTP_CONNECTIONS > 255 ) 
.................... #error Invalid MAX_HTTP_CONNECTIONS value specified. 
.................... #endif 
....................  
.................... // Structure to contain a MAC address 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... // Definition to represent an IP address 
.................... #define IP_ADDR      DWORD_VAL 
....................  
.................... // Address structure for a node 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     IP_ADDR     IPAddr; 
....................     MAC_ADDR    MACAddr; 
.................... } NODE_INFO; 
....................  
.................... // Application-dependent structure used to contain address information 
.................... typedef struct __attribute__((__packed__)) appConfigStruct  
.................... { 
....................    IP_ADDR      MyIPAddr;               // IP address 
....................    IP_ADDR      MyMask;                 // Subnet mask 
....................    IP_ADDR      MyGateway;              // Default Gateway 
....................    IP_ADDR      PrimaryDNSServer;       // Primary DNS Server 
....................    IP_ADDR      SecondaryDNSServer;     // Secondary DNS Server 
....................    IP_ADDR      DefaultIPAddr;          // Default IP address 
....................    IP_ADDR      DefaultMask;            // Default subnet mask 
....................    BYTE      NetBIOSName[16];        // NetBIOS name 
....................    struct 
....................    { 
....................       unsigned char : 6; 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    } Flags;                            // Flag structure 
....................    MAC_ADDR   MyMACAddr;              // Application MAC address 
....................  
.................... #if defined(WF_CS_TRIS) 
....................    BYTE      MySSID[WIFI_MAX_SSID];             // Wireless SSID (if using MRF24W) 
....................    BYTE        SsidLength;             // number of bytes in SSID 
....................    BYTE        SecurityMode;           // WF_SECURITY_OPEN or one of the other security modes 
....................    BYTE        SecurityKey[64];        // WiFi Security key, or passphrase.    
....................    BYTE        SecurityKeyLength;      // number of bytes in security key (can be 0) 
....................    BYTE        WepKeyIndex;            // WEP key index (only valid for WEP) 
....................    BYTE        networkType; 
....................    BYTE        adhocBehavior; 
....................     #if defined(EZ_CONFIG_STORE) // WLAN configuration data stored to NVM 
....................     BYTE        dataValid; 
....................     //BYTE        networkType; 
....................     BYTE        saveSecurityInfo;       // Save 32-byte PSK 
....................     #endif 
.................... #endif 
....................     
.................... #if defined(STACK_USE_SNMP_SERVER) || defined(STACK_USE_SNMPV3_SERVER) 
....................    // SNMPv2C Read community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE readCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1];  
....................  
....................    // SNMPv2C Write community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE writeCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1]; 
....................  
....................    UINT32 SnmpEngineBootRcrd; 
.................... #endif 
....................  
.................... } APP_CONFIG; 
....................  
.................... #ifndef THIS_IS_STACK_APPLICATION 
....................     extern APP_CONFIG AppConfig; 
.................... #endif 
....................  
....................  
.................... void StackInit(void); 
.................... void StackTask(void); 
.................... void StackApplications(void); 
.................... #endif 
....................  
.................... #include "Helpers.h" 
.................... /********************************************************************* 
....................  Header file for Helpers.c 
....................   
....................  FileName:      Helpers.h 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................       ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................       used in conjunction with a Microchip ethernet controller for 
....................       the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release 
....................   5.36        Updated compile time check for ultoa(); 
....................  ********************************************************************/ 
.................... #ifndef __HELPERS_H 
.................... #define __HELPERS_H 
....................  
....................  
.................... #if (!defined(__18CXX) && !defined(__CCS__)) || defined(HI_TECH_C) 
....................    char *strupr(char* s); 
.................... #endif 
....................  
.................... // Implement consistent ultoa() function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
....................    // C32 < 1.12 and C30 < v3.25 need this 2 parameter stack implemented function 
....................    void ultoa(DWORD Value, BYTE* Buffer); 
.................... #elif defined(__18CXX) && !defined(HI_TECH_C) 
....................    // C18 already has a 2 parameter ultoa() function 
....................    #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #else 
....................    // HI-TECH PICC-18 PRO 9.63, C30 v3.25+, and C32 v1.12+ already have a ultoa() stdlib  
....................    // library function, but it requires 3 parameters.  The TCP/IP Stack  
....................    // assumes the C18 style 2 parameter ultoa() function, so we shall  
....................    // create a macro to automatically convert the code. 
....................    #include <stdlib.h> 
....................    #define ultoa(val,buf)   ultoa((char*)(buf),(val),10) 
.................... #endif 
....................  
.................... #if defined(DEBUG) 
....................    #define DebugPrint(a)   {putrsUART(a);} 
.................... #else 
....................    #define DebugPrint(a) 
.................... #endif 
....................  
.................... DWORD   LFSRSeedRand(DWORD dwSeed); 
.................... WORD   LFSRRand(void); 
.................... DWORD   GenerateRandomDWORD(void); 
.................... void    uitoa(WORD Value, BYTE* Buffer); 
.................... void    UnencodeURL(BYTE* URL); 
.................... WORD    Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... WORD   Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... BOOL   StringToIPAddress(BYTE* str, IP_ADDR* IPAddress); 
.................... BYTE    ReadStringUART(BYTE* Dest, BYTE BufferLen); 
.................... BYTE   hexatob(WORD_VAL AsciiChars); 
.................... BYTE   btohexa_high(BYTE b); 
.................... BYTE   btohexa_low(BYTE b); 
.................... //signed char stricmppgm2ram(BYTE* a, ROM BYTE* b); 
.................... signed char stricmppgm2ram(char* a, ROM char* b);   //__CCS__ __PCH__ __PCD__ 
.................... char *    strnchr(const char *searchString, size_t count, char c); 
.................... size_t  strncpy_m(char* destStr, size_t destSize, int nStrings, ...); 
....................  
.................... #if defined(__18CXX) 
....................    BOOL   ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress); 
.................... #else 
....................    // Non-ROM variant for C30 and C32 
....................    #define ROMStringToIPAddress(a,b)   StringToIPAddress((BYTE*)a,b) 
.................... #endif 
....................  
....................  
.................... WORD    swaps(WORD v); 
....................  
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v); 
.................... #else 
.................... DWORD   swapl(DWORD v); 
.................... #endif 
....................  
.................... WORD    CalcIPChecksum(BYTE* buffer, WORD len); 
....................  
....................  
.................... #if defined(__18CXX) 
....................    DWORD leftRotateDWORD(DWORD val, BYTE bits); 
.................... #else 
....................    // Rotations are more efficient in C30 and C32 
....................    #define leftRotateDWORD(x, n) (((x) << (n)) | ((x) >> (32-(n)))) 
.................... #endif 
....................  
.................... void FormatNetBIOSName(BYTE Name[16]); 
....................  
....................  
.................... // Protocols understood by the ExtractURLFields() function.  IMPORTANT: If you  
.................... // need to reorder these (change their constant values), you must also reorder  
.................... // the constant arrays in ExtractURLFields(). 
.................... typedef enum 
.................... { 
....................    PROTOCOL_HTTP = 0u, 
....................    PROTOCOL_HTTPS, 
....................    PROTOCOL_MMS, 
....................    PROTOCOL_RTSP 
.................... } PROTOCOLS; 
....................  
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen); 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive); 
....................  
.................... #endif 
....................  
.................... #include "Delay.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  General Delay rouines 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Delay.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/9/02  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     6/10/02 Fixed C18 ms and us routines 
....................  * Howard Schlunder		4/04/06	Changed for C30 
....................  ********************************************************************/ 
.................... #ifndef __DELAY_H 
.................... #define __DELAY_H 
....................  
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#include <delays.h> 
.................... #endif 
....................  
.................... #if !defined(GetInstructionClock) 
.................... 	#error GetInstructionClock() must be defined. 
.................... #endif 
....................  
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#define Delay10us(us)		Delay10TCYx(((GetInstructionClock()/1000000)*(us))) 
.................... 	#define DelayMs(ms)												\ 
.................... 	do																\ 
.................... 	{																\ 
.................... 		unsigned int _iTemp = (ms); 								\ 
.................... 		while(_iTemp--)												\ 
.................... 			Delay1KTCYx((GetInstructionClock()+999999)/1000000);	\ 
.................... 	} while(0) 
....................  
.................... #elif defined(__C30__) || defined(__C32__) 
.................... 	void Delay10us(DWORD dwCount); 
.................... 	void DelayMs(WORD ms); 
....................  
.................... #else 
.................... 	#define Delay10us(x)			\ 
.................... 	do 								\ 
.................... 	{								\ 
.................... 		unsigned long _dcnt;		\ 
.................... 		_dcnt=x*((unsigned long)(0.00001/(1.0/GetInstructionClock())/6));	\ 
.................... 		while(_dcnt--);				\ 
.................... 	} while(0) 
.................... 	void DelayMs(WORD ms); 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "Tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __TICK_H 
.................... #define __TICK_H 
....................  
.................... #include "TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // All TICKS are stored as 32-bit unsigned integers. 
.................... // This is deprecated since it conflicts with other TICK definitions used in  
.................... // other Microchip software libraries and therefore poses a merge and maintence  
.................... // problem.  Instead of using the TICK data type, just use the base DWORD data  
.................... // type instead. 
.................... typedef __attribute__((__deprecated__)) DWORD TICK; 
....................  
.................... // This value is used by TCP and other modules to implement timeout actions. 
.................... // For this definition, the Timer must be initialized to use a 1:256 prescalar  
.................... // in Tick.c.  If using a 32kHz watch crystal as the time base, modify the  
.................... // Tick.c file to use no prescalar. 
.................... #define TICKS_PER_SECOND		((GetPeripheralClock()+128ull)/256ull)	// Internal core clock drives timer with 1:256 prescaler 
.................... //#define TICKS_PER_SECOND		(32768ul)								// 32kHz crystal drives timer with no scalar 
....................  
.................... // Represents one second in Ticks 
.................... #define TICK_SECOND				((QWORD)TICKS_PER_SECOND) 
.................... // Represents one minute in Ticks 
.................... #define TICK_MINUTE				((QWORD)TICKS_PER_SECOND*60ull) 
.................... // Represents one hour in Ticks 
.................... #define TICK_HOUR				((QWORD)TICKS_PER_SECOND*3600ull) 
....................  
....................  
.................... void TickInit(void); 
.................... DWORD TickGet(void); 
.................... DWORD TickGetDiv256(void); 
.................... DWORD TickGetDiv64K(void); 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue); 
.................... void TickUpdate(void); 
....................  
.................... #endif 
....................  
.................... #include "MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  ********************************************************************/ 
.................... #ifndef __MAC_H 
.................... #define __MAC_H 
....................  
.................... #include "../HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATBbits.LATB2 
.................... #define ENC_CS_TRIS      TRISBbits.TRISB2 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATBbits.LATB3 
.................... #define ENC_RST_TRIS     TRISBbits.TRISB3 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(WF_CS_TRIS) 
....................    // Do not use the DMA and other goodies that Microchip Ethernet modules have 
....................    #define NON_MCHP_MAC 
.................... #endif 
....................  
.................... #if defined(ENC_CS_TRIS) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the MRF24WB10 but not both ENC_CS_TRIS and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENCX24J600 or the MRF24WB10 but not both ENC100_INTERFACE_MODE and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(ENC_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the ENCX24J600 but not both ENC_CS_TRIS and ENC100_INTERFACE_MODE." 
.................... #endif 
....................  
....................  
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "ETH97J60.h" 
.................... #elif defined(ENC_CS_TRIS) || defined(WF_CS_TRIS) 
....................    #include "ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  ********************************************************************/ 
....................  
.................... #ifndef __ENC28J60_H 
.................... #define __ENC28J60_H 
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	CollisionCount:4; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	Done:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	PacketDefer:1; 
.................... 		unsigned char	ExcessiveDefer:1; 
.................... 		unsigned char	MaximumCollisions:1; 
.................... 		unsigned char	LateCollision:1; 
.................... 		unsigned char	Giant:1; 
.................... 		unsigned char	Underrun:1; 
.................... 		WORD 	 		BytesTransmittedOnWire; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PAUSEControlFrame:1; 
.................... 		unsigned char	BackpressureApplied:1; 
.................... 		unsigned char	VLANTaggedFrame:1; 
.................... 		unsigned char	Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	BYTE v[4]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	PreviouslyIgnored:1; 
.................... 		unsigned char	RXDCPreviouslySeen:1; 
.................... 		unsigned char	CarrierPreviouslySeen:1; 
.................... 		unsigned char	CodeViolation:1; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	ReceiveOk:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	DribbleNibble:1; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PauseControlFrame:1; 
.................... 		unsigned char	UnsupportedOpcode:1; 
.................... 		unsigned char	VLANType:1; 
.................... 		unsigned char	Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG  
.................... { 
.................... 	BYTE Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char :1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char BUFER:1; 
.................... 		unsigned char INT:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char :3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
.................... 		 
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
.................... 		 
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
.................... 		 
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
.................... 		 
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
.................... 		 
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char :1; 
.................... 	} MACON4bits; 
.................... 		 
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char :6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
.................... 		 
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char :5; 
.................... 	} MISTATbits; 
.................... 		 
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits2; 
.................... 		 
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	WORD Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned PDPXMD:1; 
.................... 		unsigned :2; 
.................... 		unsigned PPWRSV:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLOOPBK:1; 
.................... 		unsigned PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned JBSTAT:1; 
.................... 		unsigned LLSTAT:1; 
.................... 		unsigned :5; 
.................... 		unsigned :3; 
.................... 		unsigned PHDPX:1; 
.................... 		unsigned PFDPX:1; 
.................... 		unsigned :3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		unsigned PREV0:1; 
.................... 		unsigned PREV1:1; 
.................... 		unsigned PREV2:1; 
.................... 		unsigned PREV3:1; 
.................... 		unsigned PPN0:1; 
.................... 		unsigned PPN1:1; 
.................... 		unsigned PPN2:1; 
.................... 		unsigned PPN3:1; 
.................... 		unsigned PPN4:1; 
.................... 		unsigned PPN5:1; 
.................... 		unsigned PID19:1; 
.................... 		unsigned PID20:1; 
.................... 		unsigned PID21:1; 
.................... 		unsigned PID22:1; 
.................... 		unsigned PID23:1; 
.................... 		unsigned PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		unsigned PREV:4; 
.................... 		unsigned PPNL:4; 
.................... 		unsigned PPNH:2; 
.................... 		unsigned PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned HDLDIS:1; 
.................... 		unsigned :1; 
.................... 		unsigned JABBER:1; 
.................... 		unsigned :2; 
.................... 		unsigned TXDIS:1; 
.................... 		unsigned FRCLNK:1; 
.................... 		unsigned :1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		unsigned :5; 
.................... 		unsigned PLRITY:1; 
.................... 		unsigned :2; 
.................... 		unsigned :1; 
.................... 		unsigned DPXSTAT:1; 
.................... 		unsigned LSTAT:1; 
.................... 		unsigned COLSTAT:1; 
.................... 		unsigned RXSTAT:1; 
.................... 		unsigned TXSTAT:1; 
.................... 		unsigned :2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned PGEIE:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLNKIE:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		unsigned :2; 
.................... 		unsigned PGIF:1; 
.................... 		unsigned :1; 
.................... 		unsigned PLNKIF:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ0:1; 
.................... 		unsigned LFRQ1:1; 
.................... 		unsigned LBCFG0:1; 
.................... 		unsigned LBCFG1:1; 
.................... 		unsigned LBCFG2:1; 
.................... 		unsigned LBCFG3:1; 
.................... 		unsigned LACFG0:1; 
.................... 		unsigned LACFG1:1; 
.................... 		unsigned LACFG2:1; 
.................... 		unsigned LACFG3:1; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ:2; 
.................... 		unsigned LBCFG:4; 
.................... 		unsigned LACFG:4; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
.................... 	 
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFER		(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
.................... 	 
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
.................... 	 
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
.................... 	 
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
.................... 	 
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
.................... 	 
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDREN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
.................... 	 
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
.................... 	 
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
.................... 	 
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
.................... 	 
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "ENCX24J600.h" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or WiFi MRF24WB10 must be present. 
.................... #endif 
....................  
....................  
.................... #define MAC_TX_BUFFER_SIZE         (1500ul) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct   
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................    MAC_ADDR        DestMACAddr; 
....................    MAC_ADDR        SourceMACAddr; 
....................    WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
....................  
.................... #define MAC_IP         (0x00u) 
.................... #define MAC_ARP        (0x06u) 
.................... #define MAC_UNKNOWN    (0xFFu) 
....................  
....................  
.................... #if !defined(STACK_USE_HTTP2_SERVER) 
....................    #define RESERVED_HTTP_MEMORY 0ul 
.................... #endif 
....................  
.................... #if !defined(STACK_USE_SSL) 
....................    #define RESERVED_SSL_MEMORY 0ul 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #define MAX_PACKET_SIZE     (1514ul) 
.................... #endif 
....................  
.................... // MAC RAM definitions 
.................... #if defined(ENC100_INTERFACE_MODE) 
....................    #define RESERVED_CRYPTO_MEMORY   (128ul) 
....................    #define RAMSIZE         (24*1024ul) 
....................    #define TXSTART       (0x0000ul) 
....................    #define RXSTART       ((TXSTART + 1518ul + TCP_ETH_RAM_SIZE + RESERVED_HTTP_MEMORY + RESERVED_SSL_MEMORY + RESERVED_CRYPTO_MEMORY + 1ul) & 0xFFFE) 
....................    #define   RXSTOP         (RAMSIZE-1ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + 1518ul) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_CRYPTOB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(WF_CS_TRIS) 
....................    #define RAMSIZE       (14170ul - 8192ul - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define TXSTART       (RAMSIZE - (4ul + MAX_PACKET_SIZE + 4ul)) 
....................    #define RXSTART       (0ul) 
....................    #define RXSTOP         ((TXSTART-2ul) | 0x0001ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 4ul) 
....................    #define BASE_SCRATCH_ADDR (BASE_TX_ADDR + (MAX_PACKET_SIZE + 4ul)) 
....................    #define BASE_HTTPB_ADDR  (BASE_SCRATCH_ADDR) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_TCB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(__PIC32MX__) && defined(_ETH) && !defined(ENC_CS_TRIS) 
....................    #define BASE_TX_ADDR   (MACGetTxBaseAddr()) 
....................    #define BASE_HTTPB_ADDR   (MACGetHttpBaseAddr()) 
....................    #define BASE_SSLB_ADDR   (MACGetSslBaseAddr()) 
....................    #define RXSIZE         (EMAC_RX_BUFF_SIZE) 
....................    #define RAMSIZE         (2*RXSIZE)   // not used but silences the compiler 
.................... #else   // ENC28J60 or PIC18F97J60 family internal Ethernet controller 
....................    #define RAMSIZE         (8*1024ul) 
....................    #define TXSTART       (RAMSIZE - (1ul+1518ul+7ul) - TCP_ETH_RAM_SIZE - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define RXSTART         (0ul)                  // Should be an even memory address; must be 0 for errata 
....................    #define   RXSTOP         ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 1ul) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + (1514ul+7ul)) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
.................... #endif 
....................  
.................... #if (RXSIZE < 1400) || (RXSIZE > RAMSIZE) 
....................    #error Warning, Ethernet RX buffer is tiny.  Reduce TCP socket count, the size of each TCP socket, or move sockets to a different RAM 
.................... #endif 
....................  
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void   MACEDPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... #if defined(ENC_CS_TRIS) || defined(ENC100_INTERFACE_MODE) || \ 
....................    (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... #endif 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
.................... // ENC28J60 specific 
.................... void   SetCLKOUT(BYTE NewConfig); 
.................... BYTE   GetCLKOUT(void); 
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
....................  
.................... void MACInit(void); 
.................... void MACProcess(void); 
.................... BOOL MACIsLinked(void); 
....................  
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void MACSetReadPtrInRx(WORD offset); 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address); 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address); 
.................... BYTE MACGet(void); 
.................... WORD MACGetArray(BYTE *val, WORD len); 
.................... void MACDiscardRx(void); 
.................... WORD MACGetFreeRxSize(void); 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len); 
.................... BOOL MACIsMemCopyDone(void); 
....................  
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen); 
.................... BOOL MACIsTxReady(void); 
.................... void MACPut(BYTE val); 
.................... void MACPutArray(BYTE *val, WORD len); 
.................... void MACFlush(void); 
....................  
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
....................    void MACPutROMArray(ROM BYTE *val, WORD len); 
.................... #else 
....................    #define MACPutROMArray(a,b)   MACPutArray((BYTE*)a,b) 
.................... #endif 
....................  
.................... // PIC32MX with embedded ETHC functions 
.................... #if defined(__PIC32MX__) && defined(_ETH) 
....................    PTR_BASE MACGetTxBaseAddr(void); 
....................    PTR_BASE MACGetHttpBaseAddr(void); 
....................    PTR_BASE MACGetSslBaseAddr(void); 
.................... #endif 
....................  
....................     
.................... #endif 
....................  
.................... #include "IP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __IP_H 
.................... #define __IP_H 
....................  
....................  
.................... #define IP_PROT_ICMP    (1u) 
.................... #define IP_PROT_TCP     (6u) 
.................... #define IP_PROT_UDP     (17u) 
....................  
....................  
.................... // IP packet header definition 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
.................... } IP_HEADER; 
....................  
.................... // IP Pseudo header as defined by RFC 793 (needed for TCP and UDP  
.................... // checksum calculations/verification) 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD Length; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define SwapPseudoHeader(h)  (h.Length = swaps(h.Length)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady()       MACIsTxReady() 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(b) MACSetWritePtr(b + BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "ARP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.h and ARPTsk.h into ARP.h 
....................  ********************************************************************/ 
.................... #ifndef __ARP_H 
.................... #define __ARP_H 
....................  
.................... #ifdef STACK_CLIENT_MODE 
....................    void ARPInit(void); 
.................... #else 
....................    #define ARPInit() 
.................... #endif 
....................  
.................... #define ARP_OPERATION_REQ       0x0001u      // Operation code indicating an ARP Request 
.................... #define ARP_OPERATION_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
....................  
....................  
.................... // ARP packet structure 
.................... typedef struct  
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD        HardwareType;   // Link-layer protocol type (Ethernet is 1). 
....................     WORD        Protocol;       // The upper-layer protocol issuing an ARP request (0x0800 for IPv4).. 
....................     BYTE        MACAddrLen;     // MAC address length (6). 
....................     BYTE        ProtocolLen;    // Length of addresses used in the upper-layer protocol (4). 
....................     WORD        Operation;      // The operation the sender is performing (ARP_REQ or ARP_RESP). 
....................     MAC_ADDR    SenderMACAddr;  // The sender's hardware (MAC) address. 
....................     IP_ADDR     SenderIPAddr;   // The sender's IP address. 
....................     MAC_ADDR    TargetMACAddr;  // The target node's hardware (MAC) address. 
....................     IP_ADDR     TargetIPAddr;   // The target node's IP address. 
.................... } ARP_PACKET; 
....................  
.................... BOOL ARPProcess(void); 
.................... void ARPResolve(IP_ADDR* IPAddr); 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr); 
.................... void SwapARPPacket(ARP_PACKET* p); 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    /* API specific Definitions */ 
....................    #define ARP_REQ       0x0001u      // Operation code indicating an ARP Request 
....................    #define ARP_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
....................    struct arp_app_callbacks { 
....................        BOOL used; 
....................        void (*ARPPkt_notify)(DWORD SenderIPAddr, DWORD TargetIPAddr,  
....................                              MAC_ADDR* SenderMACAddr, MAC_ADDR* TargetMACAddr, BYTE op_req); 
....................    }; 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app); 
....................    BOOL ARPDeRegisterCallbacks(CHAR id); 
.................... #endif 
....................    BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ); 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
.................... /********************************************************************* 
....................  * 
....................  *               External serial data EEPROM Access Defs. 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        XEEPROM.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/20/02     Original (Rev. 1.0) 
.................... ********************************************************************/ 
.................... #ifndef __XEEPROM_H 
.................... #define __XEEPROM_H 
....................  
.................... #include "../HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATBbits.LATB2 
.................... #define ENC_CS_TRIS      TRISBbits.TRISB2 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATBbits.LATB3 
.................... #define ENC_RST_TRIS     TRISBbits.TRISB3 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BOOL XEE_RESULT; 
.................... #define XEE_SUCCESS FALSE 
....................  
.................... #if defined(EEPROM_CS_TRIS)	 
.................... 	void XEEInit(void); 
.................... 	XEE_RESULT XEEBeginWrite(DWORD address); 
.................... 	XEE_RESULT XEEWrite(BYTE val); 
.................... 	void XEEWriteArray(BYTE *val, WORD wLen); 
.................... 	XEE_RESULT XEEEndWrite(void); 
.................... 	XEE_RESULT XEEBeginRead(DWORD address); 
.................... 	BYTE XEERead(void); 
.................... 	XEE_RESULT XEEReadArray(DWORD address, BYTE *buffer, WORD length); 
.................... 	XEE_RESULT XEEEndRead(void); 
.................... 	BOOL XEEIsBusy(void); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI EEPROM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI EERPOM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI EEPROM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void 		You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void 		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BYTE 		You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BOOL 		You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define XEEInit()				You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginWrite(a) 		You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWrite(a)				You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWriteArray(a,b)		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndWrite()			You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginRead(a)			You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEERead(a)				You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEReadArray(a, b, c)	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndRead()			You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEIsBusy()				You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #include "SPIFlash.h" 
.................... /********************************************************************* 
....................  * 
....................  *  SPI Flash Memory Driver Header 
....................  *	- Tested to be compatible with SST25VF016B 
....................  *  - Expected compatibility with other SST (Microchip) SST25 series  
....................  *    devices 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIFlash.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * E. Wood				3/20/08	Original 
.................... ********************************************************************/ 
.................... #ifndef __SPIFLASH_H 
.................... #define __SPIFLASH_H 
....................  
.................... #include "../HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATBbits.LATB2 
.................... #define ENC_CS_TRIS      TRISBbits.TRISB2 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATBbits.LATB3 
.................... #define ENC_RST_TRIS     TRISBbits.TRISB3 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define SPI_FLASH_SECTOR_SIZE		(4096ul) 
.................... #define SPI_FLASH_PAGE_SIZE			(0ul)		// SST has no page boundary requirements 
....................  
.................... #define SPI_FLASH_SECTOR_MASK		(SPI_FLASH_SECTOR_SIZE - 1) 
....................  
....................  
.................... #if defined(SPIFLASH_CS_TRIS) 
.................... 	void SPIFlashInit(void);		 
.................... 	void SPIFlashReadArray(DWORD dwAddress, BYTE *vData, WORD wLen); 
.................... 	void SPIFlashBeginWrite(DWORD dwAddr); 
.................... 	void SPIFlashWrite(BYTE vData); 
.................... 	void SPIFlashWriteArray(BYTE *vData, WORD wLen); 
.................... 	void SPIFlashEraseSector(DWORD dwAddr); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI Flash chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI Flash chip, it  
.................... 	// means you have enabled a stack feature that requires SPI Flash hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIFlashInit()				You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashReadArray(a,b,c)	You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashBeginWrite(a)		You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWrite(a)			You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWriteArray(a,b)		You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashEraseSector(a)		You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #include "SPIRAM.h" 
.................... /********************************************************************* 
....................  * 
....................  * Data SPI RAM Access Routines 
....................  *  -Tested with AMI Semiconductor N256S0830HDA 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIRAM.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * \file SPIRAM.h 
....................  * \author Howard Henry Schlunder 
....................  * \date 25 July 2007 
.................... ********************************************************************/ 
.................... #ifndef __SPIRAM_H 
.................... #define __SPIRAM_H 
....................  
.................... #include "../HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATBbits.LATB2 
.................... #define ENC_CS_TRIS      TRISBbits.TRISB2 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATBbits.LATB3 
.................... #define ENC_RST_TRIS     TRISBbits.TRISB3 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(SPIRAM_CS_TRIS) 
.................... 	void SPIRAMInit(void); 
.................... 	void SPIRAMGetArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	void SPIRAMPutArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	 
.................... 	#define SPIRAMPutString(a,b)			SPIRAMPutArray(a, strlen((char*)b)) 
.................... 	 
.................... 	#if defined(__18CXX) 
.................... 		void SPIRAMPutROMArray(WORD wAddress, ROM BYTE *vData, WORD wLength); 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutROMArray(a, strlenpgm((ROM char*)b)) 
.................... 	#else 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutArray(a, strlen((char*)b)) 
.................... 		#define SPIRAMPutROMArray(a,b,c)	SPIRAMPutROMArray(a, b, c) 
.................... 	#endif 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI SRAM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI SRAM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI SRAM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIRAMInit()				You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMGetArray(a,b,c)		You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutArray(a,b,c)		You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutString(a,b)		You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMArray(a,b,c)	You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMString(a,b)		You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  ********************************************************************/ 
.................... #ifndef __UDP_H 
.................... #define __UDP_H 
....................  
.................... // Stores a UDP Port Number 
.................... typedef WORD UDP_PORT; 
....................  
.................... // Provides a handle to a UDP Socket 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... // UDP States  
.................... typedef enum 
.................... { 
.................... 	UDP_DNS_IS_RESOLVED,		// Special state for UDP client mode sockets 
.................... 	UDP_DNS_RESOLVE,		// Special state for UDP client mode sockets 
.................... 	UDP_GATEWAY_SEND_ARP,	// Special state for UDP client mode sockets 
.................... 	UDP_GATEWAY_GET_ARP,		// Special state for UDP client mode sockets	 
....................     UDP_CLOSED,				// Socket is idle and unallocated 
.................... 	UDP_OPENED 
.................... } UDP_STATE; 
....................  
....................  
.................... // Stores information about a current UDP socket 
.................... typedef struct 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	remoteNode;		// 10 bytes for MAC and IP address 
.................... 		DWORD		remoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
....................     //NODE_INFO   remoteNode;		// IP and MAC of remote node 
....................     UDP_PORT    remotePort;		// Remote node's UDP port number 
....................     UDP_PORT    localPort;		// Local UDP port number, or INVALID_UDP_PORT when free 
....................     UDP_STATE smState;			// State of this socket 
....................     DWORD retryInterval; 
.................... 	BYTE retryCount; 
.................... 	struct 
.................... 	{ 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 	}flags; 
.................... 	WORD eventTime; 
.................... } UDP_SOCKET_INFO; 
....................  
....................  
.................... #define INVALID_UDP_SOCKET      (0xffu)		// Indicates a UDP socket that is not valid 
.................... #define INVALID_UDP_PORT        (0ul)		// Indicates a UDP port that is not valid 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	External Global Variables 
....................   ***************************************************************************/ 
.................... #if !defined(__UDP_C) 
....................     extern UDP_SOCKET activeUDPSocket; 
....................     extern UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
.................... 	extern WORD UDPTxCount; 
.................... 	extern WORD UDPRxCount; 
.................... #endif 
....................  
.................... // Stores the header of a UDP packet 
.................... typedef struct 
.................... { 
....................     UDP_PORT    SourcePort;				// Source UDP port 
....................     UDP_PORT    DestinationPort;		// Destination UDP port 
....................     WORD        Length;					// Length of data 
....................     WORD        Checksum;				// UDP checksum of the data 
.................... } UDP_HEADER; 
....................  
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define UDP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define UDP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define UDP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use UDP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define UDP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_UDP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use UDP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define UDP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_UDP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define UDP_OPEN_IP_ADDRESS	3u 
.................... #endif 
....................  
.................... // Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... #define UDP_OPEN_NODE_INFO	4u 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Prototypes 
....................   ***************************************************************************/ 
.................... void UDPInit(void); 
.................... void UDPTask(void); 
.................... UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort,UDP_PORT remotePort); 
....................  
.................... //UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO *remoteNode, UDP_PORT remotePort); 
.................... void UDPClose(UDP_SOCKET s); 
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len); 
....................  
.................... void UDPSetTxBuffer(WORD wOffset); 
.................... void UDPSetRxBuffer(WORD wOffset); 
.................... WORD UDPIsPutReady(UDP_SOCKET s); 
.................... BOOL UDPPut(BYTE v); 
.................... WORD UDPPutArray(BYTE *cData, WORD wDataLen); 
.................... BYTE* UDPPutString(BYTE *strData); 
.................... void UDPFlush(void); 
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
.................... 	WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen); 
.................... 	ROM BYTE* UDPPutROMString(ROM BYTE *strData); 
.................... #else 
.................... 	#define UDPPutROMArray(a,b)	UDPPutArray((BYTE*)a,b) 
.................... 	#define UDPPutROMString(a)	UDPPutString((BYTE*)a) 
.................... #endif 
....................  
.................... WORD UDPIsGetReady(UDP_SOCKET s); 
.................... BOOL UDPGet(BYTE *v); 
.................... WORD UDPGetArray(BYTE *cData, WORD wDataLen); 
.................... void UDPDiscard(void); 
.................... BOOL UDPIsOpened(UDP_SOCKET socket); 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode,  
....................                         UDP_PORT remotePort) 
....................  
....................   Summary: 
....................     Macro of the legacy version of UDPOpen. 
....................      
....................   Description: 
....................     UDPOpen is a macro replacement of the legacy implementation of UDPOpen. 
....................     Creates a UDP socket handle for transmiting or receiving UDP packets.   
....................     Call this function to obtain a handle required by other UDP function. 
....................  
....................   Precondition: 
....................     UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................     localPort - UDP port number to listen on.  If 0, stack will dynamically  
....................         assign a unique port number to use. 
....................     remoteNode - Pointer to remote node info (MAC and IP address) for this 
....................         connection.  If this is a server socket (receives the first packet)  
....................         or the destination is the broadcast address, then this parameter 
....................         should be NULL. 
....................     remotePort - For client sockets, the remote port number. 
....................  
....................   Return Values: 
....................     Success - 
....................         A UDP socket handle that can be used for subsequent UDP API calls. 
....................     Failure - 
....................         INVALID_UDP_SOCKET.  This function fails when no more UDP socket  
....................         handles are available.  Increase MAX_UDP_SOCKETS to make more sockets  
....................         available. 
....................      
....................   Remarks: 
....................     When finished using the UDP socket handle, call the UDPClose() function  
....................     to free the socket and delete the handle. 
....................   ***************************************************************************/ 
.................... #define UDPOpen(localPort,remoteNode,remotePort)  UDPOpenEx((DWORD)remoteNode,UDP_OPEN_NODE_INFO,localPort,remotePort) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01  	Original        (Rev 1.0) 
....................  * Howard Schlunder		11/30/06	See "TCPIP Stack Version.txt" file 
....................  ********************************************************************/ 
.................... #ifndef __TCP_HITECH_WORKAROUND_H 
.................... #define __TCP_HITECH_WORKAROUND_H 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Type Definitions 
....................   ***************************************************************************/ 
....................  
.................... // A TCP_SOCKET is stored as a single BYTE 
.................... typedef BYTE TCP_SOCKET; 
....................  
.................... #define INVALID_SOCKET      (0xFE)	// The socket is invalid or could not be opened 
.................... #define UNKNOWN_SOCKET      (0xFF)	// The socket is not known 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	State Machine Variables 
....................   ***************************************************************************/ 
....................  
.................... // TCP States as defined by RFC 793 
.................... typedef enum 
.................... { 
.................... 	TCP_GET_DNS_MODULE,		// Special state for TCP client mode sockets 
.................... 	TCP_DNS_RESOLVE,		// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_SEND_ARP,	// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_GET_ARP,	// Special state for TCP client mode sockets 
....................  
....................     TCP_LISTEN,				// Socket is listening for connections 
....................     TCP_SYN_SENT,			// A SYN has been sent, awaiting an SYN+ACK 
....................     TCP_SYN_RECEIVED,		// A SYN has been received, awaiting an ACK 
....................     TCP_ESTABLISHED,		// Socket is connected and connection is established 
....................     TCP_FIN_WAIT_1,			// FIN WAIT state 1 
....................     TCP_FIN_WAIT_2,			// FIN WAIT state 2 
....................     TCP_CLOSING,			// Socket is closing 
.................... //	TCP_TIME_WAIT, state is not implemented 
.................... 	TCP_CLOSE_WAIT,			// Waiting to close the socket 
....................     TCP_LAST_ACK,			// The final ACK has been sent 
....................     TCP_CLOSED,				// Socket is idle and unallocated 
....................  
....................     TCP_CLOSED_BUT_RESERVED	// Special state for TCP client mode sockets.  Socket is idle, but still allocated pending application closure of the handle. 
.................... } TCP_STATE; 
....................  
.................... typedef enum 
.................... { 
.................... 	SSL_NONE = 0,			// No security is enabled 
.................... 	SSL_HANDSHAKING,		// Handshake is progressing (no application data allowed) 
.................... 	SSL_ESTABLISHED,		// Connection is established and secured 
.................... 	SSL_CLOSED				// Connection has been closed (no applicaiton data is allowed) 
.................... } SSL_STATE; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // TCP Control Block (TCB) stub data storage.  Stubs are stored in local PIC RAM for speed. 
.................... // Current size is 34 bytes (PIC18), 36 bytes (PIC24/dsPIC), or 56 (PIC32) 
.................... typedef struct 
.................... { 
.................... 	PTR_BASE bufferTxStart;		// First byte of TX buffer 
.................... 	PTR_BASE bufferRxStart;		// First byte of RX buffer.  TX buffer ends 1 byte prior 
.................... 	PTR_BASE bufferEnd;			// Last byte of RX buffer 
.................... 	PTR_BASE txHead;			// Head pointer for TX 
.................... 	PTR_BASE txTail;			// Tail pointer for TX 
.................... 	PTR_BASE rxHead;			// Head pointer for RX 
.................... 	PTR_BASE rxTail;			// Tail pointer for RX 
....................     DWORD eventTime;			// Packet retransmissions, state changes 
.................... 	WORD eventTime2;			// Window updates, automatic transmission 
.................... 	union 
.................... 	{ 
.................... 		WORD delayedACKTime;	// Delayed Acknowledgement timer 
.................... 		WORD closeWaitTime;		// TCP_CLOSE_WAIT timeout timer 
.................... 	} OverlappedTimers; 
....................     TCP_STATE smState;			// State of this socket 
....................     struct 
....................     { 
.................... 	    unsigned char vUnackedKeepalives : 3;		// Count of how many keepalives have been sent with no response 
....................         unsigned char bServer : 1;					// Socket should return to listening state when closed 
.................... 		unsigned char bTimerEnabled	: 1;			// Timer is enabled 
.................... 		unsigned char bTimer2Enabled : 1;			// Second timer is enabled 
.................... 		unsigned char bDelayedACKTimerEnabled : 1;	// DelayedACK timer is enabled 
.................... 		unsigned char bOneSegmentReceived : 1;		// A segment has been received 
.................... 		unsigned char bHalfFullFlush : 1;			// Flush is for being half full 
.................... 		unsigned char bTXASAP : 1;					// Transmit as soon as possible (for Flush) 
.................... 		unsigned char bTXASAPWithoutTimerReset : 1;	// Transmit as soon as possible (for Flush), but do not reset retransmission timers 
.................... 		unsigned char bTXFIN : 1;					// FIN needs to be transmitted 
.................... 		unsigned char bSocketReset : 1;				// Socket has been reset (self-clearing semaphore) 
.................... 		unsigned char bSSLHandshaking : 1;			// Socket is in an SSL handshake 
.................... 		unsigned char filler : 2;					// Future expansion 
....................     } Flags; 
.................... 	WORD_VAL remoteHash;	// Consists of remoteIP, remotePort, localPort for connected sockets.  It is a localPort number only for listening server sockets. 
....................  
....................     #if defined(STACK_USE_SSL) 
....................     PTR_BASE sslTxHead;		// Position of data being written in next SSL application record 
....................     						//   Also serves as cache of localSSLPort when smState = TCP_LISTENING 
....................     PTR_BASE sslRxHead;		// Position of incoming data not yet handled by SSL 
....................     BYTE sslStubID;			// Which sslStub is associated with this connection 
....................     BYTE sslReqMessage;		// Currently requested SSL message 
....................     #endif 
....................  
.................... 	BYTE vMemoryMedium;		// Which memory medium the TCB is actually stored 
.................... 	 
.................... } TCB_STUB; 
....................  
.................... // Remainder of TCP Control Block data. 
.................... // The rest of the TCB is stored in Ethernet buffer RAM or elsewhere as defined by vMemoryMedium. 
.................... // Current size is 41 (PIC18), 42 (PIC24/dsPIC), or 48 bytes (PIC32) 
.................... typedef struct 
.................... { 
.................... 	DWORD		retryInterval;			// How long to wait before retrying transmission 
.................... 	DWORD		MySEQ;					// Local sequence number 
.................... 	DWORD		RemoteSEQ;				// Remote sequence number 
.................... 	PTR_BASE	txUnackedTail;			// TX tail pointer for data that is not yet acked 
....................     WORD_VAL	remotePort;				// Remote port number 
....................     WORD_VAL	localPort;				// Local port number 
.................... 	WORD		remoteWindow;			// Remote window size 
.................... 	WORD		wFutureDataSize;		// How much out-of-order data has been received 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	niRemoteMACIP;		// 10 bytes for MAC and IP address 
.................... 		DWORD		dwRemoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
.................... 	SHORT		sHoleSize;				// Size of the hole, or -1 for none exists.  (0 indicates hole has just been filled) 
....................     struct 
....................     { 
....................         unsigned char bFINSent : 1;		// A FIN has been sent 
.................... 		unsigned char bSYNSent : 1;		// A SYN has been sent 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 		unsigned char bRXNoneACKed1 : 1;	// A duplicate ACK was likely received 
.................... 		unsigned char bRXNoneACKed2 : 1;	// A second duplicate ACK was likely received 
.................... 		unsigned char filler : 3;		// future use 
....................     } flags; 
.................... 	WORD		wRemoteMSS;				// Maximum Segment Size option advirtised by the remote node during initial handshaking 
....................     #if defined(STACK_USE_SSL) 
....................     WORD_VAL	localSSLPort;			// Local SSL port number (for listening sockets) 
....................     #endif 
.................... 	BYTE		retryCount;				// Counter for transmission retries 
.................... 	BYTE		vSocketPurpose;			// Purpose of socket (as defined in TCPIPConfig.h) 
.................... } TCB; 
....................  
.................... // Information about a socket 
.................... typedef struct 
.................... { 
.................... 	NODE_INFO remote;		// NODE_INFO structure for remote node 
.................... 	WORD_VAL remotePort;	// Port number associated with remote node 
.................... } SOCKET_INFO; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Declarations 
....................   ***************************************************************************/ 
....................  
.................... void TCPInit(void); 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP); 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP); 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP); 
.................... void TCPDisconnect(TCP_SOCKET hTCP); 
.................... void TCPClose(TCP_SOCKET hTCP); 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP); 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte); 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* Data, WORD Len); 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* Data); 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP); 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP); 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte); 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD count); 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart); 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart); 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... void TCPDiscard(TCP_SOCKET hTCP); 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len); 
.................... void TCPTick(void); 
.................... void TCPFlush(TCP_SOCKET hTCP); 
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define TCP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define TCP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define TCP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define TCP_OPEN_IP_ADDRESS	3u 
.................... 	// Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... 	#define TCP_OPEN_NODE_INFO	4u 
.................... #else 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_RAM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_ROM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_IP_ADDRESS while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_IP_ADDRESS	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_IP_ADDRESS 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_NODE_INFO while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_NODE_INFO	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_NODE_INFO 
.................... #endif 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose); 
....................  
.................... #if defined(__18CXX) 
.................... 	WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
....................  
.................... 	/***************************************************************************** 
.................... 	  Summary: 
.................... 		Alias to TCPFindROMArrayEx with no length parameter. 
.................... 	 
.................... 	  Description: 
.................... 		This function is an alias to TCPFindROMArrayEx with no length parameter.   
.................... 		It is provided for backwards compatibility with an older API. 
.................... 	  ***************************************************************************/ 
.................... 	#define TCPFindROMArray(a,b,c,d,e)		TCPFindROMArrayEx(a,b,c,d,0,e) 
.................... 	 
.................... 	WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* Data, WORD Len); 
.................... 	ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* Data); 
.................... #else 
.................... 	#define TCPFindROMArray(a,b,c,d,e) 		TCPFindArray(a,(BYTE*)b,c,d,e) 
.................... 	#define TCPFindROMArrayEx(a,b,c,d,e,f) 	TCPFindArrayEx(a,(BYTE*)b,c,d,e,f) 
.................... 	#define TCPPutROMArray(a,b,c)			TCPPutArray(a,(BYTE*)b,c) 
.................... 	#define TCPPutROMString(a,b)			TCPPutString(a,(BYTE*)b) 
.................... #endif 
....................  
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP); 
.................... // Alias to TCPIsGetReady provided for API completeness 
.................... #define TCPGetRxFIFOFull(a)					TCPIsGetReady(a) 
.................... // Alias to TCPIsPutReady provided for API completeness 
.................... #define TCPGetTxFIFOFree(a) 				TCPIsPutReady(a) 
....................  
.................... #define TCP_ADJUST_GIVE_REST_TO_RX	0x01u	// Resize flag: extra bytes go to RX  
.................... #define TCP_ADJUST_GIVE_REST_TO_TX	0x02u	// Resize flag: extra bytes go to TX 
.................... #define TCP_ADJUST_PRESERVE_RX		0x04u	// Resize flag: attempt to preserve RX buffer 
.................... #define TCP_ADJUST_PRESERVE_TX		0x08u	// Resize flag: attempt to preserve TX buffer 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags); 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host); 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType); 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP); 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port); 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg); 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP); 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP); 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP); 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len); 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len); 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone); 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP); 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP); 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFind(a,b,c,d)					TCPFindEx(a,b,c,0,d) 
....................  
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindArrayEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindArrayEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFindArray(a,b,c,d,e)				TCPFindArrayEx(a,b,c,d,0,e) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a server. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for server sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPListen(port)			TCPOpen(0, TCP_OPEN_SERVER, port, TCP_PURPOSE_DEFAULT) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a client. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for client sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPConnect(remote,port)	TCPOpen((DWORD)remote, TCP_OPEN_NODE_INFO, port, TCP_PURPOSE_DEFAULT) 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.h 
....................  * Dependencies:    TCPIPStack.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  ********************************************************************/ 
.................... #ifndef __DHCP_H 
.................... #define __DHCP_H 
....................  
.................... // UDP client port for DHCP Client transactions 
.................... #define DHCP_CLIENT_PORT                (68u) 
.................... // UDP listening port for DHCP Server messages 
.................... #define DHCP_SERVER_PORT                (67u) 
....................  
.................... #define BOOT_REQUEST                    (1u)   // BOOT_REQUEST DHCP type 
.................... #define BOOT_REPLY                      (2u)   // BOOT_REPLY DHCP type 
.................... #define BOOT_HW_TYPE                    (1u)   // BOOT_HW_TYPE DHCP type 
.................... #define BOOT_LEN_OF_HW_TYPE             (6u)   // BOOT_LEN_OF_HW_TYPE DHCP type 
....................  
.................... #define DHCP_MESSAGE_TYPE               (53u)   // DHCP Message Type constant 
.................... #define DHCP_MESSAGE_TYPE_LEN           (1u)   // Length of DHCP Message Type 
....................  
.................... #define DHCP_UNKNOWN_MESSAGE            (0u)   // Code for unknown DHCP message 
....................  
.................... #define DHCP_DISCOVER_MESSAGE           (1u)   // DCHP Discover Message 
.................... #define DHCP_OFFER_MESSAGE              (2u)   // DHCP Offer Message 
.................... #define DHCP_REQUEST_MESSAGE            (3u)   // DHCP Request message 
.................... #define DHCP_DECLINE_MESSAGE            (4u)   // DHCP Decline Message 
.................... #define DHCP_ACK_MESSAGE                (5u)   // DHCP ACK Message 
.................... #define DHCP_NAK_MESSAGE                (6u)   // DHCP NAK Message 
.................... #define DHCP_RELEASE_MESSAGE            (7u)   // DCHP Release message 
....................  
.................... #define DHCP_SERVER_IDENTIFIER          (54u)   // DHCP Server Identifier 
.................... #define DHCP_SERVER_IDENTIFIER_LEN      (4u)   // DHCP Server Identifier length 
....................  
.................... #define DHCP_OPTION_ACK_MESSAGE         (53u)   // DHCP_OPTION_ACK_MESSAGE Type 
.................... #define DHCP_PARAM_REQUEST_LIST         (55u)   // DHCP_PARAM_REQUEST_LIST Type 
.................... #define DHCP_PARAM_REQUEST_LIST_LEN     (4u)   // DHCP_PARAM_REQUEST_LIST_LEN Type 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS       (50u)   // DHCP_PARAM_REQUEST_IP_ADDRESS Type 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS_LEN   (4u)   // DHCP_PARAM_REQUEST_IP_ADDRESS_LEN Type 
.................... #define DHCP_SUBNET_MASK                (1u)   // DHCP_SUBNET_MASK Type 
.................... #define DHCP_ROUTER                     (3u)   // DHCP_ROUTER Type 
.................... #define DHCP_DNS                  (6u)   // DHCP_DNS Type 
.................... #define DHCP_HOST_NAME               (12u)   // DHCP_HOST_NAME Type 
.................... #define DHCP_IP_LEASE_TIME              (51u)   // DHCP_IP_LEASE_TIME Type 
.................... #define DHCP_END_OPTION                 (255u)   // DHCP_END_OPTION Type 
....................  
.................... // DHCP or BOOTP Header structure 
.................... #if defined(__CCS__) 
.................... typedef struct __attribute__((packed)) 
.................... #else 
.................... typedef struct __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................    BYTE      MessageType;   // Message type for this message 
....................    BYTE      HardwareType;   // Hardware type for this message 
....................    BYTE      HardwareLen;   // Length of hardware type 
....................    BYTE      Hops;         // Number of hops 
....................    DWORD      TransactionID;   // DHCP Transaction ID 
....................    WORD      SecondsElapsed;   // Number of elapsed seconds 
....................    WORD      BootpFlags;      // BOOTP Flags 
....................    IP_ADDR      ClientIP;      // Client IP 
....................    IP_ADDR      YourIP;         // Your IP 
....................    IP_ADDR      NextServerIP;   // Next Server IP 
....................    IP_ADDR      RelayAgentIP;   // Relay Agent IP 
....................    MAC_ADDR   ClientMAC;      // Client MAC Address 
.................... } BOOTP_HEADER; 
....................  
.................... // DHCP State Machine 
.................... typedef enum 
.................... { 
....................    SM_DHCP_DISABLED = 0,      // DHCP is not currently enabled 
....................    SM_DHCP_GET_SOCKET,         // DHCP is trying to obtain a socket 
....................    SM_DHCP_SEND_DISCOVERY,      // DHCP is sending a DHCP Discover message 
....................    SM_DHCP_GET_OFFER,         // DHCP is waiting for a DHCP Offer 
....................    SM_DHCP_SEND_REQUEST,      // DHCP is sending a DHCP Send Reequest message 
....................    SM_DHCP_GET_REQUEST_ACK,   // DCHP is waiting for a Request ACK message 
....................    SM_DHCP_BOUND,            // DHCP is bound 
....................    SM_DHCP_SEND_RENEW,         // DHCP is sending a DHCP renew message (first try) 
....................    SM_DHCP_GET_RENEW_ACK,      // DHCP is waiting for a renew ACK 
....................    SM_DHCP_SEND_RENEW2,      // DHCP is sending a DHCP renew message (second try) 
....................    SM_DHCP_GET_RENEW_ACK2,      // DHCP is waiting for a renew ACK 
....................    SM_DHCP_SEND_RENEW3,      // DHCP is sending a DHCP renew message (third try) 
....................    SM_DHCP_GET_RENEW_ACK3      // DHCP is waiting for a renew ACK 
.................... } SM_DHCP; 
....................  
....................  
.................... void DHCPInit(BYTE vInterface); 
.................... void DHCPTask(void); 
.................... void DHCPServerTask(void); 
.................... void DHCPDisable(BYTE vInterface); 
.................... void DHCPEnable(BYTE vInterface); 
.................... BOOL DHCPIsEnabled(BYTE vInterface); 
.................... BOOL DHCPIsBound(BYTE vInterface); 
.................... BOOL DHCPStateChanged(BYTE vInterface); 
.................... BOOL DHCPIsServerDetected(BYTE vInterface); 
....................  
.................... #if defined(STACK_USE_DHCP_SERVER) 
.................... extern BOOL bDHCPServerEnabled; 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #ifndef __ICMP_H 
.................... #define __ICMP_H 
....................  
.................... void ICMPProcess(NODE_INFO *remote, WORD len); 
....................  
.................... BOOL ICMPBeginUsage(void); 
.................... void ICMPSendPing(DWORD dwRemoteIP); 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost); 
.................... LONG ICMPGetReply(void); 
.................... void ICMPEndUsage(void); 
....................  
.................... #if defined(__18CXX) 
.................... 	void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost); 
.................... #else 
.................... 	#define ICMPSendPingToHostROM(a) 	ICMPSendPingToHost((BYTE*)(a)) 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(MRF24WG) 
....................  #define WF_DisplayModuleAssertInfo() 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #include "TCPIP Stack/ccs_email_alert.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SCAN_TASK) 
....................    #include "TCPIP Stack/ccs_wifiscan.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "TCPIP Stack/ccs_HTTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "TCPIP Stack/ccs_HTTP2.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP2.H                                /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack using web pages     ///  
.................... /// on an MultiMediaCard.                                                /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   0 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   0 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_TRIPLE_ESCAPE 
.................... #define HTTP_USE_TRIPLE_ESCAPE   0 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_AUTHENTICATION 
.................... #define  HTTP_USE_AUTHENTICATION TRUE 
.................... #endif 
....................  
.................... #ifndef HTTP_LAST_MODIFIED_CHECK 
.................... #define HTTP_LAST_MODIFIED_CHECK FALSE 
.................... #endif 
....................  
.................... void HTTPInit(void);                                                 
.................... void HTTPServer(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following two functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation 
.................... /// in http2.c for more help. 
....................  
.................... #if HTTP_USE_TRIPLE_ESCAPE 
.................... unsigned int8 http_format_char(char* file, unsigned int16 id, char *str, unsigned int8 max_ret); 
.................... #else 
.................... unsigned int8 http_format_char(char* file, char id, char *str, unsigned int8 max_ret); 
.................... #endif 
....................  
.................... void http_exec_cgi(char* file, char *key, char *val); 
....................  
.................... #if HTTP_USE_AUTHENTICATION 
....................  int1 http_check_authentication(char *fileName, char *user, char *pwd); 
.................... #endif 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TWITTER) 
....................    #include "TCPIP Stack/ccs_twitter.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "TCPIP Stack/ccs_SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "TCPIP Stack/ccs_TFTPs.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "TCPIP Stack/ccs_SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "TCPIP Stack/ccs_gratarp.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #include "TCPIP STACK/ccs_http_client.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_FTP_SERVER) 
....................    #include "fat/filesystem.h" 
....................    #include "TCPIP Stack/ccs_ftp_mdd.h" 
.................... #endif 
....................  
.................... #define TickGetDiff(a, b)  (a-b) 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif        
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #ifndef STACK_USE_MPFS 
....................       #define STACK_USE_MPFS 
....................     #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #if !defined(STACK_CLIENT_MODE) 
....................        #define STACK_CLIENT_MODE 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_WIFI 
....................    // if defined, MyWFIsConnected() won't return TRUE in AdHoc mode until after 
....................    // it receives some IP traffic.  It will then stay connected until after 5 
....................    // minutes of no activity. 
....................    #define WIFI_ADHOC_CONNECTION_TIMER ((TICK)TICKS_PER_SECOND * 300) 
....................     
....................    extern unsigned int8 g_connectionProfileID; 
....................     
....................    #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    extern int1 g_WifiAdhocIsConn; 
....................    extern TICK g_WifiAdhocTickConn; 
....................    #endif 
....................     
....................    extern unsigned int8 WIFI_channelList[16]; 
....................    extern unsigned int8 WIFI_numChannelsInList; 
....................    extern unsigned int8 WIFI_region; 
....................    extern int1 g_WifiConnectFail; 
....................     
....................    // this is similar to MACIsLinked() and WFisConnected().  this one has some 
....................    // filters and extra UI logic to better represent link status to the user. 
....................    // use this for UI displays. 
....................    // REMOVED - Use IsLinked() instead 
....................    //int1 MyWFisConnected(void); 
....................     
....................    // This routine does a few things: 
....................    //  * Reset WIFI unit if no it goes a long time without a connection, 
....................    //       because old modules would hang on WPA connect failure. 
....................    //  * Ad-Hoc connection timer support (WIFI_ADHOC_CONNECTION_TIMER) 
....................    //  * LED Traffic flickering and LED connection status 
....................    void WIFIConnectTask(void); 
....................    void WIFIConnectInitStates(void); 
....................     
....................    #if defined(WF_FORCE_NO_PS_POLL) 
....................       void WF_CCS_PsPollDisable(void); 
....................    #endif 
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void); 
....................  
.................... // A higher level version of MACIsLinked(). 
.................... //  - returns FALSE if MACIsLinked() is TRUE -but- DHCP is enabled and not 
.................... //       bound. 
.................... //  - returns FALSE in WIFI if using AdHoc mode and it has been a while 
.................... //       since no traffic 
.................... //  - else, returns MACIsLinked() 
.................... int1 IsLinked(void); 
....................  
.................... //this macro called by stack when new tcp/ip traffic tx/rx. 
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_TX_EVENT()  LinkTraffic(TRUE) 
....................    #define STACK_USE_CCS_RX_EVENT()  LinkTraffic(FALSE) 
....................    void LinkTraffic(int1 isTx); 
....................     
....................    #define WF_SECURITY_NUM_CHOICES  (WF_SECURITY_WEP_AUTO+1) 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "TCPIP Stack/mpfs.h" 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip File System 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MPFS.h 
....................  * Dependencies:    StackTsk.H 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01     Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      5/31/06      Changed EEPROM addressing to 32 bits 
....................  * DSR/CCS              5/18/11     To be compatible with #import of mpfs 
....................  *                                   into program memory, MPFS_INVALID changed 
....................  *                                   to FFFFFFFF for all modes. 
.................... ********************************************************************/ 
.................... #ifndef __MPFS_H 
.................... #define __MPFS_H 
....................  
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) 
....................     typedef DWORD MPFS;                           // For default 32 bit addressing (use /ll option with MPFS.exe) 
....................     #define MPFS_INVALID            (0xffffffffu)   // For default 32 bit addressing (use /ll option with MPFS.exe) 
.................... //    typedef WORD MPFS;                        // For old short 16 bit addressing (use /b option with MPFS.exe) 
.................... //    #define MPFS_INVALID            (0xffff)      // For old short 16 bit addressing (use /b option with MPFS.exe) 
.................... #else 
....................    /* ccs bug, this creates confusion for compiler.  maybe ptr to ptr confusion? 
....................    #if defined(__C30__) 
....................       typedef DWORD MPFS; 
....................        #define MPFS_INVALID                (MPFS)(0xffffffffu) 
....................    #else 
....................       typedef ROM BYTE* MPFS; 
....................        #define MPFS_INVALID                (MPFS)(0xffffffu) 
....................    #endif 
....................    */ 
....................   #if defined(__PCD__) || defined(__PCH__)   //__CCS__ 
....................    #define MPFS_INVALID                (MPFS)(0xffffffffu) 
....................   #else 
....................    #define MPFS_INVALID                (MPFS)(0xffffffu) 
....................   #endif 
....................    #define MPFS   __ADDRESS__ 
.................... #endif 
....................  
.................... #define MPFS_NOT_AVAILABLE              (0x0u) 
....................  
.................... #if defined(MPFS_USE_EEPROM) 
....................    #if defined(USE_EEPROM_25LC1024) 
....................       #define MPFS_WRITE_PAGE_SIZE      (256u) 
....................    #else 
....................       #define MPFS_WRITE_PAGE_SIZE      (64u) 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... BOOL MPFSInit(void); 
.................... MPFS MPFSOpen(BYTE* name); 
.................... MPFS MPFSOpenROM(ROM BYTE* name); 
.................... BYTE MPFSGet(void); 
.................... void MPFSClose(void); 
.................... MPFS MPFSFormat(void); 
.................... BOOL MPFSPut(BYTE b); 
.................... MPFS MPFSPutEnd(void); 
.................... MPFS MPFSSeek(MPFS offset); 
.................... BOOL MPFSGetLong(DWORD *ul); 
....................  
.................... #if !defined(__MPFS_C) 
....................    extern BYTE mpfsOpenCount; 
....................     extern MPFS _currentHandle; 
....................     //extern BYTE _currentCount; //ccs bug removing for now because it doesn't match definition in mpfs.c 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSGetBegin(MPFS handle) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  * 
....................  * Input:           handle      - handle of file that is to be read 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS storage media for subsequent reads. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
....................     BOOL MPFSGetBegin(MPFS handle); 
.................... #else 
....................     #define MPFSGetBegin(handle)    (_currentHandle = handle) 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSGetEnd(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  *                  MPFSGetBegin() = TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current mpfs handle. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Ends on-going read cycle. 
....................  *                  MPFS handle that is returned must be used 
....................  *                  for subsequent begin gets.. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
....................     MPFS MPFSGetEnd(void); 
.................... #else 
....................     #define MPFSGetEnd()        _currentHandle 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL MPFSIsEOF(void) 
....................  * 
....................  * PreCondition:    MPFSGetBegin() must be called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if current file read has reached end of file. 
....................  *                  FALSE if otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define MPFSIsEOF()     (_currentHandle == MPFS_INVALID) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSPutBegin(MPFS handle) 
....................  * 
....................  * PreCondition:    MPFSInit() and MPFSFormat() are already called. 
....................  * 
....................  * Input:           handle  - handle to where put to begin 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS image to get re-written 
....................  * 
....................  * Note:            MPFS will be unaccessible until MPFSClose is 
....................  *                  called. 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
....................     BOOL MPFSPutBegin(MPFS handle); 
.................... #else 
....................     #define MPFSPutBegin(handle)        (_currentHandle = handle) 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSTell(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          current MPFS file pointer 
....................  * 
....................  * Side Effects:    None. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None. 
....................  ********************************************************************/ 
.................... #define MPFSTell()      (_currentHandle) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BYTE MPFSInUse(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          No. of file currently open. 
....................  *                  If == 0, MPFS is not in use. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define MPFSIsInUse()       (mpfsOpenCount) 
....................  
.................... #endif 
....................  
....................     
....................    extern MPFS _MpfsEofLoc; 
....................     
....................    //returns number of bytes read before EOF. 
....................    //if it returns n then no EOF. 
....................    unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n); 
.................... #endif 
....................  
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void); 
.................... #endif 
....................  
.................... BYTE GenerateRandomByteFromTimers(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/TCPIPConfig.h" 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
....................  
.................... #define STACK_USE_ICMP_SERVER    1 
.................... #define STACK_USE_TCP            1 
.................... #define STACK_USE_DHCP_CLIENT    1 
....................  
.................... #define STACK_CCS_SMTP_TX_SIZE    0 
.................... #define STACK_CCS_SMTP_RX_SIZE    0 
....................  
.................... #define STACK_USE_CCS_HTTP2_SERVER 
.................... #define STACK_CCS_HTTP2_SERVER_TX_SIZE    1500 
.................... #define STACK_CCS_HTTP2_SERVER_RX_SIZE    500 
.................... #define HTTP_NUM_SOCKETS                  1 
.................... #define HTTP_PORT                         (80u) 
.................... #define HTTP_USE_DOUBLE_ESCAPE            1 
.................... #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................  
.................... #define STACK_MY_TELNET_SERVER_TX_SIZE    0 
.................... #define STACK_MY_TELNET_SERVER_RX_SIZE    0 
....................  
.................... #define STACK_MY_HTTPC_RX_SIZE    0 
.................... #define STACK_MY_HTTPC_TX_SIZE    0 
....................  
.................... #define MY_DEFAULT_HOST_NAME      "CCS_EXAMPLES" 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1      (0x0) 
.................... #define MY_DEFAULT_MAC_BYTE2      (0x8) 
.................... #define MY_DEFAULT_MAC_BYTE3      (0xdc) 
.................... #define MY_DEFAULT_MAC_BYTE4      (0x18) 
.................... #define MY_DEFAULT_MAC_BYTE5      (0x7c) 
.................... #define MY_DEFAULT_MAC_BYTE6      (0x6) 
....................  
.................... #define MY_DEFAULT_IP_ADDR_BYTE1  (10ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2  (2ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3  (10ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4  (200ul) 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1     (10ul) 
.................... #define MY_DEFAULT_GATE_BYTE2     (2ul) 
.................... #define MY_DEFAULT_GATE_BYTE3     (10ul) 
.................... #define MY_DEFAULT_GATE_BYTE4     (1ul) 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE2     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE3     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE4     (0ul) 
....................  
.................... #define TCP_CONFIGURATION      1 
....................  
.................... #define TCP_ETH_RAM_SIZE (STACK_CCS_SMTP_TX_SIZE + \ 
....................                           STACK_CCS_SMTP_RX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_TX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_RX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_TX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_RX_SIZE + \ 
....................                           STACK_MY_HTTPC_TX_SIZE + \ 
....................                           STACK_MY_HTTPC_RX_SIZE + \ 
....................                           100*TCP_CONFIGURATION) 
....................  
.................... // Define names of socket types 
.................... #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
.................... #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
.................... #define TCP_PURPOSE_TELNET             2 
.................... #define TCP_PURPOSE_FTP_COMMAND        3 
.................... #define TCP_PURPOSE_FTP_DATA           4 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
.................... #define TCP_PURPOSE_UART_2_TCP_BRIDGE  7 
.................... #define TCP_PURPOSE_HTTP_SERVER        8 
.................... #define TCP_PURPOSE_DEFAULT            9 
.................... #define TCP_PURPOSE_BERKELEY_SERVER    10 
.................... #define TCP_PURPOSE_BERKELEY_CLIENT    11 
.................... #define TCP_PURPOSE_CCS_SMTP           0x40 
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATBbits.LATB2 
.................... #define ENC_CS_TRIS      TRISBbits.TRISB2 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATBbits.LATB3 
.................... #define ENC_RST_TRIS     TRISBbits.TRISB3 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef struct 
.................... { 
....................    BYTE vSocketPurpose; 
....................    BYTE vMemoryMedium; 
....................    WORD wTXBufferSize; 
....................    WORD wRXBufferSize; 
.................... } TCPSocketInitializer_t; 
....................  
.................... #if TCP_CONFIGURATION > 0 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................          {TCP_PURPOSE_HTTP_SERVER, TCP_ETH_RAM, STACK_CCS_HTTP2_SERVER_TX_SIZE, STACK_CCS_HTTP2_SERVER_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_SMTP_CLIENT) 
....................          {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, STACK_CCS_SMTP_TX_SIZE, STACK_CCS_SMTP_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_MY_TELNET_SERVER) 
....................          {TCP_PURPOSE_TELNET, TCP_ETH_RAM, STACK_MY_TELNET_SERVER_TX_SIZE, STACK_MY_TELNET_SERVER_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................          {TCP_PURPOSE_GENERIC_TCP_CLIENT, TCP_ETH_RAM, STACK_MY_HTTPC_TX_SIZE, STACK_MY_HTTPC_RX_SIZE}, 
....................       #endif 
....................    }; 
.................... #else 
....................    #undef TCP_CONFIGURATION 
....................    #define TCP_CONFIGURATION 1 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................    }; 
.................... #endif 
....................  
.................... #include "tcpip/StackTsk2.c" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
.................... // 
.................... // __DISABLE_WIFI_INTERRUPT__ was supported in an older 5.3x version of the 
.................... // stack, but it is currently not supported anymore. 
....................  
.................... #ifndef __CCS_STACKTSK2_C__ 
.................... #define __CCS_STACKTSK2_C__ 
....................  
.................... #if defined(__DISABLE_WIFI_INTERRUPT__) 
....................    #error This has been removed. 
.................... #endif 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if defined(__PCH__) 
.................... #int_timer0 NOCLEAR 
.................... void ISRTimer0(void) 
.................... { 
....................    TickUpdate(); 
*
00134:  BRA    0116
.................... } 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && !defined(__DISABLE_WIFI_INTERRUPT__) 
.................... #int_EXT HIGH NOCLEAR 
....................    void ISREXT0(void) 
....................    { 
....................          WFEintISR(); 
....................        
....................    } 
.................... #endif 
....................  
.................... #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    int1 g_WifiAdhocIsConn = FALSE; 
....................    TICK g_WifiAdhocTickConn; 
....................    #define WIFIAdhocConnectionPing()   g_WifiAdhocIsConn=TRUE; g_WifiAdhocTickConn=TickGet() 
....................    #define WIFIAdhocConnectionReset()  g_WifiAdhocIsConn = FALSE 
.................... #endif 
....................  
.................... #include "StackTsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *   TCP/IP Stack Manager 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Handles internal RX packet pre-processing prior to dispatching  
....................  *    to upper application layers. 
....................  *    -Reference: AN833 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    ARP, IP, Network layer interface (ENC28J60.c,  
....................  *               ETH97J60.c, ENCX24J600.c, or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  * 
....................  * Darren Rook/CCS       4/13/11    Added some CCS modules (see STACK_USE_CCS_*) 
....................  *                                  Added STACK_USE_CCS_RX_EVENT() macro on TCP/IP traffic.  
.................... ********************************************************************/ 
.................... #define __STACKTSK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
00136:  GOTO   0060
.................... #if defined( WF_CS_TRIS ) 
....................     #if defined( WF_CONFIG_CONSOLE ) 
....................         #include "TCPIP Stack/WFConsole.h" 
....................     #endif 
....................     #if defined( STACK_USE_EZ_CONFIG ) || defined( EZ_CONFIG_SCAN ) 
....................         #include "TCPIP Stack/WFEasyConfig.h" 
....................     #endif 
....................    #include "TCPIP Stack/WFApi.h" 
.................... #endif 
....................  
.................... // Stack FSM states. 
.................... typedef enum 
.................... { 
....................     SM_STACK_IDLE, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
.................... BOOL g_DhcpRenew = FALSE; 
.................... extern void SetDhcpProgressState(void); 
.................... UINT32 g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................    static BOOL once = FALSE; 
....................     smStack                     = SM_STACK_IDLE; 
*
01512:  MOVLB  1
01514:  CLRF   x07
....................  
.................... #if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT) 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
01516:  BSF    4B.7
....................  
.................... #endif 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
....................    g_DhcpRenew = FALSE; 
....................    g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................    if (!once) { 
01518:  BTFSC  x12.0
0151A:  BRA    154A
....................       // Seed the LFSRRand() function 
....................       LFSRSeedRand(GenerateRandomDWORD()); 
0151C:  MOVLB  0
0151E:  GOTO   0414
01522:  MOVFF  03,5B8
01526:  MOVFF  02,5B7
0152A:  MOVFF  01,5B6
0152E:  MOVFF  00,5B5
01532:  MOVFF  03,5CE
01536:  MOVFF  02,5CD
0153A:  MOVFF  01,5CC
0153E:  MOVFF  00,5CB
01542:  CALL   03B2
....................       once = TRUE; 
01546:  MOVLB  1
01548:  BSF    x12.0
....................    } 
....................  
....................     MACInit(); 
0154A:  MOVLB  0
0154C:  GOTO   077C
....................  
.................... #if defined (WF_AGGRESSIVE_PS) && defined (WF_CS_TRIS) 
....................    WFEnableAggressivePowerSave(); 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG) && !defined(__18CXX) 
....................     WFEasyConfigInit(); 
.................... #endif     
....................  
....................     ARPInit(); 
....................  
.................... #if defined(STACK_USE_UDP) 
....................     UDPInit(); 
01550:  GOTO   0A38
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................     TCPInit(); 
01554:  BRA    120A
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    BerkeleySocketInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................     HTTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    RSAInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................     SSLInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................     FTPInit(); 
.................... #endif 
....................  
....................    #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    AnnounceInit(); 
....................    #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    DHCPInit(0); 
01556:  MOVLB  5
01558:  CLRF   xBE
0155A:  MOVLB  0
0155C:  RCALL  13A6
....................     if(!AppConfig.Flags.bIsDHCPEnabled) 
0155E:  BTFSC  4B.6
01560:  BRA    156A
....................     { 
....................         DHCPDisable(0); 
01562:  MOVLB  5
01564:  CLRF   xB5
01566:  MOVLB  0
01568:  BRA    13E4
....................     } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     AutoIPInit(0); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    RandomInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPInit(); 
0156A:  BRA    147A
.................... #endif 
....................  
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    TFTPSInit(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    EmailAlertInit(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    HttpClientInit(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_FTP_SERVER) 
0156C:  GOTO   B078 (RETURN)
....................    FTPInit(); 
....................    #endif 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     WORD dataCount; 
....................     IP_ADDR tempLocalIP; 
....................    BYTE cFrameType; 
....................    BYTE cIPFrameType; 
....................  
....................     
....................     #if defined( WF_CS_TRIS ) 
....................         // This task performs low-level MAC processing specific to the MRF24W 
....................         MACProcess(); 
....................         #if defined( STACK_USE_EZ_CONFIG ) && !defined(__18CXX) 
....................             WFEasyConfigMgr(); 
....................         #endif 
....................          
....................        #if defined(STACK_USE_DHCP_CLIENT) 
....................            // Normally, an application would not include  DHCP module 
....................            // if it is not enabled. But in case some one wants to disable 
....................            // DHCP module at run-time, remember to not clear our IP 
....................            // address if link is removed. 
....................            if(AppConfig.Flags.bIsDHCPEnabled) 
....................            { 
....................               if(g_DhcpRenew == TRUE) 
....................               { 
....................                  g_DhcpRenew = FALSE; 
....................                   AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................                  AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................                  AppConfig.Flags.bInConfigMode = TRUE; 
....................                  DHCPInit(0); 
....................                g_DhcpRetryTimer = (UINT32)TickGet(); 
....................               } else { 
....................                  if (g_DhcpRetryTimer && TickGet() - g_DhcpRetryTimer >= TICKS_PER_SECOND * 8) { 
....................                   DHCPInit(0); 
....................                   g_DhcpRetryTimer = (UINT32)TickGet(); 
....................                  } 
....................               } 
....................             
....................               // DHCP must be called all the time even after IP configuration is 
....................               // discovered. 
....................               // DHCP has to account lease expiration time and renew the configuration 
....................               // time. 
....................               DHCPTask(); 
....................                
....................               if(DHCPIsBound(0)) { 
....................                  AppConfig.Flags.bInConfigMode = FALSE; 
....................                g_DhcpRetryTimer = 0; 
....................               } 
....................            } 
....................        #endif // STACK_USE_DHCP_CLIENT 
....................          
....................     #endif // WF_CS_TRIS 
....................  
....................  
....................    #if defined(STACK_USE_DHCP_CLIENT) && !defined(WF_CS_TRIS) 
....................    // Normally, an application would not include  DHCP module 
....................    // if it is not enabled. But in case some one wants to disable 
....................    // DHCP module at run-time, remember to not clear our IP 
....................    // address if link is removed. 
....................    if(AppConfig.Flags.bIsDHCPEnabled) 
*
06C14:  BTFSS  4B.6
06C16:  BRA    6C8C
....................    { 
....................       static BOOL bLastLinkState = FALSE; 
....................       BOOL bCurrentLinkState; 
....................        
....................       bCurrentLinkState = MACIsLinked(); 
06C18:  CALL   162C
06C1C:  MOVLB  5
06C1E:  BCF    xBD.0
06C20:  BTFSC  01.0
06C22:  BSF    xBD.0
....................       if(bCurrentLinkState != bLastLinkState) 
06C24:  CLRF   00
06C26:  MOVLB  1
06C28:  BTFSC  x12.1
06C2A:  BSF    00.0
06C2C:  MOVLB  5
06C2E:  MOVF   xBD,W
06C30:  XORWF  00,W
06C32:  ANDLW  01
06C34:  BZ    6C76
....................       { 
....................          bLastLinkState = bCurrentLinkState; 
06C36:  MOVLB  1
06C38:  BCF    x12.1
06C3A:  MOVLB  5
06C3C:  BTFSS  xBD.0
06C3E:  BRA    6C46
06C40:  MOVLB  1
06C42:  BSF    x12.1
06C44:  MOVLB  5
....................          if(!bCurrentLinkState) 
06C46:  BTFSC  xBD.0
06C48:  BRA    6C76
....................          { 
....................             AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
06C4A:  MOVFF  36,22
06C4E:  MOVFF  35,21
06C52:  MOVFF  34,20
06C56:  MOVFF  33,1F
....................             AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
06C5A:  MOVFF  3A,26
06C5E:  MOVFF  39,25
06C62:  MOVFF  38,24
06C66:  MOVFF  37,23
....................             AppConfig.Flags.bInConfigMode = TRUE; 
06C6A:  BSF    4B.7
....................             DHCPInit(0); 
06C6C:  CLRF   xBE
06C6E:  MOVLB  0
06C70:  CALL   13A6
06C74:  MOVLB  5
....................          } 
....................       } 
....................     
....................       // DHCP must be called all the time even after IP configuration is 
....................       // discovered. 
....................       // DHCP has to account lease expiration time and renew the configuration 
....................       // time. 
....................       DHCPTask(); 
06C76:  MOVLB  0
06C78:  GOTO   2A58
....................        
....................       if(DHCPIsBound(0)) 
06C7C:  MOVLB  5
06C7E:  CLRF   xBE
06C80:  MOVLB  0
06C82:  GOTO   2F8C
06C86:  MOVF   01,F
06C88:  BZ    6C8C
....................          AppConfig.Flags.bInConfigMode = FALSE; 
06C8A:  BCF    4B.7
....................    } 
....................    #endif 
....................     
....................  
....................     #if defined (STACK_USE_AUTO_IP) 
....................     AutoIPTasks(); 
....................     #endif 
....................  
....................    #if defined(STACK_USE_TCP) 
....................    // Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc) 
....................    TCPTick(); 
06C8C:  GOTO   3D0A
....................    #endif 
....................  
....................  
....................    #if defined(STACK_USE_UDP) 
....................    UDPTask(); 
06C90:  GOTO   4556
....................    #endif 
....................  
....................   #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpTask(); 
....................   #endif 
....................  
....................    // Process as many incomming packets as we can 
....................    while(1) 
....................    { 
....................       //if using the random module, generate entropy 
....................       #if defined(STACK_USE_RANDOM) 
....................          RandomAdd(remoteNode.MACAddr.v[5]); 
....................       #endif 
....................  
....................       // We are about to fetch a new packet, make sure that the  
....................       // UDP module knows that any old RX data it has laying  
....................       // around will now be gone. 
....................       #if defined(STACK_USE_UDP) 
....................          UDPDiscard(); 
06C94:  CALL   2644
....................       #endif 
....................  
....................       // Fetch a packet (throws old one away, if not thrown away  
....................       // yet) 
....................       if(!MACGetHeader(&remoteNode.MACAddr, &cFrameType)) 
06C98:  MOVLW  01
06C9A:  MOVLB  5
06C9C:  MOVWF  xBF
06C9E:  MOVLW  0C
06CA0:  MOVWF  xBE
06CA2:  MOVLW  05
06CA4:  MOVWF  xC1
06CA6:  MOVLW  BB
06CA8:  MOVWF  xC0
06CAA:  MOVLB  0
06CAC:  GOTO   45E0
06CB0:  MOVF   01,F
06CB2:  BNZ   6CB6
....................          break; 
06CB4:  BRA    6DFC
....................  
....................       // When using a WiFi module, filter out all incoming packets that have  
....................       // the same source MAC address as our own MAC address.  This is to  
....................       // prevent receiving and passing our own broadcast packets up to other  
....................       // layers and avoid, for example, having our own gratuitous ARPs get  
....................       // answered by ourself. 
....................       #if defined(WF_CS_TRIS) 
....................          if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u) 
....................             continue; 
....................       #endif 
....................        
....................       #if defined(STACK_USE_CCS_RX_EVENT) 
....................       STACK_USE_CCS_RX_EVENT();  //__CCS__ 
....................       #endif 
....................        
....................       // Dispatch the packet to the appropriate handler 
....................       switch(cFrameType) 
06CB6:  MOVLB  5
06CB8:  MOVF   xBB,W
06CBA:  XORLW  06
06CBC:  MOVLB  0
06CBE:  BZ    6CC6
06CC0:  XORLW  06
06CC2:  BZ    6CCC
06CC4:  BRA    6DFA
....................       { 
....................          case MAC_ARP: 
....................             ARPProcess(); 
06CC6:  GOTO   48FE
....................             break; 
06CCA:  BRA    6DFA
....................     
....................          case MAC_IP: 
....................             if(!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount)) 
06CCC:  MOVLW  05
06CCE:  MOVLB  5
06CD0:  MOVWF  xBF
06CD2:  MOVLW  B7
06CD4:  MOVWF  xBE
06CD6:  MOVLW  01
06CD8:  MOVWF  xC1
06CDA:  MOVLW  08
06CDC:  MOVWF  xC0
06CDE:  MOVLW  05
06CE0:  MOVWF  xC3
06CE2:  MOVLW  BC
06CE4:  MOVWF  xC2
06CE6:  MOVLW  05
06CE8:  MOVWF  xC5
06CEA:  MOVLW  B5
06CEC:  MOVWF  xC4
06CEE:  MOVLB  0
06CF0:  GOTO   4ACE
06CF4:  MOVF   01,F
06CF6:  BNZ   6CFA
....................                break; 
06CF8:  BRA    6DFA
....................  
....................             #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................             if(cIPFrameType == IP_PROT_ICMP) 
06CFA:  MOVLB  5
06CFC:  DECFSZ xBC,W
06CFE:  BRA    6DA8
....................             { 
....................                #if defined(STACK_USE_IP_GLEANING) 
....................                if(AppConfig.Flags.bInConfigMode && AppConfig.Flags.bIsDHCPEnabled) 
....................                { 
....................                   // According to "IP Gleaning" procedure, 
....................                   // when we receive an ICMP packet with a valid 
....................                   // IP address while we are still in configuration 
....................                   // mode, accept that address as ours and conclude 
....................                   // configuration mode. 
....................                   if(tempLocalIP.Val != 0xffffffff) 
....................                   { 
....................                      AppConfig.Flags.bInConfigMode = FALSE; 
....................                      AppConfig.MyIPAddr = tempLocalIP; 
....................                   } 
....................                } 
....................                #endif 
....................  
....................                // Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees 
....................                if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) || 
....................                   (tempLocalIP.Val == 0xFFFFFFFF) || 
.................... #if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................                                                 (tempLocalIP.Val == 0xFB0000E0) || 
.................... #endif 
....................                   (tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val))) 
06D00:  MOVF   1F,W
06D02:  SUBWF  xB7,W
06D04:  BNZ   6D18
06D06:  MOVF   20,W
06D08:  SUBWF  xB8,W
06D0A:  BNZ   6D18
06D0C:  MOVF   21,W
06D0E:  SUBWF  xB9,W
06D10:  BNZ   6D18
06D12:  MOVF   22,W
06D14:  SUBWF  xBA,W
06D16:  BZ    6D8A
06D18:  INCFSZ xB7,W
06D1A:  BRA    6D2A
06D1C:  INCFSZ xB8,W
06D1E:  BRA    6D2A
06D20:  INCFSZ xB9,W
06D22:  BRA    6D2A
06D24:  INCFSZ xBA,W
06D26:  BRA    6D2A
06D28:  BRA    6D8A
06D2A:  MOVF   1F,W
06D2C:  ANDWF  23,W
06D2E:  MOVWF  xBE
06D30:  MOVF   20,W
06D32:  ANDWF  24,W
06D34:  MOVWF  xBF
06D36:  MOVF   21,W
06D38:  ANDWF  25,W
06D3A:  MOVWF  xC0
06D3C:  MOVF   22,W
06D3E:  ANDWF  26,W
06D40:  MOVWF  xC1
06D42:  MOVFF  23,00
06D46:  COMF   00,F
06D48:  MOVFF  24,01
06D4C:  COMF   01,F
06D4E:  MOVFF  25,02
06D52:  COMF   02,F
06D54:  MOVFF  26,03
06D58:  COMF   03,F
06D5A:  MOVF   00,W
06D5C:  IORWF  xBE,W
06D5E:  MOVWF  00
06D60:  MOVF   01,W
06D62:  IORWF  xBF,W
06D64:  MOVWF  01
06D66:  MOVF   02,W
06D68:  IORWF  xC0,W
06D6A:  MOVWF  02
06D6C:  MOVF   03,W
06D6E:  IORWF  xC1,W
06D70:  MOVWF  03
06D72:  MOVF   00,W
06D74:  SUBWF  xB7,W
06D76:  BNZ   6DA2
06D78:  MOVF   01,W
06D7A:  SUBWF  xB8,W
06D7C:  BNZ   6DA2
06D7E:  MOVF   02,W
06D80:  SUBWF  xB9,W
06D82:  BNZ   6DA2
06D84:  MOVF   03,W
06D86:  SUBWF  xBA,W
06D88:  BNZ   6DA2
....................                { 
....................                   ICMPProcess(&remoteNode, dataCount); 
06D8A:  MOVLW  01
06D8C:  MOVWF  xBF
06D8E:  MOVLW  08
06D90:  MOVWF  xBE
06D92:  MOVFF  5B6,5C1
06D96:  MOVFF  5B5,5C0
06D9A:  MOVLB  0
06D9C:  GOTO   4BEA
06DA0:  MOVLB  5
....................                } 
....................  
....................                break; 
06DA2:  MOVLB  0
06DA4:  BRA    6DFA
06DA6:  MOVLB  5
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_TCP) 
....................             if(cIPFrameType == IP_PROT_TCP) 
06DA8:  MOVF   xBC,W
06DAA:  SUBLW  06
06DAC:  BNZ   6DCE
....................             { 
....................                TCPProcess(&remoteNode, &tempLocalIP, dataCount); 
06DAE:  MOVLW  01
06DB0:  MOVWF  xBF
06DB2:  MOVLW  08
06DB4:  MOVWF  xBE
06DB6:  MOVLW  05
06DB8:  MOVWF  xC1
06DBA:  MOVLW  B7
06DBC:  MOVWF  xC0
06DBE:  MOVFF  5B6,5C3
06DC2:  MOVFF  5B5,5C2
06DC6:  MOVLB  0
06DC8:  BRA    67A4
....................                break; 
06DCA:  BRA    6DFA
06DCC:  MOVLB  5
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_UDP) 
....................             if(cIPFrameType == IP_PROT_UDP) 
06DCE:  MOVF   xBC,W
06DD0:  SUBLW  11
06DD2:  BNZ   6DF8
....................             { 
....................                // Stop processing packets if we came upon a UDP frame with application data in it 
....................                if(UDPProcess(&remoteNode, &tempLocalIP, dataCount)) 
06DD4:  MOVLW  01
06DD6:  MOVWF  xBF
06DD8:  MOVLW  08
06DDA:  MOVWF  xBE
06DDC:  MOVLW  05
06DDE:  MOVWF  xC1
06DE0:  MOVLW  B7
06DE2:  MOVWF  xC0
06DE4:  MOVFF  5B6,5C3
06DE8:  MOVFF  5B5,5C2
06DEC:  MOVLB  0
06DEE:  BRA    6A98
06DF0:  MOVF   01,F
06DF2:  BZ    6DF6
....................                   return; 
06DF4:  BRA    6DFC
06DF6:  MOVLB  5
....................             } 
....................             #endif 
....................  
....................             break; 
06DF8:  MOVLB  0
....................       } 
06DFA:  BRA    6C94
....................    } 
06DFC:  GOTO   B07C (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackApplications(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Calls all loaded application modules. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackApplications(void) 
.................... { 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................    FTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_ANNOUNCE) 
....................    DiscoveryTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    AnnounceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_NBNS) 
....................    NBNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DHCP_SERVER) 
....................    DHCPServerTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DNS_SERVER) 
....................    DNSServerTask(); 
....................    #endif 
....................     
....................    #if defined (STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TELNET_SERVER) 
....................    TelnetTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_REBOOT_SERVER) 
....................    RebootTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNTP_CLIENT) 
....................    SNTPClient(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    UDPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    TCPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SMTP_CLIENT) 
....................    SMTPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    UART2TCPBridgeTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPTask(); 
....................    #endif    
....................  
....................    #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPServer(); 
*
0AF24:  GOTO   9F0A
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    TFTPSTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_TWITTER)   //should be renamed STACK_USE_CCS_TWITTER 
....................    TwitterTask();         // processes TCP tasks including the Tweet tasks 
....................    #endif    
....................     
....................    #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    EmailAlertTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    HttpClientTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_FTP_SERVER) 
0AF28:  GOTO   B07E (RETURN)
....................    FTPTask(); 
....................    #endif    
.................... } 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_DHCP_CLIENT) 
.................... void RenewDhcp(void) 
.................... { 
....................     g_DhcpRenew = TRUE; 
....................     SetDhcpProgressState(); 
.................... }     
....................      
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "Helpers.c" 
.................... /********************************************************************* 
....................   
....................  Helper Functions for Microchip TCPIP Stack 
....................   
....................  FileName:      Helpers.c 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................       ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................       used in conjunction with a Microchip ethernet controller for 
....................       the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release; Rewritten CalcIPChecksum() to avoid 
....................               multi-byte shift operation; Added hexatob(), 
....................               btohexa_high(), and btohexa_low(); Optimized swapl(); 
....................               Added leftRotateDWORD() 
....................   5.36        Updated compile time check for ultoa(); 
....................  
....................    DARREN ROOK/CCS   Remove leftRotateDWORD() 
....................  
....................  ********************************************************************/ 
.................... #define __HELPERS_C 
....................  
.................... #include <stdarg.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDARG 
....................  
.................... #define _STDARG 
....................  
.................... typedef char * va_list; 
....................  
.................... #define va_start(a,b)  a=_VA_LIST 
.................... #define va_arg(a,b)    *(b *)_va_arg(a) 
.................... #define va_end 
.................... #define nargs          _nargs(&_va_list) 
....................  
.................... int8 _nargs(int8 * ptr) { 
....................   int8 n; 
....................  
....................   n=0; 
....................   while(*ptr) { 
....................     n++; 
....................     ptr+=*ptr; 
....................   } 
....................   return(n); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Default Random Number Generator seed. 0x41FE9F9E corresponds to calling LFSRSeedRand(1) 
.................... static DWORD dwLFSRRandSeed = 0x41FE9F9E; 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD LFSRSeedRand(DWORD dwSeed) 
....................  
....................   Summary: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Description: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    wSeed - The new 32-bit seed value to assign to the LFSR. 
....................  
....................   Returns: 
....................      The last seed in use.  This can be saved and restored by a subsequent call  
....................    to LFSRSeedRand() if you wish to use LFSRRand() in multiple contexts  
....................    without disrupting the random number sequence from the alternative  
....................    context.  For example, if App 1 needs a given sequence of random numbers  
....................    to perform a test, if you save and restore the seed in App 2, it is  
....................    possible for App 2 to not disrupt the random number sequence provided to  
....................    App 1, even if the number of times App 2 calls LFSRRand() varies. 
....................       
....................   Side Effects: 
....................    None 
....................     
....................   Remarks: 
....................    Upon initial power up, the internal seed is initialized to 0x1.  Using a  
....................    dwSeed value of 0x0 will return the same sequence of random numbers as  
....................    using the seed of 0x1. 
....................   ***************************************************************************/ 
.................... DWORD LFSRSeedRand(DWORD dwSeed) 
.................... { 
....................    DWORD dwOldSeed; 
....................    BYTE i; 
....................  
....................    // Save original seed to be returned later 
....................    dwOldSeed = dwLFSRRandSeed; 
*
003B2:  MOVFF  116,5D2
003B6:  MOVFF  115,5D1
003BA:  MOVFF  114,5D0
003BE:  MOVFF  113,5CF
....................  
....................    // Ensure zero isn't selected as a seed value, this would result in all  
....................    // 0x0000 output values from the LFSR 
....................    if(dwSeed == 0u) 
003C2:  MOVLB  5
003C4:  MOVF   xCB,F
003C6:  BNZ   03DE
003C8:  MOVF   xCC,F
003CA:  BNZ   03DE
003CC:  MOVF   xCD,F
003CE:  BNZ   03DE
003D0:  MOVF   xCE,F
003D2:  BNZ   03DE
....................       dwSeed = 1; 
003D4:  CLRF   xCE
003D6:  CLRF   xCD
003D8:  CLRF   xCC
003DA:  MOVLW  01
003DC:  MOVWF  xCB
....................        
....................    // Set the new seed 
....................    dwLFSRRandSeed = dwSeed; 
003DE:  MOVFF  5CE,116
003E2:  MOVFF  5CD,115
003E6:  MOVFF  5CC,114
003EA:  MOVFF  5CB,113
....................     
....................    // Run the LFSR a few times to get rid of obvious start up artifacts for  
....................    // seed values that don't have many set bits. 
....................    for(i = 0; i < 16; i++) 
003EE:  CLRF   xD3
003F0:  MOVF   xD3,W
003F2:  SUBLW  0F
003F4:  BNC   0400
....................       LFSRRand(); 
003F6:  MOVLB  0
003F8:  RCALL  0312
003FA:  MOVLB  5
003FC:  INCF   xD3,F
003FE:  BRA    03F0
....................     
....................    // Return saved old seed 
....................    return dwOldSeed; 
00400:  MOVFF  5CF,00
00404:  MOVFF  5D0,01
00408:  MOVFF  5D1,02
0040C:  MOVFF  5D2,03
00410:  MOVLB  0
00412:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD LFSRRand(void) 
....................  
....................   Summary: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF). 
....................  
....................   Description: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF).  The random number is generated using a  
....................    Linear Feedback Shift Register (LFSR) type pseudo-random number generator  
....................    algorithm.  The LFSR can be seeded by calling the LFSRSeedRand() function 
....................    to generate the same sequence of random numbers as a prior string of calls. 
....................     
....................    The internal LFSR will repeat after 2^32-1 iterations. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 16-bit unsigned integer. 
....................       
....................   Side Effects: 
....................    The internal LFSR seed is updated so that the next call to LFSRRand()  
....................    will return a different random number. 
....................     
....................   Remarks: 
....................    None 
....................   ***************************************************************************/ 
.................... WORD LFSRRand(void) 
.................... { 
....................    BYTE i; 
....................     
....................    // Taps: 32 31 29 1 
....................    // Characteristic polynomial: x^32 + x^31 + x^29 + x + 1 
....................    // Repeat 15 times to make the shift pattern less obvious 
....................    for(i = 0; i < 15; i++) 
*
00312:  MOVLB  6
00314:  CLRF   x0D
00316:  MOVF   x0D,W
00318:  SUBLW  0E
0031A:  BNC   03A4
....................       dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul); 
0031C:  BCF    FD8.0
0031E:  MOVLB  1
00320:  RRCF   x16,W
00322:  MOVLB  6
00324:  MOVWF  x12
00326:  MOVLB  1
00328:  RRCF   x15,W
0032A:  MOVLB  6
0032C:  MOVWF  x11
0032E:  MOVLB  1
00330:  RRCF   x14,W
00332:  MOVLB  6
00334:  MOVWF  x10
00336:  MOVLB  1
00338:  RRCF   x13,W
0033A:  MOVLB  6
0033C:  MOVWF  x0F
0033E:  MOVLB  1
00340:  MOVF   x13,W
00342:  ANDLW  01
00344:  MOVWF  00
00346:  CLRF   01
00348:  CLRF   02
0034A:  CLRF   03
0034C:  MOVLW  00
0034E:  BSF    FD8.0
00350:  SUBFWB 00,W
00352:  MOVLB  6
00354:  MOVWF  x13
00356:  MOVLW  00
00358:  SUBFWB 01,W
0035A:  MOVWF  x14
0035C:  MOVLW  00
0035E:  SUBFWB 02,W
00360:  MOVWF  x15
00362:  MOVLW  00
00364:  SUBFWB 03,W
00366:  MOVWF  x16
00368:  MOVF   x13,W
0036A:  ANDLW  01
0036C:  MOVWF  00
0036E:  CLRF   01
00370:  CLRF   02
00372:  MOVF   x16,W
00374:  ANDLW  D0
00376:  MOVWF  03
00378:  MOVF   00,W
0037A:  XORWF  x0F,W
0037C:  MOVLB  1
0037E:  MOVWF  x13
00380:  MOVF   01,W
00382:  MOVLB  6
00384:  XORWF  x10,W
00386:  MOVLB  1
00388:  MOVWF  x14
0038A:  MOVF   02,W
0038C:  MOVLB  6
0038E:  XORWF  x11,W
00390:  MOVLB  1
00392:  MOVWF  x15
00394:  MOVF   03,W
00396:  MOVLB  6
00398:  XORWF  x12,W
0039A:  MOVLB  1
0039C:  MOVWF  x16
0039E:  MOVLB  6
003A0:  INCF   x0D,F
003A2:  BRA    0316
....................  
....................    // Return 16-bits as pseudo-random number 
....................    return (WORD)dwLFSRRandSeed; 
003A4:  MOVLB  1
003A6:  MOVFF  113,01
003AA:  MOVFF  114,02
003AE:  MOVLB  0
003B0:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD GenerateRandomDWORD(void) 
....................  
....................   Summary: 
....................    Generates a random DWORD. 
....................  
....................   Description: 
....................    This function generates a random 32-bit integer.  It collects 
....................    randomness by comparing the A/D converter's internal R/C oscillator 
....................    clock with our main system clock.  By passing collected entropy to the 
....................    LFSRSeedRand()/LFSRRand() functions, the output is normalized (deskewed)  
....................    in the hopes of meeting statistical randomness tests. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 32-bit number. 
....................       
....................   Side Effects: 
....................    This function uses the A/D converter (and so you must disable  
....................    interrupts if you use the A/D converted in your ISR).  The LFSRRand()  
....................    function will be reseeded, and Timer0 (PIC18) and Timer1 (PIC24,  
....................    dsPIC, and PIC32) will be used.  TMR#H:TMR#L will have a new value. 
....................    Note that this is the same timer used by the Tick module. 
....................     
....................   Remarks: 
....................    This function times out after 1 second of attempting to generate the  
....................    random DWORD.  In such a case, the output may not be truly random.   
....................    Typically, this function executes in around 500,000 instruction cycles. 
....................     
....................    The intent of this function is to produce statistically random and 
....................    cryptographically secure random number.  Whether or not this is true on 
....................    all (or any) devices/voltages/temperatures is not tested. 
....................   ***************************************************************************/ 
.................... DWORD GenerateRandomDWORD(void) 
.................... { 
....................    BYTE vBitCount; 
....................    WORD w, wTime, wLastValue; 
....................    DWORD dwTotalTime; 
....................    union 
....................    { 
....................       DWORD   dw; 
....................       WORD   w[2]; 
....................    } randomResult; 
....................  
.................... #if defined __18CXX    
.................... { 
....................    BYTE ADCON0Save, ADCON2Save; 
....................    BYTE T0CONSave, TMR0HSave, TMR0LSave; 
....................  
....................    // Save hardware SFRs 
....................    ADCON0Save = ADCON0; 
*
00414:  MOVFF  FC2,5C4
....................    ADCON2Save = ADCON2; 
00418:  MOVFF  FC0,5C5
....................    T0CONSave = T0CON; 
0041C:  MOVFF  FD5,5C6
....................    TMR0LSave = TMR0L; 
00420:  MOVFF  FD6,5C8
....................    TMR0HSave = TMR0H; 
00424:  MOVFF  FD7,5C7
....................  
....................    // Set up Timer and A/D converter module 
....................    ADCON0 = 0x01;   // Turn on the A/D module 
00428:  MOVLW  01
0042A:  MOVWF  FC2
....................    ADCON2 = 0x3F;   // 20 Tad acquisition, Frc A/D clock used for conversion 
0042C:  MOVLW  3F
0042E:  MOVWF  FC0
....................    T0CON = 0x88;   // TMR0ON = 1, no prescalar 
00430:  MOVLW  88
00432:  MOVWF  FD5
....................    vBitCount = 0; 
00434:  MOVLB  5
00436:  CLRF   xB5
....................    dwTotalTime = 0; 
00438:  CLRF   xBF
0043A:  CLRF   xBE
0043C:  CLRF   xBD
0043E:  CLRF   xBC
....................    wLastValue = 0; 
00440:  CLRF   xBB
00442:  CLRF   xBA
....................    randomResult.dw = LFSRRand(); 
00444:  MOVLB  0
00446:  RCALL  0312
00448:  MOVLB  5
0044A:  CLRF   xC3
0044C:  CLRF   xC2
0044E:  MOVFF  02,5C1
00452:  MOVFF  01,5C0
....................    while(1) 
....................    { 
....................       // Time the duration of an A/D acquisition and conversion 
....................       TMR0H = 0x00; 
00456:  CLRF   FD7
....................       TMR0L = 0x00; 
00458:  CLRF   FD6
....................       ADCON0bits.GO = 1; 
0045A:  BSF    FC2.1
....................       ClrWdt(); 
0045C:  CLRWDT
....................       while(ADCON0bits.GO); 
0045E:  BTFSC  FC2.1
00460:  BRA    045E
....................       ((BYTE*)&wTime)[0] = TMR0L; 
00462:  MOVFF  FD6,5B8
....................       ((BYTE*)&wTime)[1] = TMR0H; 
00466:  MOVFF  FD7,5B9
....................       w = LFSRRand(); 
0046A:  MOVLB  0
0046C:  RCALL  0312
0046E:  MOVFF  02,5B7
00472:  MOVFF  01,5B6
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
00476:  MOVLB  5
00478:  MOVF   xB8,W
0047A:  ADDWF  xBC,F
0047C:  MOVF   xB9,W
0047E:  ADDWFC xBD,F
00480:  MOVLW  00
00482:  ADDWFC xBE,F
00484:  ADDWFC xBF,F
....................       if(dwTotalTime >= GetInstructionClock()) 
00486:  MOVF   xBF,F
00488:  BNZ   049A
0048A:  MOVF   xBE,W
0048C:  SUBLW  79
0048E:  BC    04B8
00490:  XORLW  FF
00492:  BNZ   049A
00494:  MOVF   xBD,W
00496:  SUBLW  11
00498:  BC    04B8
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
0049A:  MOVLB  0
0049C:  RCALL  0312
0049E:  MOVF   01,W
004A0:  MOVLB  5
004A2:  XORWF  xC0,F
004A4:  MOVF   02,W
004A6:  XORWF  xC1,F
....................          randomResult.w[1] ^= LFSRRand(); 
004A8:  MOVLB  0
004AA:  RCALL  0312
004AC:  MOVF   01,W
004AE:  MOVLB  5
004B0:  XORWF  xC2,F
004B2:  MOVF   02,W
004B4:  XORWF  xC3,F
....................          break; 
004B6:  BRA    0526
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
004B8:  MOVF   xB8,W
004BA:  SUBWF  xBA,W
004BC:  BNZ   04C6
004BE:  MOVF   xB9,W
004C0:  SUBWF  xBB,W
004C2:  BNZ   04C6
....................          continue; 
004C4:  BRA    0456
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
004C6:  MOVF   xB8,W
004C8:  SUBWF  xBA,W
004CA:  MOVWF  00
004CC:  MOVF   xB9,W
004CE:  SUBWFB xBB,W
004D0:  MOVWF  03
004D2:  MOVF   00,W
004D4:  ADDWF  xB6,W
004D6:  MOVWF  xC9
004D8:  MOVF   03,W
004DA:  ADDWFC xB7,W
004DC:  MOVWF  xCA
004DE:  CLRF   xCE
004E0:  CLRF   xCD
004E2:  MOVWF  xCC
004E4:  MOVFF  5C9,5CB
004E8:  MOVLB  0
004EA:  RCALL  03B2
....................       wLastValue = wTime; 
004EC:  MOVFF  5B9,5BB
004F0:  MOVFF  5B8,5BA
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
004F4:  BCF    FD8.0
004F6:  MOVLB  5
004F8:  RLCF   xC0,F
004FA:  RLCF   xC1,F
004FC:  RLCF   xC2,F
004FE:  RLCF   xC3,F
....................       if(LFSRRand() & 0x0080) 
00500:  MOVLB  0
00502:  RCALL  0312
00504:  MOVFF  02,5CA
00508:  MOVFF  01,5C9
0050C:  MOVLB  5
0050E:  MOVF   01,W
00510:  ANDLW  80
00512:  MOVWF  00
00514:  CLRF   03
00516:  MOVF   00,W
00518:  IORWF  03,W
0051A:  BZ    051E
....................          randomResult.w[0] |= 0x1; 
0051C:  BSF    xC0.0
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
0051E:  INCF   xB5,F
00520:  BNZ   0524
....................          break; 
00522:  BRA    0526
00524:  BRA    0456
....................    } 
....................  
....................    // Restore hardware SFRs 
....................    ADCON0 = ADCON0Save; 
00526:  MOVFF  5C4,FC2
....................    ADCON2 = ADCON2Save; 
0052A:  MOVFF  5C5,FC0
....................    TMR0H = TMR0HSave; 
0052E:  MOVFF  5C7,FD7
....................    TMR0L = TMR0LSave; 
00532:  MOVFF  5C8,FD6
....................    T0CON = T0CONSave; 
00536:  MOVFF  5C6,FD5
.................... } 
.................... #else 
.................... { 
....................    WORD AD1CON1Save, AD1CON2Save, AD1CON3Save; 
....................    WORD T1CONSave, PR1Save; 
....................  
....................    // Save hardware SFRs 
....................    AD1CON1Save = AD1CON1; 
....................    AD1CON2Save = AD1CON2; 
....................    AD1CON3Save = AD1CON3; 
....................    T1CONSave = T1CON; 
....................    PR1Save = PR1; 
....................  
....................    // Set up Timer and A/D converter module 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = 0x9F00;      // Frc A/D clock, 31 Tad acquisition 
....................    AD1CON2 = 0x003F;      // Interrupt after every 16th sample/convert 
....................    AD1CON1 = 0x80E4;      // Turn on the A/D module, auto-convert 
....................    T1CON = 0x8000;         // TON = 1, no prescalar 
....................    PR1 = 0xFFFF;         // Don't clear timer early 
....................    vBitCount = 0; 
....................    dwTotalTime = 0; 
....................    wLastValue = 0; 
....................    randomResult.dw = LFSRRand(); 
....................    while(1) 
....................    { 
....................       ClrWdt(); 
....................       #if defined(__C30__) 
....................          while(!IFS0bits.AD1IF); 
....................       #else 
....................          while(!IFS1bits.AD1IF); 
....................       #endif 
....................       wTime = TMR1; 
....................       TMR1 = 0x0000; 
....................  
....................       #if defined(__C30__) 
....................          IFS0bits.AD1IF = 0; 
....................       #else 
....................          IFS1CLR = _IFS1_AD1IF_MASK; 
....................       #endif 
....................       w = LFSRRand(); 
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
....................       if(dwTotalTime >= GetInstructionClock()) 
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
....................          randomResult.w[1] ^= LFSRRand(); 
....................          break; 
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
....................          continue; 
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
....................       wLastValue = wTime; 
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
....................       if(LFSRRand() & 0x0080) 
....................          randomResult.w[0] |= 0x1; 
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
....................          break; 
....................    } 
....................  
....................  
....................    // Restore hardware SFRs 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = AD1CON3Save; 
....................    AD1CON2 = AD1CON2Save; 
....................    AD1CON1 = AD1CON1Save; 
....................    T1CON = T1CONSave; 
....................    PR1 = PR1Save; 
.................... } 
.................... #endif 
....................  
....................    return randomResult.dw; 
0053A:  MOVFF  5C0,00
0053E:  MOVFF  5C1,01
00542:  MOVFF  5C2,02
00546:  MOVFF  5C3,03
0054A:  MOVLB  0
0054C:  GOTO   1522 (RETURN)
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_HTTP_SERVER) 
.................... /***************************************************************************** 
....................   Function: 
....................    void UnencodeURL(BYTE* URL) 
....................  
....................   Summary: 
....................    Decodes a URL-encoded string. 
....................  
....................   Description: 
....................    This function is deprecated except for use with HTTP Classic.  It 
....................    attempts to decode a URL encoded string, converting all hex escape 
....................    sequences into a literal byte.  However, it is inefficient over long 
....................    strings and does not handle URL-encoded data strings ('&' and '='). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    URL - the null-terminated string to decode 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UnencodeURL(BYTE* URL) 
.................... { 
....................    BYTE *Right, *Copy; 
....................    WORD_VAL Number; 
....................  
....................    while((Right = (BYTE*)strchr((char*)URL, '%'))) 
....................    { 
....................       // Make sure the string is long enough 
....................       if(Right[1] == '\0') 
....................          break; 
....................       if(Right[2] == '\0') 
....................          break; 
....................  
....................       // Update the string in place 
....................       Number.v[0] = Right[2]; 
....................       Number.v[1] = Right[1]; 
....................       *Right++ = hexatob(Number); 
....................       URL = Right; 
....................  
....................       // Remove two blank spots by shifting all remaining characters right two 
....................       Copy = Right + 2; 
....................       while((*Right++ = *Copy++)); 
....................    } 
.................... }           
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................   ***************************************************************************/ 
.................... BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while((i = *str++)) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................    
....................   Remarks: 
....................    This function is aliased to StringToIPAddress on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while(i = *str++) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen,  
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Decodes a Base-64 array to its literal representation. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of Base-64 encoded data 
....................    wSourceLen   - Length of the Base-64 source data 
....................    cDestData   - Pointer to write the decoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of decoded bytes written to cDestData. 
....................    
....................   Remarks: 
....................    This function is binary safe and will ignore invalid characters (CR, LF,  
....................    etc).  If cSourceData is equal to cDestData, the data will be converted 
....................    in-place.  If cSourceData is not equal to cDestData, but the regions  
....................    overlap, the behavior is undefined. 
....................     
....................    Decoded data is always at least 1/4 smaller than the source data. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_DECODE) 
.................... WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i; 
....................    BYTE vByteNumber; 
....................    WORD wBytesOutput; 
....................  
....................    vByteNumber = 0; 
....................    wBytesOutput = 0; 
....................  
....................    // Loop over all provided bytes 
....................    while(wSourceLen--) 
....................    { 
....................       // Fetch a Base64 byte and decode it to the original 6 bits 
....................       i = *cSourceData++; 
....................       if(i >= 'A' && i <= 'Z')   // Regular data 
....................          i -= 'A' - 0; 
....................       else if(i >= 'a' && i <= 'z') 
....................          i -= 'a' - 26; 
....................       else if(i >= '0' && i <= '9') 
....................          i -= '0' - 52; 
....................       else if(i == '+' || i == '-') 
....................          i = 62; 
....................       else if(i == '/' || i == '_') 
....................          i = 63; 
....................       else                   // Skip all padding (=) and non-Base64 characters 
....................          continue; 
....................  
....................  
....................       // Write the 6 bits to the correct destination location(s) 
....................       if(vByteNumber == 0u) 
....................       { 
....................          vByteNumber++; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 2; 
....................       } 
....................       else if(vByteNumber == 1u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 4; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 4; 
....................       } 
....................       else if(vByteNumber == 2u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 2; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 6; 
....................       } 
....................       else 
....................       { 
....................          vByteNumber = 0; 
....................          *cDestData++ |= i; 
....................       } 
....................    } 
....................  
....................    return wBytesOutput; 
.................... } 
.................... #endif   // #if defined(STACK_USE_BASE64_DECODE) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, 
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Encodes a binary array to Base-64. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of binary data 
....................    wSourceLen   - Length of the binary source data 
....................    cDestData   - Pointer to write the Base-64 encoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of encoded bytes written to cDestData.  This will always be 
....................      a multiple of 4. 
....................    
....................   Remarks: 
....................    Encoding cannot be performed in-place.  If cSourceData overlaps with  
....................    cDestData, the behavior is undefined. 
....................     
....................    Encoded data is always at least 1/3 larger than the source data.  It may 
....................    be 1 or 2 bytes larger than that. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP_CLIENT) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i, j; 
....................    BYTE vOutput[4]; 
....................    WORD wOutputLen; 
....................  
....................    wOutputLen = 0; 
....................    while(wDestLen >= 4u) 
....................    { 
....................       // Start out treating the output as all padding 
....................       vOutput[0] = 0xFF; 
....................       vOutput[1] = 0xFF; 
....................       vOutput[2] = 0xFF; 
....................       vOutput[3] = 0xFF; 
....................  
....................       // Get 3 input octets and split them into 4 output hextets (6-bits each)  
....................       if(wSourceLen == 0u) 
....................          break; 
....................       i = *cSourceData++; 
....................       wSourceLen--; 
....................       vOutput[0] = (i & 0xFC)>>2; 
....................       vOutput[1] = (i & 0x03)<<4; 
....................       if(wSourceLen) 
....................       { 
....................          i = *cSourceData++; 
....................          wSourceLen--; 
....................          vOutput[1] |= (i & 0xF0)>>4; 
....................          vOutput[2] = (i & 0x0F)<<2; 
....................          if(wSourceLen) 
....................          { 
....................             i = *cSourceData++; 
....................             wSourceLen--; 
....................             vOutput[2] |= (i & 0xC0)>>6; 
....................             vOutput[3] = i & 0x3F; 
....................          } 
....................       } 
....................     
....................       // Convert hextets into Base 64 alphabet and store result 
....................       for(i = 0; i < 4u; i++) 
....................       { 
....................          j = vOutput[i]; 
....................  
....................          if(j <= 25u) 
....................             j += 'A' - 0; 
....................          else if(j <= 51u) 
....................             j += 'a' - 26; 
....................          else if(j <= 61u) 
....................             j += '0' - 52; 
....................          else if(j == 62u) 
....................             j = '+'; 
....................          else if(j == 63u) 
....................             j = '/'; 
....................          else            // Padding 
....................             j = '='; 
....................  
....................          *cDestData++ = j; 
....................       } 
....................  
....................       // Update counters 
....................       wDestLen -= 4; 
....................       wOutputLen += 4; 
....................    } 
....................  
....................    return wOutputLen; 
.................... } 
.................... #endif // #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void uitoa(WORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 16-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void uitoa(WORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    WORD Digit; 
....................    WORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 10000; i < 5u; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... }              
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ultoa(DWORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 32-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... // HI-TECH PICC-18 PRO 9.63, C30 v3.25, and C32 v1.12 already have a ultoa() library function 
.................... // C18 already has a ultoa() function that more-or-less matches this one 
.................... // C32 < 1.12 and C30 < v3.25 need this function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... void ultoa(DWORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    DWORD Digit; 
....................    DWORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 1000000000; i < 10; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE hexatob(WORD_VAL AsciiChars) 
....................  
....................   Summary: 
....................    Converts a hex string to a single byte. 
....................     
....................   Description: 
....................    Converts a two-character ASCII hex string to a single packed byte. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    AsciiChars - WORD_VAL where .v[0] is the ASCII value for the lower nibble 
....................                and .v[1] is the ASCII value for the upper nibble.  Each 
....................                must range from '0'-'9', 'A'-'F', or 'a'-'f'. 
....................  
....................   Returns: 
....................      Resulting packed byte 0x00 - 0xFF. 
....................   ***************************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'A'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The upper hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'E'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The lower hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
....................  
....................   Summary: 
....................    Case-insensitive comparison of a string in RAM to a string in ROM. 
....................  
....................   Description: 
....................    Performs a case-insensitive comparison of a string in RAM to a string 
....................    in ROM.  This function performs identically to strcmppgm2ram, except that 
....................    the comparison is not case-sensitive. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    a - Pinter to tring in RAM 
....................    b - Pointer to string in ROM 
....................  
....................   Return Values: 
....................      \-1 - a < b 
....................      0   - a = b 
....................      1   - a > b 
....................   ***************************************************************************/ 
.................... //signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
.................... signed char stricmppgm2ram(char* a, ROM char* b)   //__CCS__ __PCH__ __PCD__ 
.................... { 
....................    char cA, cB; 
....................     
....................    // Load first two characters 
....................    cA = *a; 
....................    cB = *b; 
....................  
....................    //debug_http2(debug_putc, "stricmppgm2ram() '%s' '%s' %x.%x ", a, b, cA, cB); 
....................    
....................    // Loop until one string terminates 
....................    while(cA != '\0' && cB != '\0') 
....................    { 
....................       // Shift case if necessary 
....................       if(cA >= 'a' && cA <= 'z') 
....................          cA -= 'a' - 'A'; 
....................       if(cB >= 'a' && cB <= 'z') 
....................          cB -= 'a' - 'A'; 
....................           
....................       // Compare 
....................       if(cA > cB) 
....................       { 
....................          //debug_http2(debug_putc, ">\r\n"); 
....................          return 1; 
....................       } 
....................       if(cA < cB) 
....................       { 
....................          //debug_http2(debug_putc, "<\r\n"); 
....................          return -1; 
....................       } 
....................        
....................       // Characters matched, so continue 
....................       a++; 
....................       b++; 
....................       cA = *a; 
....................       cB = *b; 
....................        
....................       //debug_http2(debug_putc, "%x.%x ", cA, cB);       
....................    } 
....................     
....................    // See if one string terminated first 
....................    if(cA > cB) 
....................    { 
....................       //debug_http2(debug_putc, "done >\r\n"); 
....................       return 1; 
....................    } 
....................    if(cA < cB) 
....................    { 
....................       //debug_http2(debug_putc, "done <\r\n"); 
....................       return -1; 
....................    } 
....................  
....................    //debug_http2(debug_putc, "done =\r\n"); 
....................  
....................    // Strings match 
....................    return 0; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD swaps(WORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a WORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the WORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... WORD swaps(WORD v) 
.................... { 
....................    WORD_VAL t; 
....................    BYTE b; 
....................  
....................    t.Val   = v; 
*
01A42:  MOVFF  653,655
01A46:  MOVFF  652,654
....................    b       = t.v[1]; 
01A4A:  MOVFF  655,656
....................    t.v[1]  = t.v[0]; 
01A4E:  MOVFF  654,655
....................    t.v[0]  = b; 
01A52:  MOVFF  656,654
....................  
....................    return t.Val; 
01A56:  MOVLB  6
01A58:  MOVFF  654,01
01A5C:  MOVFF  655,02
01A60:  MOVLB  0
01A62:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD swapl(DWORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a DWORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the DWORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v) 
.................... #else 
.................... DWORD swapl(DWORD v) 
.................... #endif 
.................... { 
....................    // Swap bytes 0 and 3 
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
*
030FC:  MOVLW  06
030FE:  MOVLB  6
03100:  MOVWF  x40
03102:  MOVLW  3B
03104:  MOVWF  01
03106:  MOVFF  640,FEA
0310A:  MOVWF  FE9
0310C:  MOVFF  FEF,643
03110:  MOVLW  06
03112:  MOVWF  x45
03114:  MOVLW  3B
03116:  MOVWF  x44
03118:  MOVLW  03
0311A:  ADDWF  x44,W
0311C:  MOVWF  FE9
0311E:  MOVLW  00
03120:  ADDWFC x45,W
03122:  MOVWF  FEA
03124:  MOVF   FEF,W
03126:  XORWF  x43,W
03128:  MOVFF  640,FEA
0312C:  MOVFF  01,FE9
03130:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0]; 
03132:  MOVLW  06
03134:  MOVWF  x40
03136:  MOVLW  3B
03138:  MOVWF  x3F
0313A:  MOVLW  03
0313C:  ADDWF  x3F,W
0313E:  MOVWF  01
03140:  MOVLW  00
03142:  ADDWFC x40,W
03144:  MOVWF  03
03146:  MOVWF  FEA
03148:  MOVFF  01,FE9
0314C:  MOVFF  FEF,643
03150:  MOVLW  06
03152:  MOVWF  x45
03154:  MOVLW  3B
03156:  MOVWF  FE9
03158:  MOVFF  645,FEA
0315C:  MOVF   FEF,W
0315E:  XORWF  x43,W
03160:  MOVFF  03,FEA
03164:  MOVFF  01,FE9
03168:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
0316A:  MOVLW  06
0316C:  MOVWF  x40
0316E:  MOVLW  3B
03170:  MOVWF  01
03172:  MOVFF  640,FEA
03176:  MOVWF  FE9
03178:  MOVFF  FEF,643
0317C:  MOVLW  06
0317E:  MOVWF  x45
03180:  MOVLW  3B
03182:  MOVWF  x44
03184:  MOVLW  03
03186:  ADDWF  x44,W
03188:  MOVWF  FE9
0318A:  MOVLW  00
0318C:  ADDWFC x45,W
0318E:  MOVWF  FEA
03190:  MOVF   FEF,W
03192:  XORWF  x43,W
03194:  MOVFF  640,FEA
03198:  MOVFF  01,FE9
0319C:  MOVWF  FEF
....................  
....................    // Swap bytes 1 and 2 
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
0319E:  MOVLW  06
031A0:  MOVWF  x40
031A2:  MOVLW  3B
031A4:  MOVWF  x3F
031A6:  MOVLW  01
031A8:  ADDWF  x3F,W
031AA:  MOVWF  01
031AC:  MOVLW  00
031AE:  ADDWFC x40,W
031B0:  MOVWF  03
031B2:  MOVWF  FEA
031B4:  MOVFF  01,FE9
031B8:  MOVFF  FEF,643
031BC:  MOVLW  06
031BE:  MOVWF  x45
031C0:  MOVLW  3B
031C2:  MOVWF  x44
031C4:  MOVLW  02
031C6:  ADDWF  x44,W
031C8:  MOVWF  FE9
031CA:  MOVLW  00
031CC:  ADDWFC x45,W
031CE:  MOVWF  FEA
031D0:  MOVF   FEF,W
031D2:  XORWF  x43,W
031D4:  MOVFF  03,FEA
031D8:  MOVFF  01,FE9
031DC:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1]; 
031DE:  MOVLW  06
031E0:  MOVWF  x40
031E2:  MOVLW  3B
031E4:  MOVWF  x3F
031E6:  MOVLW  02
031E8:  ADDWF  x3F,W
031EA:  MOVWF  01
031EC:  MOVLW  00
031EE:  ADDWFC x40,W
031F0:  MOVWF  03
031F2:  MOVWF  FEA
031F4:  MOVFF  01,FE9
031F8:  MOVFF  FEF,643
031FC:  MOVLW  06
031FE:  MOVWF  x45
03200:  MOVLW  3B
03202:  MOVWF  x44
03204:  MOVLW  01
03206:  ADDWF  x44,W
03208:  MOVWF  FE9
0320A:  MOVLW  00
0320C:  ADDWFC x45,W
0320E:  MOVWF  FEA
03210:  MOVF   FEF,W
03212:  XORWF  x43,W
03214:  MOVFF  03,FEA
03218:  MOVFF  01,FE9
0321C:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
0321E:  MOVLW  06
03220:  MOVWF  x40
03222:  MOVLW  3B
03224:  MOVWF  x3F
03226:  MOVLW  01
03228:  ADDWF  x3F,W
0322A:  MOVWF  01
0322C:  MOVLW  00
0322E:  ADDWFC x40,W
03230:  MOVWF  03
03232:  MOVWF  FEA
03234:  MOVFF  01,FE9
03238:  MOVFF  FEF,643
0323C:  MOVLW  06
0323E:  MOVWF  x45
03240:  MOVLW  3B
03242:  MOVWF  x44
03244:  MOVLW  02
03246:  ADDWF  x44,W
03248:  MOVWF  FE9
0324A:  MOVLW  00
0324C:  ADDWFC x45,W
0324E:  MOVWF  FEA
03250:  MOVF   FEF,W
03252:  XORWF  x43,W
03254:  MOVFF  03,FEA
03258:  MOVFF  01,FE9
0325C:  MOVWF  FEF
....................  
....................    return v; 
0325E:  MOVFF  63B,00
03262:  MOVFF  63C,01
03266:  MOVFF  63D,02
0326A:  MOVFF  63E,03
0326E:  MOVLB  0
03270:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD CalcIPChecksum(BYTE* buffer, WORD count) 
....................  
....................   Summary: 
....................    Calculates an IP checksum value. 
....................  
....................   Description: 
....................    This function calculates an IP checksum over an array of input data.  The 
....................    checksum is the 16-bit one's complement of one's complement sum of all  
....................    words in the data (with zero-padding if an odd number of bytes are  
....................    summed).  This checksum is defined in RFC 793. 
....................  
....................   Precondition: 
....................    buffer is WORD aligned (even memory address) on 16- and 32-bit PICs. 
....................  
....................   Parameters: 
....................    buffer - pointer to the data to be checksummed 
....................    count  - number of bytes to be checksummed 
....................  
....................   Returns: 
....................    The calculated checksum. 
....................     
....................   Internal: 
....................    This function could be improved to do 32-bit sums on PIC32 platforms. 
....................   ***************************************************************************/ 
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................    union 
....................    { 
....................       WORD w[2]; 
....................       DWORD dw; 
....................    } sum; 
....................  
....................    i = count >> 1; 
*
01B26:  BCF    FD8.0
01B28:  MOVLB  6
01B2A:  RRCF   x51,W
01B2C:  MOVWF  x53
01B2E:  RRCF   x50,W
01B30:  MOVWF  x52
....................    val = (WORD*)buffer; 
01B32:  MOVFF  64F,655
01B36:  MOVFF  64E,654
....................  
....................    // Calculate the sum of all words 
....................    sum.dw = 0x00000000ul; 
01B3A:  CLRF   x59
01B3C:  CLRF   x58
01B3E:  CLRF   x57
01B40:  CLRF   x56
....................    while(i--) 
01B42:  MOVFF  653,03
01B46:  MOVF   x52,W
01B48:  BTFSC  FD8.2
01B4A:  DECF   x53,F
01B4C:  DECF   x52,F
01B4E:  IORWF  03,W
01B50:  BZ    1B8E
....................       sum.dw += (DWORD)*val++; 
01B52:  MOVFF  655,03
01B56:  MOVFF  654,00
01B5A:  MOVLW  02
01B5C:  ADDWF  x54,F
01B5E:  BTFSC  FD8.0
01B60:  INCF   x55,F
01B62:  MOVFF  00,FE9
01B66:  MOVFF  03,FEA
01B6A:  MOVFF  FEC,03
01B6E:  MOVF   FED,F
01B70:  MOVFF  FEF,00
01B74:  MOVFF  03,01
01B78:  CLRF   02
01B7A:  CLRF   03
01B7C:  MOVF   00,W
01B7E:  ADDWF  x56,F
01B80:  MOVF   01,W
01B82:  ADDWFC x57,F
01B84:  MOVF   02,W
01B86:  ADDWFC x58,F
01B88:  MOVF   03,W
01B8A:  ADDWFC x59,F
01B8C:  BRA    1B42
....................  
....................    // Add in the sum of the remaining byte, if present 
....................    if(count & 0x1) 
01B8E:  MOVF   x50,W
01B90:  ANDLW  01
01B92:  MOVWF  00
01B94:  CLRF   03
01B96:  MOVF   00,W
01B98:  IORWF  03,W
01B9A:  BZ    1BC2
....................       sum.dw += (DWORD)*(BYTE*)val; 
01B9C:  MOVFF  655,03
01BA0:  MOVFF  654,FE9
01BA4:  MOVFF  655,FEA
01BA8:  MOVFF  FEF,00
01BAC:  CLRF   01
01BAE:  CLRF   02
01BB0:  CLRF   03
01BB2:  MOVF   00,W
01BB4:  ADDWF  x56,F
01BB6:  MOVF   01,W
01BB8:  ADDWFC x57,F
01BBA:  MOVF   02,W
01BBC:  ADDWFC x58,F
01BBE:  MOVF   03,W
01BC0:  ADDWFC x59,F
....................  
....................    // Do an end-around carry (one's complement arrithmatic) 
....................    sum.dw = (DWORD)sum.w[0] + (DWORD)sum.w[1]; 
01BC2:  CLRF   x5D
01BC4:  CLRF   x5C
01BC6:  MOVFF  657,65B
01BCA:  MOVFF  656,65A
01BCE:  MOVFF  658,00
01BD2:  MOVFF  659,01
01BD6:  CLRF   02
01BD8:  CLRF   03
01BDA:  MOVF   x58,W
01BDC:  ADDWF  x56,W
01BDE:  MOVWF  x56
01BE0:  MOVF   x59,W
01BE2:  ADDWFC x57,W
01BE4:  MOVWF  x57
01BE6:  MOVF   02,W
01BE8:  ADDWFC x5C,W
01BEA:  MOVWF  x58
01BEC:  MOVF   03,W
01BEE:  ADDWFC x5D,W
01BF0:  MOVWF  x59
....................  
....................    // Do another end-around carry in case if the prior add  
....................    // caused a carry out 
....................    sum.w[0] += sum.w[1]; 
01BF2:  MOVF   x58,W
01BF4:  ADDWF  x56,F
01BF6:  MOVF   x59,W
01BF8:  ADDWFC x57,F
....................  
....................    // Return the resulting checksum 
....................    return ~sum.w[0]; 
01BFA:  MOVFF  657,03
01BFE:  COMF   03,F
01C00:  MOVF   x56,W
01C02:  XORLW  FF
01C04:  MOVWF  01
01C06:  MOVFF  03,02
01C0A:  MOVLB  0
01C0C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strupr(char* s) 
....................  
....................   Summary: 
....................    Converts a string to uppercase. 
....................  
....................   Description: 
....................    This function converts strings to uppercase on platforms that do not 
....................    already have this function defined.  All lower-case characters are 
....................    converted, an characters not included in 'a'-'z' are left as-is. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    s - the null-terminated string to be converted. 
....................  
....................   Returns: 
....................    Pointer to the initial string. 
....................   ***************************************************************************/ 
.................... #if (!defined(__CCS__) && !defined(__18CXX)) || defined(HI_TECH_C) 
.................... char* strupr(char* s) 
.................... { 
....................    char c; 
....................    char *t; 
....................  
....................    t = s; 
....................    while( (c = *t) ) 
....................    { 
....................       if(c >= 'a' && c <= 'z') 
....................       { 
....................          *t -= ('a' - 'A'); 
....................       } 
....................       t++; 
....................    } 
....................    return s; 
.................... } 
.................... #endif 
....................  
.................... #if defined(__18CXX) //&& !defined(__PCH__) 
.................... // Make this variable global for the following function. 
.................... // Hi-Tech PICC18 cannot access local function variables from inline asm. 
.................... DWORD_VAL toRotate;  
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD leftRotateDWORD(DWORD val, BYTE bits) 
....................  
....................   Summary: 
....................    Left-rotates a DWORD. 
....................  
....................   Description: 
....................    This function rotates the bits in a 32-bit DWORD left by a specific  
....................    number of bits. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    val      - the DWORD to be rotated 
....................    bits   - the number of bits by which to shift 
....................  
....................   Returns: 
....................    Rotated DWORD value. 
....................     
....................   Remarks: 
....................    This function is only implemented on 8-bit platforms for now.  The  
....................    8-bit compilers generate excessive code for this function, while C30 
....................    and C32 already generate compact code.  Those compilers are served 
....................    by a macro defined in Helpers.h. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... DWORD leftRotateDWORD(DWORD val, BYTE bits) 
.................... { 
....................    BYTE i, t; 
....................    //DWORD_VAL toRotate; 
....................    toRotate.Val = val; 
....................     
....................    for(i = bits; i >= 8u; i -= 8) 
....................    { 
....................       t = toRotate.v[3]; 
....................       toRotate.v[3] = toRotate.v[2]; 
....................       toRotate.v[2] = toRotate.v[1]; 
....................       toRotate.v[1] = toRotate.v[0]; 
....................       toRotate.v[0] = t; 
....................    } 
....................     
....................     
....................    #if defined(HI_TECH_C) 
....................    for(; i != 0; i--) 
....................    { 
....................       asm("movlb (_toRotate)>>8"); 
....................       //asm("bcf _STATUS,0,C"); 
....................       asm("bcf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("btfsc (_toRotate)&0ffh+3,7,B"); 
....................       //asm("bsf _STATUS,0,C"); 
....................       asm("bsf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("rlcf (_toRotate)&0ffh+0,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+1,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+2,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+3,F,B"); 
....................    } 
....................    #else 
....................    for(; i != 0u; i--) 
....................    { 
....................       _asm 
....................       movlb toRotate 
....................       bcf STATUS,0,0 
....................       btfsc toRotate+3,7,1 
....................       bsf STATUS,0,0 
....................       rlcf toRotate+0,1,1 
....................       rlcf toRotate+1,1,1 
....................       rlcf toRotate+2,1,1 
....................       rlcf toRotate+3,1,1 
....................       _endasm 
....................    } 
....................    #endif 
....................     
....................    return toRotate.Val; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void FormatNetBIOSName(BYTE Name[]) 
....................  
....................   Summary: 
....................    Formats a string to a valid NetBIOS name. 
....................  
....................   Description: 
....................    This function formats a string to a valid NetBIOS name.  Names will be 
....................    exactly 16 characters, as defined by the NetBIOS spec.  The 16th  
....................    character will be a 0x00 byte, while the other 15 will be the  
....................    provided string, padded with spaces as necessary. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Name - the string to format as a NetBIOS name.  This parameter must have 
....................      at least 16 bytes allocated. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void FormatNetBIOSName(BYTE Name[]) 
.................... { 
....................    BYTE i; 
....................  
....................    Name[15] = '\0'; 
....................    strupr((char*)Name); 
....................    i = 0; 
....................    while(i < 15u) 
....................    { 
....................       if(Name[i] == '\0') 
....................       { 
....................          while(i < 15u) 
....................          { 
....................             Name[i++] = ' '; 
....................          } 
....................          break; 
....................       } 
....................       i++; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char * strnchr(const char *searchString, size_t count, char c) 
....................  
....................   Summary: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character. 
....................  
....................   Description: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character.  The string is searched forward and the first occurance  
....................    location is returned.  If the search character is not present in the  
....................    string, or if the maximum character count is reached first, then a NULL  
....................    pointer is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    searchString - Pointer to a null terminated string to search.  If count is  
....................       less than the string size, then the string need not be null terminated. 
....................    count - Maximum number of characters to search before aborting. 
....................    c - Character to search for 
....................     
....................   Returns: 
....................    Pointer to the first occurance of the character c in the string  
....................    searchString.  If the character is not found or the maximum count is  
....................    reached, a NULL pointer is returned. 
....................   ***************************************************************************/ 
.................... char * strnchr(const char *searchString, size_t count, char c) 
.................... { 
....................    char c2; 
....................     
....................    while(count--) 
....................    { 
....................       c2  = *searchString++; 
....................       if(c2 == 0u) 
....................          return NULL; 
....................       if(c2 == c) 
....................          return (char*)--searchString; 
....................    } 
....................    return NULL; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
....................  
....................   Summary: 
....................    Copies multiple strings to a destination 
....................  
....................   Description: 
....................    Copies multiple strings to a destination 
....................     but doesn't copy more than destSize characters. 
....................     Useful where the destination is actually an array and an extra \0 
....................     won't be appended to overflow the buffer 
....................      
....................   Precondition: 
....................    - valid string pointers 
....................     - destSize should be > 0 
....................  
....................   Parameters: 
....................    destStr - Pointer to a string to be initialized with the multiple strings provided as arguments. 
....................  
....................     destSize    - the maximum size of the destStr field, that cannot be exceeded. 
....................                   An \0 won't be appended if the resulting size is > destSize 
....................  
....................     nStrings    - number of string parameters to be copied into destStr 
....................  
....................     ...         - variable number of arguments 
....................      
....................     
....................   Returns: 
....................    Length of the destination string, terminating \0 (if exists) not included 
....................   ***************************************************************************/ 
.................... size_t strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
.................... { 
....................     va_list     args; 
....................     const char* str; 
....................     char*       end; 
....................     size_t      len; 
....................  
....................     destStr[0] = '\0'; 
....................     end = destStr + destSize - 1; 
....................     *end = '\0'; 
....................     len = 0; 
....................      
....................     va_start( args, nStrings ); 
....................      
....................     while(nStrings--) 
....................     { 
....................         if(*end) 
....................         {   // if already full don't calculate strlen outside the string area 
....................             len = destSize; 
....................             break; 
....................         } 
....................          
....................         str = va_arg(args, const char*); 
....................         strncpy(destStr + len, str, destSize - len); 
....................         len += strlen(str); 
....................     } 
....................  
....................     va_end( args ); 
....................      
....................     return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE ExtractURLFields(BYTE *vURL,  
....................                     PROTOCOLS *protocol,  
....................                     BYTE *vUsername, WORD *wUsernameLen,  
....................                     BYTE *vPassword, WORD *wPasswordLen,  
....................                     BYTE *vHostname, WORD *wHostnameLen,  
....................                     WORD *wPort,  
....................                     BYTE *vFilePath, WORD *wFilePathLen) 
....................  
....................   Summary: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................  
....................   Description: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................     
....................    The URL string can be null terminated, or alternatively could be terminated  
....................    by a carriage return or line feed. 
....................     
....................    If the protocol is unrecognized or the protocol is recognized but the URL  
....................    is malformed, than an error is safely returned.  For more information on  
....................    URL/URI interpretation see RFC 2396. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vURL -   Pointer to null terminated URL to decode and extract from.  This  
....................       parameter is required and needs to have the minimum RFC 1738 components  
....................       in it (protocol and hostname). 
....................        
....................    protocol - Optional pointer to a PROTOCOLS enum to retrieve the decoded  
....................       protocol type.  If this parameter is unneeded, specify a NULL pointer.   
....................       The protocol is a required part of the URL, so it must always be  
....................       present.  The protocol also determines what scheme all other parameters  
....................       are decoded using, so the function will fail if an unrecognized  
....................       protocol is provided.  The PROTOCOLS enum members show all of the  
....................       currently supported protocols for this function. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       PROTOCOL_HTTP would be returned for this field. 
....................        
....................    vUsername - Optional pointer to a buffer to write the decoded username  
....................       portion of the URL.  If the URL does not contain a username or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "admin"  
....................       would be returned for this field. 
....................        
....................    wUsernameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vUsername buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wUsernameLen and vUsername are non-NULL, the  
....................       *wUsernameLen WORD is updated with the actual number of characters  
....................       written to the vUsername buffer, including the null terminator  
....................       character.  If vUsername is NULL but wUsernameLen is non-NULL, then no  
....................       characters are copied, but *wUsernameLen will return the number of  
....................       characters required to fit the full username string.  If wUsernameLen  
....................       is NULL, then the username field in the URL, if present, is ignored and  
....................       the vUsername pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a username field.  If one character was written, this indicates  
....................       that a username field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 6 (0x0006)  
....................       would be returned for this field. 
....................        
....................    vPassword - Optional pointer to a buffer to write the decoded password  
....................       portion of the URL.  If the URL does not contain a password or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "passwd"  
....................       would be returned for this field. 
....................        
....................    wPasswordLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vPassword buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wPasswordLen and vPassword are non-NULL, the  
....................       *wPasswordLen WORD is updated with the actual number of characters  
....................       written to the vPassword buffer, including the null terminator  
....................       character.  If vPassword is NULL but wPasswordLen is non-NULL, then no  
....................       characters are copied, but *wPasswordLen will return the number of  
....................       characters required to fit the full password string.  If wPasswordLen  
....................       is NULL, then the password field in the URL, if present, is ignored and  
....................       the vPassword pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a password field.  If one character was written, this indicates  
....................       that a password field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 7 (0x0007)  
....................       would be returned for this field. 
....................        
....................    vHostname - Optional pointer to a buffer to write the decoded hostname  
....................       portion of the URL.  All Internet URLs must contain a hostname or IP  
....................       address, however, if a NULL pointer is supplied, then this field is  
....................       ignored. 
....................  
....................       <p>For the example URL provided in the function description,  
....................       "www.microchip.com" would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as  
....................       "192.168.0.1".   The IP address would not be decoded to a DWORD (use the  
....................       StringToIPAddress() helper function to do this). 
....................        
....................    wHostnameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vHostname buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wHostnameLen and vHostname are non-NULL, the  
....................       *wHostnameLen WORD is updated with the actual number of characters  
....................       written to the vHostname buffer, including the null terminator  
....................       character.  If vHostname is NULL but wHostnameLen is non-NULL, then no  
....................       characters are copied, but *wHostnameLen will return the number of  
....................       characters required to fit the full hostname string.  If wHostnameLen  
....................       is NULL, then the hostname field in the URL, is ignored and the  
....................       vHostname pointer is not used. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       18 (0x0012) would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as 12 (0x000C). 
....................        
....................    wPort - Optional pointer to a WORD specifying the TCP or UDP port that the  
....................       server is listening on.  If the port field is absent from the URL, then  
....................       this parameter will specify the default port for the protocol.  For  
....................       example, "http://www.microchip.com" would result in 80 being return as  
....................       the specified port. 
....................         
....................       <p>If the wPort pointer is NULL, then the port field in the URL  
....................       is ignored, if present. 
....................        
....................    vFilePath - Optional pointer to a buffer to write the decoded file path  
....................       portion of the URL.  If a NULL pointer is supplied, then this field is  
....................       ignored.  If a file path is not present in the URL, then "/" will be  
....................       returned in this field.   
....................  
....................       <p>For the example URL provided in the function description,  
....................       "/myfile.gif" would be returned for this field. 
....................        
....................    wFilePathLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vFilePath buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wFilePathLen and vFilePath are non-NULL, the  
....................       *wFilePathLen WORD is updated with the actual number of characters  
....................       written to the vFilePath buffer, including the null terminator  
....................       character.  If vFilePath is NULL but wFilePathLen is non-NULL, then no  
....................       characters are copied, but *wFilePathLen will return the number of  
....................       characters required to fit the full file path string.  If wFilePathLen  
....................       is NULL, then the file path field in the URL, if present, is ignored and  
....................       the vFilePath pointer is not used. 
....................        
....................       <p>This function always returns "/" if no file path is present, so 
....................       *wFilePathLen will also be at least 2 characters ('/' and null  
....................       terminator) if the pointer is non-NULL. 
....................     
....................       <p>For the example URL provided in the function description, 12 (0x000C)  
....................       would be returned for this field. 
....................        
....................   Returns: 
....................    Zero on success.  Nonzero indicates an error code.  If a nonzero error code  
....................    is returned, none of the returned buffers or pointer values should be  
....................    treated as valid, but some of them may have been written to.  The following  
....................    are all possible return values. 
....................    <table> 
....................       0   No error 
....................       1   Protocol unknown (additional code needs to be added to  
....................           ExtractURLFields() and the PROTOCOLS enum needs to be updated if  
....................           you want to decode URLs of this protocol type. 
....................       2   URL malformed. Illegal or unknown URL format encountered. 
....................       3   Buffer too small.  One of the input buffer sizes is too small to  
....................           contain the URL parameter. 
....................    </table> 
....................   ***************************************************************************/ 
.................... #if 0    
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen) 
.................... { 
....................    // These two arrays must exactly match up each other and the PROTOCOLS enum  
....................    // elements.  The protocol name strings must also be specified in all  
....................    // lowercase. 
....................    static ROM char * ROM   vProtocolNames[] = {"http", "https", "mms", "rtsp"}; 
....................    static ROM WORD       wProtocolPorts[] = { 80,     443,     1755,  554}; 
....................    WORD w, w2; 
....................    BYTE i, j; 
....................    PROTOCOLS prot; 
....................    BYTE *temp, *temp2; 
....................    WORD wURLLen; 
....................    WORD wLocalPort; 
....................     
....................     
....................    // Calculate how long this URL is 
....................    wURLLen = strlen((char*)vURL); 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\r'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\n'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................     
....................  
....................    // Parse starting protocol field 
....................    // Find out how long the protocol name field is 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    if(temp == NULL) 
....................       return 2; 
....................     
....................    // Search protocol list to see if this is a recognized protocol 
....................    for(prot = 0; (BYTE)prot < sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]); prot++) 
....................    { 
....................       w = strlenpgm(vProtocolNames[prot]); 
....................       if((WORD)(temp - vURL) == w) 
....................       { 
....................          w2 = 0; 
....................          temp2 = vURL; 
....................          while(w) 
....................          { 
....................             i = *temp2++; 
....................             if((i >= 'A') && (i <= 'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != (BYTE)vProtocolNames[prot][w2++]) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w == 0u) 
....................          { 
....................             if(protocol) 
....................                *protocol = prot; 
....................             break; 
....................          } 
....................       } 
....................    } 
....................  
....................    // If we've search the whole list and didn't find a match, then  
....................    // this protocol is unknown and this URL cannot be parsed. 
....................    if((BYTE)prot >= sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0])) 
....................       return 1; 
....................     
....................    w = temp - vURL + 1; 
....................    vURL += w; 
....................    wURLLen -= w; 
....................  
....................    // Protocols using the authority field all must have a double  
....................    // slash "//" prefix 
....................    if(wURLLen < 2u) 
....................       return 2; 
....................    for(j = 0; j < 2u; j++) 
....................    { 
....................       i = *vURL++; 
....................       if(i != '/') 
....................          return 2; 
....................    } 
....................    wURLLen -= 2; 
....................     
....................  
....................    // Parse username and password fields 
....................    // See if there is a @ sign, indicating that there is at  
....................    // least a username and possibly a password in this URL 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '@'); 
....................    if(temp == NULL) 
....................    { 
....................       if(wUsernameLen) 
....................          *wUsernameLen = 0; 
....................       if(wPasswordLen) 
....................          *wPasswordLen = 0; 
....................    } 
....................    else 
....................    { 
....................       // If we get down here, there is a user name present, let's  
....................       // see if a password is also present by searching for a  
....................       // colon between the current string position and the @  
....................       // symbol. 
....................       temp2 = (BYTE*)strnchr((char*)vURL, temp - vURL, ':'); 
....................        
....................       // Calculate username length and password length, including  
....................       // null terminator (if the field exists) 
....................       if(temp2 == NULL) 
....................       { 
....................          w = temp - vURL + 1;   // Username 
....................          w2 = 0;               // Password 
....................       } 
....................       else 
....................       { 
....................          w = temp2 - vURL + 1;   // Username 
....................          w2 = temp - temp2;      // Password 
....................       } 
....................        
....................       if(wUsernameLen) 
....................       { 
....................          if(vUsername) 
....................          { 
....................             if(*wUsernameLen < w) 
....................                return 3; 
....................             memcpy((void*)vUsername, (void*)vURL, w - 1); 
....................             vUsername[w-1] = 0; 
....................          } 
....................          *wUsernameLen = w; 
....................       } 
....................     
....................       if(wPasswordLen) 
....................       { 
....................          if(vPassword) 
....................          { 
....................             if(*wPasswordLen < w2) 
....................                return 3; 
....................             if(w2) 
....................             { 
....................                memcpy((void*)vPassword, (void*)temp2+1, w2 - 1); 
....................                vPassword[w2-1] = 0; 
....................             } 
....................          } 
....................          *wPasswordLen = w2; 
....................       } 
....................     
....................       vURL += w; 
....................       wURLLen -= w; 
....................       if(w2) 
....................       { 
....................          vURL += w2; 
....................          wURLLen -= w2; 
....................       } 
....................    } 
....................  
....................  
....................    // Parse hostname field 
....................    // Find the length of the hostname, including NULL  
....................    // terminator 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    temp2 = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................    if(temp && temp2) 
....................    { 
....................       if(temp > temp2) 
....................          temp = NULL; 
....................    } 
....................    if(temp == NULL) 
....................    { 
....................       temp = temp2; 
....................       if(temp2 == NULL) 
....................          temp = vURL + wURLLen; 
....................    } 
....................    w = temp - vURL + 1; 
....................    if(wHostnameLen) 
....................    { 
....................       if(vHostname) 
....................       { 
....................          if(*wHostnameLen < w) 
....................             return 3; 
....................          memcpy((void*)vHostname, (void*)vURL, w - 1); 
....................          vHostname[w-1] = 0; 
....................       } 
....................       *wHostnameLen = w; 
....................    } 
....................    vURL += w - 1; 
....................    wURLLen -= w - 1; 
....................  
....................  
....................    // Parse port field 
....................    if(*vURL == ':') 
....................    { 
....................       vURL++; 
....................       wURLLen--; 
....................       wLocalPort = 0; 
....................       w = wURLLen; 
....................       temp = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................       if(temp != NULL) 
....................          w = temp - vURL; 
....................       w2 = w; 
....................       if(wPort) 
....................       { 
....................          while(w--) 
....................          { 
....................             wLocalPort *= 10; 
....................             wLocalPort += *vURL++ - '0'; 
....................          } 
....................          *wPort = wLocalPort; 
....................       } 
....................       else 
....................          vURL += w2; 
....................       wURLLen -= w2; 
....................    } 
....................    else if(wPort) 
....................       *wPort = wProtocolPorts[prot]; 
....................  
....................  
....................    // Parse file path field 
....................    if(wFilePathLen) 
....................    { 
....................       w = ++wURLLen; 
....................       if(wURLLen == 1u) 
....................          w = 2; 
....................       if(vFilePath) 
....................       { 
....................          if(*wFilePathLen < w) 
....................             return 3; 
....................          if(wURLLen == 1u) 
....................             vFilePath[0] = '/'; 
....................          else 
....................             memcpy((void*)vFilePath, (void*)vURL, wURLLen - 1); 
....................          vFilePath[w - 1] = 0; 
....................          *wFilePathLen = w; 
....................          return 0; 
....................       } 
....................       *wFilePathLen = w; 
....................    } 
....................    return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement,  
....................               WORD wMaxLen, BOOL bSearchCaseInsensitive) 
....................  
....................   Summary: 
....................    Replaces all instances of a particular substring with a new string 
....................  
....................   Description: 
....................    Searches a string (vExpression) and replaces all instances of a particular  
....................    substring (vFind) with a new string (vReplacement).  The start offset to  
....................    being searching and a maximum number of replacements can be specified.  The  
....................    search can be performed in a case sensitive or case insensitive manner. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vExpression - Null terminated string to search and make replacements within. 
....................    vFind - Null terminated string to search for. 
....................    vReplacement - Null terminated string to replace all instances of vFind with. 
....................    wMaxLen - Maximum length of the output vExpression string if string  
....................       expansion is going to occur (replacement length is longer than find  
....................       length).  If the replacements will cause this maximum string length to  
....................       be exceeded, then no replacements will be made and a negative result  
....................       will be returned, indicating failure.  If the replacement length is  
....................       shorter or equal to the search length, then this parameter is ignored. 
....................    bSearchCaseInsensitive - Boolean indicating if the search should be  
....................       performed in a case insensitive manner.  Specify TRUE for case  
....................       insensitive searches (slower) or FALSE for case sensitive  
....................       searching (faster). 
....................  
....................   Remarks: 
....................    If the replacement string length is shorter than or equal to the search  
....................    string length and the search string occurs in multiple overlapping  
....................    locations (ex\: expression is "aaa", find is "aa", and replacement is "bb")  
....................    then the first find match occuring when searching from left to right will  
....................    be replaced.  (ex\: output expression will be "bba"). 
....................     
....................    However, if the replacement string length is longer than the search string  
....................    length, the search will occur starting from the end of the string and  
....................    proceed to the beginning (right to left searching).  In this case if the  
....................    expression was "aaa", find was "aa", and replacement was "bbb", then the  
....................    final output expression will be "abbb".   
....................  
....................   Returns: 
....................    If zero or greater, indicates the count of how many replacements were made.   
....................    If less than zero (negative result), indicates that wMaxLen was too small  
....................    to make the necessary replacements.  In this case, no replacements were  
....................    made. 
....................   ***************************************************************************/ 
.................... #if 0 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive) 
.................... { 
....................    WORD wExpressionLen, wFindLen, wFindLenMinusOne, wReplacementLen; 
....................    WORD wFindCount, wReplacementsLeft; 
....................    BYTE i, j; 
....................    BYTE vFirstFindChar; 
....................    WORD wBytesLeft; 
....................    BYTE *vDest; 
....................    BYTE *vExpressionCompare; 
....................    ROM BYTE *vFindCompare; 
....................    WORD w; 
....................  
....................    wFindLen = strlenpgm((ROM char*)vFind); 
....................    if(wFindLen == 0u) 
....................       return 0; 
....................     
....................    wExpressionLen = strlen((char*)vExpression); 
....................    wReplacementLen = strlenpgm((ROM char*)vReplacement); 
....................  
....................    wFindCount = 0; 
....................    wFindLenMinusOne = wFindLen - 1; 
....................    vFirstFindChar = *vFind++; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................  
....................    // If the replacement string is the same length as the search string, then  
....................    // we can immediately do the needed replacements inline and return. 
....................    if(wFindLen == wReplacementLen) 
....................    { 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vExpression-1, (ROM void*)vReplacement, wReplacementLen); 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       return wFindCount; 
....................    } 
....................     
....................     
....................    // If the replacement string is shorter than the search string, then we can  
....................    // search from left to right and move the string over as we find occurrences. 
....................    if(wFindLen > wReplacementLen) 
....................    { 
....................       vDest = vExpression; 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          *vDest++ = i; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vDest-1, (ROM void*)vReplacement, wReplacementLen); 
....................          vDest += wReplacementLen-1; 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       *vDest = 0x00;   // Write new null terminator since the string may have shrunk 
....................       return wFindCount; 
....................    } 
....................     
....................    // If the replacement string is longer than the search string, then we will  
....................    // take a two pass approach.  On the first pass, we will merely count how  
....................    // many replacements to make.  With this we can calculate how long the  
....................    // final string is going to be.  On the second pass, we will search from  
....................    // right to left and expand the string as needed. 
....................  
....................    // Pass 1: count how many occurrences of vFind are in vExpression 
....................    for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................    { 
....................       i = *vExpression++; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = vFind; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare++; 
....................             j = *vFindCompare++; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................  
....................       wFindCount++; 
....................       vExpression += wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................    } 
....................     
....................    // Return immediately if no replacements are needed 
....................    if(wFindCount == 0u) 
....................       return 0; 
....................  
....................    // Pass 2: make replacements and move string over 
....................    vDest = vExpression + wFindCount * (wReplacementLen - wFindLen); 
....................    if(vDest > vExpression - wExpressionLen + wMaxLen) 
....................       return -1; 
....................    *vDest-- = 0x00;   // Write new null terminator 
....................    vExpression -= 1; 
....................    vFind -= 1; 
....................    vFirstFindChar = vFind[wFindLenMinusOne]; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................    wReplacementsLeft = wFindCount; 
....................    while(wReplacementsLeft) 
....................    { 
....................       i = *vExpression--; 
....................       *vDest-- = i; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = &vFind[wFindLenMinusOne-1]; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare--; 
....................             j = *vFindCompare--; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression-wFindLenMinusOne, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................       memcpypgm2ram((void*)vDest-wReplacementLen+2, (ROM void*)vReplacement, wReplacementLen); 
....................       vDest -= wReplacementLen-1; 
....................  
....................       vExpression -= wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................       wReplacementsLeft--; 
....................    } 
....................    return wFindCount; 
.................... } 
.................... #endif 
....................  
.................... //#include "Delay.c" //not needed, we overrode this in StackTsk2.h 
.................... #include "Tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for Timekeeping 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    Timer 0 (PIC18) or Timer 1 (PIC24F, PIC24H,  
....................  *					dsPIC30F, dsPIC33F, PIC32) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10b or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		6/13/07		Changed to use timer without  
....................  *									writing for perfect accuracy. 
.................... ********************************************************************/ 
.................... #define __TICK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // Internal counter to store Ticks.  This variable is incremented in an ISR and  
.................... // therefore must be marked volatile to prevent the compiler optimizer from  
.................... // reordering code to use this value in the main context while interrupts are  
.................... // disabled. 
.................... static volatile DWORD dwInternalTicks = 0; 
....................  
.................... // 6-byte value to store Ticks.  Allows for use over longer periods of time. 
.................... static BYTE vTickReading[6]; 
....................  
.................... static void GetTickCopy(void); 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickInit(void) 
....................  
....................   Summary: 
.................... 	Initializes the Tick manager module. 
....................  
....................   Description: 
.................... 	Configures the Tick module and any necessary hardware resources. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   	 
....................   Remarks: 
.................... 	This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TickInit(void) 
.................... { 
.................... #if defined(__18CXX) 
.................... 	// Use Timer0 for 8 bit processors 
....................     // Initialize the time 
....................     TMR0H = 0; 
*
00300:  CLRF   FD7
....................     TMR0L = 0; 
00302:  CLRF   FD6
....................  
.................... 	// Set up the timer interrupt 
.................... 	INTCON2bits.TMR0IP = 0;		// Low priority 
00304:  BCF    FF1.2
....................     INTCONbits.TMR0IF = 0; 
00306:  BCF    FF2.2
....................     INTCONbits.TMR0IE = 1;		// Enable interrupt 
00308:  BSF    FF2.5
....................  
....................     // Timer0 on, 16-bit, internal timer, 1:256 prescalar 
....................     T0CON = 0x87; 
0030A:  MOVLW  87
0030C:  MOVWF  FD5
....................  
.................... #else 
0030E:  GOTO   B070 (RETURN)
.................... 	// Use Timer 1 for 16-bit and 32-bit processors 
.................... 	// 1:256 prescale 
.................... 	T1CONbits.TCKPS = 3; 
.................... 	// Base 
.................... 	PR1 = 0xFFFF; 
.................... 	// Clear counter 
.................... 	TMR1 = 0; 
....................  
.................... 	// Enable timer interrupt 
.................... 	#if defined(__C30__) 
.................... 		IPC0bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0bits.T1IF = 0; 
.................... 		IEC0bits.T1IE = 1; 
.................... 	#else 
.................... 		IPC1bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0CLR = _IFS0_T1IF_MASK; 
.................... 		IEC0SET = _IEC0_T1IE_MASK; 
.................... 	#endif 
....................  
.................... 	// Start timer 
.................... 	T1CONbits.TON = 1; 
.................... #endif 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void GetTickCopy(void) 
....................  
....................   Summary: 
.................... 	Reads the tick value. 
....................  
....................   Description: 
.................... 	This function performs an interrupt-safe and synchronized read of the  
.................... 	48-bit Tick value. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... static void GetTickCopy(void) 
.................... { 
.................... 	// Perform an Interrupt safe and synchronized read of the 48-bit  
.................... 	// tick value 
.................... #if defined(__18CXX) 
.................... 	do 
.................... 	{ 
.................... 		INTCONbits.TMR0IE = 1;		// Enable interrupt 
*
023C2:  BSF    FF2.5
.................... 		Nop(); 
023C4:  NOP   
.................... 		INTCONbits.TMR0IE = 0;		// Disable interrupt 
023C6:  BCF    FF2.5
.................... 		vTickReading[0] = TMR0L; 
023C8:  MOVFF  FD6,11F
.................... 		vTickReading[1] = TMR0H; 
023CC:  MOVFF  FD7,120
.................... 		*((DWORD*)&vTickReading[2]) = dwInternalTicks; 
023D0:  MOVLW  01
023D2:  MOVLB  6
023D4:  MOVWF  x34
023D6:  MOVLW  21
023D8:  MOVWF  FE9
023DA:  MOVFF  634,FEA
023DE:  MOVFF  11B,FEF
023E2:  MOVFF  11C,FEC
023E6:  MOVFF  11D,FEC
023EA:  MOVFF  11E,FEC
.................... 	} while(INTCONbits.TMR0IF); 
023EE:  BTFSS  FF2.2
023F0:  BRA    23F6
023F2:  MOVLB  0
023F4:  BRA    23C2
.................... 	INTCONbits.TMR0IE = 1;			// Enable interrupt 
023F6:  BSF    FF2.5
.................... #elif defined(__C30__) 
023F8:  MOVLB  0
023FA:  RETURN 0
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0bits.T1IE = 1;			// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0bits.T1IE = 0;			// Disable interrupt 
....................  
.................... 		// Get low 2 bytes 
.................... 		((WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
.................... 		if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 			dwTempTicks--; 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0bits.T1IE = 1;				// Enable interrupt 
.................... #else	// PIC32 
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0SET = _IEC0_T1IE_MASK;	// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0CLR = _IEC0_T1IE_MASK;	// Disable interrupt 
.................... 		 
.................... 		// Get low 2 bytes 
.................... 		((volatile WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
....................  
.................... 		// PIC32MX3XX/4XX devices trigger the timer interrupt when TMR1 == PR1  
.................... 		// (TMR1 prescalar is 0x00), requiring us to undo the ISR's increment  
.................... 		// of the upper 32 bits of our 48 bit timer in the special case when  
.................... 		// TMR1 == PR1 == 0xFFFF.  For other PIC32 families, the ISR is  
.................... 		// triggered when TMR1 increments from PR1 to 0x0000, making no special  
.................... 		// corner case. 
.................... 		#if __PIC32_FEATURE_SET__ <= 460 
.................... 			if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 				dwTempTicks--; 
.................... 		#elif !defined(__PIC32_FEATURE_SET__) 
.................... 			#error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version. 
.................... 		#endif 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0SET = _IEC0_T1IE_MASK;		// Enable interrupt 
.................... #endif 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGet(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the least significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	microseconds to a few hours.  Use TickGetDiv256 or TickGetDiv64K for 
.................... 	longer periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Lower 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGet(void) 
.................... { 
.................... 	GetTickCopy(); 
023FC:  RCALL  23C2
.................... 	return *((DWORD*)&vTickReading[0]); 
023FE:  MOVLW  01
02400:  MOVLB  6
02402:  MOVWF  x34
02404:  MOVLW  1F
02406:  MOVFF  634,03
0240A:  MOVWF  FE9
0240C:  MOVFF  634,FEA
02410:  MOVFF  FEF,00
02414:  MOVFF  FEC,01
02418:  MOVFF  FEC,02
0241C:  MOVFF  FEC,03
02420:  MOVLB  0
02422:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv256(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 256. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the middle 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	minutes to a few weeks.  Use TickGet for shorter periods or TickGetDiv64K 
.................... 	for longer ones. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Middle 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv256(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
*
02F9C:  CALL   23C2
.................... 	((BYTE*)&dw)[0] = vTickReading[1];	// Note: This copy must be done one  
02FA0:  MOVFF  120,609
.................... 	((BYTE*)&dw)[1] = vTickReading[2];	// byte at a time to prevent misaligned  
02FA4:  MOVFF  121,60A
.................... 	((BYTE*)&dw)[2] = vTickReading[3];	// memory reads, which will reset the PIC. 
02FA8:  MOVFF  122,60B
.................... 	((BYTE*)&dw)[3] = vTickReading[4]; 
02FAC:  MOVFF  123,60C
.................... 	 
.................... 	return dw; 
02FB0:  MOVFF  609,00
02FB4:  MOVFF  60A,01
02FB8:  MOVFF  60B,02
02FBC:  MOVFF  60C,03
02FC0:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv64K(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 64K. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the most significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	days to a few years, or for absolute time measurements.  Use TickGet or 
.................... 	TickGetDiv256 for shorter periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Upper 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv64K(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
.................... 	((BYTE*)&dw)[0] = vTickReading[2];	// Note: This copy must be done one  
.................... 	((BYTE*)&dw)[1] = vTickReading[3];	// byte at a time to prevent misaligned  
.................... 	((BYTE*)&dw)[2] = vTickReading[4];	// memory reads, which will reset the PIC. 
.................... 	((BYTE*)&dw)[3] = vTickReading[5]; 
.................... 	 
.................... 	return dw; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
....................  
....................   Summary: 
.................... 	Converts a Tick value or difference to milliseconds. 
....................  
....................   Description: 
.................... 	This function converts a Tick value or difference to milliseconds.  For 
.................... 	example, TickConvertToMilliseconds(32768) returns 1000 when a 32.768kHz  
.................... 	clock with no prescaler drives the Tick module interrupt. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	dwTickValue	- Value to convert to milliseconds 
....................  
....................   Returns: 
....................   	Input value expressed in milliseconds. 
....................  
....................   Remarks: 
.................... 	This function performs division on DWORDs, which is slow.  Avoid using 
.................... 	it unless you absolutely must (such as displaying data to a user).  For 
.................... 	timeout comparisons, compare the current value to a multiple or fraction  
.................... 	of TICK_SECOND, which will be calculated only once at compile time. 
....................   ***************************************************************************/ 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
.................... { 
.................... 	return (dwTickValue+(TICKS_PER_SECOND/2000ul))/((DWORD)(TICKS_PER_SECOND/1000ul)); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickUpdate(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... void TickUpdate(void) 
.................... { 
....................     if(INTCONbits.TMR0IF) 
*
00116:  BTFSS  FF2.2
00118:  BRA    012E
....................     { 
.................... 		// Increment internal high tick counter 
.................... 		dwInternalTicks++; 
0011A:  MOVLW  01
0011C:  MOVLB  1
0011E:  ADDWF  x1B,F
00120:  BTFSC  FD8.0
00122:  INCF   x1C,F
00124:  BTFSC  FD8.2
00126:  INCF   x1D,F
00128:  BTFSC  FD8.2
0012A:  INCF   x1E,F
....................  
.................... 		// Reset interrupt flag 
....................         INTCONbits.TMR0IF = 0; 
0012C:  BCF    FF2.2
0012E:  MOVLB  0
....................     } 
00130:  GOTO   0136 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void _ISR _T1Interrupt(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #elif defined(__PIC32MX__) 
.................... void __attribute((interrupt(ipl2), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void) 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0CLR = _IFS0_T1IF_MASK; 
.................... } 
.................... #else 
.................... #if defined(__PCD__)  //__CCS__ __PCH__ __PCD__ ccs added 
.................... #int_timer1 NOCLEAR 
.................... void _T1Interrupt(void) 
.................... #elif __C30_VERSION__ >= 300 
.................... void _ISR __attribute__((__no_auto_psv__)) _T1Interrupt(void) 
.................... #else 
.................... void _ISR _T1Interrupt(void) 
.................... #endif 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0bits.T1IF = 0; 
.................... } 
.................... #endif 
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "ETH97J60.c" 
.................... #elif defined(WF_CS_TRIS) 
....................       #include "WF_Config.c" 
....................       #if defined(WF_USE_SCAN_FUNCTIONS) 
....................          #include "WFScan.c" 
....................       #endif 
....................       #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................          #include "WFPowerSave.c" 
....................       #else 
....................          BOOL GetAppPowerSaveMode(void) {return(TRUE);} 
....................       #endif 
....................       #if defined(WF_USE_TX_POWER_CONTROL_FUNCTIONS) 
....................          #include "WFTxPower.c" 
....................       #endif 
....................       #include "WF_Spi.c" 
....................       #include "WF_Eint.c" 
....................       #include "WFConnectionProfile.c" 
....................       #include "WFConnectionAlgorithm.c" 
....................       #include "WFConnectionManager.c" 
....................       #include "WFEventHandler.c" 
....................       #include "WFInit.c" 
....................      #if defined(STACK_USE_CCS_SCAN_TASK) 
....................       #include "ccs_wifiscan.c" 
....................      #endif       
....................      #if defined(MRF24WG) 
....................       #include "WFDriverCom_24G.c" 
....................       #include "WFDriverRaw_24G.c" 
....................       #include "WFMac_24G.c" 
....................       #include "WFMgmtMsg_24G.c" 
....................       #include "WFParamMsg_24G.c"      
....................      #else 
....................       #include "WFDriverCom.c" 
....................       #include "WFDriverRaw.c" 
....................       #include "WFMac.c" 
....................       #include "WFMgmtMsg.c" 
....................       #include "WFParamMsg.c" 
....................      #endif 
.................... #elif defined(ENC_CS_TRIS) 
....................    #include "tcpip\ENC28J60.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Medium Access Control (MAC) Layer for Microchip ENC28J60 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides access to ENC28J60 Ethernet controller 
....................  *   -Reference: ENC28J60 Data sheet, IEEE 802.3 Standard 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                  MAC.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  Delay.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     6/28/04 Original 
....................  * Howard Schlunder     10/8/04 Cleanup 
....................  * Howard Schlunder     10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder     11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder     12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder     1/09/06 Added comments and minor mods 
....................  * Howard Schlunder     1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder     6/16/06 Synchronized with PIC18F97J60 code 
....................  * Howard Schlunder     7/17/06 Updated TestMemory() for C30 
....................  * Howard Schlunder     8/07/06 Added SetRXHashTableEntry() function 
.................... ********************************************************************/ 
.................... #define __ENC28J60_C 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATBbits.LATB2 
.................... #define ENC_CS_TRIS      TRISBbits.TRISB2 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATBbits.LATB3 
.................... #define ENC_RST_TRIS     TRISBbits.TRISB3 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // Make sure that this hardware profile has an ENC28J60 in it 
.................... #if defined(ENC_CS_TRIS) 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (ENC_SPI_IF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the ENC_SPI_IF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                  ((a) & 0xFF) 
.................... #define HIGH(a)                 (((a)>>8) & 0xFF) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define WCR (0x2<<5)            // Write Control Register command 
.................... #define BFS (0x4<<5)            // Bit Field Set command 
.................... #define BFC (0x5<<5)            // Bit Field Clear command 
.................... #define RCR (0x0<<5)            // Read Control Register command 
.................... #define RBM ((0x1<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define WBM ((0x3<<5) | 0x1A)   // Write Buffer Memory command 
.................... #define SR  ((0x7<<5) | 0x1F)   // System Reset command does not use an address. 
....................                                 //   It requires 0x1F, however. 
....................  
.................... // Maximum SPI frequency specified in data sheet 
.................... #define ENC_MAX_SPI_FREQ    (20000000ul)    // Hz 
....................  
.................... #define ETHER_IP    (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... #if defined(__CCS__) 
.................... typedef struct  __attribute__((packed)) 
.................... #else 
.................... typedef struct  __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD            NextPacketPointer; 
....................     RXSTATUS        StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
....................  
.................... #if defined (__18CXX) 
....................     #define ClearSPIDoneFlag()  {ENC_SPI_IF = 0;} 
....................     #define WaitForDataByte()   {while(!ENC_SPI_IF); ENC_SPI_IF = 0;} 
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.SSPEN) 
.................... #elif defined(__C30__) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while ((ENC_SPISTATbits.SPITBF == 1) || (ENC_SPISTATbits.SPIRBF == 0)); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPISTATbits.SPIEN) 
.................... #elif defined( __PIC32MX__ ) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while (!ENC_SPISTATbits.SPITBE || !ENC_SPISTATbits.SPIRBF); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.ON) 
.................... #else 
....................     #error Determine SPI flag mechanism 
.................... #endif 
....................  
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... //void Get8KBRAM(void); 
....................  
.................... // Internal MAC level variables and flags. 
.................... static WORD_VAL NextPacketLocation; 
.................... static WORD_VAL CurrentPacketLocation; 
.................... static BOOL WasDiscarded; 
.................... static BYTE ENCRevID; 
....................  
....................  
.................... //NOTE: All code in this module expects Bank 0 to be currently selected.  If code ever changes the bank, it must restore it to Bank 0 before returning. 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *                  registers in the ENC28J60 so that normal operation can 
....................  *                  begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................     BYTE i; 
....................  
....................     // Set up the SPI module on the PIC for communications with the ENC28J60 
....................     ENC_CS_IO = 1; 
*
0077C:  BSF    F8A.2
....................     ENC_CS_TRIS = 0;        // Make the Chip Select pin an output 
0077E:  BCF    F93.2
....................  
.................... #if defined(__18CXX) 
....................     ENC_SCK_TRIS = 0; 
00780:  BCF    F94.3
....................     ENC_SDO_TRIS = 0; 
00782:  BCF    F94.5
....................     ENC_SDI_TRIS = 1; 
00784:  BSF    F94.4
.................... #endif 
....................  
....................     // If the RESET pin is connected, take the chip out of reset 
.................... #if defined(ENC_RST_IO) 
....................     ENC_RST_IO      = 1; 
00786:  BSF    F8A.3
....................     ENC_RST_TRIS    = 0; 
00788:  BCF    F93.3
.................... #endif 
....................  
....................     // Set up SPI 
....................     ClearSPIDoneFlag(); 
0078A:  BCF    F9E.3
.................... #if defined(__18CXX) 
....................     ENC_SPICON1 = 0x20;     // SSPEN bit is set, SPI in master mode, FOSC/4, 
0078C:  MOVLW  20
0078E:  MOVWF  FC6
....................                             //   IDLE state is low level 
....................     ENC_SPISTATbits.CKE = 1;// Transmit data on rising edge of clock 
00790:  BSF    FC7.6
....................     ENC_SPISTATbits.SMP = 0;// Input sampled at middle of data output time 
00792:  BCF    FC7.7
.................... #elif defined(__C30__) 
....................     ENC_SPISTAT = 0;        // clear SPI 
....................     #if defined(__PIC24H__) || defined(__dsPIC33F__) || defined(__dsPIC33E__)|| defined(__PIC24E__) 
....................         ENC_SPICON1 = 0x0F;     // 1:1 primary prescale, 5:1 secondary prescale (8MHz  @ 40MIPS) 
....................     //    ENC_SPICON1 = 0x1E;   // 4:1 primary prescale, 1:1 secondary prescale (10MHz @ 40MIPS, Doesn't work.  CLKRDY is incorrectly reported as being clear.  Problem caused by dsPIC33/PIC24H ES silicon bug.) 
....................     #elif defined(__PIC24F__) || defined(__PIC24FK__) 
....................         ENC_SPICON1 = 0x1B;     // 1:1 primary prescale, 2:1 secondary prescale (8MHz  @ 16MIPS) 
....................     #else   // dsPIC30F 
....................         ENC_SPICON1 = 0x17;     // 1:1 primary prescale, 3:1 secondary prescale (10MHz @ 30MIPS) 
....................     #endif 
....................     ENC_SPICON2 = 0; 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPISTATbits.SPIEN = 1; 
.................... #elif defined(__C32__) 
....................     ENC_SPIBRG = (GetPeripheralClock()-1ul)/2ul/ENC_MAX_SPI_FREQ; 
....................    ENC_SPICON1bits.SMP = 1;   // Delay SDI input sampling (PIC perspective) by 1/2 SPI clock 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPICON1bits.ON = 1; 
.................... #endif 
....................  
....................     // RESET the entire ENC28J60, clearing all registers 
....................     // Also wait for CLKRDY to become set. 
....................     // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................     // means the part is in RESET or there is something wrong with the SPI 
....................     // connection.  This loop makes sure that we can communicate with the 
....................     // ENC28J60 before proceeding. 
....................     do 
....................     { 
....................         SendSystemReset(); 
00794:  BRA    05A2
....................         i = ReadETHReg(ESTAT).Val; 
00796:  MOVLW  1D
00798:  MOVLB  6
0079A:  MOVWF  x53
0079C:  MOVLB  0
0079E:  RCALL  05DA
007A0:  MOVFF  01,5B5
....................     } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
007A4:  MOVLB  5
007A6:  MOVF   xB5,W
007A8:  ANDLW  08
007AA:  MOVWF  00
007AC:  CLRF   03
007AE:  MOVF   00,W
007B0:  IORWF  03,W
007B2:  BTFSC  FD8.2
007B4:  BRA    07BA
007B6:  MOVLB  0
007B8:  BRA    0794
007BA:  MOVF   xB5,W
007BC:  XORLW  FF
007BE:  ANDLW  01
007C0:  MOVWF  00
007C2:  CLRF   03
007C4:  MOVF   00,W
007C6:  IORWF  03,W
007C8:  BTFSC  FD8.2
007CA:  BRA    07D0
007CC:  MOVLB  0
007CE:  BRA    0794
....................  
....................     // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................     // and the buffer write protect pointer (receive buffer read pointer) 
....................     WasDiscarded = TRUE; 
007D0:  MOVLB  1
007D2:  BSF    x12.2
....................     NextPacketLocation.Val = RXSTART; 
007D4:  CLRF   x26
007D6:  CLRF   x25
....................  
....................     WriteReg(ERXSTL, LOW(RXSTART)); 
007D8:  MOVLW  08
007DA:  MOVLB  6
007DC:  MOVWF  x58
007DE:  CLRF   x59
007E0:  MOVLB  0
007E2:  RCALL  0604
....................     WriteReg(ERXSTH, HIGH(RXSTART)); 
007E4:  MOVLW  09
007E6:  MOVLB  6
007E8:  MOVWF  x58
007EA:  CLRF   x59
007EC:  MOVLB  0
007EE:  RCALL  0604
....................     WriteReg(ERXRDPTL, LOW(RXSTOP));    // Write low byte first 
007F0:  MOVLW  0C
007F2:  MOVLB  6
007F4:  MOVWF  x58
007F6:  MOVLW  D5
007F8:  MOVWF  x59
007FA:  MOVLB  0
007FC:  RCALL  0604
....................     WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
007FE:  MOVLW  0D
00800:  MOVLB  6
00802:  MOVWF  x58
00804:  MOVLW  11
00806:  MOVWF  x59
00808:  MOVLB  0
0080A:  RCALL  0604
....................     WriteReg(ERXNDL, LOW(RXSTOP)); 
0080C:  MOVLW  0A
0080E:  MOVLB  6
00810:  MOVWF  x58
00812:  MOVLW  D5
00814:  MOVWF  x59
00816:  MOVLB  0
00818:  RCALL  0604
....................     WriteReg(ERXNDH, HIGH(RXSTOP)); 
0081A:  MOVLW  0B
0081C:  MOVLB  6
0081E:  MOVWF  x58
00820:  MOVLW  11
00822:  MOVWF  x59
00824:  MOVLB  0
00826:  RCALL  0604
....................     WriteReg(ETXSTL, LOW(TXSTART)); 
00828:  MOVLW  04
0082A:  MOVLB  6
0082C:  MOVWF  x58
0082E:  MOVLW  D6
00830:  MOVWF  x59
00832:  MOVLB  0
00834:  RCALL  0604
....................     WriteReg(ETXSTH, HIGH(TXSTART)); 
00836:  MOVLW  05
00838:  MOVLB  6
0083A:  MOVWF  x58
0083C:  MOVLW  11
0083E:  MOVWF  x59
00840:  MOVLB  0
00842:  RCALL  0604
....................  
....................     // Write a permanant per packet control byte of 0x00 
....................     WriteReg(EWRPTL, LOW(TXSTART)); 
00844:  MOVLW  02
00846:  MOVLB  6
00848:  MOVWF  x58
0084A:  MOVLW  D6
0084C:  MOVWF  x59
0084E:  MOVLB  0
00850:  RCALL  0604
....................     WriteReg(EWRPTH, HIGH(TXSTART)); 
00852:  MOVLW  03
00854:  MOVLB  6
00856:  MOVWF  x58
00858:  MOVLW  11
0085A:  MOVWF  x59
0085C:  MOVLB  0
0085E:  RCALL  0604
....................     MACPut(0x00); 
00860:  MOVLB  6
00862:  CLRF   x56
00864:  MOVLB  0
00866:  RCALL  062E
....................  
....................  
....................     // Enter Bank 1 and configure Receive Filters 
....................     // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................     // acceptable) 
....................     // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................  
....................     // Promiscious mode example: 
....................     //BankSel(ERXFCON); 
....................     //WriteReg((BYTE)ERXFCON, ERXFCON_CRCEN); 
....................  
....................     // Enter Bank 2 and configure the MAC 
....................     BankSel(MACON1); 
00868:  MOVLW  02
0086A:  MOVLB  6
0086C:  MOVWF  x38
0086E:  CLRF   x37
00870:  MOVLB  0
00872:  RCALL  067C
....................  
....................     // Enable the receive portion of the MAC 
....................     WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
00874:  MOVLB  6
00876:  CLRF   x58
00878:  MOVLW  0D
0087A:  MOVWF  x59
0087C:  MOVLB  0
0087E:  RCALL  0604
....................  
....................     // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
.................... #if defined(FULL_DUPLEX) 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX); 
....................     WriteReg((BYTE)MABBIPG, 0x15); 
.................... #else 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
00880:  MOVLW  02
00882:  MOVLB  6
00884:  MOVWF  x58
00886:  MOVLW  32
00888:  MOVWF  x59
0088A:  MOVLB  0
0088C:  RCALL  0604
....................     WriteReg((BYTE)MABBIPG, 0x12); 
0088E:  MOVLW  04
00890:  MOVLB  6
00892:  MOVWF  x58
00894:  MOVLW  12
00896:  MOVWF  x59
00898:  MOVLB  0
0089A:  RCALL  0604
.................... #endif 
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
0089C:  MOVLW  03
0089E:  MOVLB  6
008A0:  MOVWF  x58
008A2:  MOVLW  40
008A4:  MOVWF  x59
008A6:  MOVLB  0
008A8:  RCALL  0604
....................  
....................     // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................     // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................     // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
008AA:  MOVLW  09
008AC:  MOVLB  6
008AE:  MOVWF  x58
008B0:  MOVLW  3F
008B2:  MOVWF  x59
008B4:  MOVLB  0
008B6:  RCALL  0604
....................  
....................     // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................     // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................     // later. 
....................     WriteReg((BYTE)MAIPGL, 0x12); 
008B8:  MOVLW  06
008BA:  MOVLB  6
008BC:  MOVWF  x58
008BE:  MOVLW  12
008C0:  MOVWF  x59
008C2:  MOVLB  0
008C4:  RCALL  0604
....................     WriteReg((BYTE)MAIPGH, 0x0C); 
008C6:  MOVLW  07
008C8:  MOVLB  6
008CA:  MOVWF  x58
008CC:  MOVLW  0C
008CE:  MOVWF  x59
008D0:  MOVLB  0
008D2:  RCALL  0604
....................  
....................     // Set the maximum packet size which the controller will accept 
....................     WriteReg((BYTE)MAMXFLL, LOW(6+6+2+1500+4));  // 1518 is the IEEE 802.3 specified limit 
008D4:  MOVLW  0A
008D6:  MOVLB  6
008D8:  MOVWF  x58
008DA:  MOVLW  EE
008DC:  MOVWF  x59
008DE:  MOVLB  0
008E0:  RCALL  0604
....................     WriteReg((BYTE)MAMXFLH, HIGH(6+6+2+1500+4)); // 1518 is the IEEE 802.3 specified limit 
008E2:  MOVLW  0B
008E4:  MOVLB  6
008E6:  MOVWF  x58
008E8:  MOVLW  05
008EA:  MOVWF  x59
008EC:  MOVLB  0
008EE:  RCALL  0604
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................     BankSel(MAADR1); 
008F0:  MOVLW  03
008F2:  MOVLB  6
008F4:  MOVWF  x38
008F6:  MOVLW  04
008F8:  MOVWF  x37
008FA:  MOVLB  0
008FC:  RCALL  067C
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
008FE:  MOVLW  04
00900:  MOVLB  6
00902:  MOVWF  x58
00904:  MOVFF  4C,659
00908:  MOVLB  0
0090A:  RCALL  0604
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0090C:  MOVLW  05
0090E:  MOVLB  6
00910:  MOVWF  x58
00912:  MOVFF  4D,659
00916:  MOVLB  0
00918:  RCALL  0604
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
0091A:  MOVLW  02
0091C:  MOVLB  6
0091E:  MOVWF  x58
00920:  MOVFF  4E,659
00924:  MOVLB  0
00926:  RCALL  0604
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
00928:  MOVLW  03
0092A:  MOVLB  6
0092C:  MOVWF  x58
0092E:  MOVFF  4F,659
00932:  MOVLB  0
00934:  RCALL  0604
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
00936:  MOVLB  6
00938:  CLRF   x58
0093A:  MOVFF  50,659
0093E:  MOVLB  0
00940:  RCALL  0604
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
00942:  MOVLW  01
00944:  MOVLB  6
00946:  MOVWF  x58
00948:  MOVFF  51,659
0094C:  MOVLB  0
0094E:  RCALL  0604
....................  
....................     // Disable the CLKOUT output to reduce EMI generation 
....................     WriteReg((BYTE)ECOCON, 0x00);   // Output off (0V) 
00950:  MOVLW  15
00952:  MOVLB  6
00954:  MOVWF  x58
00956:  CLRF   x59
00958:  MOVLB  0
0095A:  RCALL  0604
....................     //WriteReg((BYTE)ECOCON, 0x01); // 25.000MHz 
....................     //WriteReg((BYTE)ECOCON, 0x03); // 8.3333MHz (*4 with PLL is 33.3333MHz) 
....................  
....................     // Get the Rev ID so that we can implement the correct errata workarounds 
....................     ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
0095C:  MOVLW  12
0095E:  MOVLB  6
00960:  MOVWF  x53
00962:  MOVLB  0
00964:  RCALL  05DA
00966:  MOVFF  01,129
....................  
....................     // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................     // side effect. 
....................     WritePHYReg(PHCON2, PHCON2_HDLDIS); 
0096A:  MOVLW  10
0096C:  MOVLB  5
0096E:  MOVWF  xB6
00970:  MOVLW  01
00972:  MOVWF  xB8
00974:  CLRF   xB7
00976:  MOVLB  0
00978:  RCALL  06E4
....................  
....................     // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................     SetLEDConfig(0x3472); 
0097A:  MOVLW  14
0097C:  MOVLB  5
0097E:  MOVWF  xB6
00980:  MOVLW  34
00982:  MOVWF  xB8
00984:  MOVLW  72
00986:  MOVWF  xB7
00988:  MOVLB  0
0098A:  RCALL  06E4
....................  
....................     // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................     WritePHYReg(PHCON1, PHCON1_PDPXMD); 
.................... #elif defined(HALF_DUPLEX) 
....................     WritePHYReg(PHCON1, 0x0000); 
0098C:  MOVLB  5
0098E:  CLRF   xB6
00990:  CLRF   xB8
00992:  CLRF   xB7
00994:  MOVLB  0
00996:  RCALL  06E4
.................... #else 
....................     // Use the external LEDB polarity to determine weather full or half duplex 
....................     // communication mode should be set. 
....................     { 
....................         REG Register; 
....................         PHYREG PhyReg; 
....................  
....................         // Read the PHY duplex mode 
....................         PhyReg = ReadPHYReg(PHCON1); 
....................         DuplexState = PhyReg.PHCON1bits.PDPXMD; 
....................  
....................         // Set the MAC to the proper duplex mode 
....................         BankSel(MACON3); 
....................         Register = ReadMACReg((BYTE)MACON3); 
....................         Register.MACON3bits.FULDPX = PhyReg.PHCON1bits.PDPXMD; 
....................         WriteReg((BYTE)MACON3, Register.Val); 
....................  
....................         // Set the back-to-back inter-packet gap time to IEEE specified 
....................         // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................         // state, so it must be updated in this function. 
....................         // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................         WriteReg((BYTE)MABBIPG, PhyReg.PHCON1bits.PDPXMD ? 0x15 : 0x12); 
....................     } 
.................... #endif 
....................  
....................     BankSel(ERDPTL);        // Return to default Bank 0 
00998:  MOVLB  6
0099A:  CLRF   x38
0099C:  CLRF   x37
0099E:  MOVLB  0
009A0:  RCALL  067C
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
009A2:  MOVLW  1F
009A4:  MOVLB  6
009A6:  MOVWF  x4D
009A8:  MOVLW  04
009AA:  MOVWF  x4E
009AC:  MOVLB  0
009AE:  RCALL  0652
009B0:  GOTO   1550 (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                        and the link has been up continuously since the last 
....................  *                        call to MACIsLinked() 
....................  *                  FALSE: If the PHY reports no link partner, or the link went 
....................  *                         down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................     // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................     // goes down and comes back up before a higher level stack program calls 
....................     // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................     // call to MACIsLinked() will return TRUE (unless the link goes down 
....................     // again). 
....................     return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
0162C:  MOVLW  01
0162E:  MOVLB  5
01630:  MOVWF  xBF
01632:  MOVLB  0
01634:  BRA    1570
01636:  MOVFF  01,5BF
0163A:  MOVLW  00
0163C:  MOVLB  5
0163E:  BTFSC  01.2
01640:  MOVLW  01
01642:  MOVWF  01
01644:  MOVLB  0
01646:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *                  FALSE: If a previous transmission was started, and it has 
....................  *                         not completed yet.  While FALSE, the data in the 
....................  *                         transmit buffer and the TXST/TXND pointers must not 
....................  *                         be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
017A4:  MOVLW  1F
017A6:  MOVLB  6
017A8:  MOVWF  x53
017AA:  MOVLB  0
017AC:  CALL   05DA
017B0:  MOVFF  01,633
017B4:  MOVLW  00
017B6:  MOVLB  6
017B8:  BTFSC  01.3
017BA:  MOVLW  01
017BC:  XORLW  00
017BE:  BZ    17C4
017C0:  MOVLW  00
017C2:  BRA    17C6
017C4:  MOVLW  01
017C6:  MOVWF  01
017C8:  MOVLB  0
017CA:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *                  MACGetHeader())as being processed and frees the buffer 
....................  *                  memory associated with it 
....................  * 
....................  * Note:            Is is safe to call this function multiple times between 
....................  *                  MACGetHeader() calls.  Extra packets won't be thrown away 
....................  *                  until MACGetHeader() makes it available. 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................     WORD_VAL NewRXRDLocation; 
....................  
....................     // Make sure the current packet was not already discarded 
....................     if(WasDiscarded) 
*
025DA:  MOVLB  1
025DC:  BTFSS  x12.2
025DE:  BRA    25E2
....................         return; 
025E0:  BRA    2640
....................     WasDiscarded = TRUE; 
025E2:  BSF    x12.2
....................  
....................     // Decrement the next packet pointer before writing it into 
....................     // the ERXRDPT registers.  This is a silicon errata workaround. 
....................     // RX buffer wrapping must be taken into account if the 
....................     // NextPacketLocation is precisely RXSTART. 
....................     NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
025E4:  MOVLW  01
025E6:  SUBWF  x25,W
025E8:  MOVLB  5
025EA:  MOVWF  xE9
025EC:  MOVLW  00
025EE:  MOVLB  1
025F0:  SUBWFB x26,W
025F2:  MOVLB  5
025F4:  MOVWF  xEA
....................     if(NewRXRDLocation.Val > RXSTOP) 
025F6:  MOVF   xEA,W
025F8:  SUBLW  10
025FA:  BC    260E
025FC:  XORLW  FF
025FE:  BNZ   2606
02600:  MOVF   xE9,W
02602:  SUBLW  D5
02604:  BC    260E
....................     { 
....................         NewRXRDLocation.Val = RXSTOP; 
02606:  MOVLW  11
02608:  MOVWF  xEA
0260A:  MOVLW  D5
0260C:  MOVWF  xE9
....................     } 
....................  
....................     // Decrement the RX packet counter register, EPKTCNT 
....................     BFSReg(ECON2, ECON2_PKTDEC); 
0260E:  MOVLW  1E
02610:  MOVLB  6
02612:  MOVWF  x4D
02614:  MOVLW  40
02616:  MOVWF  x4E
02618:  MOVLB  0
0261A:  CALL   0652
....................  
....................     // Move the receive read pointer to unwrite-protect the memory used by the 
....................     // last packet.  The writing order is important: set the low byte first, 
....................     // high byte last. 
....................     WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
0261E:  MOVLW  0C
02620:  MOVLB  6
02622:  MOVWF  x58
02624:  MOVFF  5E9,659
02628:  MOVLB  0
0262A:  CALL   0604
....................     WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
0262E:  MOVLW  0D
02630:  MOVLB  6
02632:  MOVWF  x58
02634:  MOVFF  5EA,659
02638:  MOVLB  0
0263A:  CALL   0604
0263E:  MOVLB  1
02640:  MOVLB  0
02642:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *                  the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................     WORD_VAL ReadPT, WritePT; 
....................  
....................     // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................     // received at any time, it can change between reading the low and high 
....................     // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................     // is read. 
....................     BankSel(EPKTCNT); 
*
02FE4:  MOVLW  01
02FE6:  MOVLB  6
02FE8:  MOVWF  x38
02FEA:  MOVLW  19
02FEC:  MOVWF  x37
02FEE:  MOVLB  0
02FF0:  CALL   067C
....................     do { 
....................         // Save EPKTCNT in a temporary location 
....................         ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
02FF4:  MOVLW  19
02FF6:  MOVLB  6
02FF8:  MOVWF  x53
02FFA:  MOVLB  0
02FFC:  CALL   05DA
03000:  MOVFF  01,633
....................  
....................         BankSel(ERXWRPTL); 
03004:  MOVLB  6
03006:  CLRF   x38
03008:  MOVLW  0E
0300A:  MOVWF  x37
0300C:  MOVLB  0
0300E:  CALL   067C
....................         WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
03012:  MOVLW  0E
03014:  MOVLB  6
03016:  MOVWF  x53
03018:  MOVLB  0
0301A:  CALL   05DA
0301E:  MOVFF  01,635
....................         WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
03022:  MOVLW  0F
03024:  MOVLB  6
03026:  MOVWF  x53
03028:  MOVLB  0
0302A:  CALL   05DA
0302E:  MOVFF  01,636
....................  
....................         BankSel(EPKTCNT); 
03032:  MOVLW  01
03034:  MOVLB  6
03036:  MOVWF  x38
03038:  MOVLW  19
0303A:  MOVWF  x37
0303C:  MOVLB  0
0303E:  CALL   067C
....................     } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
03042:  MOVLW  19
03044:  MOVLB  6
03046:  MOVWF  x53
03048:  MOVLB  0
0304A:  CALL   05DA
0304E:  MOVFF  01,637
03052:  MOVLB  6
03054:  MOVF   x33,W
03056:  SUBWF  01,W
03058:  BTFSC  FD8.2
0305A:  BRA    3060
0305C:  MOVLB  0
0305E:  BRA    2FF4
....................  
....................     // Determine where the write protection pointer is 
....................     BankSel(ERXRDPTL); 
03060:  CLRF   x38
03062:  MOVLW  0C
03064:  MOVWF  x37
03066:  MOVLB  0
03068:  CALL   067C
....................     ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
0306C:  MOVLW  0C
0306E:  MOVLB  6
03070:  MOVWF  x53
03072:  MOVLB  0
03074:  CALL   05DA
03078:  MOVFF  01,633
....................     ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
0307C:  MOVLW  0D
0307E:  MOVLB  6
03080:  MOVWF  x53
03082:  MOVLB  0
03084:  CALL   05DA
03088:  MOVFF  01,634
....................  
....................     // Calculate the difference between the pointers, taking care to account 
....................     // for buffer wrapping conditions 
....................     if(WritePT.Val > ReadPT.Val) 
0308C:  MOVLB  6
0308E:  MOVF   x34,W
03090:  SUBWF  x36,W
03092:  BNC   30C0
03094:  BNZ   309C
03096:  MOVF   x35,W
03098:  SUBWF  x33,W
0309A:  BC    30C0
....................     { 
....................         return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
0309C:  MOVF   x33,W
0309E:  SUBWF  x35,W
030A0:  MOVWF  00
030A2:  MOVF   x34,W
030A4:  SUBWFB x36,W
030A6:  MOVWF  03
030A8:  MOVF   00,W
030AA:  XORLW  FF
030AC:  ADDLW  D6
030AE:  MOVWF  00
030B0:  MOVLW  11
030B2:  SUBFWB 03,F
030B4:  MOVFF  00,01
030B8:  MOVFF  03,02
030BC:  BRA    30F6
....................     } 
030BE:  BRA    30F6
....................     else if(WritePT.Val == ReadPT.Val) 
030C0:  MOVF   x33,W
030C2:  SUBWF  x35,W
030C4:  BNZ   30D8
030C6:  MOVF   x34,W
030C8:  SUBWF  x36,W
030CA:  BNZ   30D8
....................     { 
....................         return RXSIZE - 1; 
030CC:  MOVLW  D5
030CE:  MOVWF  01
030D0:  MOVLW  11
030D2:  MOVWF  02
030D4:  BRA    30F6
....................     } 
030D6:  BRA    30F6
....................     else 
....................     { 
....................         return ReadPT.Val - WritePT.Val - 1; 
030D8:  MOVF   x35,W
030DA:  SUBWF  x33,W
030DC:  MOVWF  x37
030DE:  MOVF   x36,W
030E0:  SUBWFB x34,W
030E2:  MOVWF  x38
030E4:  MOVLW  01
030E6:  SUBWF  x37,W
030E8:  MOVWF  00
030EA:  MOVLW  00
030EC:  SUBWFB x38,W
030EE:  MOVWF  03
030F0:  MOVFF  00,01
030F4:  MOVWF  02
....................     } 
030F6:  MOVLB  0
030F8:  GOTO   3A5A (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                           received frame. 
....................  *                  *type: Location of a BYTE to store the constant 
....................  *                         MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                         the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                        remote, and type values are updated. 
....................  *                  FALSE: If a packet was not pending.  remote and type are 
....................  *                         not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *                  been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................     ENC_PREAMBLE header; 
....................     BYTE PacketCount; 
....................  
....................     // Test if at least one packet has been received and is waiting 
....................     BankSel(EPKTCNT); 
*
045E0:  MOVLW  01
045E2:  MOVLB  6
045E4:  MOVWF  x38
045E6:  MOVLW  19
045E8:  MOVWF  x37
045EA:  MOVLB  0
045EC:  CALL   067C
....................     PacketCount = ReadETHReg((BYTE)EPKTCNT).Val; 
045F0:  MOVLW  19
045F2:  MOVLB  6
045F4:  MOVWF  x53
045F6:  MOVLB  0
045F8:  CALL   05DA
045FC:  MOVFF  01,5D6
....................     BankSel(ERDPTL); 
04600:  MOVLB  6
04602:  CLRF   x38
04604:  CLRF   x37
04606:  MOVLB  0
04608:  CALL   067C
....................     if(PacketCount == 0u) 
0460C:  MOVLB  5
0460E:  MOVF   xD6,F
04610:  BNZ   4618
....................         return FALSE; 
04612:  MOVLW  00
04614:  MOVWF  01
04616:  BRA    4730
....................  
....................     // Make absolutely certain that any previous packet was discarded 
....................     if(WasDiscarded == FALSE) 
04618:  MOVLB  1
0461A:  BTFSC  x12.2
0461C:  BRA    462E
....................     { 
....................         MACDiscardRx(); 
0461E:  MOVLB  0
04620:  CALL   25DA
....................         return FALSE; 
04624:  MOVLW  00
04626:  MOVWF  01
04628:  MOVLB  5
0462A:  BRA    4730
0462C:  MOVLB  1
....................     } 
....................  
....................     // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................     CurrentPacketLocation.Val = NextPacketLocation.Val; 
0462E:  MOVFF  126,128
04632:  MOVFF  125,127
....................     WriteReg(ERDPTL, CurrentPacketLocation.v[0]); 
04636:  MOVLB  6
04638:  CLRF   x58
0463A:  MOVFF  127,659
0463E:  MOVLB  0
04640:  CALL   0604
....................     WriteReg(ERDPTH, CurrentPacketLocation.v[1]); 
04644:  MOVLW  01
04646:  MOVLB  6
04648:  MOVWF  x58
0464A:  MOVFF  128,659
0464E:  MOVLB  0
04650:  CALL   0604
....................  
....................     // Obtain the MAC header from the Ethernet buffer 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
04654:  MOVLW  05
04656:  MOVLB  5
04658:  MOVWF  xD8
0465A:  MOVLW  C2
0465C:  MOVWF  xD7
0465E:  MOVFF  5D8,656
04662:  MOVFF  FE8,655
04666:  MOVLB  6
04668:  CLRF   x58
0466A:  MOVLW  14
0466C:  MOVWF  x57
0466E:  MOVLB  0
04670:  CALL   0C28
....................  
....................     // The EtherType field, like most items transmitted on the Ethernet medium 
....................     // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
04674:  MOVFF  5D5,653
04678:  MOVFF  5D4,652
0467C:  CALL   1A42
04680:  MOVFF  02,5D5
04684:  MOVFF  01,5D4
....................  
....................     // Validate the data returned from the ENC28J60.  Random data corruption, 
....................     // such as if a single SPI bit error occurs while communicating or a 
....................     // momentary power glitch could cause this to occur in rare circumstances. 
....................     if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................        header.StatusVector.bits.Zero || 
....................        header.StatusVector.bits.CRCError || 
....................        header.StatusVector.bits.ByteCount > 1518u || 
....................        !header.StatusVector.bits.ReceiveOk) 
04688:  MOVLB  5
0468A:  MOVF   xC3,W
0468C:  SUBLW  10
0468E:  BC    469A
04690:  XORLW  FF
04692:  BNZ   46C6
04694:  MOVF   xC2,W
04696:  SUBLW  D5
04698:  BNC   46C6
0469A:  MOVLW  05
0469C:  MOVWF  xD8
0469E:  MOVLW  C2
046A0:  MOVWF  FE9
046A2:  MOVFF  5D8,FEA
046A6:  BTFSC  FEF.0
046A8:  BRA    46C6
046AA:  BTFSC  xC7.7
046AC:  BRA    46C6
046AE:  BTFSC  xC6.4
046B0:  BRA    46C6
046B2:  MOVF   xC5,W
046B4:  SUBLW  04
046B6:  BC    46C2
046B8:  XORLW  FF
046BA:  BNZ   46C6
046BC:  MOVF   xC4,W
046BE:  SUBLW  EE
046C0:  BNC   46C6
046C2:  BTFSC  xC6.7
046C4:  BRA    46C8
....................     { 
....................         Reset(); 
046C6:  RESET
....................     } 
....................  
....................     // Save the location where the hardware will write the next packet to 
....................     NextPacketLocation.Val = header.NextPacketPointer; 
046C8:  MOVFF  5C3,126
046CC:  MOVFF  5C2,125
....................  
....................     // Return the Ethernet frame's Source MAC address field to the caller 
....................     // This parameter is useful for replying to requests without requiring an 
....................     // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
046D0:  MOVFF  5BF,03
046D4:  MOVFF  5BE,5D7
046D8:  MOVFF  5BF,5D8
046DC:  MOVLW  05
046DE:  MOVWF  xDA
046E0:  MOVLW  CE
046E2:  MOVFF  5BF,FEA
046E6:  MOVFF  5BE,FE9
046EA:  MOVFF  5DA,FE2
046EE:  MOVWF  FE1
046F0:  MOVLW  06
046F2:  MOVWF  01
046F4:  MOVFF  FE6,FEE
046F8:  DECFSZ 01,F
046FA:  BRA    46F4
....................  
....................     // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
046FC:  MOVFF  5C1,03
04700:  MOVFF  5C0,FE9
04704:  MOVFF  03,FEA
04708:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................         ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
0470A:  MOVF   xD5,W
0470C:  SUBLW  08
0470E:  BNZ   4726
04710:  MOVF   xD4,F
04712:  BZ    471A
04714:  MOVF   xD4,W
04716:  SUBLW  06
04718:  BNZ   4726
....................     { 
....................         *type = header.Type.v[0]; 
0471A:  MOVFF  5C0,FE9
0471E:  MOVFF  5C1,FEA
04722:  MOVFF  5D4,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
04726:  MOVLB  1
04728:  BCF    x12.2
....................     return TRUE; 
0472A:  MOVLW  01
0472C:  MOVWF  01
0472E:  MOVLB  5
04730:  MOVLB  0
04732:  GOTO   6CB0 (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                           MAC address (6 bytes) 
....................  *                  type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                        value to write into the Ethernet header's type field. 
....................  *                  dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *                  advantagous to call this function immediately before 
....................  *                  transmitting a packet rather than initially when the 
....................  *                  packet is first created.  The order in which the packet 
....................  *                  is constructed (header first or data first) is not 
....................  *                  important. 
....................  *****************************************************************************/ 
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
.................... { 
....................     // Set the SPI write pointer to the beginning of the transmit buffer (post per packet control byte) 
....................     WriteReg(EWRPTL, LOW(TXSTART+1)); 
*
01C0E:  MOVLW  02
01C10:  MOVLB  6
01C12:  MOVWF  x58
01C14:  MOVLW  D7
01C16:  MOVWF  x59
01C18:  MOVLB  0
01C1A:  CALL   0604
....................     WriteReg(EWRPTH, HIGH(TXSTART+1)); 
01C1E:  MOVLW  03
01C20:  MOVLB  6
01C22:  MOVWF  x58
01C24:  MOVLW  11
01C26:  MOVWF  x59
01C28:  MOVLB  0
01C2A:  CALL   0604
....................  
....................     // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
01C2E:  MOVLW  E4
01C30:  MOVLB  6
01C32:  ADDWF  x53,F
01C34:  MOVLW  11
01C36:  ADDWFC x54,F
....................  
....................     // Write the TXND pointer into the registers, given the dataLen given 
....................     WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
01C38:  MOVLW  06
01C3A:  MOVWF  x56
01C3C:  MOVLW  53
01C3E:  MOVWF  x55
01C40:  MOVWF  FE9
01C42:  MOVFF  656,FEA
01C46:  MOVFF  FEF,659
01C4A:  MOVLW  06
01C4C:  MOVWF  x58
01C4E:  MOVLB  0
01C50:  CALL   0604
....................     WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
01C54:  MOVLW  06
01C56:  MOVLB  6
01C58:  MOVWF  x56
01C5A:  MOVLW  53
01C5C:  MOVWF  x55
01C5E:  MOVLW  01
01C60:  ADDWF  x55,W
01C62:  MOVWF  FE9
01C64:  MOVLW  00
01C66:  ADDWFC x56,W
01C68:  MOVWF  FEA
01C6A:  MOVFF  FEF,659
01C6E:  MOVLW  07
01C70:  MOVWF  x58
01C72:  MOVLB  0
01C74:  CALL   0604
....................  
....................     // Set the per-packet control byte and write the Ethernet destination 
....................     // address 
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
01C78:  MOVFF  651,658
01C7C:  MOVFF  650,657
01C80:  MOVLB  6
01C82:  CLRF   x5A
01C84:  MOVLW  06
01C86:  MOVWF  x59
01C88:  MOVLB  0
01C8A:  CALL   0B7E
....................  
....................     // Write our MAC address in the Ethernet source field 
....................     MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
01C8E:  MOVLB  6
01C90:  CLRF   x56
01C92:  MOVLW  4C
01C94:  MOVWF  x55
01C96:  MOVFF  656,658
01C9A:  MOVWF  x57
01C9C:  CLRF   x5A
01C9E:  MOVLW  06
01CA0:  MOVWF  x59
01CA2:  MOVLB  0
01CA4:  CALL   0B7E
....................  
....................     // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
01CA8:  MOVLW  08
01CAA:  MOVLB  6
01CAC:  MOVWF  x56
01CAE:  MOVLB  0
01CB0:  CALL   062E
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
01CB4:  MOVLB  6
01CB6:  MOVF   x52,F
01CB8:  BNZ   1CBE
01CBA:  MOVLW  00
01CBC:  BRA    1CC0
01CBE:  MOVLW  06
01CC0:  MOVWF  x55
01CC2:  MOVWF  x56
01CC4:  MOVLB  0
01CC6:  CALL   062E
01CCA:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *                  MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *                  the Ethernet medium.  The hardware MAC will take control 
....................  *                  and handle CRC generation, collision retransmission and 
....................  *                  other details. 
....................  * 
....................  * Note:            After transmission completes (MACIsTxReady() returns TRUE), 
....................  *                  the packet can be modified and transmitted again by calling 
....................  *                  MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *                  called (in the TX data area), the data in the TX buffer 
....................  *                  will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
....................     // Reset transmit logic if a TX Error has previously occured 
....................     // This is a silicon errata workaround 
....................     BFSReg(ECON1, ECON1_TXRST); 
*
01DB6:  MOVLW  1F
01DB8:  MOVLB  6
01DBA:  MOVWF  x4D
01DBC:  MOVLW  80
01DBE:  MOVWF  x4E
01DC0:  MOVLB  0
01DC2:  CALL   0652
....................     BFCReg(ECON1, ECON1_TXRST); 
01DC6:  MOVLW  1F
01DC8:  MOVLB  6
01DCA:  MOVWF  x4D
01DCC:  MOVLW  80
01DCE:  MOVWF  x4E
01DD0:  MOVLB  0
01DD2:  CALL   0550
....................     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01DD6:  MOVLW  1C
01DD8:  MOVLB  6
01DDA:  MOVWF  x4D
01DDC:  MOVLW  0A
01DDE:  MOVWF  x4E
01DE0:  MOVLB  0
01DE2:  CALL   0550
....................  
....................     // Start the transmission 
....................     // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................     // can be modified and transmitted again by calling MACFlush() again. 
....................     // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................     // corrupted. 
....................     BFSReg(ECON1, ECON1_TXRTS); 
01DE6:  MOVLW  1F
01DE8:  MOVLB  6
01DEA:  MOVWF  x4D
01DEC:  MOVLW  08
01DEE:  MOVWF  x4E
01DF0:  MOVLB  0
01DF2:  CALL   0652
....................  
....................     // Revision B5 and B7 silicon errata workaround 
....................     if(ENCRevID == 0x05u || ENCRevID == 0x06u) 
01DF6:  MOVLB  1
01DF8:  MOVF   x29,W
01DFA:  SUBLW  05
01DFC:  BZ    1E06
01DFE:  MOVF   x29,W
01E00:  SUBLW  06
01E02:  BTFSS  FD8.2
01E04:  BRA    1FFA
....................     { 
....................         WORD AttemptCounter = 0x0000; 
01E06:  MOVLB  6
01E08:  CLRF   x34
01E0A:  CLRF   x33
....................         while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)) && (++AttemptCounter < 1000u)); 
01E0C:  MOVLW  1C
01E0E:  MOVWF  x53
01E10:  MOVLB  0
01E12:  CALL   05DA
01E16:  MOVFF  01,641
01E1A:  MOVLB  6
01E1C:  MOVF   01,W
01E1E:  ANDLW  0A
01E20:  MOVWF  00
01E22:  CLRF   03
01E24:  MOVF   00,W
01E26:  IORWF  03,W
01E28:  BNZ   1E3E
01E2A:  INCF   x33,F
01E2C:  BTFSC  FD8.2
01E2E:  INCF   x34,F
01E30:  MOVF   x34,W
01E32:  SUBLW  03
01E34:  BNC   1E3E
01E36:  BNZ   1E0C
01E38:  MOVF   x33,W
01E3A:  SUBLW  E7
01E3C:  BC    1E0C
....................         if(ReadETHReg(EIR).EIRbits.TXERIF || (AttemptCounter >= 1000u)) 
01E3E:  MOVLW  1C
01E40:  MOVWF  x53
01E42:  MOVLB  0
01E44:  CALL   05DA
01E48:  MOVFF  01,641
01E4C:  MOVLW  00
01E4E:  MOVLB  6
01E50:  BTFSC  01.1
01E52:  MOVLW  01
01E54:  XORLW  00
01E56:  BNZ   1E6C
01E58:  MOVF   x34,W
01E5A:  SUBLW  02
01E5C:  BTFSC  FD8.0
01E5E:  BRA    1FF8
01E60:  XORLW  FF
01E62:  BNZ   1E6C
01E64:  MOVF   x33,W
01E66:  SUBLW  E7
01E68:  BTFSC  FD8.0
01E6A:  BRA    1FF8
....................         { 
....................             WORD_VAL ReadPtrSave; 
....................             WORD_VAL TXEnd; 
....................             TXSTATUS TXStatus; 
....................             BYTE i; 
....................  
....................             // Cancel the previous transmission if it has become stuck set 
....................             BFCReg(ECON1, ECON1_TXRTS); 
01E6C:  MOVLW  1F
01E6E:  MOVWF  x4D
01E70:  MOVLW  08
01E72:  MOVWF  x4E
01E74:  MOVLB  0
01E76:  CALL   0550
....................  
....................             // Save the current read pointer (controlled by application) 
....................             ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
01E7A:  MOVLB  6
01E7C:  CLRF   x53
01E7E:  MOVLB  0
01E80:  CALL   05DA
01E84:  MOVFF  01,635
....................             ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
01E88:  MOVLW  01
01E8A:  MOVLB  6
01E8C:  MOVWF  x53
01E8E:  MOVLB  0
01E90:  CALL   05DA
01E94:  MOVFF  01,636
....................  
....................             // Get the location of the transmit status vector 
....................             TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
01E98:  MOVLW  06
01E9A:  MOVLB  6
01E9C:  MOVWF  x53
01E9E:  MOVLB  0
01EA0:  CALL   05DA
01EA4:  MOVFF  01,637
....................             TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
01EA8:  MOVLW  07
01EAA:  MOVLB  6
01EAC:  MOVWF  x53
01EAE:  MOVLB  0
01EB0:  CALL   05DA
01EB4:  MOVFF  01,638
....................             TXEnd.Val++; 
01EB8:  MOVLB  6
01EBA:  INCF   x37,F
01EBC:  BTFSC  FD8.2
01EBE:  INCF   x38,F
....................  
....................             // Read the transmit status vector 
....................             WriteReg(ERDPTL, TXEnd.v[0]); 
01EC0:  CLRF   x58
01EC2:  MOVFF  637,659
01EC6:  MOVLB  0
01EC8:  CALL   0604
....................             WriteReg(ERDPTH, TXEnd.v[1]); 
01ECC:  MOVLW  01
01ECE:  MOVLB  6
01ED0:  MOVWF  x58
01ED2:  MOVFF  638,659
01ED6:  MOVLB  0
01ED8:  CALL   0604
....................             MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01EDC:  MOVLW  06
01EDE:  MOVLB  6
01EE0:  MOVWF  x42
01EE2:  MOVLW  39
01EE4:  MOVWF  x41
01EE6:  MOVFF  642,656
01EEA:  MOVWF  x55
01EEC:  CLRF   x58
01EEE:  MOVLW  07
01EF0:  MOVWF  x57
01EF2:  MOVLB  0
01EF4:  CALL   0C28
....................  
....................             // Implement retransmission if a late collision occured (this can 
....................             // happen on B5 when certain link pulses arrive at the same time 
....................             // as the transmission) 
....................             for(i = 0; i < 16u; i++) 
01EF8:  MOVLB  6
01EFA:  CLRF   x40
01EFC:  MOVF   x40,W
01EFE:  SUBLW  0F
01F00:  BNC   1FDA
....................             { 
....................                 if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
01F02:  MOVLW  1C
01F04:  MOVWF  x53
01F06:  MOVLB  0
01F08:  CALL   05DA
01F0C:  MOVFF  01,641
01F10:  MOVLW  00
01F12:  MOVLB  6
01F14:  BTFSC  01.1
01F16:  MOVLW  01
01F18:  XORLW  00
01F1A:  BZ    1FD0
01F1C:  BTFSS  x3C.5
01F1E:  BRA    1FD0
....................                 { 
....................                     // Reset the TX logic 
....................                     BFSReg(ECON1, ECON1_TXRST); 
01F20:  MOVLW  1F
01F22:  MOVWF  x4D
01F24:  MOVLW  80
01F26:  MOVWF  x4E
01F28:  MOVLB  0
01F2A:  CALL   0652
....................                     BFCReg(ECON1, ECON1_TXRST); 
01F2E:  MOVLW  1F
01F30:  MOVLB  6
01F32:  MOVWF  x4D
01F34:  MOVLW  80
01F36:  MOVWF  x4E
01F38:  MOVLB  0
01F3A:  CALL   0550
....................                     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01F3E:  MOVLW  1C
01F40:  MOVLB  6
01F42:  MOVWF  x4D
01F44:  MOVLW  0A
01F46:  MOVWF  x4E
01F48:  MOVLB  0
01F4A:  CALL   0550
....................  
....................                     // Transmit the packet again 
....................                     BFSReg(ECON1, ECON1_TXRTS); 
01F4E:  MOVLW  1F
01F50:  MOVLB  6
01F52:  MOVWF  x4D
01F54:  MOVLW  08
01F56:  MOVWF  x4E
01F58:  MOVLB  0
01F5A:  CALL   0652
....................                     while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01F5E:  MOVLW  1C
01F60:  MOVLB  6
01F62:  MOVWF  x53
01F64:  MOVLB  0
01F66:  CALL   05DA
01F6A:  MOVFF  01,641
01F6E:  MOVLB  6
01F70:  MOVF   01,W
01F72:  ANDLW  0A
01F74:  MOVWF  00
01F76:  CLRF   03
01F78:  MOVF   00,W
01F7A:  IORWF  03,W
01F7C:  BTFSS  FD8.2
01F7E:  BRA    1F84
01F80:  MOVLB  0
01F82:  BRA    1F5E
....................  
....................                     // Cancel the previous transmission if it has become stuck set 
....................                     BFCReg(ECON1, ECON1_TXRTS); 
01F84:  MOVLW  1F
01F86:  MOVWF  x4D
01F88:  MOVLW  08
01F8A:  MOVWF  x4E
01F8C:  MOVLB  0
01F8E:  CALL   0550
....................  
....................                     // Read transmit status vector 
....................                     WriteReg(ERDPTL, TXEnd.v[0]); 
01F92:  MOVLB  6
01F94:  CLRF   x58
01F96:  MOVFF  637,659
01F9A:  MOVLB  0
01F9C:  CALL   0604
....................                     WriteReg(ERDPTH, TXEnd.v[1]); 
01FA0:  MOVLW  01
01FA2:  MOVLB  6
01FA4:  MOVWF  x58
01FA6:  MOVFF  638,659
01FAA:  MOVLB  0
01FAC:  CALL   0604
....................                     MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01FB0:  MOVLW  06
01FB2:  MOVLB  6
01FB4:  MOVWF  x42
01FB6:  MOVLW  39
01FB8:  MOVWF  x41
01FBA:  MOVFF  642,656
01FBE:  MOVWF  x55
01FC0:  CLRF   x58
01FC2:  MOVLW  07
01FC4:  MOVWF  x57
01FC6:  MOVLB  0
01FC8:  CALL   0C28
....................                 } 
01FCC:  BRA    1FD4
01FCE:  MOVLB  6
....................                 else 
....................                 { 
....................                     break; 
01FD0:  BRA    1FDA
01FD2:  MOVLB  0
....................                 } 
01FD4:  MOVLB  6
01FD6:  INCF   x40,F
01FD8:  BRA    1EFC
....................             } 
....................  
....................             // Restore the current read pointer 
....................             WriteReg(ERDPTL, ReadPtrSave.v[0]); 
01FDA:  CLRF   x58
01FDC:  MOVFF  635,659
01FE0:  MOVLB  0
01FE2:  CALL   0604
....................             WriteReg(ERDPTH, ReadPtrSave.v[1]); 
01FE6:  MOVLW  01
01FE8:  MOVLB  6
01FEA:  MOVWF  x58
01FEC:  MOVFF  636,659
01FF0:  MOVLB  0
01FF2:  CALL   0604
01FF6:  MOVLB  6
01FF8:  MOVLB  1
....................         } 
....................     } 
01FFA:  MOVLB  0
01FFC:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetReadPtrInRx(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *                  getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                          header's type field to relocate the SPI read 
....................  *                          pointer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read pointer are updated.  All calls to 
....................  *                  MACGet() and MACGetArray() will use these new values. 
....................  * 
....................  * Note:            RXSTOP must be statically defined as being > RXSTART for 
....................  *                  this function to work correctly.  In other words, do not 
....................  *                  define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *                  boundary. 
....................  *****************************************************************************/ 
.................... void MACSetReadPtrInRx(WORD offset) 
.................... { 
....................     WORD_VAL ReadPT; 
....................  
....................     // Determine the address of the beginning of the entire packet 
....................     // and adjust the address to the desired location 
....................     ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02424:  MOVLW  14
02426:  MOVLB  1
02428:  ADDWF  x27,W
0242A:  MOVLB  6
0242C:  MOVWF  x15
0242E:  MOVLW  00
02430:  MOVLB  1
02432:  ADDWFC x28,W
02434:  MOVLB  6
02436:  MOVWF  x16
02438:  MOVF   x11,W
0243A:  ADDWF  x15,W
0243C:  MOVWF  x13
0243E:  MOVF   x12,W
02440:  ADDWFC x16,W
02442:  MOVWF  x14
....................  
....................     // Since the receive buffer is circular, adjust if a wraparound is needed 
....................     if(ReadPT.Val > RXSTOP) 
02444:  MOVF   x14,W
02446:  SUBLW  10
02448:  BC    245C
0244A:  XORLW  FF
0244C:  BNZ   2454
0244E:  MOVF   x13,W
02450:  SUBLW  D5
02452:  BC    245C
....................         ReadPT.Val -= RXSIZE; 
02454:  MOVLW  D6
02456:  SUBWF  x13,F
02458:  MOVLW  11
0245A:  SUBWFB x14,F
....................  
....................     // Set the SPI read pointer to the new calculated value 
....................     WriteReg(ERDPTL, ReadPT.v[0]); 
0245C:  CLRF   x58
0245E:  MOVFF  613,659
02462:  MOVLB  0
02464:  CALL   0604
....................     WriteReg(ERDPTH, ReadPT.v[1]); 
02468:  MOVLW  01
0246A:  MOVLB  6
0246C:  MOVWF  x58
0246E:  MOVFF  614,659
02472:  MOVLB  0
02474:  CALL   0604
02478:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetWritePtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old EWRPT location 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(EWRPTL).Val; 
*
00B16:  MOVLW  02
00B18:  MOVLB  6
00B1A:  MOVWF  x53
00B1C:  MOVLB  0
00B1E:  RCALL  05DA
00B20:  MOVFF  01,644
....................     oldVal.v[1] = ReadETHReg(EWRPTH).Val; 
00B24:  MOVLW  03
00B26:  MOVLB  6
00B28:  MOVWF  x53
00B2A:  MOVLB  0
00B2C:  RCALL  05DA
00B2E:  MOVFF  01,645
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(EWRPTL, ((WORD_VAL*)&address)->v[0]); 
00B32:  MOVLW  06
00B34:  MOVLB  6
00B36:  MOVWF  x47
00B38:  MOVLW  42
00B3A:  MOVWF  x46
00B3C:  MOVWF  FE9
00B3E:  MOVFF  647,FEA
00B42:  MOVFF  FEF,659
00B46:  MOVLW  02
00B48:  MOVWF  x58
00B4A:  MOVLB  0
00B4C:  RCALL  0604
....................     WriteReg(EWRPTH, ((WORD_VAL*)&address)->v[1]); 
00B4E:  MOVLW  06
00B50:  MOVLB  6
00B52:  MOVWF  x47
00B54:  MOVLW  42
00B56:  MOVWF  x46
00B58:  MOVLW  01
00B5A:  ADDWF  x46,W
00B5C:  MOVWF  FE9
00B5E:  MOVLW  00
00B60:  ADDWFC x47,W
00B62:  MOVWF  FEA
00B64:  MOVFF  FEF,659
00B68:  MOVLW  03
00B6A:  MOVWF  x58
00B6C:  MOVLB  0
00B6E:  RCALL  0604
....................  
....................     return oldVal.Val; 
00B70:  MOVLB  6
00B72:  MOVFF  644,01
00B76:  MOVFF  645,02
00B7A:  MOVLB  0
00B7C:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetReadPtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old ERDPT value 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(ERDPTL).Val; 
*
00BC4:  MOVLB  6
00BC6:  CLRF   x53
00BC8:  MOVLB  0
00BCA:  RCALL  05DA
00BCC:  MOVFF  01,644
....................     oldVal.v[1] = ReadETHReg(ERDPTH).Val; 
00BD0:  MOVLW  01
00BD2:  MOVLB  6
00BD4:  MOVWF  x53
00BD6:  MOVLB  0
00BD8:  RCALL  05DA
00BDA:  MOVFF  01,645
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(ERDPTL, ((WORD_VAL*)&address)->v[0]); 
00BDE:  MOVLW  06
00BE0:  MOVLB  6
00BE2:  MOVWF  x47
00BE4:  MOVLW  42
00BE6:  MOVWF  x46
00BE8:  MOVWF  FE9
00BEA:  MOVFF  647,FEA
00BEE:  MOVFF  FEF,659
00BF2:  CLRF   x58
00BF4:  MOVLB  0
00BF6:  RCALL  0604
....................     WriteReg(ERDPTH, ((WORD_VAL*)&address)->v[1]); 
00BF8:  MOVLW  06
00BFA:  MOVLB  6
00BFC:  MOVWF  x47
00BFE:  MOVLW  42
00C00:  MOVWF  x46
00C02:  MOVLW  01
00C04:  ADDWF  x46,W
00C06:  MOVWF  FE9
00C08:  MOVLW  00
00C0A:  ADDWFC x47,W
00C0C:  MOVWF  FEA
00C0E:  MOVFF  FEF,659
00C12:  MOVLW  01
00C14:  MOVWF  x58
00C16:  MOVLB  0
00C18:  RCALL  0604
....................  
....................     return oldVal.Val; 
00C1A:  MOVLB  6
00C1C:  MOVFF  644,01
00C20:  MOVFF  645,02
00C24:  MOVLB  0
00C26:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset  - Number of bytes beyond the beginning of the 
....................  *                          Ethernet data (first byte after the type field) 
....................  *                          where the checksum should begin 
....................  *                  len     - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................     WORD_VAL temp; 
....................     WORD_VAL RDSave; 
....................  
....................     // Add the offset requested by firmware plus the Ethernet header 
....................     temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
04A1A:  MOVLW  14
04A1C:  MOVLB  1
04A1E:  ADDWF  x27,W
04A20:  MOVLB  5
04A22:  MOVWF  xE4
04A24:  MOVLW  00
04A26:  MOVLB  1
04A28:  ADDWFC x28,W
04A2A:  MOVLB  5
04A2C:  MOVWF  xE5
04A2E:  MOVF   xDC,W
04A30:  ADDWF  xE4,W
04A32:  MOVWF  xE0
04A34:  MOVF   xDD,W
04A36:  ADDWFC xE5,W
04A38:  MOVWF  xE1
....................     if(temp.Val > RXSTOP)       // Adjust value if a wrap is needed 
04A3A:  MOVF   xE1,W
04A3C:  SUBLW  10
04A3E:  BC    4A52
04A40:  XORLW  FF
04A42:  BNZ   4A4A
04A44:  MOVF   xE0,W
04A46:  SUBLW  D5
04A48:  BC    4A52
....................     { 
....................         temp.Val -= RXSIZE; 
04A4A:  MOVLW  D6
04A4C:  SUBWF  xE0,F
04A4E:  MOVLW  11
04A50:  SUBWFB xE1,F
....................     } 
....................  
....................     RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
04A52:  MOVLB  6
04A54:  CLRF   x53
04A56:  MOVLB  0
04A58:  CALL   05DA
04A5C:  MOVFF  01,5E2
....................     RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
04A60:  MOVLW  01
04A62:  MOVLB  6
04A64:  MOVWF  x53
04A66:  MOVLB  0
04A68:  CALL   05DA
04A6C:  MOVFF  01,5E3
....................  
....................     WriteReg(ERDPTL, temp.v[0]); 
04A70:  MOVLB  6
04A72:  CLRF   x58
04A74:  MOVFF  5E0,659
04A78:  MOVLB  0
04A7A:  CALL   0604
....................     WriteReg(ERDPTH, temp.v[1]); 
04A7E:  MOVLW  01
04A80:  MOVLB  6
04A82:  MOVWF  x58
04A84:  MOVFF  5E1,659
04A88:  MOVLB  0
04A8A:  CALL   0604
....................  
....................     temp.Val = CalcIPBufferChecksum(len); 
04A8E:  MOVFF  5DF,634
04A92:  MOVFF  5DE,633
04A96:  CALL   3450
04A9A:  MOVFF  02,5E1
04A9E:  MOVFF  01,5E0
....................  
....................     WriteReg(ERDPTL, RDSave.v[0]); 
04AA2:  MOVLB  6
04AA4:  CLRF   x58
04AA6:  MOVFF  5E2,659
04AAA:  MOVLB  0
04AAC:  CALL   0604
....................     WriteReg(ERDPTH, RDSave.v[1]); 
04AB0:  MOVLW  01
04AB2:  MOVLB  6
04AB4:  MOVWF  x58
04AB6:  MOVFF  5E3,659
04ABA:  MOVLB  0
04ABC:  CALL   0604
....................  
....................     return temp.Val; 
04AC0:  MOVLB  5
04AC2:  MOVFF  5E0,01
04AC6:  MOVFF  5E1,02
04ACA:  MOVLB  0
04ACC:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                       The first byte included in the checksum is the byte 
....................  *                       pointed to by ERDPT, which is updated by calls to 
....................  *                       MACSetReadPtr(), MACGet(), MACGetArray(), 
....................  *                       MACGetHeader(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *                  which can calculate the checksum faster than software, so 
....................  *                  this function replaces the CaclIPBufferChecksum() function 
....................  *                  defined in the helpers.c file.  Through the use of 
....................  *                  preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *                  buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     WORD_VAL Start; 
....................     DWORD_VAL Checksum = {0x00000000ul}; 
*
03450:  MOVLB  6
03452:  CLRF   x37
03454:  CLRF   x38
03456:  CLRF   x39
03458:  CLRF   x3A
....................     WORD ChunkLen; 
....................     WORD DataBuffer[10]; 
....................     WORD *DataPtr; 
....................  
....................     // Save the SPI read pointer starting address 
....................     Start.v[0] = ReadETHReg(ERDPTL).Val; 
0345A:  CLRF   x53
0345C:  MOVLB  0
0345E:  CALL   05DA
03462:  MOVFF  01,635
....................     Start.v[1] = ReadETHReg(ERDPTH).Val; 
03466:  MOVLW  01
03468:  MOVLB  6
0346A:  MOVWF  x53
0346C:  MOVLB  0
0346E:  CALL   05DA
03472:  MOVFF  01,636
....................  
....................     while(len) 
03476:  MOVLB  6
03478:  MOVF   x33,W
0347A:  IORWF  x34,W
0347C:  BZ    352E
....................     { 
....................         // Obtain a chunk of data (less SPI overhead compared 
....................         // to requesting one byte at a time) 
....................         ChunkLen = len > sizeof(DataBuffer) ? sizeof(DataBuffer) : len; 
0347E:  MOVF   x34,F
03480:  BNZ   3488
03482:  MOVF   x33,W
03484:  SUBLW  14
03486:  BC    348E
03488:  CLRF   03
0348A:  MOVLW  14
0348C:  BRA    3494
0348E:  MOVFF  634,03
03492:  MOVF   x33,W
03494:  MOVWF  x3B
03496:  MOVFF  03,63C
....................         MACGetArray((BYTE*)DataBuffer, ChunkLen); 
0349A:  MOVLW  06
0349C:  MOVWF  x54
0349E:  MOVLW  3D
034A0:  MOVWF  x53
034A2:  MOVFF  654,656
034A6:  MOVWF  x55
034A8:  MOVFF  63C,658
034AC:  MOVFF  63B,657
034B0:  MOVLB  0
034B2:  CALL   0C28
....................  
....................         len -= ChunkLen; 
034B6:  MOVLB  6
034B8:  MOVF   x3B,W
034BA:  SUBWF  x33,F
034BC:  MOVF   x3C,W
034BE:  SUBWFB x34,F
....................  
....................         // Take care of a last odd numbered data byte 
....................         if(((WORD_VAL*)&ChunkLen)->bits.b0) 
034C0:  MOVLW  06
034C2:  MOVWF  x54
034C4:  MOVLW  3B
034C6:  MOVWF  FE9
034C8:  MOVFF  654,FEA
034CC:  BTFSS  FEF.0
034CE:  BRA    34E8
....................         { 
....................             ((BYTE*)DataBuffer)[ChunkLen] = 0x00; 
034D0:  MOVLW  06
034D2:  MOVWF  x54
034D4:  MOVLW  3D
034D6:  ADDWF  x3B,W
034D8:  MOVWF  FE9
034DA:  MOVF   x54,W
034DC:  ADDWFC x3C,W
034DE:  MOVWF  FEA
034E0:  CLRF   FEF
....................             ChunkLen++; 
034E2:  INCF   x3B,F
034E4:  BTFSC  FD8.2
034E6:  INCF   x3C,F
....................         } 
....................  
....................         // Calculate the checksum over this chunk 
....................         DataPtr = DataBuffer; 
034E8:  MOVLW  06
034EA:  MOVWF  x52
034EC:  MOVLW  3D
034EE:  MOVWF  x51
....................         while(ChunkLen) 
034F0:  MOVF   x3B,W
034F2:  IORWF  x3C,W
034F4:  BZ    352C
....................         { 
....................             Checksum.Val += *DataPtr++; 
034F6:  MOVFF  652,03
034FA:  MOVFF  651,00
034FE:  MOVLW  02
03500:  ADDWF  x51,F
03502:  BTFSC  FD8.0
03504:  INCF   x52,F
03506:  MOVFF  00,FE9
0350A:  MOVFF  03,FEA
0350E:  MOVFF  FEC,03
03512:  MOVF   FED,F
03514:  MOVF   FEF,W
03516:  ADDWF  x37,F
03518:  MOVF   03,W
0351A:  ADDWFC x38,F
0351C:  MOVLW  00
0351E:  ADDWFC x39,F
03520:  ADDWFC x3A,F
....................             ChunkLen -= 2; 
03522:  MOVLW  02
03524:  SUBWF  x3B,F
03526:  MOVLW  00
03528:  SUBWFB x3C,F
0352A:  BRA    34F0
....................         } 
0352C:  BRA    3478
....................     } 
....................  
....................     // Restore old read pointer location 
....................     WriteReg(ERDPTL, Start.v[0]); 
0352E:  CLRF   x58
03530:  MOVFF  635,659
03534:  MOVLB  0
03536:  CALL   0604
....................     WriteReg(ERDPTH, Start.v[1]); 
0353A:  MOVLW  01
0353C:  MOVLB  6
0353E:  MOVWF  x58
03540:  MOVFF  636,659
03544:  MOVLB  0
03546:  CALL   0604
....................  
....................     // Do an end-around carry (one's complement arrithmatic) 
....................     Checksum.Val = (DWORD)Checksum.w[0] + (DWORD)Checksum.w[1]; 
0354A:  MOVLB  6
0354C:  CLRF   x56
0354E:  CLRF   x55
03550:  MOVFF  638,654
03554:  MOVFF  637,653
03558:  MOVFF  639,00
0355C:  MOVFF  63A,01
03560:  CLRF   02
03562:  CLRF   03
03564:  MOVF   x39,W
03566:  ADDWF  x37,W
03568:  MOVWF  x37
0356A:  MOVF   x3A,W
0356C:  ADDWFC x38,W
0356E:  MOVWF  x38
03570:  MOVF   02,W
03572:  ADDWFC x55,W
03574:  MOVWF  x39
03576:  MOVF   03,W
03578:  ADDWFC x56,W
0357A:  MOVWF  x3A
....................  
....................     // Do another end-around carry in case if the prior add 
....................     // caused a carry out 
....................     Checksum.w[0] += Checksum.w[1]; 
0357C:  MOVF   x39,W
0357E:  ADDWF  x37,F
03580:  MOVF   x3A,W
03582:  ADDWFC x38,F
....................  
....................     // Return the resulting checksum 
....................     return ~Checksum.w[0]; 
03584:  MOVFF  638,03
03588:  COMF   03,F
0358A:  MOVF   x37,W
0358C:  XORLW  FF
0358E:  MOVWF  01
03590:  MOVFF  03,02
03594:  MOVLB  0
03596:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           destAddr:   Destination address in the Ethernet memory to 
....................  *                              copy to.  If (PTR_BASE)-1 is specified, the  
....................  *                        current EWRPT value will be used instead. 
....................  *                  sourceAddr: Source address to read from.  If (PTR_BASE)-1 is 
....................  *                              specified, the current ERDPT value will be used 
....................  *                              instead. 
....................  *                  len:        Number of bytes to copy 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Bytes are asynchrnously transfered within the buffer.  Call 
....................  *                  MACIsMemCopyDone() to see when the transfer is complete. 
....................  * 
....................  * Note:            If a prior transfer is already in progress prior to 
....................  *                  calling this function, this function will block until it 
....................  *                  can start this transfer. 
....................  * 
....................  *                  If (PTR_BASE)-1 is used for the sourceAddr or destAddr 
....................  *                  parameters, then that pointer will get updated with the 
....................  *                  next address after the read or write. 
....................  *****************************************************************************/ 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
*
00CC8:  MOVLB  6
00CCA:  BCF    x4C.0
00CCC:  BCF    x4C.1
.................... { 
....................     WORD_VAL ReadSave, WriteSave; 
....................     BOOL UpdateWritePointer = FALSE; 
....................     BOOL UpdateReadPointer = FALSE; 
....................  
....................     if(destAddr == (PTR_BASE)-1) 
00CCE:  INCFSZ x42,W
00CD0:  BRA    0CF6
00CD2:  INCFSZ x43,W
00CD4:  BRA    0CF6
....................     { 
....................         UpdateWritePointer = TRUE; 
00CD6:  BSF    x4C.0
....................         destAddr = ReadETHReg(EWRPTL).Val; 
00CD8:  MOVLW  02
00CDA:  MOVWF  x53
00CDC:  MOVLB  0
00CDE:  RCALL  05DA
00CE0:  MOVLB  6
00CE2:  CLRF   x43
00CE4:  MOVFF  01,642
....................         ((BYTE*)&destAddr)[1] = ReadETHReg(EWRPTH).Val; 
00CE8:  MOVLW  03
00CEA:  MOVWF  x53
00CEC:  MOVLB  0
00CEE:  RCALL  05DA
00CF0:  MOVFF  01,643
00CF4:  MOVLB  6
....................     } 
....................     if(sourceAddr == (PTR_BASE)-1) 
00CF6:  INCFSZ x44,W
00CF8:  BRA    0D1C
00CFA:  INCFSZ x45,W
00CFC:  BRA    0D1C
....................     { 
....................         UpdateReadPointer = TRUE; 
00CFE:  BSF    x4C.1
....................         sourceAddr = ReadETHReg(ERDPTL).Val; 
00D00:  CLRF   x53
00D02:  MOVLB  0
00D04:  RCALL  05DA
00D06:  MOVLB  6
00D08:  CLRF   x45
00D0A:  MOVFF  01,644
....................         ((BYTE*)&sourceAddr)[1] = ReadETHReg(ERDPTH).Val; 
00D0E:  MOVLW  01
00D10:  MOVWF  x53
00D12:  MOVLB  0
00D14:  RCALL  05DA
00D16:  MOVFF  01,645
00D1A:  MOVLB  6
....................     } 
....................  
....................     // Handle special conditions where len == 0 or len == 1 
....................     // The DMA module is not capable of handling those corner cases 
....................     if(len <= 1u) 
00D1C:  MOVF   x47,F
00D1E:  BTFSS  FD8.2
00D20:  BRA    0E00
00D22:  MOVF   x46,W
00D24:  SUBLW  01
00D26:  BTFSS  FD8.0
00D28:  BRA    0E00
....................     { 
....................         if(!UpdateReadPointer) 
00D2A:  BTFSC  x4C.1
00D2C:  BRA    0D48
....................         { 
....................             ReadSave.v[0] = ReadETHReg(ERDPTL).Val; 
00D2E:  CLRF   x53
00D30:  MOVLB  0
00D32:  RCALL  05DA
00D34:  MOVFF  01,648
....................             ReadSave.v[1] = ReadETHReg(ERDPTH).Val; 
00D38:  MOVLW  01
00D3A:  MOVLB  6
00D3C:  MOVWF  x53
00D3E:  MOVLB  0
00D40:  RCALL  05DA
00D42:  MOVFF  01,649
00D46:  MOVLB  6
....................         } 
....................         if(!UpdateWritePointer) 
00D48:  BTFSC  x4C.0
00D4A:  BRA    0D68
....................         { 
....................             WriteSave.v[0] = ReadETHReg(EWRPTL).Val; 
00D4C:  MOVLW  02
00D4E:  MOVWF  x53
00D50:  MOVLB  0
00D52:  RCALL  05DA
00D54:  MOVFF  01,64A
....................             WriteSave.v[1] = ReadETHReg(EWRPTH).Val; 
00D58:  MOVLW  03
00D5A:  MOVLB  6
00D5C:  MOVWF  x53
00D5E:  MOVLB  0
00D60:  RCALL  05DA
00D62:  MOVFF  01,64B
00D66:  MOVLB  6
....................         } 
....................         WriteReg(ERDPTL, ((BYTE*)&sourceAddr)[0]); 
00D68:  CLRF   x58
00D6A:  MOVFF  644,659
00D6E:  MOVLB  0
00D70:  RCALL  0604
....................         WriteReg(ERDPTH, ((BYTE*)&sourceAddr)[1]); 
00D72:  MOVLW  01
00D74:  MOVLB  6
00D76:  MOVWF  x58
00D78:  MOVFF  645,659
00D7C:  MOVLB  0
00D7E:  RCALL  0604
....................         WriteReg(EWRPTL, ((BYTE*)&destAddr)[0]); 
00D80:  MOVLW  02
00D82:  MOVLB  6
00D84:  MOVWF  x58
00D86:  MOVFF  642,659
00D8A:  MOVLB  0
00D8C:  RCALL  0604
....................         WriteReg(EWRPTH, ((BYTE*)&destAddr)[1]); 
00D8E:  MOVLW  03
00D90:  MOVLB  6
00D92:  MOVWF  x58
00D94:  MOVFF  643,659
00D98:  MOVLB  0
00D9A:  RCALL  0604
....................         while(len--) 
00D9C:  MOVLB  6
00D9E:  MOVFF  647,03
00DA2:  MOVF   x46,W
00DA4:  BTFSC  FD8.2
00DA6:  DECF   x47,F
00DA8:  DECF   x46,F
00DAA:  IORWF  03,W
00DAC:  BZ    0DC0
....................             MACPut(MACGet()); 
00DAE:  MOVLB  0
00DB0:  RCALL  0C9E
00DB2:  MOVFF  01,64D
00DB6:  MOVFF  01,656
00DBA:  RCALL  062E
00DBC:  BRA    0D9C
00DBE:  MOVLB  6
....................         if(!UpdateReadPointer) 
00DC0:  BTFSC  x4C.1
00DC2:  BRA    0DDE
....................         { 
....................             WriteReg(ERDPTL, ReadSave.v[0]); 
00DC4:  CLRF   x58
00DC6:  MOVFF  648,659
00DCA:  MOVLB  0
00DCC:  RCALL  0604
....................             WriteReg(ERDPTH, ReadSave.v[1]); 
00DCE:  MOVLW  01
00DD0:  MOVLB  6
00DD2:  MOVWF  x58
00DD4:  MOVFF  649,659
00DD8:  MOVLB  0
00DDA:  RCALL  0604
00DDC:  MOVLB  6
....................         } 
....................         if(!UpdateWritePointer) 
00DDE:  BTFSC  x4C.0
00DE0:  BRA    0DFE
....................         { 
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
00DE2:  MOVLW  02
00DE4:  MOVWF  x58
00DE6:  MOVFF  64A,659
00DEA:  MOVLB  0
00DEC:  RCALL  0604
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
00DEE:  MOVLW  03
00DF0:  MOVLB  6
00DF2:  MOVWF  x58
00DF4:  MOVFF  64B,659
00DF8:  MOVLB  0
00DFA:  RCALL  0604
00DFC:  MOVLB  6
....................         } 
....................     } 
00DFE:  BRA    0F52
....................     else 
....................     { 
....................         if(UpdateWritePointer) 
00E00:  BTFSS  x4C.0
00E02:  BRA    0E30
....................         { 
....................             WriteSave.Val = destAddr + len; 
00E04:  MOVF   x46,W
00E06:  ADDWF  x42,W
00E08:  MOVWF  x4A
00E0A:  MOVF   x47,W
00E0C:  ADDWFC x43,W
00E0E:  MOVWF  x4B
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
00E10:  MOVLW  02
00E12:  MOVWF  x58
00E14:  MOVFF  64A,659
00E18:  MOVLB  0
00E1A:  CALL   0604
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
00E1E:  MOVLW  03
00E20:  MOVLB  6
00E22:  MOVWF  x58
00E24:  MOVFF  64B,659
00E28:  MOVLB  0
00E2A:  CALL   0604
00E2E:  MOVLB  6
....................         } 
....................         len += sourceAddr - 1; 
00E30:  MOVLW  01
00E32:  SUBWF  x44,W
00E34:  MOVWF  00
00E36:  MOVLW  00
00E38:  SUBWFB x45,W
00E3A:  MOVWF  03
00E3C:  MOVF   00,W
00E3E:  ADDWF  x46,F
00E40:  MOVF   03,W
00E42:  ADDWFC x47,F
....................         while(ReadETHReg(ECON1).ECON1bits.DMAST); 
00E44:  MOVLW  1F
00E46:  MOVWF  x53
00E48:  MOVLB  0
00E4A:  CALL   05DA
00E4E:  MOVFF  01,64D
00E52:  MOVLW  00
00E54:  MOVLB  6
00E56:  BTFSC  01.5
00E58:  MOVLW  01
00E5A:  XORLW  00
00E5C:  BNZ   0E44
....................         WriteReg(EDMASTL, ((BYTE*)&sourceAddr)[0]); 
00E5E:  MOVLW  10
00E60:  MOVWF  x58
00E62:  MOVFF  644,659
00E66:  MOVLB  0
00E68:  CALL   0604
....................         WriteReg(EDMASTH, ((BYTE*)&sourceAddr)[1]); 
00E6C:  MOVLW  11
00E6E:  MOVLB  6
00E70:  MOVWF  x58
00E72:  MOVFF  645,659
00E76:  MOVLB  0
00E78:  CALL   0604
....................         WriteReg(EDMADSTL, ((BYTE*)&destAddr)[0]); 
00E7C:  MOVLW  14
00E7E:  MOVLB  6
00E80:  MOVWF  x58
00E82:  MOVFF  642,659
00E86:  MOVLB  0
00E88:  CALL   0604
....................         WriteReg(EDMADSTH, ((BYTE*)&destAddr)[1]); 
00E8C:  MOVLW  15
00E8E:  MOVLB  6
00E90:  MOVWF  x58
00E92:  MOVFF  643,659
00E96:  MOVLB  0
00E98:  CALL   0604
....................         if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
00E9C:  MOVLB  6
00E9E:  MOVF   x45,W
00EA0:  SUBLW  11
00EA2:  BNC   0EC4
00EA4:  BNZ   0EAC
00EA6:  MOVF   x44,W
00EA8:  SUBLW  D5
00EAA:  BNC   0EC4
00EAC:  MOVF   x47,W
00EAE:  SUBLW  10
00EB0:  BC    0EC4
00EB2:  XORLW  FF
00EB4:  BNZ   0EBC
00EB6:  MOVF   x46,W
00EB8:  SUBLW  D5
00EBA:  BC    0EC4
....................             len -= RXSIZE; 
00EBC:  MOVLW  D6
00EBE:  SUBWF  x46,F
00EC0:  MOVLW  11
00EC2:  SUBWFB x47,F
....................         WriteReg(EDMANDL, ((BYTE*)&len)[0]); 
00EC4:  MOVLW  12
00EC6:  MOVWF  x58
00EC8:  MOVFF  646,659
00ECC:  MOVLB  0
00ECE:  CALL   0604
....................         WriteReg(EDMANDH, ((BYTE*)&len)[1]); 
00ED2:  MOVLW  13
00ED4:  MOVLB  6
00ED6:  MOVWF  x58
00ED8:  MOVFF  647,659
00EDC:  MOVLB  0
00EDE:  CALL   0604
....................         BFCReg(ECON1, ECON1_CSUMEN); 
00EE2:  MOVLW  1F
00EE4:  MOVLB  6
00EE6:  MOVWF  x4D
00EE8:  MOVLW  10
00EEA:  MOVWF  x4E
00EEC:  MOVLB  0
00EEE:  CALL   0550
....................         BFSReg(ECON1, ECON1_DMAST); 
00EF2:  MOVLW  1F
00EF4:  MOVLB  6
00EF6:  MOVWF  x4D
00EF8:  MOVLW  20
00EFA:  MOVWF  x4E
00EFC:  MOVLB  0
00EFE:  CALL   0652
....................         if(UpdateReadPointer) 
00F02:  MOVLB  6
00F04:  BTFSS  x4C.1
00F06:  BRA    0F52
....................         { 
....................             len++; 
00F08:  INCF   x46,F
00F0A:  BTFSC  FD8.2
00F0C:  INCF   x47,F
....................             if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
00F0E:  MOVF   x45,W
00F10:  SUBLW  11
00F12:  BNC   0F34
00F14:  BNZ   0F1C
00F16:  MOVF   x44,W
00F18:  SUBLW  D5
00F1A:  BNC   0F34
00F1C:  MOVF   x47,W
00F1E:  SUBLW  10
00F20:  BC    0F34
00F22:  XORLW  FF
00F24:  BNZ   0F2C
00F26:  MOVF   x46,W
00F28:  SUBLW  D5
00F2A:  BC    0F34
....................                 len -= RXSIZE; 
00F2C:  MOVLW  D6
00F2E:  SUBWF  x46,F
00F30:  MOVLW  11
00F32:  SUBWFB x47,F
....................             WriteReg(ERDPTL, ((BYTE*)&len)[0]); 
00F34:  CLRF   x58
00F36:  MOVFF  646,659
00F3A:  MOVLB  0
00F3C:  CALL   0604
....................             WriteReg(ERDPTH, ((BYTE*)&len)[1]); 
00F40:  MOVLW  01
00F42:  MOVLB  6
00F44:  MOVWF  x58
00F46:  MOVFF  647,659
00F4A:  MOVLB  0
00F4C:  CALL   0604
00F50:  MOVLB  6
....................         } 
....................     } 
00F52:  MOVLB  0
00F54:  RETURN 0
.................... } 
....................  
.................... BOOL MACIsMemCopyDone(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.DMAST; 
00F56:  MOVLW  1F
00F58:  MOVLB  6
00F5A:  MOVWF  x53
00F5C:  MOVLB  0
00F5E:  CALL   05DA
00F62:  MOVFF  01,642
00F66:  MOVLW  00
00F68:  MOVLB  6
00F6A:  BTFSC  01.5
00F6C:  MOVLW  01
00F6E:  XORLW  00
00F70:  BZ    0F76
00F72:  MOVLW  00
00F74:  BRA    0F78
00F76:  MOVLW  01
00F78:  MOVWF  01
00F7A:  MOVLB  0
00F7C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *                  increments ERDPT so MACGet() can be called again.  The 
....................  *                  increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
....................     BYTE Result; 
....................  
....................     ENC_CS_IO = 0; 
*
00C9E:  BCF    F8A.2
....................    ClearSPIDoneFlag(); 
00CA0:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         // Send the opcode and read a byte in two 8-bit operations 
....................         ENC_SSPBUF = RBM; 
00CA2:  MOVLW  3A
00CA4:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/address is transmitted. 
00CA6:  BTFSS  F9E.3
00CA8:  BRA    0CA6
00CAA:  BCF    F9E.3
....................         Result = ENC_SSPBUF; 
00CAC:  MOVFF  FC9,64D
....................  
....................         ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
00CB0:  CLRF   FC9
....................                                 //   contents. 
....................         WaitForDataByte();      // Wait until register is received. 
00CB2:  BTFSS  F9E.3
00CB4:  BRA    0CB2
00CB6:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Result = ENC_SSPBUF; 
00CB8:  MOVFF  FC9,64D
....................     ENC_CS_IO = 1; 
00CBC:  BSF    F8A.2
....................  
....................     return Result; 
00CBE:  MOVLB  6
00CC0:  MOVFF  64D,01
00CC4:  MOVLB  0
00CC6:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *                  len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *                  and places them into local memory.  With SPI burst support, 
....................  *                  it performs much faster than multiple MACGet() calls. 
....................  *                  ERDPT is incremented after each byte, following the same 
....................  *                  rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
....................         if(val) 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................             *val++ = ENC_SSPBUF; 
....................         } 
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................         } 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return len; 
.................... #else 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     // Start the burst operation 
....................     ENC_CS_IO = 0; 
*
00C28:  BCF    F8A.2
....................     ClearSPIDoneFlag(); 
00C2A:  BCF    F9E.3
....................     ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
00C2C:  MOVLW  3A
00C2E:  MOVWF  FC9
....................     i = 0; 
00C30:  MOVLB  6
00C32:  CLRF   x5A
00C34:  CLRF   x59
....................     if(val) 
00C36:  MOVF   x55,W
00C38:  IORWF  x56,W
00C3A:  BZ    0C44
....................         val--; 
00C3C:  MOVF   x55,W
00C3E:  BTFSC  FD8.2
00C40:  DECF   x56,F
00C42:  DECF   x55,F
....................     WaitForDataByte();      // Wait until opcode/address is transmitted. 
00C44:  BTFSS  F9E.3
00C46:  BRA    0C44
00C48:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00C4A:  MOVFF  FC9,65B
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Read the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x00000000;    // Send a dummy DWORD to generate 32 clocks 
....................                 i += 4; 
....................                 WaitForDataByte();         // Wait until DWORD is transmitted 
....................                 dwv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = dwv.v[3]; 
....................                     *(++val) = dwv.v[2]; 
....................                     *(++val) = dwv.v[1]; 
....................                     *(++val) = dwv.v[0]; 
....................                 } 
....................                 if(len - i < 4) 
....................                     break; 
....................             }; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Read the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x0000;    // Send a dummy WORD to generate 32 clocks 
....................                 i += 2; 
....................                 WaitForDataByte();      // Wait until WORD is transmitted 
....................                 wv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = wv.v[1]; 
....................                     *(++val) = wv.v[0]; 
....................                 } 
....................                 if(len - i < 2) 
....................                     break; 
....................             }; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Read the data 
....................     while(i<len) 
00C4E:  MOVF   x5A,W
00C50:  SUBWF  x58,W
00C52:  BNC   0C90
00C54:  BNZ   0C5C
00C56:  MOVF   x57,W
00C58:  SUBWF  x59,W
00C5A:  BC    0C90
....................     { 
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
00C5C:  CLRF   FC9
....................         i++; 
00C5E:  INCF   x59,F
00C60:  BTFSC  FD8.2
00C62:  INCF   x5A,F
....................         if(val) 
00C64:  MOVF   x55,W
00C66:  IORWF  x56,W
00C68:  BZ    0C84
....................         { 
....................             val++; 
00C6A:  INCF   x55,F
00C6C:  BTFSC  FD8.2
00C6E:  INCF   x56,F
....................             WaitForDataByte();  // Wait until byte is received. 
00C70:  BTFSS  F9E.3
00C72:  BRA    0C70
00C74:  BCF    F9E.3
....................             *val = ENC_SSPBUF; 
00C76:  MOVFF  655,FE9
00C7A:  MOVFF  656,FEA
00C7E:  MOVFF  FC9,FEF
....................         } 
00C82:  BRA    0C8E
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
00C84:  BTFSS  F9E.3
00C86:  BRA    0C84
00C88:  BCF    F9E.3
....................             Dummy = ENC_SSPBUF; 
00C8A:  MOVFF  FC9,65B
....................         } 
00C8E:  BRA    0C4E
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
00C90:  BSF    F8A.2
....................  
....................     return i; 
00C92:  MOVFF  659,01
00C96:  MOVFF  65A,02
.................... #endif 
00C9A:  MOVLB  0
00C9C:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *                  (8 bits) and data to write (8 bits) over the SPI. 
....................  *                  EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
0062E:  BCF    F8A.2
....................     ClearSPIDoneFlag(); 
00630:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WBM;       // Send the opcode and constant. 
00632:  MOVLW  7A
00634:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/constant is transmitted. 
00636:  BTFSS  F9E.3
00638:  BRA    0636
0063A:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
0063C:  MOVFF  FC9,657
....................         ENC_SSPBUF = val;       // Send the byte to be writen. 
00640:  MOVFF  656,FC9
....................         WaitForDataByte();      // Wait until finished transmitting 
00644:  BTFSS  F9E.3
00646:  BRA    0644
00648:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
0064A:  MOVFF  FC9,657
....................     ENC_CS_IO = 1; 
0064E:  BSF    F8A.2
00650:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
*
00B7E:  BCF    F8A.2
....................     ClearSPIDoneFlag(); 
00B80:  BCF    F9E.3
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
00B82:  MOVLW  7A
00B84:  MOVWF  FC9
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
00B86:  BTFSS  F9E.3
00B88:  BRA    0B86
00B8A:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00B8C:  MOVFF  FC9,65B
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Send the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             dwv.v[3] = *val++; 
....................             dwv.v[2] = *val++; 
....................             dwv.v[1] = *val++; 
....................             dwv.v[0] = *val++; 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = dwv.Val;       // Start sending the DWORD 
....................                 len -= 4; 
....................                 if(len < 4) 
....................                     break; 
....................                 dwv.v[3] = *val++; 
....................                 dwv.v[2] = *val++; 
....................                 dwv.v[1] = *val++; 
....................                 dwv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until DWORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until DWORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Send the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             wv.v[1] = *val++; 
....................             wv.v[0] = *val++; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = wv.Val;        // Start sending the WORD 
....................                 len -= 2; 
....................                 if(len < 2) 
....................                     break; 
....................                 wv.v[1] = *val++; 
....................                 wv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until WORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until WORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Send the data, one byte at a time 
....................     while(len) 
00B90:  MOVLB  6
00B92:  MOVF   x59,W
00B94:  IORWF  x5A,W
00B96:  BZ    0BBE
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
00B98:  MOVFF  657,FE9
00B9C:  MOVFF  658,FEA
00BA0:  MOVFF  FEF,FC9
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
00BA4:  INCF   x57,F
00BA6:  BTFSC  FD8.2
00BA8:  INCF   x58,F
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
00BAA:  MOVF   x59,W
00BAC:  BTFSC  FD8.2
00BAE:  DECF   x5A,F
00BB0:  DECF   x59,F
....................         WaitForDataByte();  // Wait until byte is transmitted 
00BB2:  BTFSS  F9E.3
00BB4:  BRA    0BB2
00BB6:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
00BB8:  MOVFF  FC9,65B
00BBC:  BRA    0B92
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
00BBE:  BSF    F8A.2
.................... #endif 
00BC0:  MOVLB  0
00BC2:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... #if defined(__18CXX) 
.................... /****************************************************************************** 
....................  * Function:        void MACPutROMArray(ROM BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutROMArray(ROM BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
....................     ClearSPIDoneFlag(); 
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
....................     Dummy = ENC_SSPBUF; 
....................  
....................     // Send the data 
....................     while(len) 
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
....................         WaitForDataByte();  // Wait until byte is transmitted 
....................         Dummy = ENC_SSPBUF; 
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
.................... #endif 
.................... }//end MACPutROMArray 
.................... #endif 
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *                  the Ethernet controller.  It resets all register contents 
....................  *                  (except for ECOCON) and returns the device to the power 
....................  *                  on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     // Note: The power save feature may prevent the reset from executing, so 
....................     // we must make sure that the device is not in power save before issuing 
....................     // a reset. 
....................     BFCReg(ECON2, ECON2_PWRSV); 
*
005A2:  MOVLW  1E
005A4:  MOVLB  6
005A6:  MOVWF  x4D
005A8:  MOVLW  20
005AA:  MOVWF  x4E
005AC:  MOVLB  0
005AE:  RCALL  0550
....................  
....................     // Give some opportunity for the regulator to reach normal regulation and 
....................     // have all clocks running 
....................     DelayMs(1); 
005B0:  MOVLW  01
005B2:  MOVLB  5
005B4:  MOVWF  xB7
005B6:  MOVLB  0
005B8:  RCALL  057A
....................  
....................     // Execute the System Reset command 
....................     ENC_CS_IO = 0; 
005BA:  BCF    F8A.2
....................     ClearSPIDoneFlag(); 
005BC:  BCF    F9E.3
....................     ENC_SSPBUF = SR; 
005BE:  SETF   FC9
....................     WaitForDataByte();      // Wait until the command is transmitted. 
005C0:  BTFSS  F9E.3
005C2:  BRA    05C0
005C4:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
005C6:  MOVFF  FC9,5B6
....................     ENC_CS_IO = 1; 
005CA:  BSF    F8A.2
....................  
....................     // Wait for the oscillator start up timer and PHY to become ready 
....................     DelayMs(1); 
005CC:  MOVLW  01
005CE:  MOVLB  5
005D0:  MOVWF  xB7
005D2:  MOVLB  0
005D4:  RCALL  057A
005D6:  GOTO   0796 (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *                  the SPI and then retrives the register contents in the 
....................  *                  next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *                  registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     // Select the chip and send the Read Control Register opcode/address 
....................     ENC_CS_IO = 0; 
005DA:  BCF    F8A.2
....................     ClearSPIDoneFlag(); 
005DC:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; 
005DE:  MOVLB  6
005E0:  MOVFF  653,FC9
....................  
....................     WaitForDataByte();      // Wait until the opcode/address is transmitted 
005E4:  BTFSS  F9E.3
005E6:  BRA    05E4
005E8:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
005EA:  MOVFF  FC9,654
....................     ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
005EE:  CLRF   FC9
....................                             //   contents 
....................     WaitForDataByte();      // Wait until the register is received 
005F0:  BTFSS  F9E.3
005F2:  BRA    05F0
005F4:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
005F6:  MOVFF  FC9,654
....................     ENC_CS_IO = 1; 
005FA:  BSF    F8A.2
....................  
....................     return r; 
005FC:  MOVFF  654,01
00600:  MOVLB  0
00602:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *                  as a dummy byte over the SPI and then retrives the 
....................  *                  register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *                  registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     ENC_CS_IO = 0; 
*
006AE:  BCF    F8A.2
....................     ClearSPIDoneFlag(); 
006B0:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; // Send the Read Control Register opcode and 
006B2:  MOVLB  5
006B4:  MOVFF  5C2,FC9
....................                                 //   address. 
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
006B8:  BTFSS  F9E.3
006BA:  BRA    06B8
006BC:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
006BE:  MOVFF  FC9,5C3
....................     ENC_SSPBUF = 0;             // Send a dummy byte 
006C2:  CLRF   FC9
....................     WaitForDataByte();          // Wait for the dummy byte to be transmitted 
006C4:  BTFSS  F9E.3
006C6:  BRA    06C4
006C8:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
006CA:  MOVFF  FC9,5C3
....................     ENC_SSPBUF = 0;             // Send another dummy byte to receive the register 
006CE:  CLRF   FC9
....................                                 //   contents. 
....................     WaitForDataByte();          // Wait until register is received. 
006D0:  BTFSS  F9E.3
006D2:  BRA    06D0
006D4:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
006D6:  MOVFF  FC9,5C3
....................     ENC_CS_IO = 1; 
006DA:  BSF    F8A.2
....................  
....................     return r; 
006DC:  MOVFF  5C3,01
006E0:  MOVLB  0
006E2:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time 
....................  *                  (10.24us). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................     PHYREG Result; 
....................  
....................     // Set the right address and start the register read operation 
....................     BankSel(MIREGADR); 
*
01570:  MOVLW  02
01572:  MOVLB  6
01574:  MOVWF  x38
01576:  MOVLW  14
01578:  MOVWF  x37
0157A:  MOVLB  0
0157C:  CALL   067C
....................     WriteReg((BYTE)MIREGADR, Register); 
01580:  MOVLW  14
01582:  MOVLB  6
01584:  MOVWF  x58
01586:  MOVFF  5BF,659
0158A:  MOVLB  0
0158C:  CALL   0604
....................     WriteReg((BYTE)MICMD, MICMD_MIIRD); 
01590:  MOVLW  12
01592:  MOVLB  6
01594:  MOVWF  x58
01596:  MOVLW  01
01598:  MOVWF  x59
0159A:  MOVLB  0
0159C:  CALL   0604
....................  
....................     // Loop to wait until the PHY register has been read through the MII 
....................     // This requires 10.24us 
....................     BankSel(MISTAT); 
015A0:  MOVLW  03
015A2:  MOVLB  6
015A4:  MOVWF  x38
015A6:  MOVLW  0A
015A8:  MOVWF  x37
015AA:  MOVLB  0
015AC:  CALL   067C
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
015B0:  MOVLW  0A
015B2:  MOVLB  5
015B4:  MOVWF  xC2
015B6:  MOVLB  0
015B8:  CALL   06AE
015BC:  MOVFF  01,5C2
015C0:  MOVLW  00
015C2:  MOVLB  5
015C4:  BTFSC  01.0
015C6:  MOVLW  01
015C8:  XORLW  00
015CA:  BTFSC  FD8.2
015CC:  BRA    15D2
015CE:  MOVLB  0
015D0:  BRA    15B0
....................  
....................     // Stop reading 
....................     BankSel(MIREGADR); 
015D2:  MOVLW  02
015D4:  MOVLB  6
015D6:  MOVWF  x38
015D8:  MOVLW  14
015DA:  MOVWF  x37
015DC:  MOVLB  0
015DE:  CALL   067C
....................     WriteReg((BYTE)MICMD, 0x00); 
015E2:  MOVLW  12
015E4:  MOVLB  6
015E6:  MOVWF  x58
015E8:  CLRF   x59
015EA:  MOVLB  0
015EC:  CALL   0604
....................  
....................     // Obtain results and return 
....................     Result.VAL.v[0] = ReadMACReg((BYTE)MIRDL).Val; 
015F0:  MOVLW  18
015F2:  MOVLB  5
015F4:  MOVWF  xC2
015F6:  MOVLB  0
015F8:  CALL   06AE
015FC:  MOVFF  01,5C0
....................     Result.VAL.v[1] = ReadMACReg((BYTE)MIRDH).Val; 
01600:  MOVLW  19
01602:  MOVLB  5
01604:  MOVWF  xC2
01606:  MOVLB  0
01608:  CALL   06AE
0160C:  MOVFF  01,5C1
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
01610:  MOVLB  6
01612:  CLRF   x38
01614:  CLRF   x37
01616:  MOVLB  0
01618:  CALL   067C
....................     return Result; 
0161C:  MOVLB  5
0161E:  MOVFF  5C0,01
01622:  MOVFF  5C1,02
01626:  MOVLB  0
01628:  GOTO   1636 (RETURN)
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                    The top 3 bits must be 0. 
....................  *                  Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *                  SPI and then sends the data to write in the next 8 SPI 
....................  *                  clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *                  BFSReg() functions.  It is seperate to maximize speed. 
....................  *                  Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *                  can write to any ETH or MAC register.  Writing to PHY 
....................  *                  registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
00604:  BCF    F8A.2
....................     ClearSPIDoneFlag(); 
00606:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = ((WCR | Address)<<8) | (WORD)Data; // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WCR | Address; // Send the opcode and address. 
00608:  MOVLB  6
0060A:  MOVF   x58,W
0060C:  IORLW  40
0060E:  MOVWF  FC9
....................         WaitForDataByte();          // Wait until opcode/constant is transmitted. 
00610:  BTFSS  F9E.3
00612:  BRA    0610
00614:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
00616:  MOVFF  FC9,65A
....................         ENC_SSPBUF = Data;          // Send the byte to be writen. 
0061A:  MOVFF  659,FC9
....................         WaitForDataByte();          // Wait until finished transmitting 
0061E:  BTFSS  F9E.3
00620:  BRA    061E
00622:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
00624:  MOVFF  FC9,65A
....................  
....................  
....................    // For faster processors (dsPIC), delay for a few clock cycles to ensure  
....................    // the MAC/MII register write Chip Select hold time minimum of 210ns is met. 
....................    #if (GetInstructionClock() > 30000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 40000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 50000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................  
....................    ENC_CS_IO = 1; 
00628:  BSF    F8A.2
0062A:  MOVLB  0
0062C:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                    to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFSReg() functions.  It is separate to maximize speed. 
....................  *                  BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
00550:  BCF    F8A.2
....................     ClearSPIDoneFlag(); 
00552:  BCF    F9E.3
....................     ENC_SSPBUF = BFC | Address; // Send the opcode and address. 
00554:  MOVLB  6
00556:  MOVF   x4D,W
00558:  IORLW  A0
0055A:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
0055C:  BTFSS  F9E.3
0055E:  BRA    055C
00560:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00562:  MOVFF  FC9,64F
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
00566:  MOVFF  64E,FC9
....................     WaitForDataByte();          // Wait until register is written. 
0056A:  BTFSS  F9E.3
0056C:  BRA    056A
0056E:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00570:  MOVFF  FC9,64F
....................     ENC_CS_IO = 1; 
00574:  BSF    F8A.2
00576:  MOVLB  0
00578:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFCReg() functions.  It is separate to maximize speed. 
....................  *                  BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
00652:  BCF    F8A.2
....................     ClearSPIDoneFlag(); 
00654:  BCF    F9E.3
....................     ENC_SSPBUF = BFS | Address; // Send the opcode and address. 
00656:  MOVLB  6
00658:  MOVF   x4D,W
0065A:  IORLW  80
0065C:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
0065E:  BTFSS  F9E.3
00660:  BRA    065E
00662:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00664:  MOVFF  FC9,64F
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
00668:  MOVFF  64E,FC9
....................     WaitForDataByte();          // Wait until register is written. 
0066C:  BTFSS  F9E.3
0066E:  BRA    066C
00670:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
00672:  MOVFF  FC9,64F
....................     ENC_CS_IO = 1; 
00676:  BSF    F8A.2
00678:  MOVLB  0
0067A:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *                  16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................     // Write the register address 
....................     BankSel(MIREGADR); 
*
006E4:  MOVLW  02
006E6:  MOVLB  6
006E8:  MOVWF  x38
006EA:  MOVLW  14
006EC:  MOVWF  x37
006EE:  MOVLB  0
006F0:  RCALL  067C
....................     WriteReg((BYTE)MIREGADR, Register); 
006F2:  MOVLW  14
006F4:  MOVLB  6
006F6:  MOVWF  x58
006F8:  MOVFF  5B6,659
006FC:  MOVLB  0
006FE:  RCALL  0604
....................  
....................     // Write the data 
....................     // Order is important: write low byte first, high byte last 
....................     WriteReg((BYTE)MIWRL, ((WORD_VAL*)&Data)->v[0]); 
00700:  MOVLW  05
00702:  MOVLB  5
00704:  MOVWF  xBA
00706:  MOVLW  B7
00708:  MOVWF  xB9
0070A:  MOVWF  FE9
0070C:  MOVFF  5BA,FEA
00710:  MOVFF  FEF,659
00714:  MOVLW  16
00716:  MOVLB  6
00718:  MOVWF  x58
0071A:  MOVLB  0
0071C:  RCALL  0604
....................     WriteReg((BYTE)MIWRH, ((WORD_VAL*)&Data)->v[1]); 
0071E:  MOVLW  05
00720:  MOVLB  5
00722:  MOVWF  xBA
00724:  MOVLW  B7
00726:  MOVWF  xB9
00728:  MOVLW  01
0072A:  ADDWF  xB9,W
0072C:  MOVWF  FE9
0072E:  MOVLW  00
00730:  ADDWFC xBA,W
00732:  MOVWF  FEA
00734:  MOVFF  FEF,659
00738:  MOVLW  17
0073A:  MOVLB  6
0073C:  MOVWF  x58
0073E:  MOVLB  0
00740:  RCALL  0604
....................  
....................     // Wait until the PHY register has been written 
....................     BankSel(MISTAT); 
00742:  MOVLW  03
00744:  MOVLB  6
00746:  MOVWF  x38
00748:  MOVLW  0A
0074A:  MOVWF  x37
0074C:  MOVLB  0
0074E:  RCALL  067C
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
00750:  MOVLW  0A
00752:  MOVLB  5
00754:  MOVWF  xC2
00756:  MOVLB  0
00758:  RCALL  06AE
0075A:  MOVFF  01,5B9
0075E:  MOVLW  00
00760:  MOVLB  5
00762:  BTFSC  01.0
00764:  MOVLW  01
00766:  XORLW  00
00768:  BTFSC  FD8.2
0076A:  BRA    0770
0076C:  MOVLB  0
0076E:  BRA    0750
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
00770:  MOVLB  6
00772:  CLRF   x38
00774:  CLRF   x37
00776:  MOVLB  0
00778:  RCALL  067C
0077A:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                    select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *                  changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................     BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
0067C:  MOVLW  1F
0067E:  MOVLB  6
00680:  MOVWF  x4D
00682:  MOVLW  03
00684:  MOVWF  x4E
00686:  MOVLB  0
00688:  RCALL  0550
....................     BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
0068A:  MOVLW  06
0068C:  MOVLB  6
0068E:  MOVWF  x3A
00690:  MOVLW  37
00692:  MOVWF  x39
00694:  MOVLW  01
00696:  ADDWF  x39,W
00698:  MOVWF  FE9
0069A:  MOVLW  00
0069C:  ADDWFC x3A,W
0069E:  MOVWF  FEA
006A0:  MOVFF  FEF,64E
006A4:  MOVLW  1F
006A6:  MOVWF  x4D
006A8:  MOVLB  0
006AA:  RCALL  0652
006AC:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *                  sleep mode, no packets can be transmitted or received. 
....................  *                  All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                  called, this function will block until it is it complete. 
....................  *                  If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................     // Disable packet reception 
....................     BFCReg(ECON1, ECON1_RXEN); 
....................  
....................     // Make sure any last packet which was in-progress when RXEN was cleared 
....................     // is completed 
....................     while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................     // If a packet is being transmitted, wait for it to finish 
....................     while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................     // Enter sleep mode 
....................     BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *                  after a previous call to MACPowerDown().  Calling this 
....................  *                  function when already powered up will have no effect. 
....................  * 
....................  * Note:            If a link partner is present, it will take 10s of 
....................  *                  milliseconds before a new link will be established after 
....................  *                  waking up.  While not linked, packets which are 
....................  *                  transmitted will most likely be lost.  MACIsLinked() can 
....................  *                  be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................     // Leave power down mode 
....................     BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................     // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................     // delay is required for the PHY module to return to an operational state. 
....................     while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                              0x01: Divide by 1 (25 MHz) 
....................  *                              0x02: Divide by 2 (12.5 MHz) 
....................  *                              0x03: Divide by 3 (8.333333 MHz) 
....................  *                              0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                              0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *                  The CLKOUT pin will beginning outputting the new frequency 
....................  *                  immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................     BankSel(ECOCON); 
....................     WriteReg((BYTE)ECOCON, NewConfig); 
....................     BankSel(ERDPTL); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                         0x01: Divide by 1 (25 MHz) 
....................  *                         0x02: Divide by 2 (12.5 MHz) 
....................  *                         0x03: Divide by 3 (8.333333 MHz) 
....................  *                         0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                         0x05: Divide by 8 (3.125 MHz) 
....................  *                         0x06: Reserved 
....................  *                         0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................     BYTE i; 
....................  
....................     BankSel(ECOCON); 
....................     i = ReadETHReg((BYTE)ECOCON).Val; 
....................     BankSel(ERDPTL); 
....................     return i; 
.................... }//end GetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
....................  * 
....................  * PreCondition:    SPI interface must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           DestMACAddr: 6 byte group destination MAC address to allow  
....................  *                         through the Hash Table Filter.  If DestMACAddr  
....................  *                         is set to 00-00-00-00-00-00, then the hash  
....................  *                         table will be cleared of all entries and the  
....................  *                         filter will be disabled. 
....................  * 
....................  * Output:          Sets the appropriate bit in the EHT* registers to allow  
....................  *               packets sent to DestMACAddr to be received and enables the  
....................  *               Hash Table receive filter (if not already). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Calculates a CRC-32 using polynomial 0x4C11DB7 and then,  
....................  *               using bits 28:23 of the CRC, sets the appropriate bit in  
....................  *               the EHT0-EHT7 registers. 
....................  * 
....................  * Note:            This code is commented out to save code space on systems  
....................  *               that do not need this function.  Change the  
....................  *               "#if STACK_USE_ZEROCONF_MDNS_SD" line to "#if 1" to  
....................  *               uncomment it, assuming you aren't using the Zeroconf module,  
....................  *               which requires mutlicast support and enables this function  
....................  *               automatically. 
....................  * 
....................  *               There is no way to individually unset destination MAC  
....................  *               addresses from the hash table since it is possible to have  
....................  *               a hash collision and therefore multiple MAC addresses  
....................  *               relying on the same hash table bit.  The stack would have  
....................  *               to individually store each 6 byte MAC address to support  
....................  *               this feature, which would waste a lot of RAM and be  
....................  *               unnecessary in most applications.  As a simple compromise,  
....................  *               you can call SetRXHashTableEntry() using a  
....................  *               00-00-00-00-00-00 destination MAC address, which will clear  
....................  *               the entire hash table and disable the hash table filter.   
....................  *               This will allow you to then re-add the necessary  
....................  *               destination address(es). 
....................  * 
....................  *               This function is intended to be used when  
....................  *               ERXFCON.ANDOR == 0 (OR). 
....................  *****************************************************************************/ 
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
.................... void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
.................... { 
....................     DWORD_VAL CRC = {0xFFFFFFFF}; 
....................     BYTE HTRegister; 
....................     BYTE i, j; 
....................  
....................    // Select proper bank for ERXFCON and EHT0-EHT7 register access 
....................    BankSel(ERXFCON); 
....................  
....................    // Clear the Hash Table bits and disable the Hash Table Filter if a special  
....................    // 00-00-00-00-00-00 destination MAC address is provided. 
....................    if((DestMACAddr.v[0] | DestMACAddr.v[1] | DestMACAddr.v[2] | DestMACAddr.v[3] | DestMACAddr.v[4] | DestMACAddr.v[5]) == 0x00u) 
....................    { 
....................       // Disable the Hash Table receive filter and clear the hash table 
....................       BFCReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................       for(i = (BYTE)EHT0; i <= (BYTE)EHT7; i++) 
....................          WriteReg(i, 0x00); 
....................    } 
....................    else 
....................    { 
....................       // Calculate a CRC-32 over the 6 byte MAC address 
....................       // using polynomial 0x4C11DB7 
....................       for(i = 0; i < sizeof(MAC_ADDR); i++) 
....................       { 
....................          BYTE  crcnext; 
....................  
....................          // shift in 8 bits 
....................          for(j = 0; j < 8; j++) 
....................          { 
....................             crcnext = 0; 
....................             if(((BYTE_VAL*)&(CRC.v[3]))->bits.b7) 
....................                crcnext = 1; 
....................             crcnext ^= (((BYTE_VAL*)&DestMACAddr.v[i])->bits.b0); 
....................  
....................             CRC.Val <<= 1; 
....................             if(crcnext) 
....................                CRC.Val ^= 0x4C11DB7; 
....................             // next bit 
....................             DestMACAddr.v[i] >>= 1; 
....................          } 
....................       } 
....................  
....................       // CRC-32 calculated, now extract bits 28:23 
....................       // Bits 25:23 define where within the Hash Table byte the bit needs to be set 
....................       // Bits 28:26 define which of the 8 Hash Table bytes that bits 25:23 apply to 
....................       i = CRC.v[3] & 0x1F; 
....................       HTRegister = (i >> 2) + (BYTE)EHT0; 
....................       i = (i << 1) & 0x06; 
....................       ((BYTE_VAL*)&i)->bits.b0 = ((BYTE_VAL*)&CRC.v[2])->bits.b7; 
....................  
....................       // Set the proper bit in the Hash Table 
....................       BFSReg(HTRegister, 1<<i); 
....................  
....................       // Ensure that the Hash Table receive filter is enabled 
....................       BFSReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................    } 
....................  
....................     BankSel(ERDPTL);            // Return to Bank 0 
.................... } 
.................... #endif 
....................  
.................... //// GetRegs is a function for debugging purposes only.  It will read all 
.................... //// registers and store them in the PIC's RAM so they can be viewed with 
.................... //// the ICD2. 
.................... //REG Regs[4][32]; 
.................... //void GetRegs(void) 
.................... //{ 
.................... //  BYTE i; 
.................... // 
.................... //  BankSel(0x000); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x100); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x200); 
.................... //  for(i=0; i<5; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][5] = ReadETHReg(i); 
.................... //  for(i=6; i<0x0F; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x0F] = ReadETHReg(i); 
.................... //  for(i=0x10; i<0x13; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x13] = ReadETHReg(i); 
.................... //  for(i=0x14; i<0x1A; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[2][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x300); 
.................... //  for(i=0; i<0x06; i++) 
.................... //      Regs[3][i] = ReadMACReg(i); 
.................... //  for(i=6; i<0x0A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  Regs[3][0x0A] = ReadMACReg(i); 
.................... //  for(i=0x0B; i<0x1A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... // 
.................... //  Regs[0][0x1A].Val = 0; 
.................... //  Regs[1][0x1A].Val = 0; 
.................... //  Regs[2][0x1A].Val = 0; 
.................... //  Regs[3][0x1A].Val = 0; 
.................... // 
.................... //  BankSel(ERDPTL); 
.................... // 
.................... //  return; 
.................... //} 
....................  
.................... //// Get8KBMem is a function intended for debugging purposes.  It will read all 
.................... //// Ethernet RAM and output it in hex out the UART 
.................... //void Get8KBMem(void) 
.................... //{ 
.................... //  WORD_VAL i; 
.................... //  BYTE v; 
.................... //  WORD_VAL RDSave; 
.................... // 
.................... //  RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
.................... //  RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
.................... // 
.................... //  for(i.Val = 0; i.Val < 8192; i.Val++) 
.................... //  { 
.................... //      WriteReg(ERDPTL, i.v[0]); 
.................... //      WriteReg(ERDPTH, i.v[1]); 
.................... //      v = MACGet(); 
.................... // 
.................... //      putcUART('0'); 
.................... //      while(BusyUART()); 
.................... //      putcUART('x'); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_high(v)); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_low(v)); 
.................... //      while(BusyUART()); 
.................... //  } 
.................... // 
.................... //  WriteReg(ERDPTL, RDSave.v[0]); 
.................... //  WriteReg(ERDPTH, RDSave.v[1]); 
.................... // 
.................... //} 
....................  
.................... #endif //#if defined(ENC_CS_TRIS) 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "ENCX24J600.c" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or ZeroG ZG2100 must be present. 
.................... #endif 
.................... #include "IP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Protocol (IP) Version 4 Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides a transport for TCP, UDP, and ICMP messages 
....................  *	 -Reference: RFC 791 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.c 
....................  * Dependencies:    Network Layer interface (ENC28J60.c, ETH97J60.c,  
....................  *					ENCX24J600.c or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook			9/21/06	Corrected IPHeaderLen not being  
....................  * 								initialized when NON_MCHP_MAC defined. 
....................  ********************************************************************/ 
.................... #define __IP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................   #define MY_IP_TTL           (255)  // Time-To-Live in hops  
....................   // IP TTL is set to 255 for Multicast DNS compatibility. See mDNS-draft-08, section 4. 
.................... #else 
....................   #define MY_IP_TTL           (100)  // Time-To-Live in hops 
.................... #endif 
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if defined(NON_MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... 	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
04ACE:  MOVLW  05
04AD0:  MOVLB  5
04AD2:  MOVWF  xDD
04AD4:  MOVLW  C8
04AD6:  MOVWF  xDC
04AD8:  MOVFF  5DD,656
04ADC:  MOVFF  FE8,655
04AE0:  MOVLB  6
04AE2:  CLRF   x58
04AE4:  MOVLW  14
04AE6:  MOVWF  x57
04AE8:  MOVLB  0
04AEA:  CALL   0C28
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if((header.VersionIHL & 0xf0) != IP_VERSION) 
04AEE:  MOVLB  5
04AF0:  MOVF   xC8,W
04AF2:  ANDLW  F0
04AF4:  MOVWF  xDC
04AF6:  CLRF   xDD
04AF8:  MOVF   xDC,W
04AFA:  SUBLW  40
04AFC:  BNZ   4B02
04AFE:  MOVF   xDD,F
04B00:  BZ    4B08
....................     	return FALSE; 
04B02:  MOVLW  00
04B04:  MOVWF  01
04B06:  BRA    4BE4
....................  
.................... 	// Throw this packet away if it is a fragment.   
.................... 	// We don't have enough RAM for IP fragment reconstruction. 
.................... 	if(header.FragmentInfo & 0xFF1F) 
04B08:  MOVF   xCE,W
04B0A:  ANDLW  1F
04B0C:  MOVWF  00
04B0E:  MOVFF  5CF,03
04B12:  MOVF   00,W
04B14:  IORWF  xCF,W
04B16:  BZ    4B1E
.................... 		return FALSE; 
04B18:  MOVLW  00
04B1A:  MOVWF  01
04B1C:  BRA    4BE4
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
04B1E:  MOVF   xC8,W
04B20:  ANDLW  0F
04B22:  MOVWF  xDC
04B24:  CLRF   xDD
04B26:  RLCF   xDC,W
04B28:  MOVWF  02
04B2A:  RLCF   xDD,W
04B2C:  MOVWF  03
04B2E:  RLCF   02,F
04B30:  RLCF   03,F
04B32:  MOVLW  FC
04B34:  ANDWF  02,F
04B36:  MOVFF  02,12C
04B3A:  MOVLB  1
....................  
.................... #if !defined(NON_MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum  
.................... 	// will come out to 0x0000 (because the header contains a  
.................... 	// precomputed checksum).  A corrupt header will have a  
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
04B3C:  MOVLB  5
04B3E:  CLRF   xDD
04B40:  CLRF   xDC
04B42:  CLRF   xDF
04B44:  MOVFF  12C,5DE
04B48:  MOVLB  0
04B4A:  RCALL  4A1A
04B4C:  MOVFF  02,5C7
04B50:  MOVFF  01,5C6
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetReadPtrInRx(IPHeaderLen); 
04B54:  MOVLB  6
04B56:  CLRF   x12
04B58:  MOVFF  12C,611
04B5C:  MOVLB  0
04B5E:  CALL   2424
....................  
....................     if(CalcChecksum.Val) 
04B62:  MOVLB  5
04B64:  MOVF   xC6,W
04B66:  IORWF  xC7,W
04B68:  BZ    4B70
.................... #else 
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = IPHeaderLen - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0u ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0u ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE  
....................         // return value and it should discard the packet. 
....................         return FALSE; 
04B6A:  MOVLW  00
04B6C:  MOVWF  01
04B6E:  BRA    4BE4
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
04B70:  MOVLW  05
04B72:  MOVLB  6
04B74:  MOVWF  x4D
04B76:  MOVLW  C8
04B78:  MOVWF  x4C
04B7A:  MOVLB  0
04B7C:  CALL   1A64
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
04B80:  MOVLB  5
04B82:  MOVF   xBE,W
04B84:  IORWF  xBF,W
04B86:  BZ    4BA0
....................         localIP->Val    = header.DestAddress.Val; 
04B88:  MOVFF  5BE,FE9
04B8C:  MOVFF  5BF,FEA
04B90:  MOVFF  5D8,FEF
04B94:  MOVFF  5D9,FEC
04B98:  MOVFF  5DA,FEC
04B9C:  MOVFF  5DB,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
04BA0:  MOVFF  5C0,FE9
04BA4:  MOVF   xC1,W
04BA6:  MOVWF  FEA
04BA8:  MOVFF  5D4,FEF
04BAC:  MOVFF  5D5,FEC
04BB0:  MOVFF  5D6,FEC
04BB4:  MOVFF  5D7,FEC
....................     *protocol           = header.Protocol; 
04BB8:  MOVFF  5C2,FE9
04BBC:  MOVFF  5C3,FEA
04BC0:  MOVFF  5D1,FEF
....................     *len 				= header.TotalLength - IPHeaderLen; 
04BC4:  MOVFF  5C4,FE9
04BC8:  MOVFF  5C5,FEA
04BCC:  MOVLB  1
04BCE:  MOVF   x2C,W
04BD0:  MOVLB  5
04BD2:  SUBWF  xCA,W
04BD4:  MOVWF  00
04BD6:  MOVLW  00
04BD8:  SUBWFB xCB,W
04BDA:  MOVFF  00,FEF
04BDE:  MOVWF  FEC
....................  
....................     return TRUE; 
04BE0:  MOVLW  01
04BE2:  MOVWF  01
04BE4:  MOVLB  0
04BE6:  GOTO   6CF4 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                  BYTE protocol, 
....................                  WORD len) 
.................... { 
....................     IP_HEADER   header; 
....................      
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
01CCC:  MOVLW  14
01CCE:  MOVLB  1
01CD0:  MOVWF  x2C
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
01CD2:  MOVLW  45
01CD4:  MOVLB  6
01CD6:  MOVWF  x38
....................     header.TypeOfService    = IP_SERVICE; 
01CD8:  CLRF   x39
....................     header.TotalLength      = sizeof(header) + len; 
01CDA:  MOVLW  14
01CDC:  ADDWF  x36,W
01CDE:  MOVWF  x3A
01CE0:  MOVLW  00
01CE2:  ADDWFC x37,W
01CE4:  MOVWF  x3B
....................     header.Identification   = ++_Identifier; 
01CE6:  MOVLB  1
01CE8:  INCF   x2A,F
01CEA:  BTFSC  FD8.2
01CEC:  INCF   x2B,F
01CEE:  MOVFF  12B,63D
01CF2:  MOVFF  12A,63C
....................     header.FragmentInfo     = 0; 
01CF6:  MOVLB  6
01CF8:  CLRF   x3F
01CFA:  CLRF   x3E
....................     header.TimeToLive       = MY_IP_TTL; 
01CFC:  MOVLW  64
01CFE:  MOVWF  x40
....................     header.Protocol         = protocol; 
01D00:  MOVFF  635,641
....................     header.HeaderChecksum   = 0; 
01D04:  CLRF   x43
01D06:  CLRF   x42
.................... 	header.SourceAddress 	= AppConfig.MyIPAddr; 
01D08:  MOVFF  22,647
01D0C:  MOVFF  21,646
01D10:  MOVFF  20,645
01D14:  MOVFF  1F,644
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
01D18:  MOVFF  633,FE9
01D1C:  MOVFF  634,FEA
01D20:  MOVFF  FEF,648
01D24:  MOVFF  FEC,649
01D28:  MOVFF  FEC,64A
01D2C:  MOVFF  FEC,64B
....................  
....................     SwapIPHeader(&header); 
01D30:  MOVLW  06
01D32:  MOVWF  x4D
01D34:  MOVLW  38
01D36:  MOVWF  x4C
01D38:  MOVLB  0
01D3A:  RCALL  1A64
....................  
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, sizeof(header)); 
01D3C:  MOVLW  06
01D3E:  MOVLB  6
01D40:  MOVWF  x4D
01D42:  MOVLW  38
01D44:  MOVWF  x4C
01D46:  MOVFF  64D,64F
01D4A:  MOVWF  x4E
01D4C:  CLRF   x51
01D4E:  MOVLW  14
01D50:  MOVWF  x50
01D52:  MOVLB  0
01D54:  RCALL  1B26
01D56:  MOVFF  02,643
01D5A:  MOVFF  01,642
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
01D5E:  MOVLW  04
01D60:  MOVLB  6
01D62:  ADDWF  x33,W
01D64:  MOVWF  01
01D66:  MOVLW  00
01D68:  ADDWFC x34,W
01D6A:  MOVWF  03
01D6C:  MOVFF  01,64C
01D70:  MOVWF  x4D
01D72:  MOVLW  14
01D74:  ADDWF  x36,W
01D76:  MOVWF  x4E
01D78:  MOVLW  00
01D7A:  ADDWFC x37,W
01D7C:  MOVWF  x4F
01D7E:  MOVFF  03,651
01D82:  MOVFF  01,650
01D86:  CLRF   x52
01D88:  MOVWF  x54
01D8A:  MOVFF  64E,653
01D8E:  MOVLB  0
01D90:  RCALL  1C0E
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
01D92:  MOVLW  06
01D94:  MOVLB  6
01D96:  MOVWF  x4D
01D98:  MOVLW  38
01D9A:  MOVWF  x4C
01D9C:  MOVFF  64D,658
01DA0:  MOVWF  x57
01DA2:  CLRF   x5A
01DA4:  MOVLW  14
01DA6:  MOVWF  x59
01DA8:  MOVLB  0
01DAA:  CALL   0B7E
....................  
....................     return 0x0000; 
01DAE:  MOVLW  00
01DB0:  MOVWF  01
01DB2:  MOVWF  02
01DB4:  RETURN 0
....................  
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset)  
.................... { 
.................... 	MACSetReadPtrInRx(Offset+IPHeaderLen); 
*
0247A:  MOVLB  1
0247C:  MOVF   x2C,W
0247E:  MOVLB  6
02480:  ADDWF  x0D,W
02482:  MOVWF  x0F
02484:  MOVLW  00
02486:  ADDWFC x0E,W
02488:  MOVWF  x10
0248A:  MOVWF  x12
0248C:  MOVFF  60F,611
02490:  MOVLB  0
02492:  RCALL  2424
02494:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
01A64:  MOVLW  02
01A66:  MOVLB  6
01A68:  ADDWF  x4C,W
01A6A:  MOVWF  01
01A6C:  MOVLW  00
01A6E:  ADDWFC x4D,W
01A70:  MOVWF  03
01A72:  MOVFF  01,64E
01A76:  MOVWF  x4F
01A78:  MOVLW  02
01A7A:  ADDWF  x4C,W
01A7C:  MOVWF  FE9
01A7E:  MOVLW  00
01A80:  ADDWFC x4D,W
01A82:  MOVWF  FEA
01A84:  MOVFF  FEC,653
01A88:  MOVF   FED,F
01A8A:  MOVFF  FEF,652
01A8E:  MOVLB  0
01A90:  RCALL  1A42
01A92:  MOVFF  64F,FEA
01A96:  MOVFF  64E,FE9
01A9A:  MOVFF  02,FEC
01A9E:  MOVF   FED,F
01AA0:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
01AA4:  MOVLW  04
01AA6:  MOVLB  6
01AA8:  ADDWF  x4C,W
01AAA:  MOVWF  01
01AAC:  MOVLW  00
01AAE:  ADDWFC x4D,W
01AB0:  MOVWF  03
01AB2:  MOVFF  01,64E
01AB6:  MOVWF  x4F
01AB8:  MOVLW  04
01ABA:  ADDWF  x4C,W
01ABC:  MOVWF  FE9
01ABE:  MOVLW  00
01AC0:  ADDWFC x4D,W
01AC2:  MOVWF  FEA
01AC4:  MOVFF  FEC,653
01AC8:  MOVF   FED,F
01ACA:  MOVFF  FEF,652
01ACE:  MOVLB  0
01AD0:  RCALL  1A42
01AD2:  MOVFF  64F,FEA
01AD6:  MOVFF  64E,FE9
01ADA:  MOVFF  02,FEC
01ADE:  MOVF   FED,F
01AE0:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
01AE4:  MOVLW  0A
01AE6:  MOVLB  6
01AE8:  ADDWF  x4C,W
01AEA:  MOVWF  01
01AEC:  MOVLW  00
01AEE:  ADDWFC x4D,W
01AF0:  MOVWF  03
01AF2:  MOVFF  01,64E
01AF6:  MOVWF  x4F
01AF8:  MOVLW  0A
01AFA:  ADDWF  x4C,W
01AFC:  MOVWF  FE9
01AFE:  MOVLW  00
01B00:  ADDWFC x4D,W
01B02:  MOVWF  FEA
01B04:  MOVFF  FEC,653
01B08:  MOVF   FED,F
01B0A:  MOVFF  FEF,652
01B0E:  MOVLB  0
01B10:  RCALL  1A42
01B12:  MOVFF  64F,FEA
01B16:  MOVFF  64E,FE9
01B1A:  MOVFF  02,FEC
01B1E:  MOVF   FED,F
01B20:  MOVFF  01,FEF
01B24:  RETURN 0
.................... } 
....................  
.................... #include "ARP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Address Resolution Protocol (ARP) Client and Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides IP address to Ethernet MAC address translation 
....................  *    -Reference: RFC 826 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  ARP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.c and ARPTsk.c into ARP.c;  
....................  *                        rewrote some of it to look more linear 
....................  * Darren Rook/CCS      Added call to GratArpReset() if using STACK_USE_CCS_GRATUITOUS_ARP 
....................  ********************************************************************/ 
.................... #define __ARP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Constants and Variables 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... //#define ARP_OPERATION_REQ       0x01u      // Operation code indicating an ARP Request 
.................... //#define ARP_OPERATION_RESP      0x02u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
.................... #endif 
....................  
.................... #ifdef STACK_CLIENT_MODE 
.................... static NODE_INFO Cache;                  // Cache for one ARP response 
.................... #endif 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define MAX_REG_APPS            2           // MAX num allowed registrations of Modules/Apps 
.................... static struct arp_app_callbacks reg_apps[MAX_REG_APPS]; // Call-Backs storage for MAX of two Modules/Apps 
.................... /* 
.................... // ARP packet structure 
.................... typedef struct __attribute__((aligned(2), packed)) 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
.................... */ 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Helper Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static BOOL ARPPut(ARP_PACKET* packet); 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Implementations 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... /************ User Application APIs ****************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
....................  
....................   Summary: 
....................    Registering callback with ARP module to get notified about certian events. 
....................     
....................   Description: 
....................      This function allows end user application to register with callbacks, which 
....................     will be called by ARP module to give notification to user-application about  
....................     events occurred at ARP layer. For ex: when a ARP-packet is received, which is 
....................     conflicting with our own pair of addresses (MAC-Address and IP-address). 
....................     This is an extension for zeroconf protocol implementation (ZeroconfLL.c) 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    app - ARP-Application callbacks structure supplied by user-application  
....................      
....................   Returns: 
....................     id > 0 - Returns non-negative value that represents the id of registration 
....................              The same id needs to be used in de-registration 
....................     -1     - When registered applications exceed MAX_REG_APPS and there is no 
....................              free slot for registration 
....................   
....................   ***************************************************************************/ 
.................... CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
.................... { 
....................     BYTE i; 
....................     for(i=0; i<MAX_REG_APPS; i++) 
....................     { 
....................         if(!reg_apps[i].used) 
....................         { 
....................             reg_apps[i].ARPPkt_notify = app->ARPPkt_notify; 
....................             reg_apps[i].used = 1; 
....................             return (i+1); // Return Code. Should be used in deregister. 
....................         } 
....................     } 
....................     return -1; // No space for registration 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
....................  
....................   Summary: 
....................    De-Registering callbacks with ARP module that are registered previously. 
....................     
....................   Description: 
....................      This function allows end user-application to de-register with callbacks,  
....................     which were registered previously. 
....................     This is called by user-application, when its no longer interested in  
....................     notifications from ARP-Module. This allows the other application to get  
....................     registered with ARP-module.    
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    reg_id - Registration-id returned in ARPRegisterCallbacks call 
....................      
....................   Returns: 
....................     TRUE  - On success 
....................     FALSE - Failure to indicate invalid reg_id   
....................   ***************************************************************************/  
.................... BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
.................... { 
....................     if(reg_id <= 0 || reg_id > MAX_REG_APPS) 
....................         return FALSE; 
....................  
....................     reg_apps[reg_id-1].used = 0; // To indicate free slot for registration 
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPProcessRxPkt(ARP_PACKET* packet) 
....................  
....................   Summary: 
....................    Processes Received-ARP packet (ARP request/Reply). 
....................     
....................   Description: 
....................      This function is to pass-on the ARP-packet to registered application, 
....................     with the notification of Rx-ARP packet.  
....................  
....................   Precondition: 
....................    ARP packet is received completely from MAC 
....................  
....................   Parameters: 
....................    packet - Rx packet to be processed      
....................  
....................   Returns: 
....................     None    
....................   ***************************************************************************/ 
.................... void ARPProcessRxPkt(ARP_PACKET* packet) 
.................... { 
....................     BYTE pass_on = 0; // Flag to indicate whether need to be forwarded 
....................     BYTE i; 
....................  
....................     // Probing Stage 
....................     if(AppConfig.MyIPAddr.Val == 0x00) 
....................     { 
....................         pass_on = 1; // Pass to Registered-Application for further processing         
....................     } 
....................     else if(AppConfig.MyIPAddr.Val) 
....................     { 
....................         /* Late-conflict */ 
....................         if(packet->SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................         { 
....................             pass_on = 1; 
....................         } 
....................     } 
....................     if(pass_on) 
....................     { 
....................      
....................         for(i =0; i< MAX_REG_APPS; i++) 
....................         { 
....................             if(reg_apps[i].used) 
....................             { 
....................                 reg_apps[i].ARPPkt_notify(packet->SenderIPAddr.Val, 
....................                                       packet->TargetIPAddr.Val, 
....................                                       &packet->SenderMACAddr, 
....................                                       &packet->TargetMACAddr, 
....................                                       packet->Operation);                 
....................             } 
....................         } 
....................     } 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPSendPkt(IP_ADDR* SrcIPAddr, IP_ADDR* DestIPAddr, int op_req ) 
....................  
....................   Summary: 
....................    Transmits an ARP request/Reply initated by Application or external module. 
....................     
....................   Description: 
....................      This function transmits and ARP request/reply to determine the hardware 
....................      address of a given IP address (or) Announce self-address to all nodes in 
....................     network. Extended for zeroconf protocol.  
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    SrcIPAddr - The Source IP-address  
....................     DestIPAddr - The Destination IP-Address 
....................     op_req     - Operation Request (ARP_REQ/ARP_RESP) 
....................  
....................   Returns: 
....................     TRUE - The ARP packet was generated properly 
....................      FALSE - Not possible return value 
....................  
....................   Remarks: 
....................      This API is to give control over AR-packet to external modules.  
....................   ***************************************************************************/ 
.................... BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................    DWORD_VAL *DestAddr = (DWORD_VAL *)&DestIPAddr; 
....................    if ((DestAddr->v[0] >= 224) &&(DestAddr->v[0] <= 239)) { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................     
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & DestAddr->v[1]; 
....................       Cache.MACAddr.v[4] = DestAddr->v[2]; 
....................       Cache.MACAddr.v[5] = DestAddr->v[3]; 
....................     
....................       Cache.IPAddr.Val = DestAddr->Val; 
....................     
....................       return TRUE; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................     packet.Operation = op_req; 
....................    packet.TargetMACAddr.v[0]   = 0xff; 
....................    packet.TargetMACAddr.v[1]   = 0xff; 
....................    packet.TargetMACAddr.v[2]   = 0xff; 
....................    packet.TargetMACAddr.v[3]   = 0xff; 
....................    packet.TargetMACAddr.v[4]   = 0xff; 
....................    packet.TargetMACAddr.v[5]   = 0xff; 
....................  
....................     packet.TargetIPAddr.Val   = DestIPAddr; 
....................     packet.SenderIPAddr.Val = SrcIPAddr; 
....................  
....................     return ( ARPPut(&packet) ); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL ARPPut(ARP_PACKET* packet) 
....................  
....................   Description: 
....................    Writes an ARP packet to the MAC. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    packet - A pointer to an ARP_PACKET structure with correct operation 
....................             and target preconfigured. 
....................  
....................   Return Values: 
....................      TRUE - The ARP packet was generated properly 
....................      FALSE - Not a possible return value 
....................   ***************************************************************************/ 
.................... static BOOL ARPPut(ARP_PACKET* packet) 
.................... { 
....................    while(!MACIsTxReady()); 
*
047F8:  CALL   17A4
047FC:  MOVF   01,F
047FE:  BZ    47F8
....................    MACSetWritePtr(BASE_TX_ADDR); 
04800:  MOVLW  11
04802:  MOVLB  6
04804:  MOVWF  x43
04806:  MOVLW  D7
04808:  MOVWF  x42
0480A:  MOVLB  0
0480C:  CALL   0B16
....................     
....................  
....................     packet->HardwareType  = HW_ETHERNET; 
04810:  MOVLB  5
04812:  MOVFF  5DA,FE9
04816:  MOVFF  5DB,FEA
0481A:  CLRF   FEC
0481C:  MOVF   FED,F
0481E:  MOVLW  01
04820:  MOVWF  FEF
....................     packet->Protocol      = ARP_IP; 
04822:  MOVLW  02
04824:  ADDWF  xDA,W
04826:  MOVWF  FE9
04828:  MOVLW  00
0482A:  ADDWFC xDB,W
0482C:  MOVWF  FEA
0482E:  MOVLW  08
04830:  MOVWF  FEC
04832:  MOVF   FED,F
04834:  CLRF   FEF
....................     packet->MACAddrLen    = sizeof(MAC_ADDR); 
04836:  MOVLW  04
04838:  ADDWF  xDA,W
0483A:  MOVWF  FE9
0483C:  MOVLW  00
0483E:  ADDWFC xDB,W
04840:  MOVWF  FEA
04842:  MOVLW  06
04844:  MOVWF  FEF
....................     packet->ProtocolLen   = sizeof(IP_ADDR); 
04846:  MOVLW  05
04848:  ADDWF  xDA,W
0484A:  MOVWF  FE9
0484C:  MOVLW  00
0484E:  ADDWFC xDB,W
04850:  MOVWF  FEA
04852:  MOVLW  04
04854:  MOVWF  FEF
.................... //    packet->SenderMACAddr = AppConfig.MyMACAddr;   // HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround 
....................    memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr)); 
04856:  MOVLW  08
04858:  ADDWF  xDA,W
0485A:  MOVWF  01
0485C:  MOVLW  00
0485E:  ADDWFC xDB,W
04860:  MOVWF  03
04862:  MOVFF  01,5DC
04866:  MOVWF  xDD
04868:  CLRF   xDF
0486A:  MOVLW  4C
0486C:  MOVFF  03,FEA
04870:  MOVFF  01,FE9
04874:  MOVFF  5DF,FE2
04878:  MOVWF  FE1
0487A:  MOVLW  06
0487C:  MOVWF  01
0487E:  MOVFF  FE6,FEE
04882:  DECFSZ 01,F
04884:  BRA    487E
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................     //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */ 
.................... #else 
....................     packet->SenderIPAddr  = AppConfig.MyIPAddr; 
04886:  MOVLW  0E
04888:  ADDWF  xDA,W
0488A:  MOVWF  FE9
0488C:  MOVLW  00
0488E:  ADDWFC xDB,W
04890:  MOVWF  FEA
04892:  MOVFF  1F,FEF
04896:  MOVFF  20,FEC
0489A:  MOVFF  21,FEC
0489E:  MOVFF  22,FEC
.................... #endif 
....................  
....................     SwapARPPacket(packet); 
048A2:  MOVFF  5DB,5DD
048A6:  MOVFF  5DA,5DC
048AA:  MOVLB  0
048AC:  RCALL  4736
....................  
....................     MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet)); 
048AE:  MOVLW  12
048B0:  MOVLB  5
048B2:  ADDWF  xDA,W
048B4:  MOVWF  01
048B6:  MOVLW  00
048B8:  ADDWFC xDB,W
048BA:  MOVWF  03
048BC:  MOVFF  01,5DC
048C0:  MOVWF  xDD
048C2:  MOVFF  FE8,651
048C6:  MOVFF  01,650
048CA:  MOVLW  06
048CC:  MOVLB  6
048CE:  MOVWF  x52
048D0:  CLRF   x54
048D2:  MOVLW  1C
048D4:  MOVWF  x53
048D6:  MOVLB  0
048D8:  CALL   1C0E
....................     MACPutArray((BYTE*)packet, sizeof(*packet)); 
048DC:  MOVFF  5DB,658
048E0:  MOVFF  5DA,657
048E4:  MOVLB  6
048E6:  CLRF   x5A
048E8:  MOVLW  1C
048EA:  MOVWF  x59
048EC:  MOVLB  0
048EE:  CALL   0B7E
....................     MACFlush(); 
048F2:  CALL   1DB6
....................     
....................    return TRUE; 
048F6:  MOVLW  01
048F8:  MOVWF  01
048FA:  GOTO   49FA (RETURN)
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPInit(void) 
....................  
....................   Summary: 
....................    Initializes the ARP module. 
....................     
....................   Description: 
....................      Initializes the ARP module.  Call this function once at boot to  
....................      invalidate the cached lookup. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................    
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPInit(void) 
.................... { 
....................     Cache.MACAddr.v[0] = 0xff; 
....................     Cache.MACAddr.v[1] = 0xff; 
....................     Cache.MACAddr.v[2] = 0xff; 
....................     Cache.MACAddr.v[3] = 0xff; 
....................     Cache.MACAddr.v[4] = 0xff; 
....................     Cache.MACAddr.v[5] = 0xff; 
....................  
....................    Cache.IPAddr.Val = 0xfffffffful; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPProcess(void) 
....................  
....................   Summary: 
....................    Processes an incoming ARP packet. 
....................     
....................   Description: 
....................      Retrieves an ARP packet from the MAC buffer and determines if it is a 
....................      response to our request (in which case the ARP is resolved) or if it 
....................      is a request requiring our response (in which case we transmit one.) 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      TRUE - All processing of this ARP packet is complete.  Do not call  
....................            again until a new ARP packet is waiting in the RX buffer. 
....................      FALSE - This function must be called again.  More time is needed to  
....................            send an ARP response. 
....................   ***************************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................    ARP_PACKET packet; 
....................    static NODE_INFO Target; 
....................     #if defined(STACK_USE_AUTO_IP) 
....................         BYTE i; 
....................     #endif 
....................    static enum 
....................    { 
....................        SM_ARP_IDLE = 0, 
....................        SM_ARP_REPLY 
....................    } smARP = SM_ARP_IDLE; 
....................  
....................     switch(smARP) 
048FE:  MOVLW  00
04900:  MOVLB  1
04902:  BTFSC  x12.3
04904:  MOVLW  01
04906:  XORLW  00
04908:  MOVLB  0
0490A:  BZ    4912
0490C:  XORLW  01
0490E:  BZ    49BA
04910:  BRA    4A0E
....................     { 
....................        case SM_ARP_IDLE: 
....................          // Obtain the incoming ARP packet 
....................           MACGetArray((BYTE*)&packet, sizeof(packet));       
04912:  MOVLW  05
04914:  MOVLB  5
04916:  MOVWF  xDB
04918:  MOVLW  BE
0491A:  MOVWF  xDA
0491C:  MOVFF  5DB,656
04920:  MOVFF  FE8,655
04924:  MOVLB  6
04926:  CLRF   x58
04928:  MOVLW  1C
0492A:  MOVWF  x57
0492C:  MOVLB  0
0492E:  CALL   0C28
....................           MACDiscardRx(); 
04932:  CALL   25DA
....................           SwapARPPacket(&packet); 
04936:  MOVLW  05
04938:  MOVLB  5
0493A:  MOVWF  xDD
0493C:  MOVLW  BE
0493E:  MOVWF  xDC
04940:  MOVLB  0
04942:  RCALL  4736
....................        
....................          // Validate the ARP packet 
....................           if ( packet.HardwareType != HW_ETHERNET     || 
....................                packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................                packet.ProtocolLen != sizeof(IP_ADDR) ) 
04944:  MOVLB  5
04946:  DECFSZ xBE,W
04948:  BRA    495A
0494A:  MOVF   xBF,F
0494C:  BNZ   495A
0494E:  MOVF   xC2,W
04950:  SUBLW  06
04952:  BNZ   495A
04954:  MOVF   xC3,W
04956:  SUBLW  04
04958:  BZ    4960
....................           { 
....................                return TRUE; 
0495A:  MOVLW  01
0495C:  MOVWF  01
0495E:  BRA    4A14
....................           } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................          ARPProcessRxPkt(&packet); 
.................... #endif 
....................  
.................... #ifdef STACK_USE_AUTO_IP 
....................             if (packet.SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................             { 
....................                 AutoIPConflict(0); 
....................                 return TRUE;                 
....................             } 
.................... #endif 
.................... #ifdef STACK_USE_CCS_GRATUITOUS_ARP 
.................... GratArpReset(); 
.................... #endif 
....................          // Handle incoming ARP responses 
.................... #ifdef STACK_CLIENT_MODE 
....................          if(packet.Operation == ARP_OPERATION_RESP) 
....................          { 
.................... /*                #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                         AutoIPConflict(i); 
....................                 #endif*/ 
....................             Cache.MACAddr = packet.SenderMACAddr; 
....................             Cache.IPAddr = packet.SenderIPAddr; 
....................             return TRUE; 
....................          } 
.................... #endif 
....................  
....................          // Handle incoming ARP requests for our MAC address 
....................          if(packet.Operation == ARP_OPERATION_REQ) 
04960:  DECFSZ xC4,W
04962:  BRA    49B8
04964:  MOVF   xC5,F
04966:  BNZ   49B8
....................          { 
....................             if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val) 
04968:  MOVF   1F,W
0496A:  SUBWF  xD6,W
0496C:  BNZ   4980
0496E:  MOVF   20,W
04970:  SUBWF  xD7,W
04972:  BNZ   4980
04974:  MOVF   21,W
04976:  SUBWF  xD8,W
04978:  BNZ   4980
0497A:  MOVF   22,W
0497C:  SUBWF  xD9,W
0497E:  BZ    4986
....................             { 
....................                return TRUE; 
04980:  MOVLW  01
04982:  MOVWF  01
04984:  BRA    4A14
....................             } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................                                /* Fix for Loop-Back suppression: 
....................                                 * For ZCLL-Claim packets, host should not respond. 
....................                                 * Check Sender's MAC-address with own MAC-address and  
....................                                 * if it is matched, response will not be sent back. This 
....................                                 * was leading to flooding of ARP-answeres */ 
....................                                 if(!memcmp (&packet.SenderMACAddr, &AppConfig.MyMACAddr, 6)) 
....................                                 { 
....................                                      putsUART("Loopback answer suppressed \r\n"); 
....................                                      return TRUE; 
....................                                 } 
.................... #endif 
....................                 #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                     { 
....................                         AutoIPConflict(i); 
....................                         return TRUE; 
....................                     }              
....................                 #endif 
....................             Target.IPAddr = packet.SenderIPAddr; 
04986:  MOVFF  5CF,130
0498A:  MOVFF  5CE,12F
0498E:  MOVFF  5CD,12E
04992:  MOVFF  5CC,12D
....................             Target.MACAddr = packet.SenderMACAddr; 
04996:  MOVLW  01
04998:  MOVWF  FEA
0499A:  MOVLW  31
0499C:  MOVWF  FE9
0499E:  MOVLW  05
049A0:  MOVWF  FE2
049A2:  MOVLW  C6
049A4:  MOVWF  FE1
049A6:  MOVLW  06
049A8:  MOVWF  01
049AA:  MOVFF  FE6,FEE
049AE:  DECFSZ 01,F
049B0:  BRA    49AA
....................  
....................             smARP = SM_ARP_REPLY; 
049B2:  MOVLB  1
049B4:  BSF    x12.3
049B6:  MOVLB  5
049B8:  MOVLB  0
....................          } 
....................          // Do not break.  If we get down here, we need to send a reply.    
....................  
....................        case SM_ARP_REPLY: 
....................            packet.Operation      = ARP_OPERATION_RESP; 
049BA:  MOVLB  5
049BC:  CLRF   xC5
049BE:  MOVLW  02
049C0:  MOVWF  xC4
....................             #if defined(STACK_USE_AUTO_IP) 
....................             if (AutoIPIsConfigured(0)) 
....................             { 
....................                 packet.TargetMACAddr.v[0] = 0xFF; 
....................                 packet.TargetMACAddr.v[1] = 0xFF; 
....................                 packet.TargetMACAddr.v[2] = 0xFF; 
....................                 packet.TargetMACAddr.v[3] = 0xFF; 
....................                 packet.TargetMACAddr.v[4] = 0xFF; 
....................                 packet.TargetMACAddr.v[5] = 0xFF; 
....................             } 
....................             else 
....................             #endif 
....................                packet.TargetMACAddr   = Target.MACAddr; 
049C2:  MOVLW  05
049C4:  MOVWF  FEA
049C6:  MOVLW  D0
049C8:  MOVWF  FE9
049CA:  MOVLW  01
049CC:  MOVWF  FE2
049CE:  MOVLW  31
049D0:  MOVWF  FE1
049D2:  MOVLW  06
049D4:  MOVWF  01
049D6:  MOVFF  FE6,FEE
049DA:  DECFSZ 01,F
049DC:  BRA    49D6
....................            packet.TargetIPAddr      = Target.IPAddr; 
049DE:  MOVFF  130,5D9
049E2:  MOVFF  12F,5D8
049E6:  MOVFF  12E,5D7
049EA:  MOVFF  12D,5D6
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................             packet.SenderIPAddr      = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................          // Send an ARP response to a previously received request 
....................          if(!ARPPut(&packet)) 
049EE:  MOVLW  05
049F0:  MOVWF  xDB
049F2:  MOVLW  BE
049F4:  MOVWF  xDA
049F6:  MOVLB  0
049F8:  BRA    47F8
049FA:  MOVF   01,F
049FC:  BNZ   4A08
....................          { 
....................               return FALSE; 
049FE:  MOVLW  00
04A00:  MOVWF  01
04A02:  MOVLB  5
04A04:  BRA    4A14
04A06:  MOVLB  0
....................          } 
....................  
....................          // Begin listening for ARP requests again 
....................          smARP = SM_ARP_IDLE; 
04A08:  MOVLB  1
04A0A:  BCF    x12.3
....................            break; 
04A0C:  MOVLB  0
....................    } 
....................  
....................     return TRUE; 
04A0E:  MOVLW  01
04A10:  MOVWF  01
04A12:  MOVLB  5
04A14:  MOVLB  0
04A16:  GOTO   6DFA (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPResolve(IP_ADDR* IPAddr) 
....................  
....................   Summary: 
....................    Transmits an ARP request to resolve an IP address. 
....................     
....................   Description: 
....................      This function transmits and ARP request to determine the hardware 
....................      address of a given IP address. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  The address must be specified  
....................           in network byte order (big endian). 
....................  
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................  
....................    To retrieve the ARP query result, call the ARPIsResolved() function. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPResolve(IP_ADDR* IPAddr) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................     if ((IPAddr->v[0] >= 224) &&(IPAddr->v[0] <= 239)) 
....................     { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................  
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & IPAddr->v[1]; 
....................       Cache.MACAddr.v[4] = IPAddr->v[2]; 
....................       Cache.MACAddr.v[5] = IPAddr->v[3]; 
....................  
....................       Cache.IPAddr.Val = IPAddr->Val; 
....................  
....................       return; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................    packet.Operation            = ARP_OPERATION_REQ; 
....................    packet.TargetMACAddr.v[0]   = 0xff; 
....................    packet.TargetMACAddr.v[1]   = 0xff; 
....................    packet.TargetMACAddr.v[2]   = 0xff; 
....................    packet.TargetMACAddr.v[3]   = 0xff; 
....................    packet.TargetMACAddr.v[4]   = 0xff; 
....................    packet.TargetMACAddr.v[5]   = 0xff; 
....................  
....................  
....................     // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet 
....................    packet.TargetIPAddr         = ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr; 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    packet.SenderIPAddr         = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................     ARPPut(&packet); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
....................  
....................   Summary: 
....................    Determines if an ARP request has been resolved yet. 
....................     
....................   Description: 
....................      This function checks if an ARP request has been resolved yet, and if 
....................      so, stores the resolved MAC address in the pointer provided. 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  This must match the IP address  
....................           provided to the ARPResolve() function call. 
....................    MACAddr - A buffer to store the corresponding MAC address retrieved from  
....................           the ARP query. 
....................  
....................   Return Values: 
....................      TRUE - The IP address has been resolved and MACAddr MAC address field 
....................          indicates the response. 
....................      FALSE -   The IP address is not yet resolved.  Try calling ARPIsResolved()  
....................          again at a later time.  If you don't get a response after a  
....................          application specific timeout period, you may want to call  
....................          ARPResolve() again to transmit another ARP query (in case if the  
....................          original query or response was lost on the network).  If you never  
....................          receive an ARP response, this may indicate that the IP address  
....................          isn't in use. 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
.................... { 
....................     if((Cache.IPAddr.Val == IPAddr->Val) ||  
....................      ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val))) 
....................     { 
....................         *MACAddr = Cache.MACAddr; 
....................         return TRUE; 
....................     } 
....................     return FALSE; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void SwapARPPacket(ARP_PACKET* p) 
....................  
....................   Description: 
....................      Swaps endian-ness of header information in an ARP packet. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    p - The ARP packet to be swapped 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void SwapARPPacket(ARP_PACKET* p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
04736:  MOVLB  5
04738:  MOVFF  5DC,01
0473C:  MOVFF  5DD,03
04740:  MOVFF  5DC,5DE
04744:  MOVFF  5DD,5DF
04748:  MOVFF  5DC,FE9
0474C:  MOVFF  5DD,FEA
04750:  MOVFF  FEC,653
04754:  MOVF   FED,F
04756:  MOVFF  FEF,652
0475A:  MOVLB  0
0475C:  CALL   1A42
04760:  MOVFF  5DF,FEA
04764:  MOVFF  5DE,FE9
04768:  MOVFF  02,FEC
0476C:  MOVF   FED,F
0476E:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
04772:  MOVLW  02
04774:  MOVLB  5
04776:  ADDWF  xDC,W
04778:  MOVWF  01
0477A:  MOVLW  00
0477C:  ADDWFC xDD,W
0477E:  MOVWF  03
04780:  MOVFF  01,5DE
04784:  MOVWF  xDF
04786:  MOVLW  02
04788:  ADDWF  xDC,W
0478A:  MOVWF  FE9
0478C:  MOVLW  00
0478E:  ADDWFC xDD,W
04790:  MOVWF  FEA
04792:  MOVFF  FEC,653
04796:  MOVF   FED,F
04798:  MOVFF  FEF,652
0479C:  MOVLB  0
0479E:  CALL   1A42
047A2:  MOVFF  5DF,FEA
047A6:  MOVFF  5DE,FE9
047AA:  MOVFF  02,FEC
047AE:  MOVF   FED,F
047B0:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
047B4:  MOVLW  06
047B6:  MOVLB  5
047B8:  ADDWF  xDC,W
047BA:  MOVWF  01
047BC:  MOVLW  00
047BE:  ADDWFC xDD,W
047C0:  MOVWF  03
047C2:  MOVFF  01,5DE
047C6:  MOVWF  xDF
047C8:  MOVLW  06
047CA:  ADDWF  xDC,W
047CC:  MOVWF  FE9
047CE:  MOVLW  00
047D0:  ADDWFC xDD,W
047D2:  MOVWF  FEA
047D4:  MOVFF  FEC,653
047D8:  MOVF   FED,F
047DA:  MOVFF  FEF,652
047DE:  MOVLB  0
047E0:  CALL   1A42
047E4:  MOVFF  5DF,FEA
047E8:  MOVFF  5DE,FE9
047EC:  MOVFF  02,FEC
047F0:  MOVF   FED,F
047F2:  MOVFF  01,FEF
047F6:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) 
....................    #include "ICMP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Control Message Protocol (ICMP) Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides "ping" diagnostics 
....................  *	 -Reference: RFC 792 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.c 
....................  * Dependencies:    IP, ARP 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #define __ICMP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... // ICMP Timeout Value 
.................... #define ICMP_TIMEOUT	(4ul*TICK_SECOND) 
....................  
.................... // ICMP Packet Structure 
.................... typedef struct 
.................... { 
.................... 	BYTE vType; 
.................... 	BYTE vCode; 
.................... 	WORD wChecksum; 
.................... 	WORD wIdentifier; 
.................... 	WORD wSequenceNumber; 
.................... 	WORD wData; 
.................... } ICMP_PACKET; 
....................  
.................... // ICMP Sequence Number 
.................... static WORD wICMPSequenceNumber; 
.................... // ICMP tick timer variable 
.................... static DWORD ICMPTimer; 
....................  
.................... // ICMP Flag structure 
.................... static struct 
.................... { 
.................... 	unsigned char bICMPInUse:1;         // Indicates that the ICMP Client is in use 
.................... 	unsigned char bReplyValid:1;        // Indicates that a correct Ping response to one of our pings was received 
.................... 	unsigned char bRemoteHostIsROM:1;   // Indicates that a remote host name was passed as a ROM pointer argument 
.................... } ICMPFlags = {0x00}; 
....................  
.................... // ICMP Static Variables 
.................... static union 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		ROM BYTE *szROM; 
.................... 		BYTE *szRAM; 
.................... 	} RemoteHost; 
.................... 	NODE_INFO ICMPRemote; 
.................... } StaticVars; 
....................  
.................... // ICMP State Machine Enumeration 
.................... static enum 
.................... { 
.................... 	SM_IDLE = 0, 
.................... 	SM_DNS_SEND_QUERY, 
.................... 	SM_DNS_GET_RESPONSE, 
.................... 	SM_ARP_SEND_QUERY, 
.................... 	SM_ARP_GET_RESPONSE, 
.................... 	SM_ICMP_SEND_ECHO_REQUEST, 
.................... 	SM_ICMP_GET_ECHO_RESPONSE 
.................... } ICMPState; 
....................  
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPProcess(void) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           *remote: Pointer to a NODE_INFO structure of the  
....................  *					ping requester 
....................  *					len: Count of how many bytes the ping header and  
....................  *					payload are in this IP packet 
....................  * 
....................  * Output:          Generates an echo reply, if requested 
....................  *					Validates and sets ICMPFlags.bReplyValid if a  
....................  *					correct ping response to one of ours is received. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPProcess(NODE_INFO *remote, WORD len) 
.................... { 
.................... 	DWORD_VAL dwVal; 
....................  
....................     // Obtain the ICMP header Type, Code, and Checksum fields 
....................     MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
*
04BEA:  MOVLW  05
04BEC:  MOVLB  5
04BEE:  MOVWF  xC7
04BF0:  MOVLW  C2
04BF2:  MOVWF  xC6
04BF4:  MOVFF  5C7,656
04BF8:  MOVFF  FE8,655
04BFC:  MOVLB  6
04BFE:  CLRF   x58
04C00:  MOVLW  04
04C02:  MOVWF  x57
04C04:  MOVLB  0
04C06:  CALL   0C28
.................... 	 
.................... 	// See if this is an ICMP echo (ping) request 
.................... 	if(dwVal.w[0] == 0x0008u) 
04C0A:  MOVLB  5
04C0C:  MOVF   xC2,W
04C0E:  SUBLW  08
04C10:  BNZ   4CCE
04C12:  MOVF   xC3,F
04C14:  BNZ   4CCE
.................... 	{ 
.................... 		// Validate the checksum using the Microchip MAC's DMA module 
.................... 		// The checksum data includes the precomputed checksum in the  
.................... 		// header, so a valid packet will always have a checksum of  
.................... 		// 0x0000 if the packet is not disturbed. 
.................... 		if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len)) 
04C16:  CLRF   xDD
04C18:  MOVLW  14
04C1A:  MOVWF  xDC
04C1C:  MOVFF  5C1,5DF
04C20:  MOVFF  5C0,5DE
04C24:  MOVLB  0
04C26:  RCALL  4A1A
04C28:  MOVF   01,W
04C2A:  IORWF  02,W
04C2C:  BZ    4C30
.................... 			return; 
04C2E:  BRA    4CCC
.................... 	 
.................... 		// Calculate new Type, Code, and Checksum values 
.................... 		dwVal.v[0] = 0x00;	// Type: 0 (ICMP echo/ping reply) 
04C30:  MOVLB  5
04C32:  CLRF   xC2
.................... 		dwVal.v[2] += 8;	// Subtract 0x0800 from the checksum 
04C34:  MOVLW  08
04C36:  ADDWF  xC4,F
.................... 		if(dwVal.v[2] < 8u) 
04C38:  MOVF   xC4,W
04C3A:  SUBLW  07
04C3C:  BNC   4C46
.................... 		{ 
.................... 			dwVal.v[3]++; 
04C3E:  INCF   xC5,F
.................... 			if(dwVal.v[3] == 0u) 
04C40:  MOVF   xC5,F
04C42:  BNZ   4C46
.................... 				dwVal.v[2]++; 
04C44:  INCF   xC4,F
.................... 		} 
.................... 	 
.................... 	    // Wait for TX hardware to become available (finish transmitting  
.................... 	    // any previous packet) 
.................... 	    while(!IPIsTxReady()); 
04C46:  MOVLB  0
04C48:  CALL   17A4
04C4C:  MOVF   01,F
04C4E:  BZ    4C48
....................  
.................... 		// Position the write pointer for the next IPPutHeader operation 
.................... 		// NOTE: do not put this before the IPIsTxReady() call for WF compatbility 
.................... 	    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
04C50:  MOVLW  11
04C52:  MOVLB  6
04C54:  MOVWF  x43
04C56:  MOVLW  E5
04C58:  MOVWF  x42
04C5A:  MOVLB  0
04C5C:  CALL   0B16
....................         	 
.................... 		// Create IP header in TX memory 
.................... 		IPPutHeader(remote, IP_PROT_ICMP, len); 
04C60:  MOVFF  5BF,634
04C64:  MOVFF  5BE,633
04C68:  MOVLW  01
04C6A:  MOVLB  6
04C6C:  MOVWF  x35
04C6E:  MOVFF  5C1,637
04C72:  MOVFF  5C0,636
04C76:  MOVLB  0
04C78:  CALL   1CCC
.................... 	 
.................... 		// Copy ICMP response into the TX memory 
.................... 		MACPutArray((BYTE*)&dwVal, sizeof(dwVal)); 
04C7C:  MOVLW  05
04C7E:  MOVLB  5
04C80:  MOVWF  xC7
04C82:  MOVLW  C2
04C84:  MOVWF  xC6
04C86:  MOVFF  5C7,658
04C8A:  MOVFF  FE8,657
04C8E:  MOVLB  6
04C90:  CLRF   x5A
04C92:  MOVLW  04
04C94:  MOVWF  x59
04C96:  MOVLB  0
04C98:  CALL   0B7E
.................... 		MACMemCopyAsync(-1, -1, len-4); 
04C9C:  MOVLW  04
04C9E:  MOVLB  5
04CA0:  SUBWF  xC0,W
04CA2:  MOVWF  xC6
04CA4:  MOVLW  00
04CA6:  SUBWFB xC1,W
04CA8:  MOVWF  xC7
04CAA:  MOVLB  6
04CAC:  SETF   x43
04CAE:  SETF   x42
04CB0:  SETF   x45
04CB2:  SETF   x44
04CB4:  MOVWF  x47
04CB6:  MOVFF  5C6,646
04CBA:  MOVLB  0
04CBC:  CALL   0CC8
.................... 		while(!MACIsMemCopyDone()); 
04CC0:  CALL   0F56
04CC4:  MOVF   01,F
04CC6:  BZ    4CC0
.................... 	 
.................... 		// Transmit the echo reply packet 
.................... 	    MACFlush(); 
04CC8:  CALL   1DB6
04CCC:  MOVLB  5
.................... 	} 
.................... #if defined(STACK_USE_ICMP_CLIENT) 
04CCE:  MOVLB  0
04CD0:  GOTO   6DA0 (RETURN)
.................... 	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request 
.................... 	{ 
.................... 		// Get the sequence number and identifier fields 
.................... 		MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
.................... 		 
.................... 		// See if the identifier matches the one we sent 
.................... 		if(dwVal.w[0] != 0xEFBE)	 
.................... 			return; 
.................... 	 
.................... 		if(dwVal.w[1] != wICMPSequenceNumber) 
.................... 			return; 
....................  
.................... 		// Validate the ICMP checksum field 
.................... 	    IPSetRxBuffer(0); 
.................... 		if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))	// Two bytes of payload were sent in the echo request 
.................... 			return; 
.................... 		 
.................... 		// Flag that we received the response and stop the timer ticking 
.................... 		ICMPFlags.bReplyValid = 1; 
.................... 		ICMPTimer = TickGet() - ICMPTimer; 
.................... 	} 
.................... #endif 
.................... } 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPing(DWORD dwRemoteIP) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           dwRemoteIP: IP Address to ping.  Must be stored  
....................  *								big endian.  Ex. 192.168.0.1 should be 
....................  *								passed as 0x0100A8C0. 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPing(DWORD dwRemoteIP) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	StaticVars.ICMPRemote.IPAddr.Val = dwRemoteIP; 
.................... 	ICMPState = SM_ARP_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHost (BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in RAM if being called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 0; 
.................... 	StaticVars.RemoteHost.szRAM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(__18CXX) 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHostROM (ROM BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in ROM. Should only be called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 1; 
.................... 	StaticVars.RemoteHost.szROM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #endif 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        LONG ICMPGetReply(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE and ICMPSendPing()  
....................  *					was called 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          -3: Could not resolve hostname (DNS timeout or  
....................  *			    	    hostname invalid) 
....................  *					-2: No response received yet 
....................  *					-1: Operation timed out (longer than ICMP_TIMEOUT)  
....................  *						has elapsed. 
....................  *					>=0: Number of TICKs that elapsed between  
....................  *						 initial ICMP transmission and reception of  
....................  *						 a valid echo. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... LONG ICMPGetReply(void) 
.................... { 
.................... 	ICMP_PACKET ICMPPacket; 
....................  
.................... 	switch(ICMPState) 
.................... 	{ 
.................... #if defined(STACK_USE_DNS) 
.................... 		case SM_DNS_SEND_QUERY: 
.................... 			// Obtain DNS module ownership 
.................... 			if(!DNSBeginUsage()) 
.................... 				break; 
.................... 			 
.................... 			// Send DNS query 
.................... 			if(ICMPFlags.bRemoteHostIsROM) 
.................... 				DNSResolveROM(StaticVars.RemoteHost.szROM, DNS_TYPE_A); 
.................... 			else 
.................... 				DNSResolve(StaticVars.RemoteHost.szRAM, DNS_TYPE_A); 
.................... 			 
.................... 			ICMPState = SM_DNS_GET_RESPONSE; 
.................... 			break; 
.................... 				 
.................... 		case SM_DNS_GET_RESPONSE: 
.................... 			// See if DNS is done, and if so, get the remote IP address 
.................... 			if(!DNSIsResolved(&StaticVars.ICMPRemote.IPAddr)) 
.................... 				break; 
.................... 			 
.................... 			// Free the DNS module 
.................... 			DNSEndUsage(); 
.................... 			 
.................... 			// Return error code if the DNS query failed 
.................... 			if(StaticVars.ICMPRemote.IPAddr.Val == 0x00000000ul) 
.................... 			{ 
.................... 				ICMPState = SM_IDLE; 
.................... 				return -3; 
.................... 			} 
....................  
.................... 			ICMPState = SM_ARP_SEND_QUERY;	 
.................... 			// No break;	 
.................... #endif 
....................  
.................... 		case SM_ARP_SEND_QUERY: 
.................... 			ARPResolve(&StaticVars.ICMPRemote.IPAddr); 
.................... 			ICMPState = SM_ARP_GET_RESPONSE; 
.................... 			break; 
.................... 			 
.................... 		case SM_ARP_GET_RESPONSE: 
.................... 			// See if the ARP reponse was successfully received 
.................... 			if(!ARPIsResolved(&StaticVars.ICMPRemote.IPAddr, &StaticVars.ICMPRemote.MACAddr)) 
.................... 				break; 
.................... 			 
.................... 			ICMPState = SM_ICMP_SEND_ECHO_REQUEST; 
.................... 			// No break;  
.................... 		 
.................... 		case SM_ICMP_SEND_ECHO_REQUEST: 
.................... 		    if(!IPIsTxReady()) 
.................... 		    	break; 
....................  
.................... 			// Set up the ping packet 
.................... 			ICMPPacket.vType = 0x08;	// 0x08: Echo (ping) request 
.................... 			ICMPPacket.vCode = 0x00; 
.................... 			ICMPPacket.wChecksum = 0x0000; 
.................... 			ICMPPacket.wIdentifier = 0xEFBE; 
.................... 			wICMPSequenceNumber++;  
.................... 			ICMPPacket.wSequenceNumber = wICMPSequenceNumber; 
.................... 			ICMPPacket.wData = 0x2860; 
.................... 			ICMPPacket.wChecksum = CalcIPChecksum((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 		 
.................... 			// Record the current time.  This will be used as a basis for  
.................... 			// finding the echo response time, which exludes the ARP and DNS  
.................... 			// steps 
.................... 			ICMPTimer = TickGet(); 
....................  
.................... 			// Position the write pointer for the next IPPutHeader operation 
.................... 		    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
.................... 		 
.................... 			// Create IP header in TX memory 
.................... 			IPPutHeader(&StaticVars.ICMPRemote, IP_PROT_ICMP, sizeof(ICMPPacket)); 
.................... 			MACPutArray((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 			MACFlush(); 
....................  
.................... 			// Echo sent, advance state 
.................... 			ICMPState = SM_ICMP_GET_ECHO_RESPONSE; 
.................... 			break; 
....................  
.................... 		case SM_ICMP_GET_ECHO_RESPONSE: 
.................... 			// See if the echo was successfully received 
.................... 			if(ICMPFlags.bReplyValid) 
.................... 				return (LONG)ICMPTimer; 
.................... 		 
.................... 			break; 
.................... 		 
.................... 		// SM_IDLE or illegal/impossible state: 
.................... 		default: 
.................... 			return -1; 
.................... 	} 
....................  
.................... 	// See if the DNS/ARP/echo request timed out 
.................... 	if(TickGet() - ICMPTimer > ICMP_TIMEOUT) 
.................... 	{ 
.................... 		// Free DNS module if we have it in use 
.................... 		#if defined(STACK_USE_DNS) 
.................... 			if(ICMPState == SM_DNS_GET_RESPONSE) 
.................... 				DNSEndUsage(); 
.................... 		#endif 
.................... 		 
.................... 		// Stop ICMP echo test and return error to caller 
.................... 		ICMPState = SM_IDLE; 
.................... 		return -1; 
.................... 	} 
....................  
.................... 	// Still working.  No response to report yet. 
.................... 	return -2; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPBeginUsage(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: You have successfully gained ownership of  
....................  *						  the ICMP client module and can now use the  
....................  *						  ICMPSendPing() and ICMPGetReply() functions. 
....................  *					FALSE: Some other application is using the ICMP  
....................  *						   client module.  Calling ICMPSendPing()  
....................  *						   will corrupt the other application's ping  
....................  *						   result. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Claims ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPBeginUsage(void) 
.................... { 
.................... 	if(ICMPFlags.bICMPInUse) 
.................... 		return FALSE; 
....................  
.................... 	ICMPFlags.bICMPInUse = TRUE; 
.................... 	return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPEndUsage(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() was called by you and it  
....................  *					returned TRUE. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Your ownership of the ICMP module is released.   
....................  *					You can no longer use ICMPSendPing(). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Gives up ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPEndUsage(void) 
.................... { 
.................... 	ICMPFlags.bICMPInUse = FALSE; 
.................... } 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   User Datagram Protocol (UDP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides unreliable, minimum latency transport of application  
....................  *    datagram (packet) oriented data 
....................  *    -Reference: RFC 768 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.c 
....................  * Dependencies:    IP, Ethernet (ENC28J60.c or ETH97J60.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/26/03  Fixed UDPGet and UDPProcess bugs 
....................  *                               as discovered and fixed by John Owen 
....................  *                               of Powerwave. 
....................  *                               1. UDPGet would return FALSE on last good byte 
....................  *                               2. UDPProcess was incorrectly calculating length. 
....................  * Nilesh Rajbharti     5/19/03  Added bFirstRead flag similar to TCP 
....................  *                               to detect very first UDPGet and 
....................  *                               reset MAC Rx pointer to begining of 
....................  *                               UDP data area.  This would ensure that 
....................  *                               if UDP socket has pending Rx data and 
....................  *                               another module resets MAC Rx pointer, 
....................  *                               next UDP socket Get would get correct 
....................  *                               data. 
....................  * Robert Sloan (RSS)    5/29/03 Improved FindMatchingSocket() 
....................  * Nilesh Rajbharti     12/2/03  Added UDPChecksum logic in UDPProcess() 
....................  * Nilesh Rajbharti     12/5/03  Modified UDPProcess() and FindMatchingSocket() 
....................  *                               to include localIP as new parameter. 
....................  *                               This corrects pseudo header checksum 
....................  *                               logic in UDPProcess(). 
....................  *                               It also corrects broadcast packet 
....................  *                               matching correct in FindMatchingSocket(). 
....................  * Howard Schlunder      1/16/06    Fixed an imporbable RX checksum bug  
....................  *                         when using a Microchip Ethernet controller) 
....................  * Howard Schlunder      6/02/06    Fixed a bug where all RXed UDP packets  
....................  *                         without a checksum (0x0000) were thrown 
....................  *                         away.  No checksum is legal in UDP. 
....................  * Howard Schlunder      8/10/06    Fixed a bug where UDP sockets would  
....................  *                         unintentionally keep the remote MAC  
....................  *                         address cached, even after calling  
....................  *                         UDPInit(), UDPClose(), or reseting  
....................  *                         the part without clearing all the  
....................  *                         PIC memory. 
....................  ********************************************************************/ 
.................... #define __UDP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // First port number for randomized local port number selection 
.................... #define LOCAL_UDP_PORT_START_NUMBER (4096u) 
....................  
.................... // Last port number for randomized local port number selection 
.................... #define LOCAL_UDP_PORT_END_NUMBER   (8192u) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    UDP Global Variables 
....................   ***************************************************************************/ 
....................  
.................... // Stores an array of information pertaining to each UDP socket 
.................... UDP_SOCKET_INFO      UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
.................... // Indicates which UDP socket is currently active 
.................... UDP_SOCKET         activeUDPSocket; 
....................  
.................... WORD UDPTxCount;   // Number of bytes written to this UDP segment 
.................... WORD UDPRxCount;   // Number of bytes read from this UDP segment 
.................... static UDP_SOCKET   LastPutSocket = INVALID_UDP_SOCKET;   // Indicates the last socket to which data was written 
.................... static WORD wPutOffset;      // Offset from beginning of payload where data is to be written. 
.................... static WORD wGetOffset;      // Offset from beginning of payload from where data is to be read. 
....................  
.................... // Stores various flags for the UDP module 
.................... static struct 
.................... { 
....................    unsigned char bFirstRead : 1;      // No data has been read from this segment yet 
....................    unsigned char bWasDiscarded : 1;   // The data in this segment has been discarded 
.................... } Flags; 
....................  
.................... // Indicates which socket has currently received data for this loop 
.................... static UDP_SOCKET SocketWithRxData = INVALID_UDP_SOCKET; 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, NODE_INFO *remoteNode, 
....................                                     IP_ADDR *localIP); 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPInit(void) 
....................  
....................   Summary: 
....................    Initializes the UDP module. 
....................  
....................   Description: 
....................    Initializes the UDP module.  This function initializes all the UDP  
....................    sockets to the closed state. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void UDPInit(void) 
.................... { 
....................     UDP_SOCKET s; 
....................  
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
*
00A38:  MOVLB  5
00A3A:  CLRF   xB5
00A3C:  MOVF   xB5,W
00A3E:  SUBLW  06
00A40:  BNC   0A50
....................     { 
....................       UDPClose(s); 
00A42:  MOVFF  5B5,5C0
00A46:  MOVLB  0
00A48:  RCALL  09B4
00A4A:  MOVLB  5
00A4C:  INCF   xB5,F
00A4E:  BRA    0A3C
....................     } 
....................    Flags.bWasDiscarded = 1; 
00A50:  MOVLB  1
00A52:  BSF    x3C.1
00A54:  MOVLB  0
00A56:  GOTO   1554 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
.................... Function: 
....................    UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort, 
....................    UDP_PORT remotePort) 
....................  
....................  Summary: 
....................     Opens a UDP socket for a client. 
....................  
....................  Description: 
....................     Provides a unified method for opening UDP sockets. This function can open both client and  
....................     server   sockets. For client sockets, it can accept a host name string to query in DNS, an IP 
....................     address as a string, an IP address in binary form, or a previously resolved NODE_INFO  
....................     structure containing the remote IP address and associated MAC address. When a host name 
....................     or IP address only is provided, UDP module will internally perform the necessary DNSResolve 
....................     and/or ARP resolution steps before reporting that the UDP socket is connected (via a call to 
....................     UDPISOpen returning TRUE). Server sockets ignore this destination parameter and listen  
....................     only on the indicated port.   Sockets are statically allocated on boot, but can be claimed with 
....................     this function and freed using UDPClose . 
....................  
.................... Conditions: 
.................... UDPInit should be called. 
....................  
.................... Input: 
....................     remoteHost -     Pointer to remote node info (MAC and IP address) for this connection.   
....................     If this is a     server socket (receives the first packet) or the destination is the broadcast  
....................     address, then this parameter should be NULL. For client sockets only. Provide a pointer to 
....................     a null-terminated string of the remote host name (ex\:"www.microchip.com" or  
....................     "192.168.1.123"), a literal destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR data type), 
....................     or a pointer to a NODE_INFO structure with the remote IP address and remote node or gateway 
....................     MAC address specified, If a string is provided. 
....................      
....................     remoteHostType - Any one of the following flags to identify the meaning of the remoteHost parameter: 
....................        - UDP_OPEN_SERVER   = Open a server socket and ignore the remoteHost parameter.  
....................           (e.g. - SNMP agent, DHCP server, Announce) 
....................        - UDP_OPEN_IP_ADDRESS = Open a client socket and connect it to a remote IP address. 
....................           Ex: 0x7B01A8C0 for 192.168.1.123 (DWORD type). Note that the byte ordering is big endian. 
....................        - UDP_OPEN_NODE_INFO = Open a client socket and connect it to a remote IP and MAC  
....................           addresses pair stored in a NODE_INFO structure. 
....................         - UDP_OPEN_RAM_HOST = Open a client socket and connect it to a remote host who's  
....................            name is stored as a null terminated string in a RAM array. Ex:"www.microchip.com" or 
....................            "192.168.0.123" 
....................         - UDP_OPEN_ROM_HOST = Open a client socket and connect it to a remote host who's 
....................            name is stored as a null terminated string in a literal string or ROM array. Ex:  
....................            "www.microchip.com" or "192.168.0.123"  
....................  
....................     localPort - UDP port number to listen on.  If 0, stack will dynamically assign a unique port  
....................     number to use. 
....................  
....................     remotePort - For client sockets, the remote port number. 
....................  
.................... Return Values: 
....................      Success -  
....................       A UDP socket handle that can be used for subsequent UDP API calls. 
....................    Failure - 
....................       INVALID_UDP_SOCKET.  This function fails when no more UDP socket 
....................       handles are available.  Increase MAX_UDP_SOCKETS to make more sockets    available. 
.................... Remarks: 
....................    When finished using the UDP socket handle, call the UDPClose() function to free the  
....................    socket and delete the handle. 
....................  
.................... *****************************************************************************/ 
.................... UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort, 
....................       UDP_PORT remotePort) 
.................... { 
....................    UDP_SOCKET s; 
....................    UDP_SOCKET_INFO *p; 
....................  
....................    // Local temp port numbers. 
....................    static WORD NextPort __attribute__((persistent)); 
....................  
....................  
....................    p = UDPSocketInfo; 
*
01648:  MOVLB  5
0164A:  CLRF   xCA
0164C:  MOVLW  53
0164E:  MOVWF  xC9
....................    for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
01650:  CLRF   xC8
01652:  MOVF   xC8,W
01654:  SUBLW  06
01656:  BTFSS  FD8.0
01658:  BRA    179C
....................    { 
....................       if(p->localPort == INVALID_UDP_PORT) 
0165A:  MOVLW  0C
0165C:  ADDWF  xC9,W
0165E:  MOVWF  FE9
01660:  MOVLW  00
01662:  ADDWFC xCA,W
01664:  MOVWF  FEA
01666:  MOVFF  FEC,5CC
0166A:  MOVF   FED,F
0166C:  MOVFF  FEF,5CB
01670:  MOVF   xCB,F
01672:  BTFSS  FD8.2
01674:  BRA    1790
01676:  MOVF   xCC,F
01678:  BTFSS  FD8.2
0167A:  BRA    1790
....................       { 
....................           p->localPort = localPort;   
0167C:  MOVLW  0C
0167E:  ADDWF  xC9,W
01680:  MOVWF  FE9
01682:  MOVLW  00
01684:  ADDWFC xCA,W
01686:  MOVWF  FEA
01688:  MOVFF  5C5,FEC
0168C:  MOVF   FED,F
0168E:  MOVFF  5C4,FEF
....................          if(localPort == 0x0000u) 
01692:  MOVF   xC4,F
01694:  BNZ   16DC
01696:  MOVF   xC5,F
01698:  BNZ   16DC
....................             { 
....................             if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER) 
0169A:  MOVLB  1
0169C:  MOVF   x3F,W
0169E:  SUBLW  1F
016A0:  BC    16AC
016A2:  XORLW  FF
016A4:  BNZ   16B2
016A6:  MOVF   x3E,W
016A8:  SUBLW  00
016AA:  BNC   16B2
016AC:  MOVF   x3F,W
016AE:  SUBLW  0F
016B0:  BNC   16B8
....................                NextPort = LOCAL_UDP_PORT_START_NUMBER; 
016B2:  MOVLW  10
016B4:  MOVWF  x3F
016B6:  CLRF   x3E
....................  
....................             p->localPort    = NextPort++; 
016B8:  MOVLW  0C
016BA:  MOVLB  5
016BC:  ADDWF  xC9,W
016BE:  MOVWF  FE9
016C0:  MOVLW  00
016C2:  ADDWFC xCA,W
016C4:  MOVWF  FEA
016C6:  MOVLB  1
016C8:  MOVFF  13F,03
016CC:  MOVF   x3E,W
016CE:  INCF   x3E,F
016D0:  BTFSC  FD8.2
016D2:  INCF   x3F,F
016D4:  MOVWF  FEF
016D6:  MOVFF  03,FEC
016DA:  MOVLB  5
....................             } 
....................          if((remoteHostType == UDP_OPEN_SERVER) || (remoteHost == 0)) 
016DC:  MOVF   xC3,F
016DE:  BZ    16F0
016E0:  MOVF   xBF,F
016E2:  BNZ   1726
016E4:  MOVF   xC0,F
016E6:  BNZ   1726
016E8:  MOVF   xC1,F
016EA:  BNZ   1726
016EC:  MOVF   xC2,F
016EE:  BNZ   1726
....................          { 
....................               //Set remote node as 0xFF ( broadcast address) 
....................               // else Set broadcast address 
....................               memset((void*)&p->remote.remoteNode, 0xFF, sizeof(p->remote)); 
016F0:  MOVFF  5CA,03
016F4:  MOVFF  5C9,5CB
016F8:  MOVFF  5CA,5CC
016FC:  MOVFF  5CA,FEA
01700:  MOVFF  5C9,FE9
01704:  SETF   00
01706:  CLRF   02
01708:  MOVLW  0A
0170A:  MOVWF  01
0170C:  MOVLB  0
0170E:  CALL   0A5A
....................               p->smState = UDP_OPENED; 
01712:  MOVLW  0E
01714:  MOVLB  5
01716:  ADDWF  xC9,W
01718:  MOVWF  FE9
0171A:  MOVLW  00
0171C:  ADDWFC xCA,W
0171E:  MOVWF  FEA
01720:  MOVLW  05
01722:  MOVWF  FEF
....................          } 
01724:  BRA    1770
....................          else 
....................          { 
....................             switch(remoteHostType) 
01726:  MOVF   xC3,W
01728:  XORLW  04
0172A:  MOVLB  0
0172C:  BZ    1730
0172E:  BRA    176E
....................             { 
.................... #if defined (STACK_CLIENT_MODE) 
.................... #if defined (STACK_USE_DNS) 
....................                case UDP_OPEN_RAM_HOST: 
....................                case UDP_OPEN_ROM_HOST: 
....................                   //set the UDP state to UDP_GET_DNS_MODULE 
....................                   p->remote.remoteHost = remoteHost; 
....................                   p->flags.bRemoteHostIsROM = (remoteHostType == UDP_OPEN_ROM_HOST); 
....................                   p->smState = UDP_DNS_RESOLVE; 
....................                break; 
.................... #endif 
....................                case UDP_OPEN_IP_ADDRESS: 
....................                // remoteHost is a literal IP address.   This doesn't need DNS and can skip directly to the Gateway ARPing step.     
....................                //Next UDP state UDP_GATEWAY_SEND_ARP; 
....................                p->remote.remoteNode.IPAddr.Val = remoteHost; 
....................                p->retryCount = 0; 
....................                p->retryInterval = (TICK_SECOND/4)/256; 
....................                p->smState = UDP_GATEWAY_SEND_ARP; 
....................                break; 
.................... #endif                   
....................                case UDP_OPEN_NODE_INFO: 
....................                //skip DNS and ARP resolution steps if connecting to a remote node which we've already 
....................                   memcpy((void*)(BYTE*)&p->remote,(void*)(BYTE*)(PTR_BASE)remoteHost,sizeof(p->remote)); 
01730:  MOVLB  5
01732:  MOVFF  5CA,03
01736:  MOVFF  5C9,5CB
0173A:  MOVFF  5CA,5CC
0173E:  MOVFF  5CA,FEA
01742:  MOVFF  5C9,FE9
01746:  MOVFF  5C0,FE2
0174A:  MOVFF  5BF,FE1
0174E:  MOVLW  0A
01750:  MOVWF  01
01752:  MOVFF  FE6,FEE
01756:  DECFSZ 01,F
01758:  BRA    1752
....................                   p->smState = UDP_OPENED; 
0175A:  MOVLW  0E
0175C:  ADDWF  xC9,W
0175E:  MOVWF  FE9
01760:  MOVLW  00
01762:  ADDWFC xCA,W
01764:  MOVWF  FEA
01766:  MOVLW  05
01768:  MOVWF  FEF
....................                // CALL UDPFlushto transmit incluind peding data. 
....................                break; 
0176A:  BRA    1770
0176C:  MOVLB  0
....................                default: 
....................                   break; 
0176E:  MOVLB  5
....................             } 
....................          } 
....................          p->remotePort   = remotePort; 
01770:  MOVLW  0A
01772:  ADDWF  xC9,W
01774:  MOVWF  FE9
01776:  MOVLW  00
01778:  ADDWFC xCA,W
0177A:  MOVWF  FEA
0177C:  MOVFF  5C7,FEC
01780:  MOVF   FED,F
01782:  MOVFF  5C6,FEF
....................  
....................          // Mark this socket as active. 
....................          // Once an active socket is set, subsequent operation can be 
....................          // done without explicitely supply socket identifier. 
....................          activeUDPSocket = s; 
01786:  MOVFF  5C8,52
....................          return s; 
0178A:  MOVFF  5C8,01
0178E:  BRA    17A0
....................       } 
....................       p++; 
01790:  MOVLW  17
01792:  ADDWF  xC9,F
01794:  BTFSC  FD8.0
01796:  INCF   xCA,F
01798:  INCF   xC8,F
0179A:  BRA    1652
....................    } 
....................  
....................    return (UDP_SOCKET)INVALID_UDP_SOCKET; 
0179C:  MOVLW  FF
0179E:  MOVWF  01
017A0:  MOVLB  0
017A2:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... /****************************************************************************** 
.................... Function: 
....................    void UDPTask(void) 
....................  
....................   Summary: 
....................      Performs periodic UDP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic UDP tasks.  Each socket's state machine is  
....................    checked, and any elapsed timeout periods are handled. 
....................  
....................   Precondition: 
....................    UDP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................  
.................... ******************************************************************************/ 
.................... void UDPTask(void) 
.................... { 
....................    UDP_SOCKET ss; 
....................     
....................    for ( ss = 0; ss < MAX_UDP_SOCKETS; ss++ ) 
*
04556:  MOVLB  5
04558:  CLRF   xBE
0455A:  MOVF   xBE,W
0455C:  SUBLW  06
0455E:  BNC   45DA
....................    { 
....................  
....................       // need to put Extra check if UDP has opened or NOT 
....................  
....................       if((UDPSocketInfo[ss].smState == UDP_OPENED) || 
....................          (UDPSocketInfo[ss].smState == UDP_CLOSED)) 
04560:  MOVF   xBE,W
04562:  MULLW  17
04564:  MOVF   FF3,W
04566:  CLRF   xC0
04568:  MOVWF  xBF
0456A:  MOVLW  0E
0456C:  ADDWF  xBF,W
0456E:  MOVWF  01
04570:  MOVLW  00
04572:  ADDWFC xC0,W
04574:  MOVWF  03
04576:  MOVF   01,W
04578:  ADDLW  53
0457A:  MOVWF  FE9
0457C:  MOVLW  00
0457E:  ADDWFC 03,W
04580:  MOVWF  FEA
04582:  MOVF   FEF,W
04584:  SUBLW  05
04586:  BZ    45B0
04588:  MOVF   xBE,W
0458A:  MULLW  17
0458C:  MOVF   FF3,W
0458E:  CLRF   xC0
04590:  MOVWF  xBF
04592:  MOVLW  0E
04594:  ADDWF  xBF,W
04596:  MOVWF  01
04598:  MOVLW  00
0459A:  ADDWFC xC0,W
0459C:  MOVWF  03
0459E:  MOVF   01,W
045A0:  ADDLW  53
045A2:  MOVWF  FE9
045A4:  MOVLW  00
045A6:  ADDWFC 03,W
045A8:  MOVWF  FEA
045AA:  MOVF   FEF,W
045AC:  SUBLW  04
045AE:  BNZ   45B2
....................          continue; 
045B0:  BRA    45D6
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(UDPSocketInfo[ss].smState) 
045B2:  MOVF   xBE,W
045B4:  MULLW  17
045B6:  MOVF   FF3,W
045B8:  CLRF   xC0
045BA:  MOVWF  xBF
045BC:  MOVLW  0E
045BE:  ADDWF  xBF,W
045C0:  MOVWF  01
045C2:  MOVLW  00
045C4:  ADDWFC xC0,W
045C6:  MOVWF  03
045C8:  MOVF   01,W
045CA:  ADDLW  53
045CC:  MOVWF  FE9
045CE:  MOVLW  00
045D0:  ADDWFC 03,W
045D2:  MOVWF  FEA
045D4:  MOVF   FEF,W
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case UDP_DNS_RESOLVE: 
....................          if(DNSBeginUsage()) 
....................          { 
....................             // call DNS Resolve function and move to UDP next State machine 
....................             UDPSocketInfo[ss].smState = UDP_DNS_IS_RESOLVED; 
....................             if(UDPSocketInfo[ss].flags.bRemoteHostIsROM) 
....................                DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A); 
....................             else 
....................                DNSResolve((BYTE*)(PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A); 
....................          } 
....................          break;             
....................          case UDP_DNS_IS_RESOLVED: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................             // See if DNS resolution has finished.   Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................              
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
....................             { 
....................                if(DNSEndUsage()) 
....................                { 
....................                   UDPSocketInfo[ss].remote.remoteNode.IPAddr.Val = ipResolvedDNSIP.Val; 
....................                   UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP; 
....................                   UDPSocketInfo[ss].retryCount = 0; 
....................                   UDPSocketInfo[ss].retryInterval = (TICK_SECOND/4)/256; 
....................                } 
....................                else 
....................                { 
....................                   UDPSocketInfo[ss].smState = UDP_DNS_RESOLVE; 
....................                } 
....................             }          
....................          } 
....................          break; 
....................          #endif // #if defined(STACK_USE_DNS) 
....................  
....................          case UDP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address  
....................             //(either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             UDPSocketInfo[ss].eventTime = (WORD)TickGetDiv256(); 
....................             ARPResolve(&UDPSocketInfo[ss].remote.remoteNode.IPAddr); 
....................             UDPSocketInfo[ss].smState = UDP_GATEWAY_GET_ARP; 
....................             break; 
....................  
....................          case UDP_GATEWAY_GET_ARP: 
....................          if(!ARPIsResolved(&UDPSocketInfo[ss].remote.remoteNode.IPAddr,  
....................                         &UDPSocketInfo[ss].remote.remoteNode.MACAddr)) 
....................          { 
....................             // Time out if too much time is spent in this state 
....................             // Note that this will continuously send out ARP  
....................             // requests for an infinite time if the Gateway  
....................             // never responds 
....................             if((WORD)TickGetDiv256() - UDPSocketInfo[ss].eventTime> (WORD)UDPSocketInfo[ss].retryInterval) 
....................             { 
....................                // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                if(UDPSocketInfo[ss].retryCount < 6u) 
....................                { 
....................                   UDPSocketInfo[ss].retryCount++; 
....................                   UDPSocketInfo[ss].retryInterval <<= 1; 
....................                } 
....................                // Retransmit ARP request 
....................                UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP; 
....................             }             
....................          } 
....................          else 
....................          { 
....................             UDPSocketInfo[ss].smState = UDP_OPENED; 
....................          } 
....................          break; 
....................          default: 
....................          case UDP_OPENED: 
....................          case UDP_CLOSED: 
....................          // not used 
....................          break; 
.................... #endif // #if defined(STACK_CLIENT_MODE) 
....................       } 
045D6:  INCF   xBE,F
045D8:  BRA    455A
....................    } 
045DA:  MOVLB  0
045DC:  GOTO   6C94 (RETURN)
.................... }  
....................  
.................... /****************************************************************************** 
....................   
....................   Function: 
....................      BOOL UDPISOpened(UDP_SOCKET socket) 
....................    
....................  Summary: 
....................      Determines if a socket has an established connection. 
....................  
....................  Description: 
....................    This function determines if a socket has an established connection to a remote node .   
....................    Call this function after calling UDPOpen to determine when the connection is set up  
....................    and ready for use.   
....................  
....................  Precondition: 
....................    UDP is initialized. 
....................  
....................  Parameters: 
....................    socket - The socket to check. 
....................  
....................  Return Values: 
....................    TRUE - The socket has been opened and ARP has been resolved. 
....................    FALSE - The socket is not currently connected. 
....................  
....................  Remarks: 
....................    None 
....................   
....................  *****************************************************************************/ 
.................... BOOL UDPIsOpened(UDP_SOCKET socket) 
.................... { 
....................    return (UDPSocketInfo[socket].smState == UDP_OPENED); 
.................... } 
....................  
....................  
.................... #if 0 
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPTask(void) 
....................  
....................   Summary: 
....................    Performs state management and housekeeping for UDP. 
....................     
....................   Description: 
....................    Performs state management and housekeeping for UDP.  This is an internal 
....................    function meant to be called by StackTask() (not a user API). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      None 
....................       
....................   Remarks: 
....................    UDPTask() is called once per StackTask() iteration to ensure that calls  
....................    to UDPIsPutReady() always update the Ethernet Write pointer location  
....................    between StackTask() iterations. 
....................   ***************************************************************************/ 
.................... void UDPTask(void) 
.................... { 
....................    LastPutSocket = INVALID_UDP_SOCKET; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode,  
....................                   UDP_PORT remotePort) 
....................  
....................   Summary: 
....................    Creates a UDP socket handle for transmiting or receiving UDP packets. 
....................     
....................   Description: 
....................    Creates a UDP socket handle for transmiting or receiving UDP packets.   
....................    Call this function to obtain a handle required by other UDP function. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    localPort - UDP port number to listen on.  If 0, stack will dynamically  
....................       assign a unique port number to use. 
....................    remoteNode - Pointer to remote node info (MAC and IP address) for this 
....................       connection.  If this is a server socket (receives the first packet)  
....................       or the destination is the broadcast address, then this parameter 
....................       should be NULL. 
....................    remotePort - For client sockets, the remote port number. 
....................  
....................   Return Values: 
....................      Success - 
....................       A UDP socket handle that can be used for subsequent UDP API calls. 
....................    Failure - 
....................       INVALID_UDP_SOCKET.  This function fails when no more UDP socket  
....................       handles are available.  Increase MAX_UDP_SOCKETS to make more sockets  
....................       available. 
....................       
....................   Remarks: 
....................    When finished using the UDP socket handle, call the UDPClose() function  
....................    to free the socket and delete the handle. 
....................   ***************************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort) 
.................... { 
....................     UDP_SOCKET s; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................    // Local temp port numbers. 
....................    static WORD NextPort __attribute__((persistent)); 
....................  
....................  
....................     p = UDPSocketInfo; 
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
....................     { 
....................         if(p->localPort == INVALID_UDP_PORT) 
....................         { 
....................          p->localPort = localPort;    
....................  
....................          if(localPort == 0x0000u) 
....................          { 
....................             if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER) 
....................                NextPort = LOCAL_UDP_PORT_START_NUMBER; 
....................     
....................                p->localPort    = NextPort++; 
....................          } 
....................  
....................             // If remoteNode is supplied, remember it. 
....................             if(remoteNode) 
....................             { 
....................                 memcpy((void*)&p->remoteNode, 
....................                         (const void*)remoteNode, 
....................                         sizeof(p->remoteNode)); 
....................             } 
....................             else 
....................          { 
....................             // else Set broadcast address 
....................             memset((void*)&p->remoteNode, 0xFF, sizeof(p->remoteNode)); 
....................          } 
....................  
....................             p->remotePort   = remotePort; 
....................  
....................             // Mark this socket as active. 
....................             // Once an active socket is set, subsequent operation can be 
....................             // done without explicitely supply socket identifier. 
....................             activeUDPSocket = s; 
....................             return s; 
....................         } 
....................         p++; 
....................     } 
....................  
....................     return (UDP_SOCKET)INVALID_UDP_SOCKET; 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPClose(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Closes a UDP socket and frees the handle. 
....................     
....................   Description: 
....................    Closes a UDP socket and frees the handle.  Call this function to release 
....................    a socket and return it to the pool for use by future communications. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket handle to be released.  If an illegal handle value is  
....................       provided, the function safely does nothing. 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function does not affect the previously designated active socket. 
....................   ***************************************************************************/ 
.................... void UDPClose(UDP_SOCKET s) 
.................... { 
....................    if(s >= MAX_UDP_SOCKETS) 
*
009B4:  MOVLB  5
009B6:  MOVF   xC0,W
009B8:  SUBLW  06
009BA:  BC    09BE
....................       return; 
009BC:  BRA    0A34
....................  
....................    UDPSocketInfo[s].localPort = INVALID_UDP_PORT; 
009BE:  MOVF   xC0,W
009C0:  MULLW  17
009C2:  MOVF   FF3,W
009C4:  CLRF   xC2
009C6:  MOVWF  xC1
009C8:  MOVLW  0C
009CA:  ADDWF  xC1,W
009CC:  MOVWF  01
009CE:  MOVLW  00
009D0:  ADDWFC xC2,W
009D2:  MOVWF  03
009D4:  MOVF   01,W
009D6:  ADDLW  53
009D8:  MOVWF  FE9
009DA:  MOVLW  00
009DC:  ADDWFC 03,W
009DE:  MOVWF  FEA
009E0:  CLRF   FEC
009E2:  MOVF   FED,F
009E4:  CLRF   FEF
....................    UDPSocketInfo[s].remote.remoteNode.IPAddr.Val = 0x00000000; 
009E6:  MOVF   xC0,W
009E8:  MULLW  17
009EA:  MOVF   FF3,W
009EC:  CLRF   xC2
009EE:  MOVWF  xC1
009F0:  MOVLW  53
009F2:  ADDWF  xC1,W
009F4:  MOVWF  FE9
009F6:  MOVLW  00
009F8:  ADDWFC xC2,W
009FA:  MOVWF  FEA
009FC:  MOVF   FEE,F
009FE:  MOVF   FEE,F
00A00:  CLRF   FEC
00A02:  MOVF   FED,F
00A04:  CLRF   FEF
00A06:  MOVF   FED,F
00A08:  CLRF   FEF
00A0A:  MOVF   FED,F
00A0C:  CLRF   FEF
....................    UDPSocketInfo[s].smState = UDP_CLOSED; 
00A0E:  MOVF   xC0,W
00A10:  MULLW  17
00A12:  MOVF   FF3,W
00A14:  CLRF   xC2
00A16:  MOVWF  xC1
00A18:  MOVLW  0E
00A1A:  ADDWF  xC1,W
00A1C:  MOVWF  01
00A1E:  MOVLW  00
00A20:  ADDWFC xC2,W
00A22:  MOVWF  03
00A24:  MOVF   01,W
00A26:  ADDLW  53
00A28:  MOVWF  FE9
00A2A:  MOVLW  00
00A2C:  ADDWFC 03,W
00A2E:  MOVWF  FEA
00A30:  MOVLW  04
00A32:  MOVWF  FEF
00A34:  MOVLB  0
00A36:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPSetTxBuffer(WORD wOffset) 
....................  
....................   Summary: 
....................    Moves the pointer within the TX buffer. 
....................     
....................   Description: 
....................    This function allows the write location within the TX buffer to be  
....................    specified.  Future calls to UDPPut, UDPPutArray, UDPPutString, etc will 
....................    write data from the indicated location. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called and a socket is currently  
....................    active. 
....................  
....................   Parameters: 
....................    wOffset - Offset from beginning of UDP packet data payload to place the 
....................       write pointer. 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UDPSetTxBuffer(WORD wOffset) 
.................... { 
....................    IPSetTxBuffer(wOffset+sizeof(UDP_HEADER)); 
*
017CC:  MOVLW  08
017CE:  MOVLB  5
017D0:  ADDWF  xC0,W
017D2:  MOVWF  xC2
017D4:  MOVLW  00
017D6:  ADDWFC xC1,W
017D8:  MOVWF  xC3
017DA:  MOVLW  D7
017DC:  ADDWF  xC2,F
017DE:  MOVLW  11
017E0:  ADDWFC xC3,F
017E2:  MOVLW  0E
017E4:  ADDWF  xC2,F
017E6:  MOVLW  00
017E8:  ADDWFC xC3,F
017EA:  MOVLW  14
017EC:  ADDWF  xC2,F
017EE:  MOVLW  00
017F0:  ADDWFC xC3,F
017F2:  MOVFF  5C3,643
017F6:  MOVFF  5C2,642
017FA:  MOVLB  0
017FC:  CALL   0B16
....................    wPutOffset = wOffset; 
01800:  MOVFF  5C1,139
01804:  MOVFF  5C0,138
01808:  GOTO   1838 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPSetRxBuffer(WORD wOffset) 
....................  
....................   Summary: 
....................    Moves the pointer within the RX buffer. 
....................     
....................   Description: 
....................    This function allows the read location within the RX buffer to be  
....................    specified.  Future calls to UDPGet and UDPGetArray will read data from 
....................    the indicated location forward. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called and a socket is currently  
....................    active. 
....................  
....................   Parameters: 
....................    wOffset - Offset from beginning of UDP packet data payload to place the 
....................       read pointer. 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UDPSetRxBuffer(WORD wOffset) 
.................... { 
....................    IPSetRxBuffer(wOffset+sizeof(UDP_HEADER)); 
*
02496:  MOVLW  08
02498:  MOVLB  5
0249A:  ADDWF  xCC,W
0249C:  MOVWF  xCE
0249E:  MOVLW  00
024A0:  ADDWFC xCD,W
024A2:  MOVWF  xCF
024A4:  MOVFF  FE8,60E
024A8:  MOVFF  5CE,60D
024AC:  MOVLB  0
024AE:  RCALL  247A
....................    wGetOffset = wOffset; 
024B0:  MOVFF  5CD,13B
024B4:  MOVFF  5CC,13A
024B8:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................    
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPIsPutReady(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Determines how many bytes can be written to the UDP socket. 
....................     
....................   Description: 
....................    This function determines if bytes can be written to the specified UDP 
....................    socket.  It also prepares the UDP module for writing by setting the  
....................    indicated socket as the currently active connection. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket to be made active 
....................  
....................   Returns: 
....................      The number of bytes that can be written to this socket. 
....................   ***************************************************************************/ 
.................... WORD UDPIsPutReady(UDP_SOCKET s) 
.................... { 
....................    if(!MACIsTxReady()) 
*
0180C:  RCALL  17A4
0180E:  MOVF   01,F
01810:  BNZ   181A
....................       return 0; 
01812:  MOVLW  00
01814:  MOVWF  01
01816:  MOVWF  02
01818:  BRA    1854
....................  
....................    if(LastPutSocket != s) 
0181A:  MOVLB  5
0181C:  MOVF   xBF,W
0181E:  MOVLB  1
01820:  SUBWF  x37,W
01822:  BZ    183A
....................    { 
....................       LastPutSocket = s; 
01824:  MOVFF  5BF,137
....................       UDPTxCount = 0; 
01828:  MOVLB  0
0182A:  CLRF   xF5
0182C:  CLRF   xF4
....................       UDPSetTxBuffer(0); 
0182E:  MOVLB  5
01830:  CLRF   xC1
01832:  CLRF   xC0
01834:  MOVLB  0
01836:  BRA    17CC
01838:  MOVLB  1
....................    } 
....................  
....................    activeUDPSocket = s; 
0183A:  MOVFF  5BF,52
....................  
....................    return MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) - UDPTxCount; 
0183E:  MOVLW  C0
01840:  BSF    FD8.0
01842:  MOVLB  0
01844:  SUBFWB xF4,W
01846:  MOVWF  00
01848:  MOVLW  05
0184A:  SUBFWB xF5,W
0184C:  MOVWF  03
0184E:  MOVFF  00,01
01852:  MOVWF  02
01854:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPPut(BYTE v) 
....................  
....................   Summary: 
....................    Writes a byte to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a single byte to the currently active UDP socket,  
....................    while incrementing the buffer length.  UDPIsPutReady should be used  
....................    before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    v - The byte to be loaded into the transmit buffer. 
....................  
....................   Return Values: 
....................      TRUE - The byte was successfully written to the socket. 
....................      FALSE - The transmit buffer is already full and so the write failed. 
....................   ***************************************************************************/ 
.................... BOOL UDPPut(BYTE v) 
.................... { 
....................    // See if we are out of transmit space. 
....................    if(wPutOffset >= (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER))) 
*
0196A:  MOVLB  1
0196C:  MOVF   x39,W
0196E:  SUBLW  04
01970:  BC    1982
01972:  XORLW  FF
01974:  BNZ   197C
01976:  MOVF   x38,W
01978:  SUBLW  BF
0197A:  BC    1982
....................    { 
....................       return FALSE; 
0197C:  MOVLW  00
0197E:  MOVWF  01
01980:  BRA    19BC
....................    } 
....................  
....................     // Load application data byte 
....................     MACPut(v); 
01982:  MOVFF  5C8,656
01986:  MOVLB  0
01988:  CALL   062E
....................    wPutOffset++; 
0198C:  MOVLB  1
0198E:  INCF   x38,F
01990:  BTFSC  FD8.2
01992:  INCF   x39,F
....................    if(wPutOffset > UDPTxCount) 
01994:  MOVLB  0
01996:  MOVF   xF5,W
01998:  MOVLB  1
0199A:  SUBWF  x39,W
0199C:  BNC   19B8
0199E:  BNZ   19B0
019A0:  MOVF   x38,W
019A2:  MOVLB  0
019A4:  SUBWF  xF4,W
019A6:  BTFSS  FD8.0
019A8:  BRA    19AE
019AA:  MOVLB  1
019AC:  BRA    19B8
019AE:  MOVLB  1
....................       UDPTxCount = wPutOffset; 
019B0:  MOVFF  139,F5
019B4:  MOVFF  138,F4
....................  
....................     return TRUE; 
019B8:  MOVLW  01
019BA:  MOVWF  01
019BC:  MOVLB  0
019BE:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPPutArray(BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Writes an array of bytes to the currently active socket. 
....................     
....................   Description: 
....................    This function writes an array of bytes to the currently active UDP socket,  
....................    while incrementing the buffer length.  UDPIsPutReady should be used  
....................    before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The array to write to the socket. 
....................    wDateLen - Number of bytes from cData to be written. 
....................     
....................   Returns: 
....................      The number of bytes successfully placed in the UDP transmit buffer.  If 
....................      this value is less than wDataLen, then the buffer became full and the 
....................      input was truncated. 
....................   ***************************************************************************/ 
.................... WORD UDPPutArray(BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wTemp; 
....................  
....................    wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset; 
019C0:  MOVLW  C0
019C2:  BSF    FD8.0
019C4:  MOVLB  1
019C6:  SUBFWB x38,W
019C8:  MOVLB  5
019CA:  MOVWF  xCC
019CC:  MOVLW  05
019CE:  MOVLB  1
019D0:  SUBFWB x39,W
019D2:  MOVLB  5
019D4:  MOVWF  xCD
....................    if(wTemp < wDataLen) 
019D6:  MOVF   xCD,W
019D8:  SUBWF  xCB,W
019DA:  BNC   19EC
019DC:  BNZ   19E4
019DE:  MOVF   xCA,W
019E0:  SUBWF  xCC,W
019E2:  BC    19EC
....................       wDataLen = wTemp; 
019E4:  MOVFF  5CD,5CB
019E8:  MOVFF  5CC,5CA
....................  
....................    wPutOffset += wDataLen; 
019EC:  MOVF   xCA,W
019EE:  MOVLB  1
019F0:  ADDWF  x38,F
019F2:  MOVLB  5
019F4:  MOVF   xCB,W
019F6:  MOVLB  1
019F8:  ADDWFC x39,F
....................    if(wPutOffset > UDPTxCount) 
019FA:  MOVLB  0
019FC:  MOVF   xF5,W
019FE:  MOVLB  1
01A00:  SUBWF  x39,W
01A02:  BNC   1A1E
01A04:  BNZ   1A16
01A06:  MOVF   x38,W
01A08:  MOVLB  0
01A0A:  SUBWF  xF4,W
01A0C:  BTFSS  FD8.0
01A0E:  BRA    1A14
01A10:  MOVLB  1
01A12:  BRA    1A1E
01A14:  MOVLB  1
....................       UDPTxCount = wPutOffset; 
01A16:  MOVFF  139,F5
01A1A:  MOVFF  138,F4
....................  
....................     // Load application data bytes 
....................     MACPutArray(cData, wDataLen); 
01A1E:  MOVFF  5C9,658
01A22:  MOVFF  5C8,657
01A26:  MOVFF  5CB,65A
01A2A:  MOVFF  5CA,659
01A2E:  MOVLB  0
01A30:  CALL   0B7E
....................  
....................     return wDataLen; 
01A34:  MOVLB  5
01A36:  MOVFF  5CA,01
01A3A:  MOVFF  5CB,02
01A3E:  MOVLB  0
01A40:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Writes an array of bytes from ROM to the currently active socket. 
....................     
....................   Description: 
....................    This function writes an array of bytes from ROM to the currently active  
....................    UDP socket, while incrementing the buffer length.  UDPIsPutReady should  
....................    be used before calling this function to specify the currently active  
....................    socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The array to write to the socket. 
....................    wDateLen - Number of bytes from cData to be written. 
....................     
....................   Returns: 
....................      The number of bytes successfully placed in the UDP transmit buffer.  If 
....................      this value is less than wDataLen, then the buffer became full and the 
....................      input was truncated. 
....................       
....................   Remarks: 
....................    This function is aliased to UDPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wTemp; 
....................  
....................    wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset; 
....................    if(wTemp < wDataLen) 
....................       wDataLen = wTemp; 
....................  
....................    wPutOffset += wDataLen; 
....................    if(wPutOffset > UDPTxCount) 
....................       UDPTxCount = wPutOffset; 
....................  
....................     // Load application data bytes 
....................     MACPutROMArray(cData, wDataLen); 
....................  
....................     return wDataLen; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* UDPPutString(BYTE *strData) 
....................  
....................   Summary: 
....................    Writes null-terminated string to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a null-terminated string to the currently active  
....................    UDP socket, while incrementing the buffer length.  UDPIsPutReady should  
....................    be used before calling this function to specify the currently active 
....................    socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - Pointer to the string to be written to the socket. 
....................     
....................   Returns: 
....................      A pointer to the byte following the last byte written.  Note that this 
....................      is different than the UDPPutArray functions.  If this pointer does not 
....................      dereference to a NULL byte, then the buffer became full and the input 
....................      data was truncated. 
....................   ***************************************************************************/ 
.................... BYTE* UDPPutString(BYTE *strData) 
.................... { 
....................    return strData + UDPPutArray(strData, strlen((char*)strData)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* UDPPutString(BYTE *strData) 
....................  
....................   Summary: 
....................    Writes null-terminated string from ROM to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a null-terminated string from ROM to the currently 
....................    active UDP socket, while incrementing the buffer length.  UDPIsPutReady 
....................    should be used before calling this function to specify the currently 
....................    active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - Pointer to the string to be written to the socket. 
....................     
....................   Returns: 
....................      A pointer to the byte following the last byte written.  Note that this 
....................      is different than the UDPPutArray functions.  If this pointer does not 
....................      dereference to a NULL byte, then the buffer became full and the input 
....................      data was truncated. 
....................    
....................   Remarks: 
....................    This function is aliased to UDPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* UDPPutROMString(ROM BYTE *strData) 
.................... { 
....................    return strData + UDPPutROMArray(strData, strlenpgm((ROM char*)strData)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPFlush(void) 
....................  
....................   Summary: 
....................    Transmits all pending data in a UDP socket. 
....................     
....................   Description: 
....................    This function builds a UDP packet with the pending TX data and marks it  
....................    for transmission over the network interface.  Since UDP is a frame-based 
....................    protocol, this function must be called before returning to the main 
....................    stack loop whenever any data is written. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket, and 
....................    data has been written to the socket using the UDPPut family of functions. 
....................  
....................   Parameters: 
....................    None 
....................     
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................    Note that unlike TCPFlush, UDPFlush must be called before returning to  
....................    the main stack loop.  There is no auto transmit for UDP segments. 
....................   ***************************************************************************/ 
.................... void UDPFlush(void) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET_INFO *p; 
....................     WORD         wUDPLength; 
....................  
....................     p = &UDPSocketInfo[activeUDPSocket]; 
*
01FFE:  MOVF   52,W
02000:  MULLW  17
02002:  MOVF   FF3,W
02004:  CLRF   03
02006:  ADDLW  53
02008:  MOVWF  01
0200A:  MOVLW  00
0200C:  ADDWFC 03,F
0200E:  MOVFF  01,5CE
02012:  MOVLB  5
02014:  MOVFF  03,5CF
....................  
....................    wUDPLength = UDPTxCount + sizeof(UDP_HEADER); 
02018:  MOVLW  08
0201A:  MOVLB  0
0201C:  ADDWF  xF4,W
0201E:  MOVLB  5
02020:  MOVWF  xD0
02022:  MOVLW  00
02024:  MOVLB  0
02026:  ADDWFC xF5,W
02028:  MOVLB  5
0202A:  MOVWF  xD1
....................  
....................    // Generate the correct UDP header 
....................     h.SourcePort        = swaps(p->localPort); 
0202C:  MOVLW  0C
0202E:  ADDWF  xCE,W
02030:  MOVWF  FE9
02032:  MOVLW  00
02034:  ADDWFC xCF,W
02036:  MOVWF  FEA
02038:  MOVFF  FEC,653
0203C:  MOVF   FED,F
0203E:  MOVFF  FEF,652
02042:  MOVLB  0
02044:  RCALL  1A42
02046:  MOVFF  02,5C7
0204A:  MOVFF  01,5C6
....................     h.DestinationPort   = swaps(p->remotePort); 
0204E:  MOVLW  0A
02050:  MOVLB  5
02052:  ADDWF  xCE,W
02054:  MOVWF  FE9
02056:  MOVLW  00
02058:  ADDWFC xCF,W
0205A:  MOVWF  FEA
0205C:  MOVFF  FEC,653
02060:  MOVF   FED,F
02062:  MOVFF  FEF,652
02066:  MOVLB  0
02068:  RCALL  1A42
0206A:  MOVFF  02,5C9
0206E:  MOVFF  01,5C8
....................     h.Length            = swaps(wUDPLength); 
02072:  MOVFF  5D1,653
02076:  MOVFF  5D0,652
0207A:  RCALL  1A42
0207C:  MOVFF  02,5CB
02080:  MOVFF  01,5CA
....................    h.Checksum          = 0x0000; 
02084:  MOVLB  5
02086:  CLRF   xCD
02088:  CLRF   xCC
....................      
....................    // Calculate IP pseudoheader checksum if we are going to enable  
....................    // the checksum field 
....................    #if defined(UDP_USE_TX_CHECKSUM) 
....................    { 
....................       PSEUDO_HEADER   pseudoHeader; 
....................        
....................       pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
....................       pseudoHeader.DestAddress    = p->remote.remoteNode.IPAddr; 
....................       pseudoHeader.Zero           = 0x0; 
....................       pseudoHeader.Protocol       = IP_PROT_UDP; 
....................       pseudoHeader.Length         = wUDPLength; 
....................       SwapPseudoHeader(pseudoHeader); 
....................       h.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
....................    } 
....................    #endif 
....................  
....................    // Position the hardware write pointer where we will need to  
....................    // begin writing the IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
0208A:  MOVLW  11
0208C:  MOVLB  6
0208E:  MOVWF  x43
02090:  MOVLW  E5
02092:  MOVWF  x42
02094:  MOVLB  0
02096:  CALL   0B16
....................     
....................    // Write IP header to packet 
....................    IPPutHeader(&p->remote.remoteNode, IP_PROT_UDP, wUDPLength); 
0209A:  MOVFF  5CE,01
0209E:  MOVFF  5CF,03
020A2:  MOVFF  5CE,5D2
020A6:  MOVFF  5CF,5D3
020AA:  MOVFF  5CF,634
020AE:  MOVFF  5CE,633
020B2:  MOVLW  11
020B4:  MOVLB  6
020B6:  MOVWF  x35
020B8:  MOVFF  5D1,637
020BC:  MOVFF  5D0,636
020C0:  MOVLB  0
020C2:  RCALL  1CCC
....................  
....................     // Write UDP header to packet 
....................     MACPutArray((BYTE*)&h, sizeof(h)); 
020C4:  MOVLW  05
020C6:  MOVLB  5
020C8:  MOVWF  xD3
020CA:  MOVLW  C6
020CC:  MOVWF  xD2
020CE:  MOVFF  5D3,658
020D2:  MOVFF  FE8,657
020D6:  MOVLB  6
020D8:  CLRF   x5A
020DA:  MOVLW  08
020DC:  MOVWF  x59
020DE:  MOVLB  0
020E0:  CALL   0B7E
....................      
....................    // Calculate the final UDP checksum and write it in, if enabled 
....................    #if defined(UDP_USE_TX_CHECKSUM) 
....................    { 
....................         PTR_BASE   wReadPtrSave; 
....................         WORD      wChecksum; 
....................  
....................       wReadPtrSave = MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
....................       wChecksum = CalcIPBufferChecksum(wUDPLength); 
....................       if(wChecksum == 0x0000u) 
....................          wChecksum = 0xFFFF; 
....................       MACSetReadPtr(wReadPtrSave); 
....................       MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 6);   // 6 is the offset to the Checksum field in UDP_HEADER 
....................       MACPutArray((BYTE*)&wChecksum, sizeof(wChecksum)); 
....................    } 
....................    #endif 
....................      
....................    // Transmit the packet 
....................     MACFlush(); 
020E4:  RCALL  1DB6
....................  
....................    // Reset packet size counter for the next TX operation 
....................     UDPTxCount = 0; 
020E6:  CLRF   xF5
020E8:  CLRF   xF4
....................    LastPutSocket = INVALID_UDP_SOCKET; 
020EA:  MOVLB  1
020EC:  SETF   x37
020EE:  MOVLB  0
020F0:  GOTO   23B0 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPIsGetReady(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the UDP socket. 
....................     
....................   Description: 
....................    This function determines if bytes can be read from the specified UDP 
....................    socket.  It also prepares the UDP module for reading by setting the  
....................    indicated socket as the currently active connection. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket to be made active (which has already been opened or is 
....................       listening) 
....................  
....................   Returns: 
....................      The number of bytes that can be read from this socket. 
....................   ***************************************************************************/ 
.................... WORD UDPIsGetReady(UDP_SOCKET s) 
.................... { 
....................     activeUDPSocket = s; 
*
024BA:  MOVFF  5BF,52
....................    if(SocketWithRxData != s) 
024BE:  MOVLB  5
024C0:  MOVF   xBF,W
024C2:  MOVLB  1
024C4:  SUBWF  x3D,W
024C6:  BZ    24D0
....................       return 0; 
024C8:  MOVLW  00
024CA:  MOVWF  01
024CC:  MOVWF  02
024CE:  BRA    24FC
....................  
....................     // If this is the very first time we are accessing this packet,  
....................     // move the read point to the begining of the packet. 
....................     if(Flags.bFirstRead) 
024D0:  BTFSS  x3C.0
024D2:  BRA    24E2
....................     { 
....................         Flags.bFirstRead = 0; 
024D4:  BCF    x3C.0
....................         UDPSetRxBuffer(0); 
024D6:  MOVLB  5
024D8:  CLRF   xCD
024DA:  CLRF   xCC
024DC:  MOVLB  0
024DE:  RCALL  2496
024E0:  MOVLB  1
....................     } 
....................  
....................     return UDPRxCount - wGetOffset; 
024E2:  MOVF   x3A,W
024E4:  MOVLB  0
024E6:  SUBWF  xF6,W
024E8:  MOVWF  00
024EA:  MOVLB  1
024EC:  MOVF   x3B,W
024EE:  MOVLB  0
024F0:  SUBWFB xF7,W
024F2:  MOVWF  03
024F4:  MOVFF  00,01
024F8:  MOVWF  02
024FA:  MOVLB  1
024FC:  MOVLB  0
024FE:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPGet(BYTE *v) 
....................  
....................   Summary: 
....................    Reads a byte from the currently active socket. 
....................     
....................   Description: 
....................    This function reads a single byte from the currently active UDP socket,  
....................    while decrementing the remaining buffer length.  UDPIsGetReady should be  
....................    used before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    v - The buffer to receive the data being read. 
....................  
....................   Return Values: 
....................      TRUE - A byte was successfully read 
....................      FALSE - No data remained in the read buffer 
....................   ***************************************************************************/ 
.................... BOOL UDPGet(BYTE *v) 
.................... { 
....................    // Make sure that there is data to return 
....................     if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket)) 
02500:  MOVF   xF7,W
02502:  MOVLB  1
02504:  SUBWF  x3B,W
02506:  BNC   2514
02508:  BNZ   251A
0250A:  MOVLB  0
0250C:  MOVF   xF6,W
0250E:  MOVLB  1
02510:  SUBWF  x3A,W
02512:  BC    251A
02514:  MOVF   52,W
02516:  SUBWF  x3D,W
02518:  BZ    2520
....................         return FALSE; 
0251A:  MOVLW  00
0251C:  MOVWF  01
0251E:  BRA    254A
....................  
....................     *v = MACGet(); 
02520:  MOVFF  5CF,03
02524:  MOVFF  5CE,5D0
02528:  MOVFF  5CF,5D1
0252C:  MOVLB  0
0252E:  CALL   0C9E
02532:  MOVFF  5D1,FEA
02536:  MOVFF  5D0,FE9
0253A:  MOVFF  01,FEF
....................     wGetOffset++; 
0253E:  MOVLB  1
02540:  INCF   x3A,F
02542:  BTFSC  FD8.2
02544:  INCF   x3B,F
....................  
....................     return TRUE; 
02546:  MOVLW  01
02548:  MOVWF  01
0254A:  MOVLB  0
0254C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPGetArray(BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Reads an array of bytes from the currently active socket. 
....................     
....................   Description: 
....................    This function reads an array of bytes from the currently active UDP socket,  
....................    while decrementing the remaining bytes available. UDPIsGetReady should be  
....................    used before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The buffer to receive the bytes being read.  If NULL, the bytes are  
....................          simply discarded without being written anywhere (effectively skips  
....................          over the bytes in the RX buffer, although if you need to skip a lot  
....................          of data, seeking using the UDPSetRxBuffer() will be more efficient). 
....................    wDateLen - Number of bytes to be read from the socket. 
....................     
....................   Returns: 
....................      The number of bytes successfully read from the UDP buffer.  If this 
....................      value is less than wDataLen, then the buffer was emptied and no more  
....................      data is available. 
....................   ***************************************************************************/ 
.................... WORD UDPGetArray(BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wBytesAvailable; 
....................     
....................    // Make sure that there is data to return 
....................     if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket)) 
0254E:  MOVF   xF7,W
02550:  MOVLB  1
02552:  SUBWF  x3B,W
02554:  BNC   2562
02556:  BNZ   2568
02558:  MOVLB  0
0255A:  MOVF   xF6,W
0255C:  MOVLB  1
0255E:  SUBWF  x3A,W
02560:  BC    2568
02562:  MOVF   52,W
02564:  SUBWF  x3D,W
02566:  BZ    2570
....................       return 0; 
02568:  MOVLW  00
0256A:  MOVWF  01
0256C:  MOVWF  02
0256E:  BRA    25D6
....................  
....................    // Make sure we don't try to read more data than exists 
....................    wBytesAvailable = UDPRxCount - wGetOffset; 
02570:  MOVF   x3A,W
02572:  MOVLB  0
02574:  SUBWF  xF6,W
02576:  MOVLB  5
02578:  MOVWF  xD2
0257A:  MOVLB  1
0257C:  MOVF   x3B,W
0257E:  MOVLB  0
02580:  SUBWFB xF7,W
02582:  MOVLB  5
02584:  MOVWF  xD3
....................    if(wBytesAvailable < wDataLen) 
02586:  MOVF   xD3,W
02588:  SUBWF  xD1,W
0258A:  BNC   259C
0258C:  BNZ   2594
0258E:  MOVF   xD0,W
02590:  SUBWF  xD2,W
02592:  BC    259C
....................       wDataLen = wBytesAvailable; 
02594:  MOVFF  5D3,5D1
02598:  MOVFF  5D2,5D0
....................  
....................    wDataLen = MACGetArray(cData, wDataLen); 
0259C:  MOVFF  5CF,656
025A0:  MOVFF  5CE,655
025A4:  MOVFF  5D1,658
025A8:  MOVFF  5D0,657
025AC:  MOVLB  0
025AE:  CALL   0C28
025B2:  MOVFF  02,5D1
025B6:  MOVFF  01,5D0
....................     wGetOffset += wDataLen; 
025BA:  MOVLB  5
025BC:  MOVF   xD0,W
025BE:  MOVLB  1
025C0:  ADDWF  x3A,F
025C2:  MOVLB  5
025C4:  MOVF   xD1,W
025C6:  MOVLB  1
025C8:  ADDWFC x3B,F
....................  
....................     return wDataLen; 
025CA:  MOVLB  5
025CC:  MOVFF  5D0,01
025D0:  MOVFF  5D1,02
025D4:  MOVLB  1
025D6:  MOVLB  0
025D8:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPDiscard(void) 
....................  
....................   Summary: 
....................    Discards any remaining RX data from a UDP socket. 
....................     
....................   Description: 
....................    This function discards any remaining received data in the currently  
....................    active UDP socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to select the currently active 
....................    socket. 
....................  
....................   Parameters: 
....................    None 
....................     
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................    It is safe to call this function more than is necessary.  If no data is 
....................    available, this function does nothing. 
....................   ***************************************************************************/ 
.................... void UDPDiscard(void) 
.................... { 
....................    if(!Flags.bWasDiscarded) 
*
02644:  MOVLB  1
02646:  BTFSC  x3C.1
02648:  BRA    2658
....................    { 
....................       MACDiscardRx(); 
0264A:  MOVLB  0
0264C:  RCALL  25DA
....................       UDPRxCount = 0; 
0264E:  CLRF   xF7
02650:  CLRF   xF6
....................       SocketWithRxData = INVALID_UDP_SOCKET; 
02652:  MOVLB  1
02654:  SETF   x3D
....................       Flags.bWasDiscarded = 1; 
02656:  BSF    x3C.1
....................    } 
02658:  MOVLB  0
0265A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
....................  
....................   Summary: 
....................    Handles an incoming UDP segment. 
....................     
....................   Description: 
....................    This function handles an incoming UDP segment to determine if it is  
....................    acceptable and should be handed to one of the stack applications for 
....................    processing. 
....................  
....................   Precondition: 
....................    UDPInit() has been called an a UDP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remoteNode - The remote node that sent this segment. 
....................    localIP - The destination IP address for this segment. 
....................    len - Total length of the UDP segment. 
....................     
....................   Return Values: 
....................      TRUE - A valid packet is waiting and the stack applications should be 
....................         called to handle it. 
....................      FALSE - The packet was discarded. 
....................   ***************************************************************************/ 
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET      s; 
....................     PSEUDO_HEADER   pseudoHeader; 
....................     DWORD_VAL      checksums; 
....................  
....................    UDPRxCount = 0; 
*
06A98:  CLRF   xF7
06A9A:  CLRF   xF6
....................  
....................     // Retrieve UDP header. 
....................     MACGetArray((BYTE*)&h, sizeof(h)); 
06A9C:  MOVLW  05
06A9E:  MOVLB  5
06AA0:  MOVWF  xDE
06AA2:  MOVLW  C4
06AA4:  MOVWF  xDD
06AA6:  MOVFF  5DE,656
06AAA:  MOVFF  FE8,655
06AAE:  MOVLB  6
06AB0:  CLRF   x58
06AB2:  MOVLW  08
06AB4:  MOVWF  x57
06AB6:  MOVLB  0
06AB8:  CALL   0C28
....................  
....................     h.SourcePort        = swaps(h.SourcePort); 
06ABC:  MOVFF  5C5,653
06AC0:  MOVFF  5C4,652
06AC4:  CALL   1A42
06AC8:  MOVFF  02,5C5
06ACC:  MOVFF  01,5C4
....................     h.DestinationPort   = swaps(h.DestinationPort); 
06AD0:  MOVFF  5C7,653
06AD4:  MOVFF  5C6,652
06AD8:  CALL   1A42
06ADC:  MOVFF  02,5C7
06AE0:  MOVFF  01,5C6
....................     h.Length            = swaps(h.Length) - sizeof(UDP_HEADER); 
06AE4:  MOVFF  5C9,653
06AE8:  MOVFF  5C8,652
06AEC:  CALL   1A42
06AF0:  MOVLW  08
06AF2:  MOVLB  5
06AF4:  SUBWF  01,W
06AF6:  MOVWF  xC8
06AF8:  MOVLW  00
06AFA:  SUBWFB 02,W
06AFC:  MOVWF  xC9
....................  
....................    // See if we need to validate the checksum field (0x0000 is disabled) 
....................    if(h.Checksum) 
06AFE:  MOVF   xCA,W
06B00:  IORWF  xCB,W
06B02:  BZ    6BC2
....................    { 
....................        // Calculate IP pseudoheader checksum. 
....................        pseudoHeader.SourceAddress      = remoteNode->IPAddr; 
06B04:  MOVFF  5BE,FE9
06B08:  MOVFF  5BF,FEA
06B0C:  MOVFF  FEF,5CD
06B10:  MOVFF  FEC,5CE
06B14:  MOVFF  FEC,5CF
06B18:  MOVFF  FEC,5D0
....................        pseudoHeader.DestAddress.Val   = localIP->Val; 
06B1C:  MOVFF  5C0,FE9
06B20:  MOVFF  5C1,FEA
06B24:  MOVFF  FEF,5D1
06B28:  MOVFF  FEC,5D2
06B2C:  MOVFF  FEC,5D3
06B30:  MOVFF  FEC,5D4
....................        pseudoHeader.Zero            = 0x0; 
06B34:  CLRF   xD5
....................        pseudoHeader.Protocol         = IP_PROT_UDP; 
06B36:  MOVLW  11
06B38:  MOVWF  xD6
....................        pseudoHeader.Length            = len; 
06B3A:  MOVFF  5C3,5D8
06B3E:  MOVFF  5C2,5D7
....................  
....................        SwapPseudoHeader(pseudoHeader); 
06B42:  MOVFF  5D8,653
06B46:  MOVFF  5D7,652
06B4A:  MOVLB  0
06B4C:  CALL   1A42
06B50:  MOVFF  02,5D8
06B54:  MOVFF  01,5D7
....................     
....................        checksums.w[0] = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................                                        sizeof(pseudoHeader)); 
06B58:  MOVLW  05
06B5A:  MOVLB  5
06B5C:  MOVWF  xDE
06B5E:  MOVLW  CD
06B60:  MOVWF  xDD
06B62:  MOVFF  5DE,64F
06B66:  MOVFF  FE8,64E
06B6A:  MOVLB  6
06B6C:  CLRF   x51
06B6E:  MOVLW  0C
06B70:  MOVWF  x50
06B72:  MOVLB  0
06B74:  CALL   1B26
06B78:  MOVFF  01,5D9
06B7C:  MOVLB  5
06B7E:  COMF   xD9,F
06B80:  MOVFF  02,5DA
06B84:  COMF   xDA,F
....................     
....................     
....................        // Now calculate UDP packet checksum in NIC RAM -- should match pseudoHeader 
....................        IPSetRxBuffer(0); 
06B86:  MOVLB  6
06B88:  CLRF   x0E
06B8A:  CLRF   x0D
06B8C:  MOVLB  0
06B8E:  CALL   247A
....................        checksums.w[1] = CalcIPBufferChecksum(len); 
06B92:  MOVFF  5C3,634
06B96:  MOVFF  5C2,633
06B9A:  CALL   3450
06B9E:  MOVFF  02,5DC
06BA2:  MOVFF  01,5DB
....................     
....................        if(checksums.w[0] != checksums.w[1]) 
06BA6:  MOVLB  5
06BA8:  MOVF   xDB,W
06BAA:  SUBWF  xD9,W
06BAC:  BNZ   6BB4
06BAE:  MOVF   xDC,W
06BB0:  SUBWF  xDA,W
06BB2:  BZ    6BC2
....................        { 
....................            MACDiscardRx(); 
06BB4:  MOVLB  0
06BB6:  CALL   25DA
....................            return FALSE; 
06BBA:  MOVLW  00
06BBC:  MOVWF  01
06BBE:  BRA    6C10
06BC0:  MOVLB  5
....................        } 
....................    } 
....................  
....................     s = FindMatchingUDPSocket(&h, remoteNode, localIP); 
06BC2:  MOVLW  05
06BC4:  MOVWF  xDE
06BC6:  MOVLW  C4
06BC8:  MOVWF  xDD
06BCA:  MOVFF  5BF,5E0
06BCE:  MOVFF  5BE,5DF
06BD2:  MOVFF  5C1,5E2
06BD6:  MOVFF  5C0,5E1
06BDA:  MOVLB  0
06BDC:  BRA    6912
06BDE:  MOVFF  01,5CC
....................     if(s == INVALID_UDP_SOCKET) 
06BE2:  MOVLB  5
06BE4:  INCFSZ xCC,W
06BE6:  BRA    6BF8
....................     { 
....................         // If there is no matching socket, There is no one to handle 
....................         // this data.  Discard it. 
....................         MACDiscardRx(); 
06BE8:  MOVLB  0
06BEA:  CALL   25DA
....................       return FALSE; 
06BEE:  MOVLW  00
06BF0:  MOVWF  01
06BF2:  BRA    6C10
....................     } 
06BF4:  BRA    6C0C
06BF6:  MOVLB  5
....................     else 
....................     { 
....................       SocketWithRxData = s; 
06BF8:  MOVFF  5CC,13D
....................         UDPRxCount = h.Length; 
06BFC:  MOVFF  5C9,F7
06C00:  MOVFF  5C8,F6
....................         Flags.bFirstRead = 1; 
06C04:  MOVLB  1
06C06:  BSF    x3C.0
....................       Flags.bWasDiscarded = 0; 
06C08:  BCF    x3C.1
06C0A:  MOVLB  0
....................     } 
....................  
....................  
....................     return TRUE; 
06C0C:  MOVLW  01
06C0E:  MOVWF  01
06C10:  GOTO   6DF0 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, NODE_INFO *remoteNode, 
....................                                            IP_ADDR *localIP) 
....................  
....................   Summary: 
....................    Matches an incoming UDP segment to a currently active socket. 
....................     
....................   Description: 
....................    This function attempts to match an incoming UDP segment to a currently 
....................    active socket for processing. 
....................  
....................   Precondition: 
....................    UDP segment header and IP header have both been retrieved. 
....................  
....................   Parameters: 
....................    h - The UDP header that was received. 
....................    remoteNode - IP and MAC of the remote node that sent this segment. 
....................    localIP - IP address that this segment was destined for. 
....................     
....................   Returns: 
....................      A UDP_SOCKET handle of a matching socket, or INVALID_UDP_SOCKET when no 
....................      match could be made. 
....................   ***************************************************************************/ 
.................... static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, 
....................                                      NODE_INFO *remoteNode, 
....................                                      IP_ADDR *localIP) 
.................... { 
....................    UDP_SOCKET s; 
....................    UDP_SOCKET partialMatch; 
....................    UDP_SOCKET_INFO *p; 
....................  
.................... // This is commented out because most applications don't need this type of filtering.  It comes at a performance cost. 
.................... //   // Filter out unicast packets that aren't for our IP address, but accept  
.................... //   // all multicast and broadcast traffic 
.................... //   if(!((localIP->Val == AppConfig.MyIPAddr.Val) || (localIP->v[0] & 0x80) || (localIP->Val == (AppConfig.MyIPAddr.Val | (~AppConfig.MyMask.Val))))) 
.................... //      return INVALID_UDP_SOCKET; 
....................  
....................    // Discard any packets received that were generated by ourself.  In  
....................    // structured Wi-Fi networks, the Access Point rebroadcasts our broadcast  
....................    // and multicast packets, causing self-reception to occur unless filtered  
....................    // out. 
....................    if(remoteNode->IPAddr.Val == AppConfig.MyIPAddr.Val) 
*
06912:  MOVLB  5
06914:  MOVFF  5DF,FE9
06918:  MOVFF  5E0,FEA
0691C:  MOVFF  FEF,5E7
06920:  MOVFF  FEC,5E8
06924:  MOVFF  FEC,5E9
06928:  MOVFF  FEC,5EA
0692C:  MOVF   1F,W
0692E:  SUBWF  xE7,W
06930:  BNZ   694A
06932:  MOVF   20,W
06934:  SUBWF  xE8,W
06936:  BNZ   694A
06938:  MOVF   21,W
0693A:  SUBWF  xE9,W
0693C:  BNZ   694A
0693E:  MOVF   22,W
06940:  SUBWF  xEA,W
06942:  BNZ   694A
....................       return INVALID_UDP_SOCKET; 
06944:  MOVLW  FF
06946:  MOVWF  01
06948:  BRA    6A92
....................  
....................    partialMatch = INVALID_UDP_SOCKET; 
0694A:  SETF   xE4
....................  
....................    p = UDPSocketInfo; 
0694C:  CLRF   xE6
0694E:  MOVLW  53
06950:  MOVWF  xE5
....................     for(s = 0; s < MAX_UDP_SOCKETS; s++) 
06952:  CLRF   xE3
06954:  MOVF   xE3,W
06956:  SUBLW  06
06958:  BNC   6A1C
....................    { 
....................       // This packet is said to be matching with current socket: 
....................       // 1. If its destination port matches with our local port and 
....................       // 2. Packet source IP address matches with previously saved socket remote IP address and 
....................       // 3. Packet source port number matches with previously saved socket remote port number 
....................       if(p->localPort == h->DestinationPort) 
0695A:  MOVLW  0C
0695C:  ADDWF  xE5,W
0695E:  MOVWF  FE9
06960:  MOVLW  00
06962:  ADDWFC xE6,W
06964:  MOVWF  FEA
06966:  MOVFF  FEC,5E8
0696A:  MOVF   FED,F
0696C:  MOVFF  FEF,5E7
06970:  MOVLW  02
06972:  ADDWF  xDD,W
06974:  MOVWF  FE9
06976:  MOVLW  00
06978:  ADDWFC xDE,W
0697A:  MOVWF  FEA
0697C:  MOVFF  FEC,03
06980:  MOVF   FED,F
06982:  MOVF   FEF,W
06984:  SUBWF  xE7,W
06986:  BNZ   6A10
06988:  MOVF   03,W
0698A:  SUBWF  xE8,W
0698C:  BNZ   6A10
....................       { 
....................          if(p->remotePort == h->SourcePort) 
0698E:  MOVLW  0A
06990:  ADDWF  xE5,W
06992:  MOVWF  FE9
06994:  MOVLW  00
06996:  ADDWFC xE6,W
06998:  MOVWF  FEA
0699A:  MOVFF  FEC,5E8
0699E:  MOVF   FED,F
069A0:  MOVFF  FEF,5E7
069A4:  MOVFF  5DD,FE9
069A8:  MOVFF  5DE,FEA
069AC:  MOVFF  FEC,03
069B0:  MOVF   FED,F
069B2:  MOVF   FEF,W
069B4:  SUBWF  xE7,W
069B6:  BNZ   6A0C
069B8:  MOVF   03,W
069BA:  SUBWF  xE8,W
069BC:  BNZ   6A0C
....................          { 
....................             if(p->remote.remoteNode.IPAddr.Val == remoteNode->IPAddr.Val) 
069BE:  MOVFF  5E5,FE9
069C2:  MOVFF  5E6,FEA
069C6:  MOVFF  FEF,5E7
069CA:  MOVFF  FEC,5E8
069CE:  MOVFF  FEC,5E9
069D2:  MOVFF  FEC,5EA
069D6:  MOVFF  5DF,FE9
069DA:  MOVFF  5E0,FEA
069DE:  MOVFF  FEF,00
069E2:  MOVFF  FEC,01
069E6:  MOVFF  FEC,02
069EA:  MOVFF  FEC,03
069EE:  MOVF   00,W
069F0:  SUBWF  xE7,W
069F2:  BNZ   6A0C
069F4:  MOVF   01,W
069F6:  SUBWF  xE8,W
069F8:  BNZ   6A0C
069FA:  MOVF   02,W
069FC:  SUBWF  xE9,W
069FE:  BNZ   6A0C
06A00:  MOVF   03,W
06A02:  SUBWF  xEA,W
06A04:  BNZ   6A0C
....................             { 
....................                return s; 
06A06:  MOVFF  5E3,01
06A0A:  BRA    6A92
....................             } 
....................          } 
....................  
....................          partialMatch = s; 
06A0C:  MOVFF  5E3,5E4
....................       } 
....................       p++; 
06A10:  MOVLW  17
06A12:  ADDWF  xE5,F
06A14:  BTFSC  FD8.0
06A16:  INCF   xE6,F
06A18:  INCF   xE3,F
06A1A:  BRA    6954
....................    } 
....................  
....................    if(partialMatch != INVALID_UDP_SOCKET) 
06A1C:  INCFSZ xE4,W
06A1E:  BRA    6A22
06A20:  BRA    6A8E
....................    { 
....................       p = &UDPSocketInfo[partialMatch]; 
06A22:  MOVF   xE4,W
06A24:  MULLW  17
06A26:  MOVF   FF3,W
06A28:  CLRF   03
06A2A:  ADDLW  53
06A2C:  MOVWF  01
06A2E:  MOVLW  00
06A30:  ADDWFC 03,F
06A32:  MOVFF  01,5E5
06A36:  MOVFF  03,5E6
....................  
....................       memcpy((void*)&p->remote.remoteNode, 
....................             (const void*)remoteNode, sizeof(p->remote.remoteNode) ); 
06A3A:  MOVFF  5E6,03
06A3E:  MOVFF  5E5,5E7
06A42:  MOVFF  5E6,5E8
06A46:  MOVFF  5E6,FEA
06A4A:  MOVFF  5E5,FE9
06A4E:  MOVFF  5E0,FE2
06A52:  MOVFF  5DF,FE1
06A56:  MOVLW  0A
06A58:  MOVWF  01
06A5A:  MOVFF  FE6,FEE
06A5E:  DECFSZ 01,F
06A60:  BRA    6A5A
....................  
....................       p->remotePort = h->SourcePort; 
06A62:  MOVLW  0A
06A64:  ADDWF  xE5,W
06A66:  MOVWF  01
06A68:  MOVLW  00
06A6A:  ADDWFC xE6,W
06A6C:  MOVFF  5DD,FE9
06A70:  MOVFF  5DE,FEA
06A74:  MOVFF  FEC,03
06A78:  MOVF   FED,F
06A7A:  MOVFF  FEF,5E9
06A7E:  MOVWF  FEA
06A80:  MOVFF  01,FE9
06A84:  MOVFF  03,FEC
06A88:  MOVF   FED,F
06A8A:  MOVFF  5E9,FEF
....................    } 
....................  
....................    return partialMatch; 
06A8E:  MOVFF  5E4,01
06A92:  MOVLB  0
06A94:  GOTO   6BDE (RETURN)
.................... } 
....................  
....................  
.................... #endif //#if defined(STACK_USE_UDP) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    #include "DHCP.c" 
.................... /********************************************************************* 
.................... * 
.................... *   Dynamic Host Configuration Protocol (DHCP) Client 
.................... *   Module for Microchip TCP/IP Stack 
.................... *    -Provides automatic IP address, subnet mask, gateway address,  
.................... *     DNS server address, and other configuration parameters on DHCP  
.................... *     enabled networks. 
.................... *    -Reference: RFC 2131, 2132 
.................... * 
.................... ********************************************************************* 
.................... * FileName:      DHCP.c 
.................... * Dependencies:   UDP 
.................... * Processor:   PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
.................... * Compiler:      Microchip C32 v1.05 or higher 
.................... *            Microchip C30 v3.12 or higher 
.................... *            Microchip C18 v3.30 or higher 
.................... *            HI-TECH PICC-18 PRO 9.63PL2 or higher 
.................... * Company:      Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
.................... * reserved. 
.................... * 
.................... * Microchip licenses to you the right to use, modify, copy, and 
.................... * distribute: 
.................... * (i)  the Software when embedded on a Microchip microcontroller or 
.................... *      digital signal controller product ("Device") which is 
.................... *      integrated into Licensee's product; or 
.................... * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
.................... *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
.................... *      used in conjunction with a Microchip ethernet controller for 
.................... *      the sole purpose of interfacing with the ethernet controller. 
.................... * 
.................... * You should refer to the license agreement accompanying this 
.................... * Software for additional information regarding your rights and 
.................... * obligations. 
.................... * 
.................... * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
.................... * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
.................... * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
.................... * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
.................... * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
.................... * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
.................... * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
.................... * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
.................... * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
.................... * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
.................... * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
.................... * 
.................... * 
.................... * Author               Date    Comment 
.................... *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
.................... * Nilesh Rajbharti     7/10/02  Explicitly initialized tempIPAddress 
.................... *                                               (Rev 2.11) 
.................... * Nilesh Rajbharti     5/16/03 Increased DHCP_TIMEOUT to 2 seconds. 
.................... * Nilesh Rajbharti     5/16/03 Fixed SM_DHCP_BROADCAST logic 
.................... *                              where UDPPut was called before setting 
.................... *                              active socket. 
.................... * Robert Sloan         5/29/03 Improved DHCP State machine to handle 
.................... *                              NAK and renew existing IP address. 
.................... * Nilesh Rajbharti     8/15/03 Modified _DHCPRecieve() to check for 
.................... *                              chaddr field before accpting the packet. 
.................... *                              Fixed DHCPTask() where it would not 
.................... *                              reply to first OFFER. 
.................... * Nilesh Rajbharti     3/1/04  Used tickDiff in DHCPTask() "bind" 
.................... *                              state to adjust for irregular TICK_SECOND 
.................... *                              Without this logic, actual lease time count 
.................... *                              down may be incorrect. 
.................... * Howard Schlunder      5/11/06   Fixed tickDiff usage, reducing  
.................... *                        accumulated timing error.  Fixed DHCP  
.................... *                        state machine requesting IP 0.0.0.0  
.................... *                        after lease expiration. 
.................... * Howard Schlunder      6/01/06   Added DHCPFlags.bits.bOfferReceived flag to  
.................... *                        allow operation on networks with multiple 
.................... *                        DHCP servers offering multiple addresses 
.................... * Howard Schlunder      8/01/06 Added DNS server option to DHCP request,  
.................... *                        untested Host Name option to DHCP request 
.................... * Howard Schlunder      1/09/06   Fixed a DHCP renewal not renewing lease time bug 
.................... * Howard Schlunder      3/16/07 Rewrote DHCP state machine 
.................... * Darren Rook/CCS       04/11/11 Changed default time from 2s to 5s. 
.................... * Darren Rook/CCS       04/11/11 Added MY_UNIT_HOSTNAME support. 
.................... * Darren Rook  (CCS)    01/06/12 Random XID (g_DNSTransactionID) 
.................... ********************************************************************/ 
.................... #define __DHCP_C 
....................  
.................... #include "TCPIPConfig.h" 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
....................  
.................... #define STACK_USE_ICMP_SERVER    1 
.................... #define STACK_USE_TCP            1 
.................... #define STACK_USE_DHCP_CLIENT    1 
....................  
.................... #define STACK_CCS_SMTP_TX_SIZE    0 
.................... #define STACK_CCS_SMTP_RX_SIZE    0 
....................  
.................... #define STACK_USE_CCS_HTTP2_SERVER 
.................... #define STACK_CCS_HTTP2_SERVER_TX_SIZE    1500 
.................... #define STACK_CCS_HTTP2_SERVER_RX_SIZE    500 
.................... #define HTTP_NUM_SOCKETS                  1 
.................... #define HTTP_PORT                         (80u) 
.................... #define HTTP_USE_DOUBLE_ESCAPE            1 
.................... #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................  
.................... #define STACK_MY_TELNET_SERVER_TX_SIZE    0 
.................... #define STACK_MY_TELNET_SERVER_RX_SIZE    0 
....................  
.................... #define STACK_MY_HTTPC_RX_SIZE    0 
.................... #define STACK_MY_HTTPC_TX_SIZE    0 
....................  
.................... #define MY_DEFAULT_HOST_NAME      "CCS_EXAMPLES" 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1      (0x0) 
.................... #define MY_DEFAULT_MAC_BYTE2      (0x8) 
.................... #define MY_DEFAULT_MAC_BYTE3      (0xdc) 
.................... #define MY_DEFAULT_MAC_BYTE4      (0x18) 
.................... #define MY_DEFAULT_MAC_BYTE5      (0x7c) 
.................... #define MY_DEFAULT_MAC_BYTE6      (0x6) 
....................  
.................... #define MY_DEFAULT_IP_ADDR_BYTE1  (10ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE2  (2ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE3  (10ul) 
.................... #define MY_DEFAULT_IP_ADDR_BYTE4  (200ul) 
....................  
.................... #define MY_DEFAULT_GATE_BYTE1     (10ul) 
.................... #define MY_DEFAULT_GATE_BYTE2     (2ul) 
.................... #define MY_DEFAULT_GATE_BYTE3     (10ul) 
.................... #define MY_DEFAULT_GATE_BYTE4     (1ul) 
....................  
.................... #define MY_DEFAULT_MASK_BYTE1     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE2     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE3     (255ul) 
.................... #define MY_DEFAULT_MASK_BYTE4     (0ul) 
....................  
.................... #define TCP_CONFIGURATION      1 
....................  
.................... #define TCP_ETH_RAM_SIZE (STACK_CCS_SMTP_TX_SIZE + \ 
....................                           STACK_CCS_SMTP_RX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_TX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_RX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_TX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_RX_SIZE + \ 
....................                           STACK_MY_HTTPC_TX_SIZE + \ 
....................                           STACK_MY_HTTPC_RX_SIZE + \ 
....................                           100*TCP_CONFIGURATION) 
....................  
.................... // Define names of socket types 
.................... #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
.................... #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
.................... #define TCP_PURPOSE_TELNET             2 
.................... #define TCP_PURPOSE_FTP_COMMAND        3 
.................... #define TCP_PURPOSE_FTP_DATA           4 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
.................... #define TCP_PURPOSE_UART_2_TCP_BRIDGE  7 
.................... #define TCP_PURPOSE_HTTP_SERVER        8 
.................... #define TCP_PURPOSE_DEFAULT            9 
.................... #define TCP_PURPOSE_BERKELEY_SERVER    10 
.................... #define TCP_PURPOSE_BERKELEY_CLIENT    11 
.................... #define TCP_PURPOSE_CCS_SMTP           0x40 
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // Defines how long to wait before a DHCP request times out 
.................... #define DHCP_TIMEOUT            (5ul*TICK_SECOND) //__CCS__ 
....................  
.................... union 
.................... { 
....................    uint8_t b[4]; 
....................    uint16_t w[2]; 
....................    uint32_t dw; 
.................... } g_DNSTransactionID;   //__CCS__ 
....................  
.................... // Unique variables per interface 
.................... typedef struct 
.................... { 
....................    UDP_SOCKET         hDHCPSocket;   // Handle to DHCP client socket 
....................    SM_DHCP            smState;      // DHCP client state machine variable 
....................    union 
....................    { 
....................        struct 
....................        { 
....................            unsigned char bIsBound : 1;            // Whether or not DHCP is currently bound 
....................            unsigned char bEvent : 1;            // Indicates to an external module that the DHCP client has been reset, has obtained new parameters via the DHCP client, or has refreshed a lease on existing ones 
....................            unsigned char bOfferReceived : 1;      // Whether or not an offer has been received 
....................          unsigned char bDHCPServerDetected : 1;   // Indicates if a DCHP server has been detected 
....................          unsigned char bUseUnicastMode : 1;      // Indicates if the  
....................        } bits; 
....................        BYTE val; 
....................    } flags; 
....................    DWORD             dwTimer;      // Tick timer value used for triggering future events after a certain wait period. 
....................    DWORD            dwLeaseTime;   // DHCP lease time remaining, in seconds 
....................    DWORD            dwServerID;      // DHCP Server ID cache 
....................    IP_ADDR            tempIPAddress;   // Temporary IP address to use when no DHCP lease 
....................    IP_ADDR            tempGateway;   // Temporary gateway to use when no DHCP lease 
....................    IP_ADDR            tempMask;      // Temporary mask to use when no DHCP lease 
....................    #if defined(STACK_USE_DNS) 
....................    IP_ADDR            tempDNS;      // Temporary primary DNS server 
....................    IP_ADDR            tempDNS2;      // Temporary secondary DNS server 
....................    #endif    
....................    // Indicates which DHCP values are currently valid 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          char IPAddress:1;   // Leased IP address is valid 
....................          char Gateway:1;      // Gateway address is valid 
....................          char Mask:1;      // Subnet mask is valid 
....................          char DNS:1;         // Primary DNS is valid 
....................          char DNS2:1;      // Secondary DNS is valid 
....................          char HostName:1;   // Host name is valid (not implemented) 
....................       } bits; 
....................       BYTE val; 
....................    } validValues; 
.................... } DHCP_CLIENT_VARS; 
....................  
.................... BOOL DHCPClientInitializedOnce = FALSE; 
....................  
.................... static BYTE _DHCPReceive(void); 
.................... static void _DHCPSend(BYTE messageType, BOOL bRenewing); 
....................  
.................... #if defined (WF_CS_IO) 
.................... extern void SignalDHCPSuccessful(void); 
.................... extern void SetDhcpProgressState(void); 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void LoadState(BYTE vInterface) 
....................  
....................   Summary: 
....................    Saves the DHCPClient state information structure to the appropriate  
....................    location and loads DHCPClient with the state information for the specified  
....................    interface. 
....................  
....................   Description: 
....................    Saves the DHCPClient state information structure to the appropriate  
....................    location and loads DHCPClient with the state information for the specified  
....................    interface. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................      This function does nothing when you only have one physical interface. 
.................... ***************************************************************************/ 
.................... #if NETWORK_INTERFACES > 1 
....................  
.................... static DHCP_CLIENT_VARS   DHCPClients[NETWORK_INTERFACES]; 
.................... static DHCP_CLIENT_VARS   *SelectedDHCPClient; 
.................... #define DHCPClient      (*SelectedDHCPClient) 
.................... #define LoadState(v)   do(SelectedDHCPClient = &DHCPClients[v])while(0) 
....................  
.................... #else 
....................  
.................... static DHCP_CLIENT_VARS DHCPClient; 
.................... #define LoadState(v) 
....................  
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void DHCPInit(BYTE vInterface) 
....................  
....................   Summary: 
....................    Resets the DHCP client module for the specified interface. 
....................  
....................   Description: 
....................    Resets the DHCP client module, giving up any current lease, knowledge of  
....................    DHCP servers, etc. for the specified interface. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    vInterface - Interface number to initialize DHCP client state variables  
....................       for.   If you only have one interface, specify 0x00. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function may be called multiple times throughout the life of the  
....................    application, if desired.   
.................... ***************************************************************************/ 
.................... void DHCPInit(BYTE vInterface) 
.................... { 
....................    BYTE i; 
....................     
....................    // Upon the first call after POR, we must reset all handles to invalid so  
....................    // that we don't inadvertently close someone else's handle. 
....................    if(!DHCPClientInitializedOnce) 
*
013A6:  MOVLB  1
013A8:  BTFSC  x12.4
013AA:  BRA    13C2
....................    { 
....................       DHCPClientInitializedOnce = TRUE; 
013AC:  BSF    x12.4
....................       for(i = 0; i < NETWORK_INTERFACES; i++) 
013AE:  MOVLB  5
013B0:  CLRF   xBF
013B2:  MOVF   xBF,F
013B4:  BNZ   13C0
....................       { 
....................          LoadState(i); 
....................          DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
013B6:  MOVLB  1
013B8:  SETF   x44
013BA:  MOVLB  5
013BC:  INCF   xBF,F
013BE:  BRA    13B2
013C0:  MOVLB  1
....................       }       
....................    } 
....................     
....................     
....................    LoadState(vInterface); 
....................     
....................    if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET) 
013C2:  INCFSZ x44,W
013C4:  BRA    13C8
013C6:  BRA    13D6
....................    { 
....................       UDPClose(DHCPClient.hDHCPSocket); 
013C8:  MOVFF  144,5C0
013CC:  MOVLB  0
013CE:  CALL   09B4
....................       DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
013D2:  MOVLB  1
013D4:  SETF   x44
....................    } 
....................  
....................    // Reset state machine and flags to default values 
....................    DHCPClient.smState = SM_DHCP_GET_SOCKET; 
013D6:  MOVLW  01
013D8:  MOVWF  x45
....................    DHCPClient.flags.val = 0; 
013DA:  CLRF   x46
....................    DHCPClient.flags.bits.bUseUnicastMode = TRUE;   // This flag toggles before use, so this statement actually means to start out using broadcast mode. 
013DC:  BSF    x46.4
....................    DHCPClient.flags.bits.bEvent = TRUE; 
013DE:  BSF    x46.1
013E0:  MOVLB  0
013E2:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void DHCPDisable(BYTE vInterface) 
....................  
....................   Summary: 
....................    Disables the DHCP Client for the specified interface. 
....................  
....................   Description: 
....................    Disables the DHCP client for the specified interface by sending the state  
....................    machine to "SM_DHCP_DISABLED".  If the interface was previously configured  
....................    by DHCP, the configuration will continue to be used but the module will no  
....................    longer preform any renewals. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    vInterface - Interface number to disable the DHCP client on.   If you only  
....................       have one interface, specify 0x00. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Since the interface continues using its old configuration, it is possible  
....................    that the lease may expire and the DHCP server provide the IP to another 
....................    client.  The application should replace the current IP address and other 
....................    configuration with static information following a call to this function. 
.................... ***************************************************************************/ 
.................... void DHCPDisable(BYTE vInterface) 
.................... { 
....................    LoadState(vInterface); 
....................  
....................    if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET) 
013E4:  MOVLB  1
013E6:  INCFSZ x44,W
013E8:  BRA    13EC
013EA:  BRA    13FA
....................    { 
....................       UDPClose(DHCPClient.hDHCPSocket); 
013EC:  MOVFF  144,5C0
013F0:  MOVLB  0
013F2:  CALL   09B4
....................       DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
013F6:  MOVLB  1
013F8:  SETF   x44
....................    } 
....................  
....................    DHCPClient.smState = SM_DHCP_DISABLED; 
013FA:  CLRF   x45
013FC:  MOVLB  0
013FE:  GOTO   156A (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void DHCPEnable(BYTE vInterface) 
....................  
....................   Summary: 
....................    Enables the DHCP client for the specified interface. 
....................  
....................   Description: 
....................    Enables the DHCP client for the specified interface, if it is disabled.   
....................    If it is already enabled, nothing is done. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    vInterface - Interface number to enable the DHCP client on.   If you only  
....................       have one interface, specify 0x00. 
....................  
....................   Returns: 
....................    None 
.................... ***************************************************************************/ 
.................... void DHCPEnable(BYTE vInterface) 
.................... { 
....................    LoadState(vInterface); 
....................  
....................    if(DHCPClient.smState == SM_DHCP_DISABLED) 
....................    { 
....................       DHCPClient.smState = SM_DHCP_GET_SOCKET; 
....................       DHCPClient.flags.bits.bIsBound = FALSE; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL DHCPIsEnabled(BYTE vInterface) 
....................  
....................   Summary: 
....................    Determins if the DHCP client is enabled on the specified interface. 
....................  
....................   Description: 
....................    Determins if the DHCP client is enabled on the specified interface. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    vInterface - Interface number to query.   If you only have one interface,  
....................       specify 0x00. 
....................  
....................   Returns: 
....................    None 
.................... ***************************************************************************/ 
.................... BOOL DHCPIsEnabled(BYTE vInterface) 
.................... { 
....................    LoadState(vInterface); 
....................    return DHCPClient.smState != SM_DHCP_DISABLED; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL DHCPIsBound(BYTE vInterface) 
....................  
....................   Summary: 
....................    Determins if the DHCP client has an IP address lease on the specified  
....................    interface. 
....................  
....................   Description: 
....................    Determins if the DHCP client has an IP address lease on the specified  
....................    interface. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    vInterface - Interface number to query.   If you only have one interface,  
....................       specify 0x00. 
....................  
....................   Returns: 
....................    TRUE - DHCP client has obtained an IP address lease (and likely other  
....................       parameters) and these values are currently being used. 
....................    FALSE - No IP address is currently leased 
.................... ***************************************************************************/ 
.................... BOOL DHCPIsBound(BYTE vInterface) 
.................... { 
....................    LoadState(vInterface); 
....................    return DHCPClient.flags.bits.bIsBound; 
*
02F8C:  MOVLW  00
02F8E:  MOVLB  1
02F90:  BTFSC  x46.0
02F92:  MOVLW  01
02F94:  MOVWF  01
02F96:  MOVLB  0
02F98:  GOTO   6C86 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL DHCPStateChanged(BYTE vInterface) 
....................  
....................   Summary: 
....................    Determins if the DHCP client on the specified interface has changed states  
....................    or refreshed its IP address lease. 
....................  
....................   Description: 
....................    Determins if the DHCP client on the specified interface has changed states  
....................    or refreshed its IP address lease.  This function can be used to determine 
....................    when to update an LCD or other display whenever the DHCP assigned IP  
....................    address has potentially changed. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    vInterface - Interface number to query.   If you only have one interface,  
....................       specify 0x00. 
....................  
....................   Returns: 
....................    TRUE - The IP address lease have been reliquished (due to reinitilization),  
....................       obtained (first event), or renewed since the last call to  
....................       DHCPStateChanged(). 
....................    FALSE - The DHCP client has not detected any changes since the last call to  
....................       DHCPStateChanged(). 
.................... ***************************************************************************/ 
.................... BOOL DHCPStateChanged(BYTE vInterface) 
.................... { 
....................    LoadState(vInterface); 
....................    if(DHCPClient.flags.bits.bEvent) 
....................    { 
....................       DHCPClient.flags.bits.bEvent = 0; 
....................       return TRUE; 
....................    } 
....................    return FALSE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL DHCPIsServerDetected(BYTE vInterface) 
....................  
....................   Summary: 
....................    Determins if the DHCP client on the specified interface has seen a DHCP  
....................    server. 
....................  
....................   Description: 
....................    Determins if the DHCP client on the specified interface has seen a DHCP  
....................    server. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    vInterface - Interface number to query.   If you only have one interface,  
....................       specify 0x00. 
....................  
....................   Returns: 
....................    TRUE - At least one DHCP server is attached to the specified network  
....................       interface. 
....................    FALSE - No DHCP servers are currently detected on the specified network  
....................       interface. 
.................... ***************************************************************************/ 
.................... BOOL DHCPIsServerDetected(BYTE vInterface) 
.................... { 
....................    LoadState(vInterface); 
....................    return DHCPClient.flags.bits.bDHCPServerDetected; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void DHCPTask(void) 
....................  
....................   Summary: 
....................    Performs periodic DHCP tasks for all interfaces. 
....................  
....................   Description: 
....................    This function performs any periodic tasks requied by the DHCP module,  
....................    such as sending and receiving messages involved with obtaining and 
....................    maintaining a lease. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
.................... ***************************************************************************/ 
.................... void DHCPTask(void) 
.................... { 
....................    BYTE i; 
....................     
....................    for(i = 0; i < NETWORK_INTERFACES; i++) 
*
02A58:  MOVLB  5
02A5A:  CLRF   xBE
02A5C:  MOVF   xBE,F
02A5E:  BTFSS  FD8.2
02A60:  BRA    2F52
....................    { 
....................       LoadState(i); 
....................       switch(DHCPClient.smState) 
02A62:  MOVLB  1
02A64:  MOVF   x45,W
02A66:  ADDLW  F3
02A68:  BTFSC  FD8.0
02A6A:  BRA    2F4C
02A6C:  ADDLW  0D
02A6E:  MOVLB  0
02A70:  GOTO   2F58
....................       { 
....................          case SM_DHCP_DISABLED: 
....................             // When the module is disabled, do absolutely nothing 
....................             break; 
02A74:  MOVLB  1
02A76:  BRA    2F4C
....................           
....................          case SM_DHCP_GET_SOCKET: 
....................             // Open a socket to send and receive broadcast messages on 
....................             //DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT); 
....................              
....................             DHCPClient.hDHCPSocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_CLIENT_PORT, DHCP_SERVER_PORT); 
02A78:  MOVLB  5
02A7A:  CLRF   xC2
02A7C:  CLRF   xC1
02A7E:  CLRF   xC0
02A80:  CLRF   xBF
02A82:  CLRF   xC3
02A84:  CLRF   xC5
02A86:  MOVLW  44
02A88:  MOVWF  xC4
02A8A:  CLRF   xC7
02A8C:  MOVLW  43
02A8E:  MOVWF  xC6
02A90:  MOVLB  0
02A92:  CALL   1648
02A96:  MOVFF  01,144
....................             if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET) 
02A9A:  MOVLB  1
02A9C:  INCFSZ x44,W
02A9E:  BRA    2AA2
....................                break; 
02AA0:  BRA    2F4C
....................     
....................             DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02AA2:  MOVLW  02
02AA4:  MOVWF  x45
02AA6:  MOVLB  0
....................             // No break 
....................     
....................          case SM_DHCP_SEND_DISCOVERY: 
....................             // Assume default IP Lease time of 60 seconds. 
....................             // This should be minimum possible to make sure that if the 
....................             // server did not specify lease time, we try again after this  
....................             // minimum time. 
....................             DHCPClient.dwLeaseTime = 60; 
02AA8:  MOVLB  1
02AAA:  CLRF   x4E
02AAC:  CLRF   x4D
02AAE:  CLRF   x4C
02AB0:  MOVLW  3C
02AB2:  MOVWF  x4B
....................             DHCPClient.validValues.val = 0x00; 
02AB4:  CLRF   x5F
....................             DHCPClient.flags.bits.bIsBound = FALSE;    
02AB6:  BCF    x46.0
....................             DHCPClient.flags.bits.bOfferReceived = FALSE; 
02AB8:  BCF    x46.2
....................     
....................             // No point in wasting time transmitting a discovery if we are  
....................             // unlinked.  No one will see it.   
....................             if(!MACIsLinked()) 
02ABA:  MOVLB  0
02ABC:  CALL   162C
02AC0:  MOVF   01,F
02AC2:  BNZ   2ACA
....................                break; 
02AC4:  MOVLB  1
02AC6:  BRA    2F4C
02AC8:  MOVLB  0
....................     
....................             // Ensure transmitter is ready to accept data 
....................             if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 300u) 
02ACA:  MOVFF  144,5BF
02ACE:  CALL   180C
02AD2:  MOVFF  02,5C0
02AD6:  MOVFF  01,5BF
02ADA:  MOVLB  5
02ADC:  MOVF   02,W
02ADE:  SUBLW  01
02AE0:  BNC   2AF0
02AE2:  BNZ   2AEA
02AE4:  MOVF   xBF,W
02AE6:  SUBLW  2B
02AE8:  BNC   2AF0
....................                break; 
02AEA:  MOVLB  1
02AEC:  BRA    2F4C
02AEE:  MOVLB  5
....................  
....................             // Toggle the BOOTP Broadcast flag to ensure compatibility with  
....................             // bad DHCP servers that don't know how to handle broadcast  
....................             // responses.  This results in the next discovery attempt to be  
....................             // made using the opposite mode. 
....................             DHCPClient.flags.bits.bUseUnicastMode ^= 1; 
02AF0:  MOVLW  00
02AF2:  MOVLB  1
02AF4:  BTFSC  x46.4
02AF6:  MOVLW  01
02AF8:  XORLW  01
02AFA:  BCF    x46.4
02AFC:  BTFSC  FE8.0
02AFE:  BSF    x46.4
....................     
....................             // Ensure that we transmit to the broadcast IP and MAC addresses 
....................             // The UDP Socket remembers who it was last talking to 
....................             memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remote.remoteNode)); 
02B00:  MOVF   x44,W
02B02:  MULLW  17
02B04:  MOVF   FF3,W
02B06:  MOVLB  5
02B08:  CLRF   xC0
02B0A:  MOVWF  xBF
02B0C:  MOVLW  53
02B0E:  ADDWF  xBF,W
02B10:  MOVWF  01
02B12:  MOVLW  00
02B14:  ADDWFC xC0,W
02B16:  MOVWF  03
02B18:  MOVFF  01,5C1
02B1C:  MOVWF  xC2
02B1E:  MOVWF  FEA
02B20:  MOVFF  01,FE9
02B24:  SETF   00
02B26:  CLRF   02
02B28:  MOVLW  0A
02B2A:  MOVWF  01
02B2C:  MOVLB  0
02B2E:  CALL   0A5A
....................     
....................             // Send the DHCP Discover broadcast 
....................             _DHCPSend(DHCP_DISCOVER_MESSAGE, FALSE); 
02B32:  MOVLW  01
02B34:  MOVLB  5
02B36:  MOVWF  xBF
02B38:  CLRF   xC0
02B3A:  MOVLB  0
02B3C:  CALL   20F4
....................     
....................             // Start a timer and begin looking for a response 
....................             DHCPClient.dwTimer = TickGet(); 
02B40:  RCALL  23FC
02B42:  MOVFF  03,14A
02B46:  MOVFF  02,149
02B4A:  MOVFF  01,148
02B4E:  MOVFF  00,147
....................             DHCPClient.smState = SM_DHCP_GET_OFFER; 
02B52:  MOVLW  03
02B54:  MOVLB  1
02B56:  MOVWF  x45
....................             break; 
02B58:  BRA    2F4C
....................     
....................          case SM_DHCP_GET_OFFER: 
....................             // Check to see if a packet has arrived 
....................             if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) 
02B5A:  MOVFF  144,5BF
02B5E:  RCALL  24BA
02B60:  MOVFF  02,5C0
02B64:  MOVFF  01,5BF
02B68:  MOVLB  5
02B6A:  MOVF   xC0,F
02B6C:  BNZ   2BD2
02B6E:  MOVF   xBF,W
02B70:  SUBLW  F9
02B72:  BNC   2BD2
....................             { 
....................                // Go back and transmit a new discovery if we didn't get an offer after 2 seconds 
....................                if(TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT) 
02B74:  MOVLB  0
02B76:  RCALL  23FC
02B78:  MOVFF  03,5C2
02B7C:  MOVFF  02,5C1
02B80:  MOVFF  01,5C0
02B84:  MOVFF  00,5BF
02B88:  MOVLB  1
02B8A:  MOVF   x47,W
02B8C:  MOVLB  5
02B8E:  SUBWF  xBF,F
02B90:  MOVLB  1
02B92:  MOVF   x48,W
02B94:  MOVLB  5
02B96:  SUBWFB xC0,F
02B98:  MOVLB  1
02B9A:  MOVF   x49,W
02B9C:  MOVLB  5
02B9E:  SUBWFB xC1,F
02BA0:  MOVLB  1
02BA2:  MOVF   x4A,W
02BA4:  MOVLB  5
02BA6:  SUBWFB xC2,F
02BA8:  BNZ   2BC4
02BAA:  MOVF   xC1,W
02BAC:  SUBLW  01
02BAE:  BC    2BCC
02BB0:  XORLW  FF
02BB2:  BNZ   2BC4
02BB4:  MOVF   xC0,W
02BB6:  SUBLW  61
02BB8:  BC    2BCC
02BBA:  XORLW  FF
02BBC:  BNZ   2BC4
02BBE:  MOVF   xBF,W
02BC0:  SUBLW  59
02BC2:  BC    2BCC
....................                   DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02BC4:  MOVLW  02
02BC6:  MOVLB  1
02BC8:  MOVWF  x45
02BCA:  MOVLB  5
....................                break; 
02BCC:  MOVLB  1
02BCE:  BRA    2F4C
02BD0:  MOVLB  5
....................             } 
....................     
....................             // Let the DHCP server module know that there is a DHCP server  
....................             // on this network 
....................             DHCPClient.flags.bits.bDHCPServerDetected = TRUE; 
02BD2:  MOVLB  1
02BD4:  BSF    x46.3
....................     
....................             // Check to see if we received an offer 
....................             if(_DHCPReceive() != DHCP_OFFER_MESSAGE) 
02BD6:  MOVLB  0
02BD8:  RCALL  265C
02BDA:  MOVF   01,W
02BDC:  SUBLW  02
02BDE:  BZ    2BE6
....................                break; 
02BE0:  MOVLB  1
02BE2:  BRA    2F4C
02BE4:  MOVLB  0
....................     
....................             DHCPClient.smState = SM_DHCP_SEND_REQUEST; 
02BE6:  MOVLW  04
02BE8:  MOVLB  1
02BEA:  MOVWF  x45
02BEC:  MOVLB  0
....................             // No break 
....................     
....................          case SM_DHCP_SEND_REQUEST: 
....................             if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u) 
02BEE:  MOVFF  144,5BF
02BF2:  CALL   180C
02BF6:  MOVFF  02,5C0
02BFA:  MOVFF  01,5BF
02BFE:  MOVLB  5
02C00:  MOVF   02,W
02C02:  SUBLW  01
02C04:  BNC   2C14
02C06:  BNZ   2C0E
02C08:  MOVF   xBF,W
02C0A:  SUBLW  01
02C0C:  BNC   2C14
....................                break; 
02C0E:  MOVLB  1
02C10:  BRA    2F4C
02C12:  MOVLB  5
....................  
....................             // Ensure that we transmit to the broadcast IP and MAC addresses 
....................             // The UDP Socket remembers who it was last talking to, so  
....................             // we must set this back to the broadcast address since the  
....................             // current socket values are the unicast addresses of the DHCP  
....................             // server. 
....................             memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remote.remoteNode)); 
02C14:  MOVLB  1
02C16:  MOVF   x44,W
02C18:  MULLW  17
02C1A:  MOVF   FF3,W
02C1C:  MOVLB  5
02C1E:  CLRF   xC0
02C20:  MOVWF  xBF
02C22:  MOVLW  53
02C24:  ADDWF  xBF,W
02C26:  MOVWF  01
02C28:  MOVLW  00
02C2A:  ADDWFC xC0,W
02C2C:  MOVWF  03
02C2E:  MOVFF  01,5C1
02C32:  MOVWF  xC2
02C34:  MOVWF  FEA
02C36:  MOVFF  01,FE9
02C3A:  SETF   00
02C3C:  CLRF   02
02C3E:  MOVLW  0A
02C40:  MOVWF  01
02C42:  MOVLB  0
02C44:  CALL   0A5A
....................     
....................             // Send the DHCP request message 
....................             _DHCPSend(DHCP_REQUEST_MESSAGE, FALSE); 
02C48:  MOVLW  03
02C4A:  MOVLB  5
02C4C:  MOVWF  xBF
02C4E:  CLRF   xC0
02C50:  MOVLB  0
02C52:  CALL   20F4
....................     
....................             // Start a timer and begin looking for a response 
....................             DHCPClient.dwTimer = TickGet(); 
02C56:  CALL   23FC
02C5A:  MOVFF  03,14A
02C5E:  MOVFF  02,149
02C62:  MOVFF  01,148
02C66:  MOVFF  00,147
....................             DHCPClient.smState = SM_DHCP_GET_REQUEST_ACK; 
02C6A:  MOVLW  05
02C6C:  MOVLB  1
02C6E:  MOVWF  x45
....................             break; 
02C70:  BRA    2F4C
....................     
....................          case SM_DHCP_GET_REQUEST_ACK: 
....................             // Check to see if a packet has arrived 
....................             if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) 
02C72:  MOVFF  144,5BF
02C76:  RCALL  24BA
02C78:  MOVFF  02,5C0
02C7C:  MOVFF  01,5BF
02C80:  MOVLB  5
02C82:  MOVF   xC0,F
02C84:  BNZ   2CEC
02C86:  MOVF   xBF,W
02C88:  SUBLW  F9
02C8A:  BNC   2CEC
....................             { 
....................                // Go back and transmit a new discovery if we didn't get an ACK after 2 seconds 
....................                if(TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT) 
02C8C:  MOVLB  0
02C8E:  CALL   23FC
02C92:  MOVFF  03,5C2
02C96:  MOVFF  02,5C1
02C9A:  MOVFF  01,5C0
02C9E:  MOVFF  00,5BF
02CA2:  MOVLB  1
02CA4:  MOVF   x47,W
02CA6:  MOVLB  5
02CA8:  SUBWF  xBF,F
02CAA:  MOVLB  1
02CAC:  MOVF   x48,W
02CAE:  MOVLB  5
02CB0:  SUBWFB xC0,F
02CB2:  MOVLB  1
02CB4:  MOVF   x49,W
02CB6:  MOVLB  5
02CB8:  SUBWFB xC1,F
02CBA:  MOVLB  1
02CBC:  MOVF   x4A,W
02CBE:  MOVLB  5
02CC0:  SUBWFB xC2,F
02CC2:  BNZ   2CDE
02CC4:  MOVF   xC1,W
02CC6:  SUBLW  01
02CC8:  BC    2CE6
02CCA:  XORLW  FF
02CCC:  BNZ   2CDE
02CCE:  MOVF   xC0,W
02CD0:  SUBLW  61
02CD2:  BC    2CE6
02CD4:  XORLW  FF
02CD6:  BNZ   2CDE
02CD8:  MOVF   xBF,W
02CDA:  SUBLW  59
02CDC:  BC    2CE6
....................                   DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02CDE:  MOVLW  02
02CE0:  MOVLB  1
02CE2:  MOVWF  x45
02CE4:  MOVLB  5
....................                break; 
02CE6:  MOVLB  1
02CE8:  BRA    2F4C
02CEA:  MOVLB  5
....................             } 
....................     
....................             // Check to see if we received an offer 
....................             switch(_DHCPReceive()) 
02CEC:  MOVLB  0
02CEE:  RCALL  265C
02CF0:  MOVF   01,W
02CF2:  XORLW  05
02CF4:  BZ    2CFC
02CF6:  XORLW  03
02CF8:  BZ    2D68
02CFA:  BRA    2D70
....................             { 
....................                case DHCP_ACK_MESSAGE: 
....................                   UDPClose(DHCPClient.hDHCPSocket); 
02CFC:  MOVFF  144,5C0
02D00:  CALL   09B4
....................                   DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
02D04:  MOVLB  1
02D06:  SETF   x44
....................                   DHCPClient.dwTimer = TickGet(); 
02D08:  MOVLB  0
02D0A:  CALL   23FC
02D0E:  MOVFF  03,14A
02D12:  MOVFF  02,149
02D16:  MOVFF  01,148
02D1A:  MOVFF  00,147
....................                   DHCPClient.smState = SM_DHCP_BOUND; 
02D1E:  MOVLW  06
02D20:  MOVLB  1
02D22:  MOVWF  x45
....................                   DHCPClient.flags.bits.bEvent = 1; 
02D24:  BSF    x46.1
....................                   DHCPClient.flags.bits.bIsBound = TRUE;    
02D26:  BSF    x46.0
....................  
....................                   if(DHCPClient.validValues.bits.IPAddress) 
02D28:  BTFSS  x5F.0
02D2A:  BRA    2D3C
....................                   { 
....................                      AppConfig.MyIPAddr = DHCPClient.tempIPAddress; 
02D2C:  MOVFF  156,22
02D30:  MOVFF  155,21
02D34:  MOVFF  154,20
02D38:  MOVFF  153,1F
....................                       
....................                      #if defined(WF_CS_IO)  
....................                          #if defined(STACK_USE_UART ) 
....................                              putrsUART("DHCP client successful\r\n"); 
....................                          #endif 
....................                          SignalDHCPSuccessful(); 
....................                      #endif 
....................                       
....................                   }    
....................                   if(DHCPClient.validValues.bits.Mask) 
02D3C:  BTFSS  x5F.2
02D3E:  BRA    2D50
....................                      AppConfig.MyMask = DHCPClient.tempMask; 
02D40:  MOVFF  15E,26
02D44:  MOVFF  15D,25
02D48:  MOVFF  15C,24
02D4C:  MOVFF  15B,23
....................                   if(DHCPClient.validValues.bits.Gateway) 
02D50:  BTFSS  x5F.1
02D52:  BRA    2D64
....................                      AppConfig.MyGateway = DHCPClient.tempGateway; 
02D54:  MOVFF  15A,2A
02D58:  MOVFF  159,29
02D5C:  MOVFF  158,28
02D60:  MOVFF  157,27
....................                   #if defined(STACK_USE_DNS) 
....................                      if(DHCPClient.validValues.bits.DNS) 
....................                         AppConfig.PrimaryDNSServer.Val = DHCPClient.tempDNS.Val; 
....................                      AppConfig.SecondaryDNSServer.Val = 0x00000000ul; 
....................                      if(DHCPClient.validValues.bits.DNS2) 
....................                         AppConfig.SecondaryDNSServer.Val = DHCPClient.tempDNS2.Val; 
....................                   #endif 
....................                   //if(DHCPClient.validValues.bits.HostName) 
....................                   //   memcpy(AppConfig.NetBIOSName, (void*)DHCPClient.tempHostName, sizeof(AppConfig.NetBIOSName)); 
....................     
....................                   break; 
02D64:  MOVLB  0
02D66:  BRA    2D70
....................     
....................                case DHCP_NAK_MESSAGE: 
....................                   DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02D68:  MOVLW  02
02D6A:  MOVLB  1
02D6C:  MOVWF  x45
....................                   break; 
02D6E:  MOVLB  0
....................             } 
....................             break; 
02D70:  MOVLB  1
02D72:  BRA    2F4C
....................     
....................          case SM_DHCP_BOUND: 
....................             if(TickGet() - DHCPClient.dwTimer < TICK_SECOND) 
02D74:  CALL   23FC
02D78:  MOVFF  03,5C2
02D7C:  MOVFF  02,5C1
02D80:  MOVFF  01,5C0
02D84:  MOVFF  00,5BF
02D88:  MOVLB  1
02D8A:  MOVF   x47,W
02D8C:  MOVLB  5
02D8E:  SUBWF  xBF,F
02D90:  MOVLB  1
02D92:  MOVF   x48,W
02D94:  MOVLB  5
02D96:  SUBWFB xC0,F
02D98:  MOVLB  1
02D9A:  MOVF   x49,W
02D9C:  MOVLB  5
02D9E:  SUBWFB xC1,F
02DA0:  MOVLB  1
02DA2:  MOVF   x4A,W
02DA4:  MOVLB  5
02DA6:  SUBWFB xC2,F
02DA8:  BNZ   2DC2
02DAA:  MOVF   xC1,F
02DAC:  BNZ   2DC2
02DAE:  MOVF   xC0,W
02DB0:  SUBLW  7A
02DB2:  BNC   2DC2
02DB4:  BNZ   2DBC
02DB6:  MOVF   xBF,W
02DB8:  SUBLW  11
02DBA:  BNC   2DC2
....................                break; 
02DBC:  MOVLB  1
02DBE:  BRA    2F4C
02DC0:  MOVLB  5
....................     
....................             // Check to see if our lease is still valid, if so, decrement lease  
....................             // time 
....................             if(DHCPClient.dwLeaseTime >= 2ul) 
02DC2:  MOVLB  1
02DC4:  MOVF   x4E,F
02DC6:  BNZ   2DD6
02DC8:  MOVF   x4D,F
02DCA:  BNZ   2DD6
02DCC:  MOVF   x4C,F
02DCE:  BNZ   2DD6
02DD0:  MOVF   x4B,W
02DD2:  SUBLW  01
02DD4:  BC    2DF6
....................             { 
....................                DHCPClient.dwTimer += TICK_SECOND; 
02DD6:  MOVLW  12
02DD8:  ADDWF  x47,F
02DDA:  MOVLW  7A
02DDC:  ADDWFC x48,F
02DDE:  MOVLW  00
02DE0:  ADDWFC x49,F
02DE2:  ADDWFC x4A,F
....................                DHCPClient.dwLeaseTime--; 
02DE4:  MOVLW  FF
02DE6:  ADDWF  x4B,F
02DE8:  BTFSS  FD8.0
02DEA:  ADDWF  x4C,F
02DEC:  BTFSS  FD8.0
02DEE:  ADDWF  x4D,F
02DF0:  BTFSS  FD8.0
02DF2:  ADDWF  x4E,F
....................                break; 
02DF4:  BRA    2F4C
....................             } 
....................     
....................             // Open a socket to send and receive DHCP messages on 
....................             //DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT); 
....................              
....................             DHCPClient.hDHCPSocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_CLIENT_PORT, DHCP_SERVER_PORT); 
02DF6:  MOVLB  5
02DF8:  CLRF   xC2
02DFA:  CLRF   xC1
02DFC:  CLRF   xC0
02DFE:  CLRF   xBF
02E00:  CLRF   xC3
02E02:  CLRF   xC5
02E04:  MOVLW  44
02E06:  MOVWF  xC4
02E08:  CLRF   xC7
02E0A:  MOVLW  43
02E0C:  MOVWF  xC6
02E0E:  MOVLB  0
02E10:  CALL   1648
02E14:  MOVFF  01,144
....................             if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET) 
02E18:  MOVLB  1
02E1A:  INCFSZ x44,W
02E1C:  BRA    2E20
....................                break; 
02E1E:  BRA    2F4C
....................     
....................             DHCPClient.smState = SM_DHCP_SEND_RENEW; 
02E20:  MOVLW  07
02E22:  MOVWF  x45
02E24:  MOVLB  0
....................             // No break 
....................     
....................          case SM_DHCP_SEND_RENEW: 
....................          case SM_DHCP_SEND_RENEW2: 
....................          case SM_DHCP_SEND_RENEW3: 
....................             if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u) 
02E26:  MOVFF  144,5BF
02E2A:  CALL   180C
02E2E:  MOVFF  02,5C0
02E32:  MOVFF  01,5BF
02E36:  MOVLB  5
02E38:  MOVF   02,W
02E3A:  SUBLW  01
02E3C:  BNC   2E4C
02E3E:  BNZ   2E46
02E40:  MOVF   xBF,W
02E42:  SUBLW  01
02E44:  BNC   2E4C
....................                break; 
02E46:  MOVLB  1
02E48:  BRA    2F4C
02E4A:  MOVLB  5
....................  
....................                                 #if defined(WF_CS_IO) 
....................                                     SetDhcpProgressState(); 
....................                                 #endif 
....................             // Send the DHCP request message 
....................             _DHCPSend(DHCP_REQUEST_MESSAGE, TRUE); 
02E4C:  MOVLW  03
02E4E:  MOVWF  xBF
02E50:  MOVLW  01
02E52:  MOVWF  xC0
02E54:  MOVLB  0
02E56:  CALL   20F4
....................             DHCPClient.flags.bits.bOfferReceived = FALSE; 
02E5A:  MOVLB  1
02E5C:  BCF    x46.2
....................     
....................             // Start a timer and begin looking for a response 
....................             DHCPClient.dwTimer = TickGet(); 
02E5E:  MOVLB  0
02E60:  CALL   23FC
02E64:  MOVFF  03,14A
02E68:  MOVFF  02,149
02E6C:  MOVFF  01,148
02E70:  MOVFF  00,147
....................             DHCPClient.smState++; 
02E74:  MOVLB  1
02E76:  INCF   x45,F
....................             break; 
02E78:  BRA    2F4C
....................     
....................          case SM_DHCP_GET_RENEW_ACK: 
....................          case SM_DHCP_GET_RENEW_ACK2: 
....................          case SM_DHCP_GET_RENEW_ACK3: 
....................             // Check to see if a packet has arrived 
....................             if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) 
02E7A:  MOVFF  144,5BF
02E7E:  CALL   24BA
02E82:  MOVFF  02,5C0
02E86:  MOVFF  01,5BF
02E8A:  MOVLB  5
02E8C:  MOVF   xC0,F
02E8E:  BNZ   2EFE
02E90:  MOVF   xBF,W
02E92:  SUBLW  F9
02E94:  BNC   2EFE
....................             { 
....................                // Go back and transmit a new discovery if we didn't get an ACK after 2 seconds 
....................                if(TickGet() - DHCPClient.dwTimer >=  DHCP_TIMEOUT) 
02E96:  MOVLB  0
02E98:  CALL   23FC
02E9C:  MOVFF  03,5C2
02EA0:  MOVFF  02,5C1
02EA4:  MOVFF  01,5C0
02EA8:  MOVFF  00,5BF
02EAC:  MOVLB  1
02EAE:  MOVF   x47,W
02EB0:  MOVLB  5
02EB2:  SUBWF  xBF,F
02EB4:  MOVLB  1
02EB6:  MOVF   x48,W
02EB8:  MOVLB  5
02EBA:  SUBWFB xC0,F
02EBC:  MOVLB  1
02EBE:  MOVF   x49,W
02EC0:  MOVLB  5
02EC2:  SUBWFB xC1,F
02EC4:  MOVLB  1
02EC6:  MOVF   x4A,W
02EC8:  MOVLB  5
02ECA:  SUBWFB xC2,F
02ECC:  BNZ   2EE8
02ECE:  MOVF   xC1,W
02ED0:  SUBLW  01
02ED2:  BC    2EF8
02ED4:  XORLW  FF
02ED6:  BNZ   2EE8
02ED8:  MOVF   xC0,W
02EDA:  SUBLW  61
02EDC:  BC    2EF8
02EDE:  XORLW  FF
02EE0:  BNZ   2EE8
02EE2:  MOVF   xBF,W
02EE4:  SUBLW  59
02EE6:  BC    2EF8
....................                { 
....................                   if(++DHCPClient.smState > SM_DHCP_GET_RENEW_ACK3) 
02EE8:  MOVLB  1
02EEA:  INCF   x45,F
02EEC:  MOVF   x45,W
02EEE:  SUBLW  0C
02EF0:  BC    2EF6
....................                      DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02EF2:  MOVLW  02
02EF4:  MOVWF  x45
02EF6:  MOVLB  5
....................                } 
....................                break; 
02EF8:  MOVLB  1
02EFA:  BRA    2F4C
02EFC:  MOVLB  5
....................             } 
....................     
....................             // Check to see if we received an offer 
....................             switch(_DHCPReceive()) 
02EFE:  MOVLB  0
02F00:  CALL   265C
02F04:  MOVF   01,W
02F06:  XORLW  05
02F08:  BZ    2F10
02F0A:  XORLW  03
02F0C:  BZ    2F3E
02F0E:  BRA    2F46
....................             { 
....................                case DHCP_ACK_MESSAGE: 
....................                   UDPClose(DHCPClient.hDHCPSocket); 
02F10:  MOVFF  144,5C0
02F14:  CALL   09B4
....................                   DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
02F18:  MOVLB  1
02F1A:  SETF   x44
....................                   DHCPClient.dwTimer = TickGet(); 
02F1C:  MOVLB  0
02F1E:  CALL   23FC
02F22:  MOVFF  03,14A
02F26:  MOVFF  02,149
02F2A:  MOVFF  01,148
02F2E:  MOVFF  00,147
....................                   DHCPClient.smState = SM_DHCP_BOUND; 
02F32:  MOVLW  06
02F34:  MOVLB  1
02F36:  MOVWF  x45
....................                   DHCPClient.flags.bits.bEvent = 1; 
02F38:  BSF    x46.1
....................                   break; 
02F3A:  MOVLB  0
02F3C:  BRA    2F46
....................        
....................                case DHCP_NAK_MESSAGE: 
....................                   DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
02F3E:  MOVLW  02
02F40:  MOVLB  1
02F42:  MOVWF  x45
....................                   break; 
02F44:  MOVLB  0
....................             } 
....................             break; 
02F46:  MOVLB  1
02F48:  BRA    2F4C
02F4A:  MOVLB  1
....................       } 
02F4C:  MOVLB  5
02F4E:  INCF   xBE,F
02F50:  BRA    2A5C
....................    } 
02F52:  MOVLB  0
02F54:  GOTO   6C7C (RETURN)
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
.................... Function: 
....................   void _DHCPReceive(void) 
....................  
.................... Description: 
....................   Receives and parses a DHCP message. 
....................  
.................... Precondition: 
....................   A DHCP message is waiting in the UDP buffer. 
....................  
.................... Parameters: 
....................   None 
....................  
.................... Returns: 
....................   One of the DCHP_TYPE* contants. 
.................... ***************************************************************************/ 
.................... static BYTE _DHCPReceive(void) 
.................... { 
....................    /********************************************************************* 
....................    DHCP PACKET FORMAT AS PER RFC 1541 
....................  
....................    0                   1                   2                   3 
....................    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
....................    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
....................    |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    | 
....................    +---------------+---------------+---------------+---------------+ 
....................    |                            xid (4)                            | 
....................    +-------------------------------+-------------------------------+ 
....................    |           secs (2)            |           flags (2)           | 
....................    +-------------------------------+-------------------------------+ 
....................    |                          ciaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          yiaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          siaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                          giaddr  (4)                          | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          chaddr  (16)                         | 
....................    |                                                               | 
....................    |                                                               | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          sname   (64)                         | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          file    (128)                        | 
....................    +---------------------------------------------------------------+ 
....................    |                                                               | 
....................    |                          options (312)                        | 
....................    +---------------------------------------------------------------+ 
....................  
....................    ********************************************************************/ 
....................    BYTE v; 
....................    BYTE i, j; 
....................    BYTE type; 
....................    BOOL lbDone; 
....................    DWORD tempServerID; 
....................    unsigned int32 xid;  // __CCS__ add g_DNSTransactionID 
....................  
....................  
....................    // Assume unknown message until proven otherwise. 
....................    type = DHCP_UNKNOWN_MESSAGE; 
*
0265C:  MOVLB  5
0265E:  CLRF   xC2
....................  
....................    UDPGet(&v);                             // op 
02660:  MOVLW  05
02662:  MOVWF  xCF
02664:  MOVLW  BF
02666:  MOVWF  xCE
02668:  MOVLB  0
0266A:  RCALL  2500
....................  
....................    // Make sure this is BOOT_REPLY. 
....................    if ( v == BOOT_REPLY ) 
0266C:  MOVLB  5
0266E:  MOVF   xBF,W
02670:  SUBLW  02
02672:  BTFSS  FD8.2
02674:  BRA    29F4
....................    { 
....................       // __CCS__ add g_DNSTransactionID 
....................       // get xid 
....................       UDPSetRxBuffer(4); 
02676:  CLRF   xCD
02678:  MOVLW  04
0267A:  MOVWF  xCC
0267C:  MOVLB  0
0267E:  RCALL  2496
....................       UDPGetArray(&xid, 4); 
02680:  MOVLW  05
02682:  MOVLB  5
02684:  MOVWF  xCF
02686:  MOVLW  C8
02688:  MOVWF  xCE
0268A:  CLRF   xD1
0268C:  MOVLW  04
0268E:  MOVWF  xD0
02690:  MOVLB  0
02692:  RCALL  254E
....................       if (xid != g_DNSTransactionID.dw) 
02694:  MOVLB  1
02696:  MOVF   x40,W
02698:  MOVLB  5
0269A:  SUBWF  xC8,W
0269C:  BNZ   26BC
0269E:  MOVLB  1
026A0:  MOVF   x41,W
026A2:  MOVLB  5
026A4:  SUBWF  xC9,W
026A6:  BNZ   26BC
026A8:  MOVLB  1
026AA:  MOVF   x42,W
026AC:  MOVLB  5
026AE:  SUBWF  xCA,W
026B0:  BNZ   26BC
026B2:  MOVLB  1
026B4:  MOVF   x43,W
026B6:  MOVLB  5
026B8:  SUBWF  xCB,W
026BA:  BZ    26BE
....................          goto UDPInvalid; 
026BC:  BRA    2A4A
....................           
....................       // Jump to chaddr field (Client Hardware Address -- our MAC address for  
....................       // Ethernet and WiFi networks) and verify that this message is directed  
....................       // to us before doing any other processing. 
....................       UDPSetRxBuffer(28);      // chaddr field is at offset 28 in the UDP packet payload -- see DHCP packet format above 
026BE:  CLRF   xCD
026C0:  MOVLW  1C
026C2:  MOVWF  xCC
026C4:  MOVLB  0
026C6:  RCALL  2496
....................       for ( i = 0; i < 6u; i++ ) 
026C8:  MOVLB  5
026CA:  CLRF   xC0
026CC:  MOVF   xC0,W
026CE:  SUBLW  05
026D0:  BNC   26FA
....................       { 
....................          UDPGet(&v); 
026D2:  MOVLW  05
026D4:  MOVWF  xCF
026D6:  MOVLW  BF
026D8:  MOVWF  xCE
026DA:  MOVLB  0
026DC:  RCALL  2500
....................          if ( v != AppConfig.MyMACAddr.v[i]) 
026DE:  CLRF   03
026E0:  MOVLB  5
026E2:  MOVF   xC0,W
026E4:  ADDLW  4C
026E6:  MOVWF  FE9
026E8:  MOVLW  00
026EA:  ADDWFC 03,W
026EC:  MOVWF  FEA
026EE:  MOVF   FEF,W
026F0:  SUBWF  xBF,W
026F2:  BZ    26F6
....................             goto UDPInvalid; 
026F4:  BRA    2A4A
026F6:  INCF   xC0,F
026F8:  BRA    26CC
....................       } 
....................  
....................       // Check to see if this is the first offer.  If it is, record its  
....................       // yiaddr value ("Your (client) IP address") so that we can REQUEST to  
....................       // use it later. 
....................       if(!DHCPClient.flags.bits.bOfferReceived) 
026FA:  MOVLB  1
026FC:  BTFSC  x46.2
026FE:  BRA    272A
....................       { 
....................          UDPSetRxBuffer(16); 
02700:  MOVLB  5
02702:  CLRF   xCD
02704:  MOVLW  10
02706:  MOVWF  xCC
02708:  MOVLB  0
0270A:  RCALL  2496
....................          UDPGetArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress)); 
0270C:  MOVLW  01
0270E:  MOVLB  5
02710:  MOVWF  xCD
02712:  MOVLW  53
02714:  MOVWF  xCC
02716:  MOVFF  5CD,5CF
0271A:  MOVWF  xCE
0271C:  CLRF   xD1
0271E:  MOVLW  04
02720:  MOVWF  xD0
02722:  MOVLB  0
02724:  RCALL  254E
....................          DHCPClient.validValues.bits.IPAddress = 1; 
02726:  MOVLB  1
02728:  BSF    x5F.0
....................       } 
....................  
....................       // Jump to DHCP options (ignore htype, hlen, hops, xid, secs, flags,  
....................       // ciaddr, siaddr, giaddr, padding part of chaddr, sname, file, magic  
....................       // cookie fields) 
....................       UDPSetRxBuffer(240); 
0272A:  MOVLB  5
0272C:  CLRF   xCD
0272E:  MOVLW  F0
02730:  MOVWF  xCC
02732:  MOVLB  0
02734:  RCALL  2496
....................  
....................       lbDone = FALSE; 
02736:  MOVLB  5
02738:  BCF    xC3.0
....................       do 
....................       { 
....................          // Get the Option number 
....................          // Break out eventually in case if this is a malformed  
....................          // DHCP message, ie: missing DHCP_END_OPTION marker 
....................          if(!UDPGet(&v)) 
0273A:  MOVLW  05
0273C:  MOVWF  xCF
0273E:  MOVLW  BF
02740:  MOVWF  xCE
02742:  MOVLB  0
02744:  RCALL  2500
02746:  MOVF   01,F
02748:  BNZ   2752
....................          { 
....................             lbDone = TRUE; 
0274A:  MOVLB  5
0274C:  BSF    xC3.0
....................             break; 
0274E:  BRA    29F4
02750:  MOVLB  0
....................          } 
....................  
....................          switch(v) 
02752:  MOVLB  5
02754:  MOVF   xBF,W
02756:  XORLW  35
02758:  MOVLB  0
0275A:  BZ    2778
0275C:  XORLW  34
0275E:  BZ    27BA
02760:  XORLW  02
02762:  BZ    281E
02764:  XORLW  35
02766:  BTFSC  FD8.2
02768:  BRA    289E
0276A:  XORLW  C9
0276C:  BTFSC  FD8.2
0276E:  BRA    28F6
02770:  XORLW  CC
02772:  BTFSC  FD8.2
02774:  BRA    28FE
02776:  BRA    29C4
....................          { 
....................             case DHCP_MESSAGE_TYPE: 
....................                UDPGet(&v);                         // Skip len 
02778:  MOVLW  05
0277A:  MOVLB  5
0277C:  MOVWF  xCF
0277E:  MOVLW  BF
02780:  MOVWF  xCE
02782:  MOVLB  0
02784:  RCALL  2500
....................                // Len must be 1. 
....................                if ( v == 1u ) 
02786:  MOVLB  5
02788:  DECFSZ xBF,W
0278A:  BRA    27B4
....................                { 
....................                   UDPGet(&type);                  // Get type 
0278C:  MOVLW  05
0278E:  MOVWF  xCF
02790:  MOVLW  C2
02792:  MOVWF  xCE
02794:  MOVLB  0
02796:  RCALL  2500
....................  
....................                   // Throw away the packet if we know we don't need it (ie: another offer when we already have one) 
....................                   if(DHCPClient.flags.bits.bOfferReceived && (type == DHCP_OFFER_MESSAGE)) 
02798:  MOVLB  1
0279A:  BTFSS  x46.2
0279C:  BRA    27B0
0279E:  MOVLB  5
027A0:  MOVF   xC2,W
027A2:  SUBLW  02
027A4:  BTFSC  FD8.2
027A6:  BRA    27AC
027A8:  MOVLB  1
027AA:  BRA    27B0
....................                   { 
....................                      goto UDPInvalid; 
027AC:  BRA    2A4A
027AE:  MOVLB  1
....................                   } 
....................                } 
027B0:  BRA    27B8
027B2:  MOVLB  5
....................                else 
....................                   goto UDPInvalid; 
027B4:  BRA    2A4A
027B6:  MOVLB  1
....................                break; 
027B8:  BRA    29EE
....................  
....................             case DHCP_SUBNET_MASK: 
....................                UDPGet(&v);                     // Skip len 
027BA:  MOVLW  05
027BC:  MOVLB  5
027BE:  MOVWF  xCF
027C0:  MOVLW  BF
027C2:  MOVWF  xCE
027C4:  MOVLB  0
027C6:  RCALL  2500
....................                // Len must be 4. 
....................                if ( v == 4u ) 
027C8:  MOVLB  5
027CA:  MOVF   xBF,W
027CC:  SUBLW  04
027CE:  BNZ   2818
....................                { 
....................                   // Check to see if this is the first offer 
....................                   if(DHCPClient.flags.bits.bOfferReceived) 
027D0:  MOVLB  1
027D2:  BTFSS  x46.2
027D4:  BRA    27F6
....................                   { 
....................                      // Discard offered IP mask, we already have an offer 
....................                      for ( i = 0; i < 4u; i++ ) 
027D6:  MOVLB  5
027D8:  CLRF   xC0
027DA:  MOVF   xC0,W
027DC:  SUBLW  03
027DE:  BNC   27F2
....................                         UDPGet(&v); 
027E0:  MOVLW  05
027E2:  MOVWF  xCF
027E4:  MOVLW  BF
027E6:  MOVWF  xCE
027E8:  MOVLB  0
027EA:  RCALL  2500
027EC:  MOVLB  5
027EE:  INCF   xC0,F
027F0:  BRA    27DA
....................                   } 
027F2:  BRA    2816
027F4:  MOVLB  1
....................                   else 
....................                   { 
....................                      UDPGetArray((BYTE*)&DHCPClient.tempMask, sizeof(DHCPClient.tempMask)); 
027F6:  MOVLW  01
027F8:  MOVLB  5
027FA:  MOVWF  xCD
027FC:  MOVLW  5B
027FE:  MOVWF  xCC
02800:  MOVFF  5CD,5CF
02804:  MOVWF  xCE
02806:  CLRF   xD1
02808:  MOVLW  04
0280A:  MOVWF  xD0
0280C:  MOVLB  0
0280E:  RCALL  254E
....................                      DHCPClient.validValues.bits.Mask = 1; 
02810:  MOVLB  1
02812:  BSF    x5F.2
02814:  MOVLB  5
....................                   } 
....................                } 
02816:  BRA    281A
....................                else 
....................                   goto UDPInvalid; 
02818:  BRA    2A4A
....................                break; 
0281A:  MOVLB  1
0281C:  BRA    29EE
....................  
....................             case DHCP_ROUTER: 
....................                UDPGet(&j); 
0281E:  MOVLW  05
02820:  MOVLB  5
02822:  MOVWF  xCF
02824:  MOVLW  C1
02826:  MOVWF  xCE
02828:  MOVLB  0
0282A:  RCALL  2500
....................                // Len must be >= 4. 
....................                if ( j >= 4u ) 
0282C:  MOVLB  5
0282E:  MOVF   xC1,W
02830:  SUBLW  03
02832:  BC    287C
....................                { 
....................                   // Check to see if this is the first offer 
....................                   if(DHCPClient.flags.bits.bOfferReceived) 
02834:  MOVLB  1
02836:  BTFSS  x46.2
02838:  BRA    285A
....................                   { 
....................                      // Discard offered Gateway address, we already have an offer 
....................                      for ( i = 0; i < 4u; i++ ) 
0283A:  MOVLB  5
0283C:  CLRF   xC0
0283E:  MOVF   xC0,W
02840:  SUBLW  03
02842:  BNC   2856
....................                         UDPGet(&v); 
02844:  MOVLW  05
02846:  MOVWF  xCF
02848:  MOVLW  BF
0284A:  MOVWF  xCE
0284C:  MOVLB  0
0284E:  RCALL  2500
02850:  MOVLB  5
02852:  INCF   xC0,F
02854:  BRA    283E
....................                   } 
02856:  BRA    287A
02858:  MOVLB  1
....................                   else 
....................                   { 
....................                      UDPGetArray((BYTE*)&DHCPClient.tempGateway, sizeof(DHCPClient.tempGateway)); 
0285A:  MOVLW  01
0285C:  MOVLB  5
0285E:  MOVWF  xCD
02860:  MOVLW  57
02862:  MOVWF  xCC
02864:  MOVFF  5CD,5CF
02868:  MOVWF  xCE
0286A:  CLRF   xD1
0286C:  MOVLW  04
0286E:  MOVWF  xD0
02870:  MOVLB  0
02872:  RCALL  254E
....................                      DHCPClient.validValues.bits.Gateway = 1; 
02874:  MOVLB  1
02876:  BSF    x5F.1
02878:  MOVLB  5
....................                   } 
....................                } 
0287A:  BRA    287E
....................                else 
....................                   goto UDPInvalid; 
0287C:  BRA    2A4A
....................  
....................                // Discard any other router addresses. 
....................                j -= 4; 
0287E:  MOVLW  04
02880:  SUBWF  xC1,F
....................                while(j--) 
02882:  MOVF   xC1,W
02884:  DECF   xC1,F
02886:  XORLW  00
02888:  BZ    289A
....................                   UDPGet(&v); 
0288A:  MOVLW  05
0288C:  MOVWF  xCF
0288E:  MOVLW  BF
02890:  MOVWF  xCE
02892:  MOVLB  0
02894:  RCALL  2500
02896:  MOVLB  5
02898:  BRA    2882
....................                break; 
0289A:  MOVLB  1
0289C:  BRA    29EE
....................  
....................             #if defined(STACK_USE_DNS) 
....................             case DHCP_DNS: 
....................                UDPGet(&j); 
....................                // Len must be >= 4. 
....................                if(j < 4u) 
....................                   goto UDPInvalid; 
....................  
....................                // Check to see if this is the first offer 
....................                if(!DHCPClient.flags.bits.bOfferReceived) 
....................                { 
....................                   UDPGetArray((BYTE*)&DHCPClient.tempDNS, sizeof(DHCPClient.tempDNS)); 
....................                   DHCPClient.validValues.bits.DNS = 1; 
....................                   j -= 4; 
....................                } 
....................  
....................                // Len must be >= 4 for a secondary DNS server address 
....................                if(j >= 4u) 
....................                { 
....................                   // Check to see if this is the first offer 
....................                   if(!DHCPClient.flags.bits.bOfferReceived) 
....................                   { 
....................                      UDPGetArray((BYTE*)&DHCPClient.tempDNS2, sizeof(DHCPClient.tempDNS2)); 
....................                      DHCPClient.validValues.bits.DNS2 = 1; 
....................                      j -= 4; 
....................                   } 
....................                } 
....................  
....................                // Discard any other DNS server addresses 
....................                while(j--) 
....................                   UDPGet(&v); 
....................                break; 
....................             #endif 
....................  
....................                //            case DHCP_HOST_NAME: 
....................                //                UDPGet(&j); 
....................                //                // Len must be >= 4. 
....................                //                if(j < 1u) 
....................                //               goto UDPInvalid; 
....................                // 
....................                //            // Check to see if this is the first offer 
....................                //            if(DHCPFlags.bits.bOfferReceived) 
....................                //            { 
....................                //                 // Discard offered host name, we already have an offer 
....................                //                   while(j--) 
....................                //                       UDPGet(&v); 
....................                //            } 
....................                //            else 
....................                //            { 
....................                //               for(i = 0; j, i < sizeof(tempHostName); i++, j--) 
....................                //               { 
....................                //                  UDPGet(&tempHostName[i]); 
....................                //               } 
....................                //               while(j--) 
....................                //               { 
....................                //                  UDPGet(&v); 
....................                //               } 
....................                //               ValidValues.bits.HostName = 1; 
....................                //            } 
....................                // 
....................                //                break; 
....................  
....................             case DHCP_SERVER_IDENTIFIER: 
....................                UDPGet(&v);                         // Get len 
0289E:  MOVLW  05
028A0:  MOVLB  5
028A2:  MOVWF  xCF
028A4:  MOVLW  BF
028A6:  MOVWF  xCE
028A8:  MOVLB  0
028AA:  RCALL  2500
....................                // Len must be 4. 
....................                if ( v == 4u ) 
028AC:  MOVLB  5
028AE:  MOVF   xBF,W
028B0:  SUBLW  04
028B2:  BNZ   28EE
....................                { 
....................                   UDPGet(&(((BYTE*)&tempServerID)[3]));   // Get the id 
028B4:  MOVLW  05
028B6:  MOVWF  xCF
028B8:  MOVLW  C7
028BA:  MOVWF  xCE
028BC:  MOVLB  0
028BE:  RCALL  2500
....................                   UDPGet(&(((BYTE*)&tempServerID)[2])); 
028C0:  MOVLW  05
028C2:  MOVLB  5
028C4:  MOVWF  xCF
028C6:  MOVLW  C6
028C8:  MOVWF  xCE
028CA:  MOVLB  0
028CC:  RCALL  2500
....................                   UDPGet(&(((BYTE*)&tempServerID)[1])); 
028CE:  MOVLW  05
028D0:  MOVLB  5
028D2:  MOVWF  xCF
028D4:  MOVLW  C5
028D6:  MOVWF  xCE
028D8:  MOVLB  0
028DA:  RCALL  2500
....................                   UDPGet(&(((BYTE*)&tempServerID)[0])); 
028DC:  MOVLW  05
028DE:  MOVLB  5
028E0:  MOVWF  xCF
028E2:  MOVLW  C4
028E4:  MOVWF  xCE
028E6:  MOVLB  0
028E8:  RCALL  2500
....................                   #warning this wasn't working with old compilers 
....................                } 
028EA:  BRA    28F2
028EC:  MOVLB  5
....................                else 
....................                   goto UDPInvalid; 
028EE:  BRA    2A4A
028F0:  MOVLB  0
....................                break; 
028F2:  MOVLB  1
028F4:  BRA    29EE
....................  
....................             case DHCP_END_OPTION: 
....................                lbDone = TRUE; 
028F6:  MOVLB  5
028F8:  BSF    xC3.0
....................                break; 
028FA:  MOVLB  1
028FC:  BRA    29EE
....................  
....................             case DHCP_IP_LEASE_TIME: 
....................                UDPGet(&v);                         // Get len 
028FE:  MOVLW  05
02900:  MOVLB  5
02902:  MOVWF  xCF
02904:  MOVLW  BF
02906:  MOVWF  xCE
02908:  MOVLB  0
0290A:  RCALL  2500
....................                // Len must be 4. 
....................                if ( v == 4u ) 
0290C:  MOVLB  5
0290E:  MOVF   xBF,W
02910:  SUBLW  04
02912:  BNZ   29BC
....................                { 
....................                   // Check to see if this is the first offer 
....................                   if(DHCPClient.flags.bits.bOfferReceived) 
02914:  MOVLB  1
02916:  BTFSS  x46.2
02918:  BRA    293A
....................                   { 
....................                      // Discard offered lease time, we already have an offer 
....................                      for ( i = 0; i < 4u; i++ ) 
0291A:  MOVLB  5
0291C:  CLRF   xC0
0291E:  MOVF   xC0,W
02920:  SUBLW  03
02922:  BNC   2936
....................                         UDPGet(&v); 
02924:  MOVLW  05
02926:  MOVWF  xCF
02928:  MOVLW  BF
0292A:  MOVWF  xCE
0292C:  MOVLB  0
0292E:  RCALL  2500
02930:  MOVLB  5
02932:  INCF   xC0,F
02934:  BRA    291E
....................                   } 
02936:  BRA    29BA
02938:  MOVLB  1
....................                   else 
....................                   { 
....................                      UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[3])); 
0293A:  MOVLW  01
0293C:  MOVLB  5
0293E:  MOVWF  xCF
02940:  MOVLW  4E
02942:  MOVWF  xCE
02944:  MOVLB  0
02946:  RCALL  2500
....................                      UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[2])); 
02948:  MOVLW  01
0294A:  MOVLB  5
0294C:  MOVWF  xCF
0294E:  MOVLW  4D
02950:  MOVWF  xCE
02952:  MOVLB  0
02954:  RCALL  2500
....................                      UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[1])); 
02956:  MOVLW  01
02958:  MOVLB  5
0295A:  MOVWF  xCF
0295C:  MOVLW  4C
0295E:  MOVWF  xCE
02960:  MOVLB  0
02962:  RCALL  2500
....................                      UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[0])); 
02964:  MOVLW  01
02966:  MOVLB  5
02968:  MOVWF  xCF
0296A:  MOVLW  4B
0296C:  MOVWF  xCE
0296E:  MOVLB  0
02970:  RCALL  2500
....................                      #warning this wasn't working with old compilers 
....................  
....................                      // In case if our clock is not as accurate as the remote  
....................                      // DHCP server's clock, let's treat the lease time as only  
....................                      // 96.875% of the value given 
....................                      DHCPClient.dwLeaseTime -= DHCPClient.dwLeaseTime>>5; 
02972:  MOVLB  1
02974:  RRCF   x4E,W
02976:  MOVWF  03
02978:  RRCF   x4D,W
0297A:  MOVWF  02
0297C:  RRCF   x4C,W
0297E:  MOVWF  01
02980:  RRCF   x4B,W
02982:  MOVWF  00
02984:  RRCF   03,F
02986:  RRCF   02,F
02988:  RRCF   01,F
0298A:  RRCF   00,F
0298C:  RRCF   03,F
0298E:  RRCF   02,F
02990:  RRCF   01,F
02992:  RRCF   00,F
02994:  RRCF   03,F
02996:  RRCF   02,F
02998:  RRCF   01,F
0299A:  RRCF   00,F
0299C:  RRCF   03,F
0299E:  RRCF   02,F
029A0:  RRCF   01,F
029A2:  RRCF   00,F
029A4:  MOVLW  07
029A6:  ANDWF  03,F
029A8:  MOVF   00,W
029AA:  SUBWF  x4B,F
029AC:  MOVF   01,W
029AE:  SUBWFB x4C,F
029B0:  MOVF   02,W
029B2:  SUBWFB x4D,F
029B4:  MOVF   03,W
029B6:  SUBWFB x4E,F
029B8:  MOVLB  5
....................                   } 
....................                } 
029BA:  BRA    29BE
....................                else 
....................                   goto UDPInvalid; 
029BC:  BRA    2A4A
....................                break; 
029BE:  MOVLB  1
029C0:  BRA    29EE
029C2:  MOVLB  0
....................  
....................             default: 
....................                // Ignore all unsupport tags. 
....................                UDPGet(&j);                     // Get option len 
029C4:  MOVLW  05
029C6:  MOVLB  5
029C8:  MOVWF  xCF
029CA:  MOVLW  C1
029CC:  MOVWF  xCE
029CE:  MOVLB  0
029D0:  RCALL  2500
....................                while( j-- )                    // Ignore option values 
029D2:  MOVLB  5
029D4:  MOVF   xC1,W
029D6:  DECF   xC1,F
029D8:  XORLW  00
029DA:  BZ    29EC
....................                   UDPGet(&v); 
029DC:  MOVLW  05
029DE:  MOVWF  xCF
029E0:  MOVLW  BF
029E2:  MOVWF  xCE
029E4:  MOVLB  0
029E6:  RCALL  2500
029E8:  BRA    29D2
029EA:  MOVLB  5
029EC:  MOVLB  1
....................          } 
....................       } while( !lbDone ); 
029EE:  MOVLB  5
029F0:  BTFSS  xC3.0
029F2:  BRA    273A
....................    } 
....................  
....................    // If this is an OFFER message, remember current server id. 
....................    if ( type == DHCP_OFFER_MESSAGE ) 
029F4:  MOVF   xC2,W
029F6:  SUBLW  02
029F8:  BNZ   2A12
....................    { 
....................       DHCPClient.dwServerID = tempServerID; 
029FA:  MOVFF  5C7,152
029FE:  MOVFF  5C6,151
02A02:  MOVFF  5C5,150
02A06:  MOVFF  5C4,14F
....................       DHCPClient.flags.bits.bOfferReceived = TRUE; 
02A0A:  MOVLB  1
02A0C:  BSF    x46.2
....................    } 
02A0E:  BRA    2A3E
02A10:  MOVLB  5
....................    else 
....................    { 
....................       // For other types of messages, make sure that received 
....................       // server id matches with our previous one. 
....................       if ( DHCPClient.dwServerID != tempServerID ) 
02A12:  MOVF   xC4,W
02A14:  MOVLB  1
02A16:  SUBWF  x4F,W
02A18:  BNZ   2A38
02A1A:  MOVLB  5
02A1C:  MOVF   xC5,W
02A1E:  MOVLB  1
02A20:  SUBWF  x50,W
02A22:  BNZ   2A38
02A24:  MOVLB  5
02A26:  MOVF   xC6,W
02A28:  MOVLB  1
02A2A:  SUBWF  x51,W
02A2C:  BNZ   2A38
02A2E:  MOVLB  5
02A30:  MOVF   xC7,W
02A32:  MOVLB  1
02A34:  SUBWF  x52,W
02A36:  BZ    2A3E
....................          type = DHCP_UNKNOWN_MESSAGE; 
02A38:  MOVLB  5
02A3A:  CLRF   xC2
02A3C:  MOVLB  1
....................    } 
....................  
....................    UDPDiscard();                             // We are done with this packet 
02A3E:  MOVLB  0
02A40:  RCALL  2644
....................    return type; 
02A42:  MOVLB  5
02A44:  MOVFF  5C2,01
02A48:  BRA    2A54
....................  
.................... UDPInvalid: 
....................    UDPDiscard(); 
02A4A:  MOVLB  0
02A4C:  RCALL  2644
....................    return DHCP_UNKNOWN_MESSAGE; 
02A4E:  MOVLW  00
02A50:  MOVWF  01
02A52:  MOVLB  5
02A54:  MOVLB  0
02A56:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void _DHCPSend(BYTE messageType, BOOL bRenewing) 
....................  
....................   Description: 
....................    Sends a DHCP message. 
....................  
....................   Precondition: 
....................    UDP is ready to write a DHCP packet. 
....................  
....................   Parameters: 
....................    messageType - One of the DHCP_TYPE constants 
....................    bRenewing - Whether or not this is a renewal request 
....................  
....................   Returns: 
....................    None 
.................... ***************************************************************************/ 
.................... static void _DHCPSend(BYTE messageType, BOOL bRenewing) 
.................... { 
....................    BYTE i; 
....................    IP_ADDR   MyIP; 
....................  
....................             // __CCS__ add g_DNSTransactionID 
....................    if (messageType == DHCP_DISCOVER_MESSAGE) 
*
020F4:  MOVLB  5
020F6:  DECFSZ xBF,W
020F8:  BRA    2116
....................    { 
....................       g_DNSTransactionID.w[0] = rand(); 
020FA:  MOVLB  0
020FC:  CALL   18FA
02100:  MOVFF  02,141
02104:  MOVFF  01,140
....................       g_DNSTransactionID.w[1] = rand(); 
02108:  CALL   18FA
0210C:  MOVFF  02,143
02110:  MOVFF  01,142
02114:  MOVLB  5
....................    } 
....................  
....................    UDPPut(BOOT_REQUEST);                       // op 
02116:  MOVLW  01
02118:  MOVWF  xC8
0211A:  MOVLB  0
0211C:  RCALL  196A
....................    UDPPut(BOOT_HW_TYPE);                       // htype 
0211E:  MOVLW  01
02120:  MOVLB  5
02122:  MOVWF  xC8
02124:  MOVLB  0
02126:  RCALL  196A
....................    UDPPut(BOOT_LEN_OF_HW_TYPE);                // hlen 
02128:  MOVLW  06
0212A:  MOVLB  5
0212C:  MOVWF  xC8
0212E:  MOVLB  0
02130:  RCALL  196A
....................    UDPPut(0);                                  // hops 
02132:  MOVLB  5
02134:  CLRF   xC8
02136:  MOVLB  0
02138:  RCALL  196A
....................    UDPPut(g_DNSTransactionID.b[0]);                               // xid[0] 
0213A:  MOVFF  140,5C8
0213E:  RCALL  196A
....................    UDPPut(g_DNSTransactionID.b[1]);                               // xid[1] 
02140:  MOVFF  141,5C8
02144:  RCALL  196A
....................    UDPPut(g_DNSTransactionID.b[2]);                               // xid[2] 
02146:  MOVFF  142,5C8
0214A:  RCALL  196A
....................    UDPPut(g_DNSTransactionID.b[3]);                               // xid[3] 
0214C:  MOVFF  143,5C8
02150:  RCALL  196A
....................    UDPPut(0);                                  // secs[0] 
02152:  MOVLB  5
02154:  CLRF   xC8
02156:  MOVLB  0
02158:  RCALL  196A
....................    UDPPut(0);                                  // secs[1] 
0215A:  MOVLB  5
0215C:  CLRF   xC8
0215E:  MOVLB  0
02160:  RCALL  196A
....................    UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00: 0x80);// flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode 
02162:  MOVLB  1
02164:  BTFSS  x46.4
02166:  BRA    216C
02168:  MOVLW  00
0216A:  BRA    216E
0216C:  MOVLW  80
0216E:  MOVLB  5
02170:  MOVWF  xC6
02172:  MOVWF  xC8
02174:  MOVLB  0
02176:  CALL   196A
....................    UDPPut(0);                                  // flags[1] 
0217A:  MOVLB  5
0217C:  CLRF   xC8
0217E:  MOVLB  0
02180:  CALL   196A
....................  
....................    // If this is DHCP REQUEST message, use previously allocated IP address. 
....................    if((messageType == DHCP_REQUEST_MESSAGE) && bRenewing) 
02184:  MOVLB  5
02186:  MOVF   xBF,W
02188:  SUBLW  03
0218A:  BNZ   21AC
0218C:  MOVF   xC0,F
0218E:  BZ    21AC
....................    { 
....................       UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress)); 
02190:  MOVLW  01
02192:  MOVWF  xC7
02194:  MOVLW  53
02196:  MOVWF  xC6
02198:  MOVFF  5C7,5C9
0219C:  MOVWF  xC8
0219E:  CLRF   xCB
021A0:  MOVLW  04
021A2:  MOVWF  xCA
021A4:  MOVLB  0
021A6:  RCALL  19C0
....................    } 
021A8:  BRA    21D2
021AA:  MOVLB  5
....................    else 
....................    { 
....................       UDPPut(0x00); 
021AC:  CLRF   xC8
021AE:  MOVLB  0
021B0:  CALL   196A
....................       UDPPut(0x00); 
021B4:  MOVLB  5
021B6:  CLRF   xC8
021B8:  MOVLB  0
021BA:  CALL   196A
....................       UDPPut(0x00); 
021BE:  MOVLB  5
021C0:  CLRF   xC8
021C2:  MOVLB  0
021C4:  CALL   196A
....................       UDPPut(0x00); 
021C8:  MOVLB  5
021CA:  CLRF   xC8
021CC:  MOVLB  0
021CE:  CALL   196A
....................    } 
....................  
....................    // Set yiaddr, siaddr, giaddr as zeros, 
....................    for ( i = 0; i < 12u; i++ ) 
021D2:  MOVLB  5
021D4:  CLRF   xC1
021D6:  MOVF   xC1,W
021D8:  SUBLW  0B
021DA:  BNC   21EA
....................       UDPPut(0x00); 
021DC:  CLRF   xC8
021DE:  MOVLB  0
021E0:  CALL   196A
021E4:  MOVLB  5
021E6:  INCF   xC1,F
021E8:  BRA    21D6
....................  
....................    // Load chaddr - Client hardware address. 
....................    UDPPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
021EA:  CLRF   xC7
021EC:  MOVLW  4C
021EE:  MOVWF  xC6
021F0:  MOVFF  5C7,5C9
021F4:  MOVWF  xC8
021F6:  CLRF   xCB
021F8:  MOVLW  06
021FA:  MOVWF  xCA
021FC:  MOVLB  0
021FE:  CALL   19C0
....................  
....................    // Set chaddr[6..15], sname and file as zeros. 
....................    for ( i = 0; i < 202u; i++ ) 
02202:  MOVLB  5
02204:  CLRF   xC1
02206:  MOVF   xC1,W
02208:  SUBLW  C9
0220A:  BNC   221A
....................       UDPPut(0); 
0220C:  CLRF   xC8
0220E:  MOVLB  0
02210:  CALL   196A
02214:  MOVLB  5
02216:  INCF   xC1,F
02218:  BRA    2206
....................  
....................    // Load magic cookie as per RFC 1533. 
....................    UDPPut(99); 
0221A:  MOVLW  63
0221C:  MOVWF  xC8
0221E:  MOVLB  0
02220:  CALL   196A
....................    UDPPut(130); 
02224:  MOVLW  82
02226:  MOVLB  5
02228:  MOVWF  xC8
0222A:  MOVLB  0
0222C:  CALL   196A
....................    UDPPut(83); 
02230:  MOVLW  53
02232:  MOVLB  5
02234:  MOVWF  xC8
02236:  MOVLB  0
02238:  CALL   196A
....................    UDPPut(99); 
0223C:  MOVLW  63
0223E:  MOVLB  5
02240:  MOVWF  xC8
02242:  MOVLB  0
02244:  CALL   196A
....................  
....................    // Load message type. 
....................    UDPPut(DHCP_MESSAGE_TYPE); 
02248:  MOVLW  35
0224A:  MOVLB  5
0224C:  MOVWF  xC8
0224E:  MOVLB  0
02250:  CALL   196A
....................    UDPPut(DHCP_MESSAGE_TYPE_LEN); 
02254:  MOVLW  01
02256:  MOVLB  5
02258:  MOVWF  xC8
0225A:  MOVLB  0
0225C:  CALL   196A
....................    UDPPut(messageType); 
02260:  MOVFF  5BF,5C8
02264:  CALL   196A
....................  
....................    if(messageType == DHCP_DISCOVER_MESSAGE) 
02268:  MOVLB  5
0226A:  DECFSZ xBF,W
0226C:  BRA    2274
....................    { 
....................       // Reset offered flag so we know to act upon the next valid offer 
....................       DHCPClient.flags.bits.bOfferReceived = FALSE; 
0226E:  MOVLB  1
02270:  BCF    x46.2
02272:  MOVLB  5
....................    } 
....................  
....................  
....................    if((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) 
02274:  MOVF   xBF,W
02276:  SUBLW  03
02278:  BNZ   22B6
0227A:  MOVF   xC0,F
0227C:  BNZ   22B6
....................    { 
....................       // DHCP REQUEST message must include server identifier the first time 
....................       // to identify the server we are talking to. 
....................       // _DHCPReceive() would populate "serverID" when it 
....................       // receives DHCP OFFER message. We will simply use that 
....................       // when we are replying to server. 
....................       // If this is a renwal request, we must not include server id. 
....................       UDPPut(DHCP_SERVER_IDENTIFIER); 
0227E:  MOVLW  36
02280:  MOVWF  xC8
02282:  MOVLB  0
02284:  CALL   196A
....................       UDPPut(DHCP_SERVER_IDENTIFIER_LEN); 
02288:  MOVLW  04
0228A:  MOVLB  5
0228C:  MOVWF  xC8
0228E:  MOVLB  0
02290:  CALL   196A
....................       UDPPut(((BYTE*)(&DHCPClient.dwServerID))[3]); 
02294:  MOVFF  152,5C8
02298:  CALL   196A
....................       UDPPut(((BYTE*)(&DHCPClient.dwServerID))[2]); 
0229C:  MOVFF  151,5C8
022A0:  CALL   196A
....................       UDPPut(((BYTE*)(&DHCPClient.dwServerID))[1]); 
022A4:  MOVFF  150,5C8
022A8:  CALL   196A
....................       UDPPut(((BYTE*)(&DHCPClient.dwServerID))[0]); 
022AC:  MOVFF  14F,5C8
022B0:  CALL   196A
022B4:  MOVLB  5
....................       #warning not working in old compilers 
....................    } 
....................  
....................     //Set Host Name = ID String 
....................     //__CCS__ addition 
....................    #if defined(MY_UNIT_HOSTNAME) 
....................     UDPPut(12); 
....................     UDPPut(strlen(MY_UNIT_HOSTNAME)); 
....................     printf(UDPPut, "%s", MY_UNIT_HOSTNAME); 
....................    #endif    
....................     
....................    // Load our interested parameters 
....................    // This is hardcoded list.  If any new parameters are desired, 
....................    // new lines must be added here. 
....................    UDPPut(DHCP_PARAM_REQUEST_LIST); 
022B6:  MOVLW  37
022B8:  MOVWF  xC8
022BA:  MOVLB  0
022BC:  CALL   196A
....................    UDPPut(DHCP_PARAM_REQUEST_LIST_LEN); 
022C0:  MOVLW  04
022C2:  MOVLB  5
022C4:  MOVWF  xC8
022C6:  MOVLB  0
022C8:  CALL   196A
....................    UDPPut(DHCP_SUBNET_MASK); 
022CC:  MOVLW  01
022CE:  MOVLB  5
022D0:  MOVWF  xC8
022D2:  MOVLB  0
022D4:  CALL   196A
....................    UDPPut(DHCP_ROUTER); 
022D8:  MOVLW  03
022DA:  MOVLB  5
022DC:  MOVWF  xC8
022DE:  MOVLB  0
022E0:  CALL   196A
....................    UDPPut(DHCP_DNS); 
022E4:  MOVLW  06
022E6:  MOVLB  5
022E8:  MOVWF  xC8
022EA:  MOVLB  0
022EC:  CALL   196A
....................    UDPPut(DHCP_HOST_NAME); 
022F0:  MOVLW  0C
022F2:  MOVLB  5
022F4:  MOVWF  xC8
022F6:  MOVLB  0
022F8:  CALL   196A
....................  
....................    // Add requested IP address to DHCP Request Message 
....................    if( ((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) ||  
....................       ((messageType == DHCP_DISCOVER_MESSAGE) && DHCPClient.tempIPAddress.Val)) 
022FC:  MOVLB  5
022FE:  MOVF   xBF,W
02300:  SUBLW  03
02302:  BNZ   2308
02304:  MOVF   xC0,F
02306:  BZ    2338
02308:  DECFSZ xBF,W
0230A:  BRA    236C
0230C:  MOVLB  1
0230E:  MOVF   x53,F
02310:  BTFSC  FD8.2
02312:  BRA    2318
02314:  MOVLB  5
02316:  BRA    2338
02318:  MOVF   x54,F
0231A:  BTFSC  FD8.2
0231C:  BRA    2322
0231E:  MOVLB  5
02320:  BRA    2338
02322:  MOVF   x55,F
02324:  BTFSC  FD8.2
02326:  BRA    232C
02328:  MOVLB  5
0232A:  BRA    2338
0232C:  MOVF   x56,F
0232E:  BTFSS  FD8.2
02330:  BRA    2336
02332:  MOVLB  5
02334:  BRA    236C
02336:  MOVLB  5
....................    { 
....................       UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS); 
02338:  MOVLW  32
0233A:  MOVWF  xC8
0233C:  MOVLB  0
0233E:  CALL   196A
....................       UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN); 
02342:  MOVLW  04
02344:  MOVLB  5
02346:  MOVWF  xC8
02348:  MOVLB  0
0234A:  CALL   196A
....................       UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, DHCP_PARAM_REQUEST_IP_ADDRESS_LEN); 
0234E:  MOVLW  01
02350:  MOVLB  5
02352:  MOVWF  xC7
02354:  MOVLW  53
02356:  MOVWF  xC6
02358:  MOVFF  5C7,5C9
0235C:  MOVWF  xC8
0235E:  CLRF   xCB
02360:  MOVLW  04
02362:  MOVWF  xCA
02364:  MOVLB  0
02366:  CALL   19C0
0236A:  MOVLB  5
....................    } 
....................  
....................    // Add any new paramter request here. 
....................  
....................    // End of Options. 
....................    UDPPut(DHCP_END_OPTION); 
0236C:  SETF   xC8
0236E:  MOVLB  0
02370:  CALL   196A
....................  
....................    // Add zero padding to ensure compatibility with old BOOTP relays that discard small packets (<300 UDP octets) 
....................    while(UDPTxCount < 300u) 
02374:  MOVF   xF5,W
02376:  SUBLW  01
02378:  BNC   238E
0237A:  BNZ   2382
0237C:  MOVF   xF4,W
0237E:  SUBLW  2B
02380:  BNC   238E
....................       UDPPut(0);  
02382:  MOVLB  5
02384:  CLRF   xC8
02386:  MOVLB  0
02388:  CALL   196A
0238C:  BRA    2374
....................  
....................    // Make sure we advertise a 0.0.0.0 IP address so all DHCP servers will respond.  If we have a static IP outside the DHCP server's scope, it may simply ignore discover messages. 
....................    MyIP.Val = AppConfig.MyIPAddr.Val; 
0238E:  MOVFF  22,5C5
02392:  MOVFF  21,5C4
02396:  MOVFF  20,5C3
0239A:  MOVFF  1F,5C2
....................    if(!bRenewing) 
0239E:  MOVLB  5
023A0:  MOVF   xC0,F
023A2:  BNZ   23AC
....................       AppConfig.MyIPAddr.Val = 0x00000000; 
023A4:  CLRF   22
023A6:  CLRF   21
023A8:  CLRF   20
023AA:  CLRF   1F
....................    UDPFlush(); 
023AC:  MOVLB  0
023AE:  BRA    1FFE
....................    AppConfig.MyIPAddr.Val = MyIP.Val; 
023B0:  MOVFF  5C5,22
023B4:  MOVFF  5C4,21
023B8:  MOVFF  5C3,20
023BC:  MOVFF  5C2,1F
023C0:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... #endif   //#if defined(STACK_USE_DHCP_CLIENT) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS_SERVER) 
....................    #include "DNSs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Transmission Control Protocol (TCP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides reliable, handshaked transport of application stream  
....................  *    oriented data with flow control 
....................  *    -Reference: RFC 793 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.c 
....................  * Dependencies:    IP, Tick, Ethernet/WiFi (ENC28J60.c, ETH97J60.c,  
....................  *               ENCX24J600.c, or WFMac.c), ARP (optional),  
....................  *               DNS (optional) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date       Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01     Original        (Rev 1.0) 
....................  * Howard Schlunder      12/11/06   Changed almost everything to  
....................  *                           better meet RFC 793. 
....................  * Darren Rook          04/14/11 Changed TCP_SOCKET_COUNT to use TCP_CONFIGURATION. 
....................  ********************************************************************/ 
.................... #define __TCP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_TCP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // Starting port for client sockets 
.................... #define LOCAL_PORT_START_NUMBER (1024u) 
.................... // End port for client sockets 
.................... #define LOCAL_PORT_END_NUMBER   (5000u) 
....................  
.................... // For debugging only.  Normal applications should never enable these 
.................... //#define DEBUG_GENERATE_TX_LOSS      62257 
.................... //#define DEBUG_GENERATE_RX_LOSS      64225 
....................  
.................... // A lot of pointer dereference code can be removed if you  
.................... // locally copy TCBStubs to an absolute memory location. 
.................... // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will  
.................... // occur and will substantially decrease the entire TCP ROM  
.................... // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE  
.................... // undefined, the local caching will be disabled.  On PIC18  
.................... // products, this will improve TCP performance/throughput by  
.................... // approximately 15%. 
.................... #define TCP_OPTIMIZE_FOR_SIZE 
....................  
.................... // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE  
.................... // should always be enabled on PIC24/dsPIC products.  On PIC32  
.................... // products there is very little difference and depnds on compiler  
.................... // optimization level 
.................... #if defined(__C30__) && !defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #define TCP_OPTIMIZE_FOR_SIZE 
.................... #elif defined(__C32__) && defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #undef TCP_OPTIMIZE_FOR_SIZE 
.................... #endif 
....................  
.................... // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually  
.................... // govered by the remote node's MSS option advirtised during connection  
.................... // establishment.  However, if the remote node specifies an unhandlably large  
.................... // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't  
.................... // cause any TX buffer overflows.  If the remote node does not advirtise a MSS  
.................... // option, all TX segments are fixed at 536 bytes maximum. 
.................... #define TCP_MAX_SEG_SIZE_TX         (1460u) 
....................  
.................... // TCP Maximum Segment Size for RX.  This value is advirtised during connection  
.................... // establishment and the remote node should obey it.  This should be set to 536  
.................... // to avoid IP layer fragmentation from causing packet loss.  However, raising  
.................... // its value can enhance performance at the (small) risk of introducing  
.................... // incompatibility with certain special remote nodes (ex: ones connected via a  
.................... // slow dial up modem). 
.................... #define TCP_MAX_SEG_SIZE_RX         (536u) 
....................  
.................... // TCP Timeout and retransmit numbers 
.................... #define TCP_START_TIMEOUT_VAL      ((DWORD)TICK_SECOND*1)   // Timeout to retransmit unacked data 
.................... #define TCP_DELAYED_ACK_TIMEOUT      ((DWORD)TICK_SECOND/10)   // Timeout for delayed-acknowledgement algorithm 
.................... #define TCP_FIN_WAIT_2_TIMEOUT      ((DWORD)TICK_SECOND*5)   // Timeout for FIN WAIT 2 state 
.................... #define TCP_KEEP_ALIVE_TIMEOUT      ((DWORD)TICK_SECOND*10)   // Timeout for keep-alive messages when no traffic is sent 
.................... #define TCP_CLOSE_WAIT_TIMEOUT      ((DWORD)TICK_SECOND/5)   // Timeout for the CLOSE_WAIT state 
.................... #define TCP_MAX_RETRIES             (5u)               // Maximum number of retransmission attempts 
.................... #define TCP_MAX_UNACKED_KEEP_ALIVES   (6u)               // Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection 
.................... #define TCP_MAX_SYN_RETRIES         (2u)   // Smaller than all other retries to reduce SYN flood DoS duration 
....................  
.................... #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL   (TICK_SECOND/25ull)   // Timeout before automatically transmitting unflushed data 
.................... #define TCP_WINDOW_UPDATE_TIMEOUT_VAL   (TICK_SECOND/5ull)   // Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call 
....................  
.................... #define TCP_SYN_QUEUE_MAX_ENTRIES   (3u)                // Number of TCP RX SYN packets to save if they cannot be serviced immediately 
.................... #define TCP_SYN_QUEUE_TIMEOUT      ((DWORD)TICK_SECOND*3)   // Timeout for when SYN queue entries are deleted if unserviceable 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCP Header Data Types 
....................   ***************************************************************************/ 
....................  
.................... #define FIN     (0x01)      // FIN Flag as defined in RFC 
.................... #define SYN     (0x02)      // SYN Flag as defined in RFC 
.................... #define RST     (0x04)      // Reset Flag as defined in RFC 
.................... #define PSH     (0x08)      // Push Flag as defined in RFC 
.................... #define ACK     (0x10)      // Acknowledge Flag as defined in RFC 
.................... #define URG     (0x20)      // Urgent Flag as defined in RFC 
....................  
.................... // TCP Header Data Structure 
.................... typedef struct 
.................... { 
....................    WORD    SourcePort;      // Local port number 
....................    WORD    DestPort;      // Remote port number 
....................    DWORD   SeqNumber;      // Local sequence number 
....................    DWORD   AckNumber;      // Acknowledging remote sequence number 
....................  
....................    struct 
....................    { 
....................       unsigned char Reserved3      : 4; 
....................       unsigned char Val            : 4; 
....................    } DataOffset;         // Data offset flags nibble 
....................  
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned char flagFIN    : 1; 
....................          unsigned char flagSYN    : 1; 
....................          unsigned char flagRST    : 1; 
....................          unsigned char flagPSH    : 1; 
....................          unsigned char flagACK    : 1; 
....................          unsigned char flagURG    : 1; 
....................          unsigned char Reserved2  : 2; 
....................       } bits; 
....................       BYTE byte; 
....................    } Flags;            // TCP Flags as defined in RFC 
....................  
....................    WORD    Window;         // Local free RX buffer window 
....................    WORD    Checksum;      // Data payload checksum 
....................    WORD    UrgentPointer;   // Urgent pointer 
.................... } TCP_HEADER; 
....................  
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00u)      // End of List TCP Option Flag 
.................... #define TCP_OPTIONS_NO_OP           (0x01u)      // No Op TCP Option 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)      // Maximum segment size TCP flag 
.................... typedef struct 
.................... { 
....................    BYTE        Kind;                     // Type of option 
....................    BYTE        Length;                     // Length 
....................    WORD_VAL    MaxSegSize;                  // Maximum segment size 
.................... } TCP_OPTIONS;                           // TCP Options data structure                      
....................  
.................... // Structure containing all the important elements of an incomming  
.................... // SYN packet in order to establish a connection at a future time  
.................... // if all sockets on the listening port are already connected to  
.................... // someone 
.................... typedef struct  
.................... { 
....................    NODE_INFO   niSourceAddress;// Remote IP address and MAC address 
....................    WORD      wSourcePort;   // Remote TCP port number that the response SYN needs to be sent to 
....................    DWORD      dwSourceSEQ;   // Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN 
....................    WORD      wDestPort;      // Local TCP port which the original SYN was destined for 
....................    WORD      wTimestamp;      // Timer to expire old SYN packets that can't be serviced at all 
.................... } TCP_SYN_QUEUE; 
....................  
....................  
.................... #if defined(STACK_CLIENT_MODE) 
.................... static WORD NextPort __attribute__((persistent));   // Tracking variable for next local client port number 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // Determines the number of defined TCP sockets 
.................... //#define TCP_SOCKET_COUNT   (sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])) 
.................... #define TCP_SOCKET_COUNT   TCP_CONFIGURATION    //ccs changed 
....................  
.................... #if defined(HI_TECH_C) 
....................    // The initializer forces this large array out of the bss section  
....................    // so we can link correctly. 
....................    #pragma psect bigdata=TCB_uRAM_BIG 
....................    #pragma psect data=TCB_uRAM 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};    
....................    #pragma psect data=ordinary_data_sect 
....................    #pragma psect bigdata=ordinary_data_sect_big 
.................... #else 
....................    // The TCB array is very large.  With the C18 compiler, one must  
....................    // modify the linker script to make an array that spans more than  
....................    // one memory bank.  To do this, make the necessary changes to your  
....................    // processor's linker script (.lkr).  Here is an example showing  
....................    // gpr11 and 128 bytes of gpr12 being combined into one 384 byte  
....................    // block used exclusively by the TCB_uRAM data section: 
....................    // ... 
....................    // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
....................    // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
....................    // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
....................    // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
....................    // ... 
....................    // SECTION    NAME=TCB_uRAM    RAM=gpr11b 
....................    // ... 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata TCB_uRAM 
....................    #endif 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT]; 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata               // Return to any other RAM section 
....................    #endif 
.................... #endif 
....................  
.................... static TCB MyTCB;                           // Currently loaded TCB 
.................... static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;      // Current TCP socket 
.................... #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata SYN_QUEUE_RAM_SECT 
....................    #endif 
....................    static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];   // Array of saved incoming SYN requests that need to be serviced later 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata 
....................    #endif 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static void TCPRAMCopy(PTR_BASE wDest, BYTE vDestType, PTR_BASE wSource, BYTE vSourceType, WORD wLength); 
....................  
.................... #if defined(__18CXX) 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength); 
.................... #else 
....................    #define TCPRAMCopyROM(a,b,c,d)   TCPRAMCopy(a,b,c,TCP_PIC_RAM,d) 
.................... #endif 
....................  
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags); 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len); 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote); 
.................... static void SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(void); 
.................... static void SyncTCB(void); 
....................  
.................... #if defined(WF_CS_TRIS) 
.................... UINT16 WFGetTCBSize(void); 
.................... #endif 
....................  
.................... // Indicates if this packet is a retransmission (no reset) or a new packet (reset required) 
.................... #define SENDTCP_RESET_TIMERS   0x01 
.................... // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6 
.................... #define SENDTCP_KEEP_ALIVE      0x02 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Optimization Configuration 
....................   ***************************************************************************/ 
....................  
.................... #if defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    static TCB_STUB MyTCBStub; 
....................     
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    static void SyncTCBStub(TCP_SOCKET hTCP) 
....................    { 
....................       if(hCurrentTCP == hTCP) 
*
00A74:  MOVLB  5
00A76:  MOVF   xF3,W
00A78:  MOVLB  1
00A7A:  SUBWF  xA3,W
00A7C:  BNZ   0A80
....................          return; 
00A7E:  BRA    0B12
....................     
....................       if(hCurrentTCP != INVALID_SOCKET) 
00A80:  MOVF   xA3,W
00A82:  SUBLW  FE
00A84:  BZ    0AC2
....................       { 
....................          // Save the current TCB stub 
....................          memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub)); 
00A86:  MOVF   xA3,W
00A88:  MULLW  1C
00A8A:  MOVF   FF3,W
00A8C:  CLRF   03
00A8E:  ADDLW  60
00A90:  MOVWF  01
00A92:  MOVLW  01
00A94:  ADDWFC 03,F
00A96:  MOVFF  01,5F4
00A9A:  MOVLB  5
00A9C:  MOVFF  03,5F5
00AA0:  MOVLW  01
00AA2:  MOVWF  xF7
00AA4:  MOVLW  E0
00AA6:  MOVFF  03,FEA
00AAA:  MOVFF  01,FE9
00AAE:  MOVFF  5F7,FE2
00AB2:  MOVWF  FE1
00AB4:  MOVLW  1C
00AB6:  MOVWF  01
00AB8:  MOVFF  FE6,FEE
00ABC:  DECFSZ 01,F
00ABE:  BRA    0AB8
00AC0:  MOVLB  1
....................       } 
....................     
....................       hCurrentTCP = hTCP; 
00AC2:  MOVFF  5F3,1A3
....................     
....................       if(hTCP == INVALID_SOCKET) 
00AC6:  MOVLB  5
00AC8:  MOVF   xF3,W
00ACA:  SUBLW  FE
00ACC:  BNZ   0AD4
....................          return; 
00ACE:  MOVLB  1
00AD0:  BRA    0B12
00AD2:  MOVLB  5
....................     
....................       // Load up the new TCB stub 
....................       memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub)); 
00AD4:  MOVLW  01
00AD6:  MOVWF  xF5
00AD8:  MOVLW  E0
00ADA:  MOVWF  xF4
00ADC:  MOVF   xF3,W
00ADE:  MULLW  1C
00AE0:  MOVF   FF3,W
00AE2:  CLRF   03
00AE4:  ADDLW  60
00AE6:  MOVWF  01
00AE8:  MOVLW  01
00AEA:  ADDWFC 03,F
00AEC:  MOVFF  01,5F6
00AF0:  MOVFF  03,5F7
00AF4:  MOVFF  5F5,FEA
00AF8:  MOVFF  5F4,FE9
00AFC:  MOVFF  03,FE2
00B00:  MOVFF  01,FE1
00B04:  MOVLW  1C
00B06:  MOVWF  01
00B08:  MOVFF  FE6,FEE
00B0C:  DECFSZ 01,F
00B0E:  BRA    0B08
00B10:  MOVLB  1
00B12:  MOVLB  0
00B14:  RETURN 0
....................    } 
.................... #else 
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    #define SyncTCBStub(a)   hCurrentTCP = (a) 
....................    // Alias to current TCP stub. 
....................    #define MyTCBStub      TCBStubs[hCurrentTCP] 
.................... #endif 
....................  
....................  
....................  
.................... // Flushes MyTCB cache and loads up the specified TCB. 
.................... // Does nothing on cache hit. 
.................... static void SyncTCB(void) 
.................... { 
....................    static TCP_SOCKET hLastTCB = INVALID_SOCKET; 
....................     
....................    if(hLastTCB == hCurrentTCP) 
*
01064:  MOVLB  1
01066:  MOVF   xA3,W
01068:  SUBWF  xFC,W
0106A:  BNZ   106E
....................       return; 
0106C:  BRA    1134
....................  
....................    if(hLastTCB != INVALID_SOCKET) 
0106E:  MOVF   xFC,W
01070:  SUBLW  FE
01072:  BZ    10EE
....................    { 
....................       // Save the current TCB 
....................       TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB)); 
01074:  MOVF   xFC,W
01076:  MULLW  1C
01078:  MOVF   FF3,W
0107A:  MOVLB  6
0107C:  CLRF   x34
0107E:  MOVWF  x33
01080:  MOVLW  60
01082:  ADDWF  x33,W
01084:  MOVWF  FE9
01086:  MOVLW  01
01088:  ADDWFC x34,W
0108A:  MOVWF  FEA
0108C:  MOVFF  FEC,636
01090:  MOVF   FED,F
01092:  MOVFF  FEF,635
01096:  MOVLW  27
01098:  SUBWF  x35,F
0109A:  MOVLW  00
0109C:  SUBWFB x36,F
0109E:  MOVLB  1
010A0:  MOVF   xFC,W
010A2:  MULLW  1C
010A4:  MOVF   FF3,W
010A6:  MOVLB  6
010A8:  CLRF   x38
010AA:  MOVWF  x37
010AC:  MOVLW  1B
010AE:  ADDWF  x37,W
010B0:  MOVWF  01
010B2:  MOVLW  00
010B4:  ADDWFC x38,W
010B6:  MOVWF  03
010B8:  MOVF   01,W
010BA:  ADDLW  60
010BC:  MOVWF  FE9
010BE:  MOVLW  01
010C0:  ADDWFC 03,W
010C2:  MOVWF  FEA
010C4:  MOVFF  FEF,63C
010C8:  MOVLW  01
010CA:  MOVWF  x39
010CC:  MOVLW  7C
010CE:  MOVWF  x38
010D0:  MOVFF  636,63B
010D4:  MOVFF  635,63A
010D8:  MOVFF  639,63E
010DC:  MOVWF  x3D
010DE:  MOVLW  01
010E0:  MOVWF  x3F
010E2:  CLRF   x41
010E4:  MOVLW  27
010E6:  MOVWF  x40
010E8:  MOVLB  0
010EA:  RCALL  0F7E
010EC:  MOVLB  1
....................    } 
....................  
....................    // Load up the new TCB 
....................    hLastTCB = hCurrentTCP; 
010EE:  MOVFF  1A3,1FC
....................    TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB)); 
010F2:  MOVLW  01
010F4:  MOVLB  6
010F6:  MOVWF  x34
010F8:  MOVLW  7C
010FA:  MOVWF  x33
010FC:  MOVLW  27
010FE:  MOVLB  1
01100:  SUBWF  xE0,W
01102:  MOVLB  6
01104:  MOVWF  x35
01106:  MOVLW  00
01108:  MOVLB  1
0110A:  SUBWFB xE1,W
0110C:  MOVLB  6
0110E:  MOVWF  x36
01110:  MOVFF  634,63B
01114:  MOVFF  633,63A
01118:  MOVLW  01
0111A:  MOVWF  x3C
0111C:  MOVFF  636,63E
01120:  MOVFF  635,63D
01124:  MOVFF  1FB,63F
01128:  CLRF   x41
0112A:  MOVLW  27
0112C:  MOVWF  x40
0112E:  MOVLB  0
01130:  RCALL  0F7E
01132:  MOVLB  1
01134:  MOVLB  0
01136:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPInit(void) 
....................  
....................   Summary: 
....................    Initializes the TCP module. 
....................  
....................   Description: 
....................    Initializes the TCP module.  This function sets up the TCP buffers 
....................    in memory and initializes each socket to the CLOSED state.  If 
....................    insufficient memory was allocated for the TCP sockets, the function 
....................    will hang here to be captured by the debugger. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TCPInit(void) 
*
0120A:  MOVLW  17
0120C:  MOVLB  5
0120E:  MOVWF  xBF
01210:  MOVLW  C8
01212:  MOVWF  xBE
.................... { 
....................    BYTE i; 
....................    BYTE vSocketsAllocated; 
....................    WORD wTXSize, wRXSize; 
....................    PTR_BASE ptrBaseAddress; 
....................    BYTE vMedium; 
....................    #if TCP_ETH_RAM_SIZE > 0 
....................    WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_PIC_RAM_SIZE > 0 
....................    PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_SPI_RAM_SIZE > 0 
....................    WORD wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS; 
....................    #endif 
....................  
....................    #if defined(STACK_CLIENT_MODE) 
....................       // Initialize NextPort to a random value if it is zero (such as after  
....................       // reset on a PIC32 or PIC18 when the static memory initializer is  
....................       // used).  By starting with a random number, we decrease the risk of  
....................       // reusing a port number that was previously used if the user power  
....................       // cycles the device. 
....................       if(NextPort == 0u) 
....................          NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER; 
....................    #endif 
....................  
....................  
....................    // Mark all SYN Queue entries as invalid by zeroing the memory 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................       memset((void*)SYNQueue, 0x00, sizeof(SYNQueue)); 
01214:  MOVLW  01
01216:  MOVWF  xC1
01218:  MOVLW  A4
0121A:  MOVWF  xC0
0121C:  MOVFF  5C1,FEA
01220:  MOVWF  FE9
01222:  CLRF   00
01224:  CLRF   02
01226:  MOVLW  3C
01228:  MOVWF  01
0122A:  MOVLB  0
0122C:  RCALL  0A5A
....................    #endif 
....................     
....................    // Allocate all socket FIFO addresses 
....................    vSocketsAllocated = 0; 
0122E:  MOVLB  5
01230:  CLRF   xB6
....................    for(i = 0; i < TCP_SOCKET_COUNT; i++) 
01232:  CLRF   xB5
01234:  MOVF   xB5,F
01236:  BTFSS  FD8.2
01238:  BRA    13A0
....................    { 
....................       // Generate all needed sockets of each type (TCP_PURPOSE_*) 
....................       SyncTCBStub(i); 
0123A:  MOVFF  5B5,5F3
0123E:  MOVLB  0
01240:  RCALL  0A74
....................     
....................       vMedium = TCPSocketInitializer[i].vMemoryMedium; 
01242:  MOVLB  5
01244:  MOVF   xB5,W
01246:  MULLW  06
01248:  MOVF   FF3,W
0124A:  CLRF   xC1
0124C:  MOVWF  xC0
0124E:  MOVLW  01
01250:  ADDWF  xC0,W
01252:  MOVWF  01
01254:  MOVLW  00
01256:  ADDWFC xC1,W
01258:  MOVWF  03
0125A:  MOVF   01,W
0125C:  ADDLW  01
0125E:  MOVWF  FE9
01260:  MOVLW  01
01262:  ADDWFC 03,W
01264:  MOVWF  FEA
01266:  MOVFF  FEF,5BD
....................       wTXSize = TCPSocketInitializer[i].wTXBufferSize; 
0126A:  MOVF   xB5,W
0126C:  MULLW  06
0126E:  MOVF   FF3,W
01270:  CLRF   xC1
01272:  MOVWF  xC0
01274:  MOVLW  02
01276:  ADDWF  xC0,W
01278:  MOVWF  01
0127A:  MOVLW  00
0127C:  ADDWFC xC1,W
0127E:  MOVWF  03
01280:  MOVF   01,W
01282:  ADDLW  01
01284:  MOVWF  FE9
01286:  MOVLW  01
01288:  ADDWFC 03,W
0128A:  MOVWF  FEA
0128C:  MOVFF  FEC,5B8
01290:  MOVF   FED,F
01292:  MOVFF  FEF,5B7
....................       wRXSize = TCPSocketInitializer[i].wRXBufferSize; 
01296:  MOVF   xB5,W
01298:  MULLW  06
0129A:  MOVF   FF3,W
0129C:  CLRF   xC1
0129E:  MOVWF  xC0
012A0:  MOVLW  04
012A2:  ADDWF  xC0,W
012A4:  MOVWF  01
012A6:  MOVLW  00
012A8:  ADDWFC xC1,W
012AA:  MOVWF  03
012AC:  MOVF   01,W
012AE:  ADDLW  01
012B0:  MOVWF  FE9
012B2:  MOVLW  01
012B4:  ADDWFC 03,W
012B6:  MOVWF  FEA
012B8:  MOVFF  FEC,5BA
012BC:  MOVF   FED,F
012BE:  MOVFF  FEF,5B9
....................     
....................       switch(vMedium) 
012C2:  MOVF   xBD,W
012C4:  XORLW  00
012C6:  MOVLB  0
012C8:  BZ    12CC
012CA:  BRA    131A
....................       { 
....................          #if TCP_ETH_RAM_SIZE > 0 
....................          case TCP_ETH_RAM: 
....................             ptrBaseAddress = wCurrentETHAddress; 
012CC:  MOVFF  5BF,5BC
012D0:  MOVFF  5BE,5BB
....................             wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
012D4:  MOVLW  27
012D6:  MOVLB  5
012D8:  ADDWF  xB7,W
012DA:  MOVWF  xC0
012DC:  MOVLW  00
012DE:  ADDWFC xB8,W
012E0:  MOVWF  xC1
012E2:  MOVLW  01
012E4:  ADDWF  xC0,F
012E6:  MOVLW  00
012E8:  ADDWFC xC1,F
012EA:  MOVF   xB9,W
012EC:  ADDWF  xC0,F
012EE:  MOVF   xBA,W
012F0:  ADDWFC xC1,F
012F2:  MOVLW  01
012F4:  ADDWF  xC0,W
012F6:  MOVWF  01
012F8:  MOVLW  00
012FA:  ADDWFC xC1,W
012FC:  MOVWF  03
012FE:  MOVF   01,W
01300:  ADDWF  xBE,F
01302:  MOVF   03,W
01304:  ADDWFC xBF,F
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
.................... #if defined(WF_CS_TRIS) 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + WFGetTCBSize()/*TCP_ETH_RAM_SIZE*/); 
.................... #else 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE); 
01306:  MOVF   xBF,W
01308:  SUBLW  1E
0130A:  BC    1316
0130C:  XORLW  FF
0130E:  BNZ   1306
01310:  MOVF   xBE,W
01312:  SUBLW  FC
01314:  BNC   1306
.................... #endif 
....................             break; 
01316:  BRA    131E
01318:  MOVLB  0
....................          #endif 
....................              
....................          #if TCP_PIC_RAM_SIZE > 0 
....................          case TCP_PIC_RAM: 
....................             ptrBaseAddress = ptrCurrentPICAddress; 
....................             ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE); 
....................             break; 
....................          #endif 
....................              
....................          #if TCP_SPI_RAM_SIZE > 0 
....................          case TCP_SPI_RAM: 
....................             ptrBaseAddress = wCurrentSPIAddress; 
....................             wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE); 
....................             break; 
....................          #endif 
....................           
....................          default: 
....................             while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations. 
0131A:  BRA    131A
0131C:  MOVLB  5
....................       } 
....................     
....................       MyTCBStub.vMemoryMedium = vMedium; 
0131E:  MOVFF  5BD,1FB
....................       MyTCBStub.bufferTxStart   = ptrBaseAddress + sizeof(TCB); 
01322:  MOVLW  27
01324:  ADDWF  xBB,W
01326:  MOVLB  1
01328:  MOVWF  xE0
0132A:  MOVLW  00
0132C:  MOVLB  5
0132E:  ADDWFC xBC,W
01330:  MOVLB  1
01332:  MOVWF  xE1
....................       MyTCBStub.bufferRxStart   = MyTCBStub.bufferTxStart + wTXSize + 1; 
01334:  MOVLB  5
01336:  MOVF   xB7,W
01338:  MOVLB  1
0133A:  ADDWF  xE0,W
0133C:  MOVLB  5
0133E:  MOVWF  xC0
01340:  MOVF   xB8,W
01342:  MOVLB  1
01344:  ADDWFC xE1,W
01346:  MOVLB  5
01348:  MOVWF  xC1
0134A:  MOVLW  01
0134C:  ADDWF  xC0,W
0134E:  MOVLB  1
01350:  MOVWF  xE2
01352:  MOVLW  00
01354:  MOVLB  5
01356:  ADDWFC xC1,W
01358:  MOVLB  1
0135A:  MOVWF  xE3
....................       MyTCBStub.bufferEnd      = MyTCBStub.bufferRxStart + wRXSize; 
0135C:  MOVLB  5
0135E:  MOVF   xB9,W
01360:  MOVLB  1
01362:  ADDWF  xE2,W
01364:  MOVWF  xE4
01366:  MOVLB  5
01368:  MOVF   xBA,W
0136A:  MOVLB  1
0136C:  ADDWFC xE3,W
0136E:  MOVWF  xE5
....................       MyTCBStub.smState      = TCP_CLOSED; 
01370:  MOVLW  0D
01372:  MOVWF  xF6
....................       MyTCBStub.Flags.bServer   = FALSE; 
01374:  BCF    xF7.3
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................       #endif       
....................  
....................       SyncTCB(); 
01376:  MOVLB  0
01378:  RCALL  1064
....................       MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose; 
0137A:  MOVLB  5
0137C:  MOVF   xB5,W
0137E:  MULLW  06
01380:  MOVF   FF3,W
01382:  CLRF   xC1
01384:  MOVWF  xC0
01386:  MOVLW  01
01388:  ADDWF  xC0,W
0138A:  MOVWF  FE9
0138C:  MOVLW  01
0138E:  ADDWFC xC1,W
01390:  MOVWF  FEA
01392:  MOVFF  FEF,1A2
....................       CloseSocket(); 
01396:  MOVLB  0
01398:  RCALL  1138
0139A:  MOVLB  5
0139C:  INCF   xB5,F
0139E:  BRA    1234
....................    } 
013A0:  MOVLB  0
013A2:  GOTO   1556 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
....................      
....................   Summary: 
....................     Opens a TCP socket for listening or as a client. 
....................  
....................   Description: 
....................     Provides a unified method for opening TCP sockets. This function can 
....................     open both client and server sockets. For client sockets, it can accept 
....................     a host name string to query in DNS, an IP address as a string, an IP 
....................     address in binary form, or a previously resolved NODE_INFO structure 
....................     containing the remote IP address and associated MAC address. When a 
....................     host name or IP address only is provided, the TCP module will 
....................     internally perform the necessary DNS and/or ARP resolution steps before 
....................     reporting that the TCP socket is connected (via a call to 
....................     TCPISConnected returning TRUE). Server sockets ignore this destination 
....................     parameter and listen only on the indicated port. 
....................      
....................     The vSocketPurpose field allows sockets to be opened with varying 
....................     buffer size parameters and memory storage mediums. This field 
....................     corresponds to pre-defined sockets allocated in the 
....................     TCPSocketInitializer[] array in TCPIPConfig.h. The TCPIPConfig.h file 
....................     can be edited using the TCP/IP Configuration Wizard. 
....................      
....................     Sockets are statically allocated on boot, but can be claimed with this 
....................     \function and freed using TCPDisconnect or TCPClose (for client 
....................     sockets). Server sockets can be freed using TCPClose only (calls to 
....................     TCPDisconnect will return server sockets to the listening state, 
....................     allowing reuse). 
....................  
....................   Conditions: 
....................     TCP is initialized. 
....................  
....................   Input: 
....................     dwRemoteHost -     For client sockets only. Provide a pointer to a 
....................                        null\-terminated string of the remote host name (ex\: 
....................                        "www.microchip.com" or "192.168.1.123"), a literal 
....................                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR 
....................                        data type), or a pointer to a NODE_INFO structure 
....................                        with the remote IP address and remote node or gateway 
....................                        MAC address specified. If a string is provided, note 
....................                        that it must be statically allocated in memory and 
....................                        cannot be modified or deallocated until 
....................                        TCPIsConnected returns TRUE.<p />This parameter is 
....................                        ignored for server sockets. 
....................     vRemoteHostType -  Any one of the following flags to identify the 
....................                        meaning of the dwRemoteHost parameter\: 
....................                        * TCP_OPEN_SERVER &#45; Open a server socket and 
....................                          ignore the dwRemoteHost parameter. 
....................                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a RAM array. Ex\: 
....................                          "www.microchip.com" or "192.168.0.123" (BYTE&#42; 
....................                          type) 
....................                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a literal string or ROM 
....................                          array. Ex\: "www.microchip.com" or "192.168.0.123" 
....................                          (ROM BYTE&#42; type) 
....................                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and 
....................                          connect it to a remote IP address. Ex\: 0x7B01A8C0 
....................                          for 192.168.1.123 (DWORD type). Note that the byte 
....................                          ordering is big endian. 
....................                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and 
....................                          connect it to a remote IP and MAC addresses pair 
....................                          stored in a NODE_INFO structure. dwRemoteHost must be 
....................                          a pointer to the NODE_INFO structure. This option is 
....................                          provided for backwards compatibility with 
....................                          applications built against prior stack versions that 
....................                          only implemented the TCPConnect() function. It can 
....................                          also be used to skip DNS and ARP resolution steps if 
....................                          connecting to a remote node which you've already 
....................                          connected to and have cached addresses for. 
....................     wPort -            TCP port to listen on or connect to\: 
....................                        * Client sockets &#45; the remote TCP port to which a 
....................                          connection should be made. The local port for client 
....................                          sockets will be automatically picked by the TCP 
....................                          module. 
....................                        * Server sockets &#45; the local TCP port on which to 
....................                          listen for connections. 
....................     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in 
....................                        TCPIPConfig.h or the TCPIPConfig utility (see 
....................                        TCPSocketInitializer[] array). 
....................  
....................   Return Values: 
....................     INVALID_SOCKET -  No sockets of the specified type were available to be 
....................                       opened. 
....................     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when 
....................                       calling all other TCP APIs. 
....................  
....................   Remarks: 
....................     This function replaces the old TCPConnect and TCPListen functions. 
....................      
....................     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination 
....................     type, the DNS client module must also be enabled (STACK_USE_DNS must be 
....................     defined in TCPIPConfig.h). 
....................  
....................   Example: 
....................     \ \  
....................     <code> 
....................     // Open a server socket 
....................     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
....................      
....................     // Open a client socket to www.microchip.com 
....................     // The double cast here prevents compiler warnings 
....................     skt = TCPOpen((DWORD)(PTR_BASE)"www.microchip.com", 
....................                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT); 
....................      
....................     // Reopen a client socket without repeating DNS or ARP 
....................     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket 
....................     skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO, 
....................                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT); 
....................     </code>                                                     
....................   *****************************************************************************/ 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................  
....................    // Find an available socket that matches the specified socket type 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
01402:  MOVLB  5
01404:  CLRF   xC0
01406:  MOVF   xC0,F
01408:  BNZ   1470
....................    { 
....................       SyncTCBStub(hTCP); 
0140A:  MOVFF  5C0,5F3
0140E:  MOVLB  0
01410:  CALL   0A74
....................  
....................       // Sockets that are in use will be in a non-closed state 
....................       if(MyTCBStub.smState != TCP_CLOSED) 
01414:  MOVLB  1
01416:  MOVF   xF6,W
01418:  SUBLW  0D
0141A:  BZ    141E
....................          continue; 
0141C:  BRA    146A
....................  
....................       SyncTCB(); 
0141E:  MOVLB  0
01420:  RCALL  1064
....................  
....................       // See if this socket matches the desired type 
....................       if(MyTCB.vSocketPurpose != vSocketPurpose) 
01422:  MOVLB  5
01424:  MOVF   xBF,W
01426:  MOVLB  1
01428:  SUBWF  xA2,W
0142A:  BZ    142E
....................          continue; 
0142C:  BRA    146A
....................  
....................       // Start out assuming worst case Maximum Segment Size (changes when MSS  
....................       // option is received from remote node) 
....................       MyTCB.wRemoteMSS = 536; 
0142E:  MOVLW  02
01430:  MOVWF  xA0
01432:  MOVLW  18
01434:  MOVWF  x9F
....................  
....................       // See if this is a server socket 
....................       if(vRemoteHostType == TCP_OPEN_SERVER) 
01436:  MOVLB  5
01438:  MOVF   xBC,F
0143A:  BNZ   1458
....................       { 
....................          MyTCB.localPort.Val = wPort; 
0143C:  MOVFF  5BE,18D
01440:  MOVFF  5BD,18C
....................          MyTCBStub.Flags.bServer = TRUE; 
01444:  MOVLB  1
01446:  BSF    xF7.3
....................          MyTCBStub.smState = TCP_LISTEN; 
01448:  MOVLW  04
0144A:  MOVWF  xF6
....................          MyTCBStub.remoteHash.Val = wPort; 
0144C:  MOVFF  5BE,1FA
01450:  MOVFF  5BD,1F9
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          MyTCB.localSSLPort.Val = 0; 
....................          #endif 
....................       } 
01454:  BRA    1460
01456:  MOVLB  5
....................       // Handle all the client mode socket types 
....................       else 
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          { 
....................             // Each new socket that is opened by this node, gets the  
....................             // next sequential local port number. 
....................             if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER) 
....................                NextPort = LOCAL_PORT_START_NUMBER; 
....................              
....................             // Set the non-zero TCB fields 
....................             MyTCB.localPort.Val = NextPort++; 
....................             MyTCB.remotePort.Val = wPort; 
....................     
....................             // Flag to start the DNS, ARP, SYN processes 
....................             MyTCBStub.eventTime = TickGet(); 
....................             MyTCBStub.Flags.bTimerEnabled = 1; 
....................     
....................             switch(vRemoteHostType) 
....................             { 
....................                #if defined(STACK_USE_DNS) 
....................                case TCP_OPEN_RAM_HOST: 
....................                case TCP_OPEN_ROM_HOST: 
....................                   MyTCB.remote.dwRemoteHost = dwRemoteHost; 
....................                   MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST); 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                   break; 
....................                #endif 
....................        
....................                case TCP_OPEN_IP_ADDRESS: 
....................                   // dwRemoteHost is a literal IP address.  This  
....................                   // doesn't need DNS and can skip directly to the  
....................                   // Gateway ARPing step. 
....................                   MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val; 
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost; 
....................                   MyTCB.retryCount = 0; 
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                   break; 
....................        
....................                case TCP_OPEN_NODE_INFO: 
....................                   MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val; 
....................                   memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO)); 
....................                   MyTCBStub.smState = TCP_SYN_SENT; 
....................                   SendTCP(SYN, SENDTCP_RESET_TIMERS); 
....................                   break; 
....................             } 
....................          }       
....................          #else 
....................          { 
....................             return INVALID_SOCKET; 
01458:  MOVLW  FE
0145A:  MOVWF  01
0145C:  BRA    1474
0145E:  MOVLB  1
....................          }    
....................          #endif 
....................       } 
....................        
....................       return hTCP;       
01460:  MOVLB  5
01462:  MOVFF  5C0,01
01466:  BRA    1474
01468:  MOVLB  1
0146A:  MOVLB  5
0146C:  INCF   xC0,F
0146E:  BRA    1406
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    return INVALID_SOCKET; 
01470:  MOVLW  FE
01472:  MOVWF  01
01474:  MOVLB  0
01476:  GOTO   14D4 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPWasReset(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Self-clearing semaphore inidicating socket reset. 
....................  
....................   Description: 
....................    This function is a self-clearing semaphore indicating whether or not 
....................    a socket has been disconnected since the previous call.  This function 
....................    works for all possible disconnections: a call to TCPDisconnect, a FIN  
....................    from the remote node, or an acknowledgement timeout caused by the loss 
....................    of a network link.  It also returns TRUE after the first call to TCPInit. 
....................    Applications should use this function to reset their state machines. 
....................     
....................    This function was added due to the possibility of an error when relying 
....................    on TCPIsConnected returing FALSE to check for a condition requiring a 
....................    state machine reset.  If a socket is closed (due to a FIN ACK) and then 
....................    immediately reopened (due to a the arrival of a new SYN) in the same 
....................    cycle of the stack, calls to TCPIsConnected by the application will  
....................    never return FALSE even though the socket has been disconnected.  This  
....................    can cause errors for protocols such as HTTP in which a client will  
....................    immediately open a new connection upon closing of a prior one.  Relying 
....................    on this function instead allows applications to trap those conditions  
....................    and properly reset their internal state for the new connection. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has been disconnected since the previous call. 
....................      FALSE - The socket has not been disconnected since the previous call. 
....................   ***************************************************************************/ 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return TRUE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.Flags.bSocketReset) 
....................    { 
....................       MyTCBStub.Flags.bSocketReset = 0; 
....................       return TRUE; 
....................    }    
....................     
....................    return FALSE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsConnected(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a socket has an established connection. 
....................  
....................   Description: 
....................    This function determines if a socket has an established connection to  
....................    a remote node.  Call this function after calling TCPOpen to determine  
....................    when the connection is set up and ready for use.  This function was  
....................    historically used to check for disconnections, but TCPWasReset is now a 
....................    more appropriate solution.  
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has an established connection to a remote node. 
....................      FALSE - The socket is not currently connected. 
....................  
....................   Remarks: 
....................    A socket is said to be connected only if it is in the TCP_ESTABLISHED 
....................    state.  Sockets in the process of opening or closing will return FALSE. 
....................   ***************************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
06E00:  MOVLB  5
06E02:  MOVF   xC3,W
06E04:  SUBLW  00
06E06:  BC    6E0E
....................     { 
....................         return FALSE; 
06E08:  MOVLW  00
06E0A:  MOVWF  01
06E0C:  BRA    6E2A
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
06E0E:  MOVFF  5C3,5F3
06E12:  MOVLB  0
06E14:  CALL   0A74
....................    return (MyTCBStub.smState == TCP_ESTABLISHED); 
06E18:  MOVLB  1
06E1A:  MOVF   xF6,W
06E1C:  SUBLW  07
06E1E:  BZ    6E24
06E20:  MOVLW  00
06E22:  BRA    6E26
06E24:  MOVLW  01
06E26:  MOVWF  01
06E28:  MOVLB  5
06E2A:  MOVLB  0
06E2C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDisconnect(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket. 
....................  
....................   Description: 
....................    This function closes a connection to a remote node by sending a FIN (if  
....................    currently connected). 
....................     
....................    The function can be called a second time to force a socket closed by  
....................    sending a RST packet.  This is useful when the application knows that  
....................    the remote node will not send an ACK (if it has crashed or lost its link), 
....................    or when the application needs to reuse the socket immediately regardless 
....................    of whether or not the remote node would like to transmit more data before 
....................    closing. 
....................     
....................    For client mode sockets, upon return, the hTCP handle is relinquished to  
....................    the TCP/IP stack and must no longer be used by the application (except for  
....................    an immediate subsequent call to TCPDisconnect() to force a RST  
....................    transmission, if needed).   
....................     
....................    For server mode sockets, upon return, the hTCP handle is NOT relinquished  
....................    to the TCP/IP stack.  After closing, the socket returns to the listening  
....................    state allowing future connection requests to be serviced.  This leaves the  
....................    hTCP handle in a valid state and must be retained for future operations on  
....................    the socket.  If you want to close the server and relinquish the socket back  
....................    to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect(). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle of the socket to disconnect. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted 
....................    first to allow the SSL session to be resumed at a later time. 
....................   ***************************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
03C20:  MOVLB  5
03C22:  MOVF   xC3,W
03C24:  SUBLW  00
03C26:  BC    3C2A
....................     { 
....................         return; 
03C28:  BRA    3D06
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
03C2A:  MOVFF  5C3,5F3
03C2E:  MOVLB  0
03C30:  CALL   0A74
....................  
....................    // Delete all data in the RX FIFO 
....................    // In this stack's API, the application TCP handle is  
....................    // immediately invalid after calling this function, so there  
....................    // is no longer any way to receive data from the TCP RX FIFO,  
....................    // even though the data is still there.  Leaving the data there  
....................    // could interfere with the remote node sending us a FIN if our 
....................    // RX window is zero 
....................    MyTCBStub.rxTail = MyTCBStub.rxHead; 
03C34:  MOVFF  1EB,1ED
03C38:  MOVFF  1EA,1EC
....................  
....................    switch(MyTCBStub.smState) 
03C3C:  MOVLB  1
03C3E:  MOVF   xF6,W
03C40:  XORLW  00
03C42:  MOVLB  0
03C44:  BZ    3C70
03C46:  XORLW  02
03C48:  BZ    3C70
03C4A:  XORLW  01
03C4C:  BZ    3C70
03C4E:  XORLW  06
03C50:  BZ    3C70
03C52:  XORLW  03
03C54:  BZ    3C76
03C56:  XORLW  01
03C58:  BZ    3C76
03C5A:  XORLW  0C
03C5C:  BZ    3CB0
03C5E:  XORLW  05
03C60:  BZ    3CEA
03C62:  XORLW  06
03C64:  BZ    3CF4
03C66:  XORLW  01
03C68:  BZ    3CF4
03C6A:  XORLW  05
03C6C:  BZ    3CF4
03C6E:  BRA    3CF4
....................    { 
....................       #if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS) 
....................       case TCP_DNS_RESOLVE: 
....................          DNSEndUsage();   // Release the DNS module, since the user is aborting 
....................          CloseSocket(); 
....................          break; 
....................       #endif 
....................  
....................       case TCP_GET_DNS_MODULE: 
....................       case TCP_GATEWAY_SEND_ARP: 
....................       case TCP_GATEWAY_GET_ARP: 
....................       case TCP_SYN_SENT: 
....................          CloseSocket(); 
03C70:  CALL   1138
....................          break; 
03C74:  BRA    3D04
....................  
....................       case TCP_SYN_RECEIVED: 
....................       case TCP_ESTABLISHED: 
....................          #if defined(STACK_USE_SSL) 
....................          // When disconnecting SSL sockets, send a close_notify so we can resume later 
....................          if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          { 
....................             // Flush pending data and send close_notify 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY); 
....................          } 
....................          #endif 
....................  
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
03C76:  MOVLW  11
03C78:  MOVLB  6
03C7A:  MOVWF  x09
03C7C:  MOVLW  01
03C7E:  MOVWF  x0A
03C80:  MOVLB  0
03C82:  RCALL  3598
....................             if(MyTCB.remoteWindow == 0u) 
03C84:  MOVLB  1
03C86:  MOVF   x8E,F
03C88:  BNZ   3C90
03C8A:  MOVF   x8F,F
03C8C:  BNZ   3C90
....................                break; 
03C8E:  BRA    3CA8
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
03C90:  MOVF   x88,W
03C92:  SUBWF  xE6,W
03C94:  BTFSC  FD8.2
03C96:  BRA    3C9C
03C98:  MOVLB  0
03C9A:  BRA    3C76
03C9C:  MOVF   x89,W
03C9E:  SUBWF  xE7,W
03CA0:  BTFSC  FD8.2
03CA2:  BRA    3CA8
03CA4:  MOVLB  0
03CA6:  BRA    3C76
....................           
....................          MyTCBStub.smState = TCP_FIN_WAIT_1; 
03CA8:  MOVLW  08
03CAA:  MOVWF  xF6
....................          break; 
03CAC:  MOVLB  0
03CAE:  BRA    3D04
....................  
....................       case TCP_CLOSE_WAIT: 
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
03CB0:  MOVLW  11
03CB2:  MOVLB  6
03CB4:  MOVWF  x09
03CB6:  MOVLW  01
03CB8:  MOVWF  x0A
03CBA:  MOVLB  0
03CBC:  RCALL  3598
....................             if(MyTCB.remoteWindow == 0u) 
03CBE:  MOVLB  1
03CC0:  MOVF   x8E,F
03CC2:  BNZ   3CCA
03CC4:  MOVF   x8F,F
03CC6:  BNZ   3CCA
....................                break; 
03CC8:  BRA    3CE2
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
03CCA:  MOVF   x88,W
03CCC:  SUBWF  xE6,W
03CCE:  BTFSC  FD8.2
03CD0:  BRA    3CD6
03CD2:  MOVLB  0
03CD4:  BRA    3CB0
03CD6:  MOVF   x89,W
03CD8:  SUBWF  xE7,W
03CDA:  BTFSC  FD8.2
03CDC:  BRA    3CE2
03CDE:  MOVLB  0
03CE0:  BRA    3CB0
....................  
....................          MyTCBStub.smState = TCP_LAST_ACK; 
03CE2:  MOVLW  0C
03CE4:  MOVWF  xF6
....................          break; 
03CE6:  MOVLB  0
03CE8:  BRA    3D04
....................           
....................       // These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while 
....................       //case TCP_CLOSED: 
....................       //case TCP_LISTEN: 
....................       //case TCP_CLOSING: 
....................       //case TCP_TIME_WAIT: 
....................       //   return; 
....................  
....................       case TCP_CLOSED_BUT_RESERVED: 
....................          MyTCBStub.smState = TCP_CLOSED; 
03CEA:  MOVLW  0D
03CEC:  MOVLB  1
03CEE:  MOVWF  xF6
....................          break; 
03CF0:  MOVLB  0
03CF2:  BRA    3D04
....................  
....................       // These states will close themselves after some delay, however,  
....................       // this is handled so that the user can call TCPDisconnect()  
....................       // twice to immediately close a socket (using an RST) without  
....................       // having to get an ACK back from the remote node.  This is  
....................       // great for instance when the application determines that  
....................       // the remote node has been physically disconnected and  
....................       // already knows that no ACK will be returned.  Alternatively,  
....................       // if the application needs to immediately reuse the socket  
....................       // regardless of what the other node's state is in (half open). 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_LAST_ACK: 
....................       default: 
....................          SendTCP(RST | ACK, 0); 
03CF4:  MOVLW  14
03CF6:  MOVLB  6
03CF8:  MOVWF  x09
03CFA:  CLRF   x0A
03CFC:  MOVLB  0
03CFE:  RCALL  3598
....................          CloseSocket(); 
03D00:  CALL   1138
....................          break; 
03D04:  MOVLB  5
....................    } 
03D06:  MOVLB  0
03D08:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPClose(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles. 
....................  
....................   Description: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles.  This function performs identically to the  
....................    TCPDisconnect() function, except that both client and server mode socket  
....................    handles are relinquished to the TCP/IP stack upon return. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle to the socket to disconnect and close. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPClose(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bServer = FALSE; 
....................    TCPDisconnect(hTCP); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Obtains information about a currently open socket. 
....................  
....................   Description: 
....................    Returns the SOCKET_INFO structure associated with this socket.  This  
....................    contains the NODE_INFO structure with IP and MAC address (or gateway 
....................    MAC) and the remote port. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The SOCKET_INFO structure associated with this socket.  This structure is  
....................    allocated statically by the function and is valid only until the next  
....................    time TCPGetRemoteInfo() is called. 
....................   ***************************************************************************/ 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
.................... { 
....................    static SOCKET_INFO   RemoteInfo; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................    memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO)); 
....................    RemoteInfo.remotePort.Val = MyTCB.remotePort.Val; 
....................  
....................    return &RemoteInfo; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPFlush(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Immediately transmits all pending TX data. 
....................  
....................   Description: 
....................    This function immediately transmits all pending TX data with a PSH  
....................    flag.  If this function is not called, data will automatically be sent 
....................    when either a) the TX buffer is half full or b) the  
....................    TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose data is to be transmitted. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    SSL application data is automatically flushed, so this function has  
....................    no effect for SSL sockets. 
....................   ***************************************************************************/ 
.................... void TCPFlush(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
08B5A:  MOVLB  5
08B5C:  MOVF   xF1,W
08B5E:  SUBLW  00
08B60:  BC    8B64
....................     { 
....................         return; 
08B62:  BRA    8B94
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
08B64:  MOVFF  5F1,5F3
08B68:  MOVLB  0
08B6A:  CALL   0A74
....................    SyncTCB(); 
08B6E:  CALL   1064
....................  
....................    // NOTE: Pending SSL data will NOT be transferred here 
....................  
....................    if(MyTCBStub.txHead != MyTCB.txUnackedTail) 
08B72:  MOVLB  1
08B74:  MOVF   x88,W
08B76:  SUBWF  xE6,W
08B78:  BNZ   8B80
08B7A:  MOVF   x89,W
08B7C:  SUBWF  xE7,W
08B7E:  BZ    8B92
....................    { 
....................       // Send the TCP segment with all unacked bytes 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
08B80:  MOVLW  10
08B82:  MOVLB  6
08B84:  MOVWF  x09
08B86:  MOVLW  01
08B88:  MOVWF  x0A
08B8A:  MOVLB  0
08B8C:  CALL   3598
08B90:  MOVLB  1
08B92:  MOVLB  5
....................    } 
08B94:  MOVLB  0
08B96:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPIsPutReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how much free space is available in the TCP TX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be written to the  
....................    TCP TX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to transmit 
....................    more data. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be written in the TCP TX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
08AAC:  MOVLB  5
08AAE:  MOVF   xF1,W
08AB0:  SUBLW  00
08AB2:  BC    8ABC
....................     { 
....................         return 0; 
08AB4:  MOVLW  00
08AB6:  MOVWF  01
08AB8:  MOVWF  02
08ABA:  BRA    8B56
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
08ABC:  MOVFF  5F1,5F3
08AC0:  MOVLB  0
08AC2:  CALL   0A74
....................  
....................    i = MyTCBStub.smState; 
08AC6:  MOVFF  1F6,5F2
....................  
....................    // Unconnected sockets shouldn't be transmitting anything. 
....................    if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) )) 
08ACA:  MOVLB  5
08ACC:  MOVF   xF2,W
08ACE:  SUBLW  07
08AD0:  BZ    8AE0
08AD2:  MOVF   xF2,W
08AD4:  SUBLW  0B
08AD6:  BZ    8AE0
....................       return 0; 
08AD8:  MOVLW  00
08ADA:  MOVWF  01
08ADC:  MOVWF  02
08ADE:  BRA    8B56
....................  
....................    // Calculate the free space in this socket's TX FIFO 
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    {// Use sslTxHead as the head pointer when SSL is active 
....................       WORD rem; 
....................        
....................       // Find out raw free space 
....................       if(MyTCBStub.sslTxHead >= MyTCBStub.txTail) 
....................          rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail); 
....................       else 
....................          rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1; 
....................           
....................       // Reserve space for a new MAC and header 
....................       if(rem > 22u) 
....................          return rem - 22; 
....................       else 
....................          return 0; 
....................    } 
....................    #endif 
....................     
....................    if(MyTCBStub.txHead >= MyTCBStub.txTail) 
08AE0:  MOVLB  1
08AE2:  MOVF   xE9,W
08AE4:  SUBWF  xE7,W
08AE6:  BNC   8B32
08AE8:  BNZ   8AF0
08AEA:  MOVF   xE8,W
08AEC:  SUBWF  xE6,W
08AEE:  BNC   8B32
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail); 
08AF0:  MOVF   xE0,W
08AF2:  SUBWF  xE2,W
08AF4:  MOVLB  5
08AF6:  MOVWF  xF3
08AF8:  MOVLB  1
08AFA:  MOVF   xE1,W
08AFC:  SUBWFB xE3,W
08AFE:  MOVLB  5
08B00:  MOVWF  xF4
08B02:  MOVLW  01
08B04:  SUBWF  xF3,F
08B06:  MOVLW  00
08B08:  SUBWFB xF4,F
08B0A:  MOVLB  1
08B0C:  MOVF   xE8,W
08B0E:  SUBWF  xE6,W
08B10:  MOVWF  00
08B12:  MOVF   xE9,W
08B14:  SUBWFB xE7,W
08B16:  MOVWF  03
08B18:  MOVF   00,W
08B1A:  MOVLB  5
08B1C:  SUBWF  xF3,W
08B1E:  MOVWF  00
08B20:  MOVF   03,W
08B22:  SUBWFB xF4,W
08B24:  MOVWF  03
08B26:  MOVFF  00,01
08B2A:  MOVWF  02
08B2C:  BRA    8B56
08B2E:  BRA    8B56
08B30:  MOVLB  1
....................    else 
....................       return MyTCBStub.txTail - MyTCBStub.txHead - 1; 
08B32:  MOVF   xE6,W
08B34:  SUBWF  xE8,W
08B36:  MOVLB  5
08B38:  MOVWF  xF3
08B3A:  MOVLB  1
08B3C:  MOVF   xE7,W
08B3E:  SUBWFB xE9,W
08B40:  MOVLB  5
08B42:  MOVWF  xF4
08B44:  MOVLW  01
08B46:  SUBWF  xF3,W
08B48:  MOVWF  00
08B4A:  MOVLW  00
08B4C:  SUBWFB xF4,W
08B4E:  MOVWF  03
08B50:  MOVFF  00,01
08B54:  MOVWF  02
08B56:  MOVLB  0
08B58:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
....................  
....................   Description: 
....................    Writes a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    byte - The byte to write. 
....................  
....................   Return Values: 
....................    TRUE - The byte was written to the transmit buffer. 
....................    FALSE - The transmit buffer was full, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
.................... { 
....................    WORD wFreeTXSpace; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
08B98:  MOVLB  5
08B9A:  MOVF   xED,W
08B9C:  SUBLW  00
08B9E:  BC    8BA6
....................     { 
....................         return 0; 
08BA0:  MOVLW  00
08BA2:  MOVWF  01
08BA4:  BRA    8CB6
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
08BA6:  MOVFF  5ED,5F3
08BAA:  MOVLB  0
08BAC:  CALL   0A74
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
08BB0:  MOVFF  5ED,5F1
08BB4:  RCALL  8AAC
08BB6:  MOVFF  02,5F0
08BBA:  MOVFF  01,5EF
....................    if(wFreeTXSpace == 0u) 
08BBE:  MOVLB  5
08BC0:  MOVF   xEF,F
08BC2:  BNZ   8BD0
08BC4:  MOVF   xF0,F
08BC6:  BNZ   8BD0
....................       return FALSE; 
08BC8:  MOVLW  00
08BCA:  MOVWF  01
08BCC:  BRA    8CB6
08BCE:  BRA    8BE2
....................    else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster 
08BD0:  DECFSZ xEF,W
08BD2:  BRA    8BE2
08BD4:  MOVF   xF0,F
08BD6:  BNZ   8BE2
....................       TCPFlush(hTCP);    
08BD8:  MOVFF  5ED,5F1
08BDC:  MOVLB  0
08BDE:  RCALL  8B5A
08BE0:  MOVLB  5
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
08BE2:  MOVLB  1
08BE4:  BTFSC  xF8.0
08BE6:  BRA    8C2C
08BE8:  MOVF   xE0,W
08BEA:  SUBWF  xE2,W
08BEC:  MOVLB  5
08BEE:  MOVWF  xF1
08BF0:  MOVLB  1
08BF2:  MOVF   xE1,W
08BF4:  SUBWFB xE3,W
08BF6:  MOVLB  5
08BF8:  MOVWF  xF2
08BFA:  BCF    FD8.0
08BFC:  RRCF   xF2,W
08BFE:  MOVWF  03
08C00:  RRCF   xF1,W
08C02:  MOVWF  02
08C04:  MOVWF  01
08C06:  MOVF   xF0,W
08C08:  SUBWF  03,W
08C0A:  BTFSC  FD8.0
08C0C:  BRA    8C12
08C0E:  MOVLB  1
08C10:  BRA    8C2C
08C12:  BNZ   8C20
08C14:  MOVF   xEF,W
08C16:  SUBWF  01,W
08C18:  BTFSC  FD8.0
08C1A:  BRA    8C20
08C1C:  MOVLB  1
08C1E:  BRA    8C2C
....................    { 
....................       TCPFlush(hTCP);    
08C20:  MOVFF  5ED,5F1
08C24:  MOVLB  0
08C26:  RCALL  8B5A
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
08C28:  MOVLB  1
08C2A:  BSF    xF8.0
....................    } 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    else 
....................    { 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    #else 
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
08C2C:  MOVLW  05
08C2E:  MOVLB  5
08C30:  MOVWF  xF2
08C32:  MOVLW  EE
08C34:  MOVWF  xF1
08C36:  MOVFF  1E7,63B
08C3A:  MOVFF  1E6,63A
08C3E:  MOVFF  1FB,63C
08C42:  MOVFF  5F2,63E
08C46:  MOVFF  FE8,63D
08C4A:  MOVLW  01
08C4C:  MOVLB  6
08C4E:  MOVWF  x3F
08C50:  CLRF   x41
08C52:  MOVWF  x40
08C54:  MOVLB  0
08C56:  CALL   0F7E
....................    if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
08C5A:  MOVLB  1
08C5C:  INCF   xE6,F
08C5E:  BTFSC  FD8.2
08C60:  INCF   xE7,F
08C62:  MOVF   xE3,W
08C64:  SUBWF  xE7,W
08C66:  BNC   8C78
08C68:  BNZ   8C70
08C6A:  MOVF   xE2,W
08C6C:  SUBWF  xE6,W
08C6E:  BNC   8C78
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
08C70:  MOVFF  1E1,1E7
08C74:  MOVFF  1E0,1E6
....................    #endif 
....................     
....................  
....................    // Send the last byte as a separate packet (likely will make the remote node send back ACK faster) 
....................    if(wFreeTXSpace == 1u) 
08C78:  MOVLB  5
08C7A:  DECFSZ xEF,W
08C7C:  BRA    8C8C
08C7E:  MOVF   xF0,F
08C80:  BNZ   8C8C
....................    { 
....................       TCPFlush(hTCP); 
08C82:  MOVFF  5ED,5F1
08C86:  MOVLB  0
08C88:  RCALL  8B5A
....................    } 
08C8A:  BRA    8CB0
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
08C8C:  MOVLB  1
08C8E:  BTFSC  xF7.5
08C90:  BRA    8CAE
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
08C92:  BSF    xF7.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
08C94:  MOVLB  0
08C96:  CALL   2F9C
08C9A:  MOVLW  04
08C9C:  MOVLB  5
08C9E:  ADDWF  00,W
08CA0:  MOVLB  1
08CA2:  MOVWF  xF2
08CA4:  MOVLW  00
08CA6:  MOVLB  5
08CA8:  ADDWFC 01,W
08CAA:  MOVLB  1
08CAC:  MOVWF  xF3
08CAE:  MOVLB  0
....................    } 
....................  
....................    return TRUE; 
08CB0:  MOVLW  01
08CB2:  MOVWF  01
08CB4:  MOVLB  5
08CB6:  MOVLB  0
08CB8:  GOTO   8CC6 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from RAM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from ROM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................  
....................   Remarks: 
....................    This function is aliased to TCPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from RAM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................   ***************************************************************************/ 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
.................... { 
....................    return data + TCPPutArray(hTCP, data, strlen((char*)data)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from ROM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................     
....................    This function is aliased to TCPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
.................... { 
....................    return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are pending in the TCP TX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    Number of bytes pending to be flushed in the TCP TX FIFO. 
....................   ***************************************************************************/ 
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
09EA6:  MOVLB  5
09EA8:  MOVF   xC3,W
09EAA:  SUBLW  00
09EAC:  BC    9EB6
....................     { 
....................         return 0; 
09EAE:  MOVLW  00
09EB0:  MOVWF  01
09EB2:  MOVWF  02
09EB4:  BRA    9F06
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
09EB6:  MOVFF  5C3,5F3
09EBA:  MOVLB  0
09EBC:  CALL   0A74
....................  
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1; 
09EC0:  MOVLB  1
09EC2:  MOVF   xE0,W
09EC4:  SUBWF  xE2,W
09EC6:  MOVLB  5
09EC8:  MOVWF  xC8
09ECA:  MOVLB  1
09ECC:  MOVF   xE1,W
09ECE:  SUBWFB xE3,W
09ED0:  MOVLB  5
09ED2:  MOVWF  xC9
09ED4:  MOVLW  01
09ED6:  SUBWF  xC8,W
09ED8:  MOVWF  xC6
09EDA:  MOVLW  00
09EDC:  SUBWFB xC9,W
09EDE:  MOVWF  xC7
....................  
....................    // Find out how many data bytes are free in the TX FIFO 
....................    wDataLen = TCPIsPutReady(hTCP); 
09EE0:  MOVFF  5C3,5F1
09EE4:  MOVLB  0
09EE6:  CALL   8AAC
09EEA:  MOVFF  02,5C5
09EEE:  MOVFF  01,5C4
....................  
....................    return wFIFOSize - wDataLen; 
09EF2:  MOVLB  5
09EF4:  MOVF   xC4,W
09EF6:  SUBWF  xC6,W
09EF8:  MOVWF  00
09EFA:  MOVF   xC5,W
09EFC:  SUBWFB xC7,W
09EFE:  MOVWF  03
09F00:  MOVFF  00,01
09F04:  MOVWF  02
09F06:  MOVLB  0
09F08:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDiscard(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Discards any pending data in the TCP RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose RX FIFO is to be cleared. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPDiscard(TCP_SOCKET hTCP) 
.................... { 
....................    if(TCPIsGetReady(hTCP)) 
*
080CA:  MOVFF  5C3,5C8
080CE:  CALL   6E2E
080D2:  MOVF   01,W
080D4:  IORWF  02,W
080D6:  BZ    80F8
....................    { 
....................       SyncTCBStub(hTCP); 
080D8:  MOVFF  5C3,5F3
080DC:  CALL   0A74
....................     
....................       // Delete all data in the RX buffer 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
080E0:  MOVFF  1EB,1ED
080E4:  MOVFF  1EA,1EC
....................     
....................       // Send a Window update message to the remote node 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
080E8:  MOVLW  10
080EA:  MOVLB  6
080EC:  MOVWF  x09
080EE:  MOVLW  01
080F0:  MOVWF  x0A
080F2:  MOVLB  0
080F4:  CALL   3598
....................    } 
080F8:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void WORD TCPIsGetReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the TCP RX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be read from the  
....................    TCP RX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to wait for 
....................    more data to arrive. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be read from the TCP RX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
06E2E:  MOVLB  5
06E30:  MOVF   xC8,W
06E32:  SUBLW  00
06E34:  BC    6E3E
....................     { 
....................         return 0; 
06E36:  MOVLW  00
06E38:  MOVWF  01
06E3A:  MOVWF  02
06E3C:  BRA    6EAA
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
06E3E:  MOVFF  5C8,5F3
06E42:  MOVLB  0
06E44:  CALL   0A74
....................        
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
06E48:  MOVLB  1
06E4A:  MOVF   xED,W
06E4C:  SUBWF  xEB,W
06E4E:  BNC   6E72
06E50:  BNZ   6E58
06E52:  MOVF   xEC,W
06E54:  SUBWF  xEA,W
06E56:  BNC   6E72
....................       return MyTCBStub.rxHead - MyTCBStub.rxTail; 
06E58:  MOVF   xEC,W
06E5A:  SUBWF  xEA,W
06E5C:  MOVWF  00
06E5E:  MOVF   xED,W
06E60:  SUBWFB xEB,W
06E62:  MOVWF  03
06E64:  MOVFF  00,01
06E68:  MOVWF  02
06E6A:  MOVLB  5
06E6C:  BRA    6EAA
06E6E:  BRA    6EAA
06E70:  MOVLB  1
....................    else 
....................       return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart); 
06E72:  MOVF   xEC,W
06E74:  SUBWF  xE4,W
06E76:  MOVLB  5
06E78:  MOVWF  xC9
06E7A:  MOVLB  1
06E7C:  MOVF   xED,W
06E7E:  SUBWFB xE5,W
06E80:  MOVLB  5
06E82:  MOVWF  xCA
06E84:  MOVLW  01
06E86:  ADDWF  xC9,F
06E88:  MOVLW  00
06E8A:  ADDWFC xCA,F
06E8C:  MOVLB  1
06E8E:  MOVF   xE2,W
06E90:  SUBWF  xEA,W
06E92:  MOVWF  00
06E94:  MOVF   xE3,W
06E96:  SUBWFB xEB,W
06E98:  MOVWF  03
06E9A:  MOVF   00,W
06E9C:  MOVLB  5
06E9E:  ADDWF  xC9,W
06EA0:  MOVWF  01
06EA2:  MOVF   xCA,W
06EA4:  ADDWFC 03,F
06EA6:  MOVFF  03,02
06EAA:  MOVLB  0
06EAC:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
....................  
....................   Description: 
....................    Retrieves a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which to read. 
....................    byte - Pointer to location in which the read byte should be stored. 
....................  
....................   Return Values: 
....................    TRUE - A byte was read from the buffer. 
....................    FALSE - The buffer was empty, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
.................... { 
....................    WORD wGetReadyCount; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
06EAE:  MOVFF  5C3,5C8
06EB2:  RCALL  6E2E
06EB4:  MOVFF  02,5C7
06EB8:  MOVFF  01,5C6
....................    if(wGetReadyCount == 0u) 
06EBC:  MOVLB  5
06EBE:  MOVF   xC6,F
06EC0:  BNZ   6ECC
06EC2:  MOVF   xC7,F
06EC4:  BNZ   6ECC
....................       return FALSE; 
06EC6:  MOVLW  00
06EC8:  MOVWF  01
06ECA:  BRA    6F5A
....................  
....................    SyncTCBStub(hTCP); 
06ECC:  MOVFF  5C3,5F3
06ED0:  MOVLB  0
06ED2:  CALL   0A74
....................     
....................    if(byte) 
06ED6:  MOVLB  5
06ED8:  MOVF   xC4,W
06EDA:  IORWF  xC5,W
06EDC:  BZ    6F04
....................       TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1); 
06EDE:  MOVFF  5C5,63B
06EE2:  MOVFF  5C4,63A
06EE6:  MOVLW  01
06EE8:  MOVLB  6
06EEA:  MOVWF  x3C
06EEC:  MOVFF  1ED,63E
06EF0:  MOVFF  1EC,63D
06EF4:  MOVFF  1FB,63F
06EF8:  CLRF   x41
06EFA:  MOVWF  x40
06EFC:  MOVLB  0
06EFE:  CALL   0F7E
06F02:  MOVLB  5
....................    if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
06F04:  MOVLB  1
06F06:  INCF   xEC,F
06F08:  BTFSC  FD8.2
06F0A:  INCF   xED,F
06F0C:  MOVF   xE5,W
06F0E:  SUBWF  xED,W
06F10:  BNC   6F22
06F12:  BNZ   6F1A
06F14:  MOVF   xEC,W
06F16:  SUBWF  xE4,W
06F18:  BC    6F22
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
06F1A:  MOVFF  1E3,1ED
06F1E:  MOVFF  1E2,1EC
....................  
....................    // Send a window update if we've run out of data 
....................    if(wGetReadyCount == 1u) 
06F22:  MOVLB  5
06F24:  DECFSZ xC6,W
06F26:  BRA    6F32
06F28:  MOVF   xC7,F
06F2A:  BNZ   6F32
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
06F2C:  MOVLB  1
06F2E:  BSF    xF8.2
....................    } 
06F30:  BRA    6F54
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
06F32:  MOVLB  1
06F34:  BTFSC  xF7.5
06F36:  BRA    6F54
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
06F38:  BSF    xF7.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
06F3A:  MOVLB  0
06F3C:  CALL   2F9C
06F40:  MOVLW  18
06F42:  MOVLB  5
06F44:  ADDWF  00,W
06F46:  MOVLB  1
06F48:  MOVWF  xF2
06F4A:  MOVLW  00
06F4C:  MOVLB  5
06F4E:  ADDWFC 01,W
06F50:  MOVLB  1
06F52:  MOVWF  xF3
....................    } 
....................  
....................  
....................    return TRUE; 
06F54:  MOVLW  01
06F56:  MOVWF  01
06F58:  MOVLB  5
06F5A:  MOVLB  0
06F5C:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
....................  
....................   Description: 
....................    Reads an array of data bytes from a TCP socket's receive FIFO.  The data  
....................    is removed from the FIFO in the process. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which data is to be read. 
....................    buffer - Pointer to the array to store data that was read. 
....................    len  - Number of bytes to be read. 
....................  
....................   Returns: 
....................    The number of bytes read from the socket.  If less than len, the 
....................    RX FIFO buffer became empty or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
.................... { 
....................    WORD wGetReadyCount; 
....................    WORD RightLen = 0; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
....................    if(wGetReadyCount == 0u) 
....................       return 0x0000u; 
....................  
....................    SyncTCBStub(hTCP); 
....................  
....................    // Make sure we don't try to read more data than is available 
....................    if(len > wGetReadyCount) 
....................       len = wGetReadyCount; 
....................  
....................    // See if we need a two part get 
....................    if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd) 
....................    { 
....................       RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1; 
....................       if(buffer) 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen); 
....................          buffer += RightLen; 
....................       } 
....................       len -= RightLen; 
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
....................    } 
....................  
....................    if(buffer) 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len); 
....................    MyTCBStub.rxTail += len; 
....................    len += RightLen; 
....................  
....................    // Send a window update if we've run low on data 
....................    if(wGetReadyCount - len <= len) 
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
....................    } 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are free in the RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes free in the TCP RX FIFO.  If zero, no additional  
....................    data can be received until the application removes some data using one 
....................    of the TCPGet family functions. 
....................   ***************************************************************************/ 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart; 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    { 
....................       PTR_BASE SSLtemp = MyTCBStub.rxHead; 
....................  
....................       // Move SSL pointer to determine full buffer size 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................  
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................        
....................       // Move SSL pointer back to proper location (if we changed it) 
....................       MyTCBStub.rxHead = SSLtemp; 
....................    } 
....................    #else 
....................    { 
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................    } 
....................    #endif 
....................     
....................    // Perform the calculation    
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
....................  
....................   Summary: 
....................      Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer. 
....................  
....................   Description: 
....................    Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer.  No TCP control actions are taken as a  
....................      result of this function (ex: no window update is sent to the remote node). 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    vBuffer - Destination to write the peeked data bytes. 
....................    wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer. 
....................    wStart - Zero-indexed starting position within the FIFO to start peeking  
....................       from. 
....................  
....................   Return Values: 
....................    Number of bytes actually peeked from the stream and copied to vBuffer.   
....................    This value can be less than wLen if wStart + wLen is greater than the  
....................    deepest possible character in the RX FIFO. 
....................  
....................   Remarks: 
....................      None 
....................   ***************************************************************************/ 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD w; 
....................    WORD wBytesUntilWrap; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and decrease read length  
....................    // if the start offset + read length is beyond the end of the FIFO 
....................    w = TCPIsGetReady(hTCP); 
....................    if(wStart + wLen > w) 
....................       wLen = w - wStart; 
....................  
....................    // Find the read start location 
....................    ptrRead = MyTCBStub.rxTail + wStart; 
....................    if(ptrRead > MyTCBStub.bufferEnd) 
....................       ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................  
....................    // Calculate how many bytes can be read in a single go 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1; 
....................    if(wLen <= wBytesUntilWrap) 
....................    { 
....................       // Read all at once 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen); 
....................    } 
....................    else 
....................    { 
....................       // Read all bytes up to the wrap position and then read remaining bytes  
....................       // at the start of the buffer 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap); 
....................       TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap); 
....................    } 
....................     
....................    return wLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
....................  
....................   Summary: 
....................      Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................  
....................   Description: 
....................    Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    wStart - Zero-indexed starting position within the FIFO to peek from. 
....................  
....................   Return Values: 
....................    Byte peeked from the RX FIFO.  If there is no data in the buffer or an  
....................    illegal wStart starting offset is given, then an indeterminate value is  
....................    returned.  The caller must ensure that valid parameters are passed to avoid  
....................    (i.e ensure that TCPIsGetReady() returns a number that is less than wStart  
....................    before calling TCPPeek()). 
....................  
....................   Remarks: 
....................      Use the TCPPeekArray() function to read more than one byte.  It will  
....................      perform better than calling TCPPeek() in a loop. 
....................   ***************************************************************************/ 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
.................... { 
....................    BYTE i; 
....................     
....................    TCPPeekArray(hTCP, &i, 1, wStart); 
....................    return i; 
.................... } 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Search Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a ROM string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................     
....................    This function is aliased to TCPFindArrayEx on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    ROM BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, 
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a byte in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of a byte in the TCP RX 
....................    buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the cFind 
....................    byte is ' ', a value of 1 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFind - The byte to find in the buffer. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare); 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPTick(void) 
....................  
....................   Summary: 
....................      Performs periodic TCP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic TCP tasks.  Each  
....................    socket's state machine is checked, and any elapsed timeout periods 
....................    are handled. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    BOOL bRetransmit; 
....................    BOOL bCloseSocket; 
....................    BYTE vFlags; 
....................    WORD w; 
....................  
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
03D0A:  MOVLB  5
03D0C:  CLRF   xBE
03D0E:  MOVF   xBE,F
03D10:  BTFSS  FD8.2
03D12:  BRA    43CC
....................    { 
....................       SyncTCBStub(hTCP); 
03D14:  MOVFF  5BE,5F3
03D18:  MOVLB  0
03D1A:  CALL   0A74
....................        
....................       // Handle any SSL Processing and Message Transmission 
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Handle any periodic tasks, such as RSA operations 
....................          SSLPeriodic(hTCP, MyTCBStub.sslStubID); 
....................           
....................          // If unsent data is waiting, transmit it as an application record 
....................          if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u) 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................           
....................          // If an SSL message is requested, send it now 
....................          if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE) 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage); 
....................       } 
....................       #endif 
....................        
....................       vFlags = 0x00; 
03D1E:  MOVLB  5
03D20:  CLRF   xC0
....................       bRetransmit = FALSE; 
03D22:  BCF    xBF.0
....................       bCloseSocket = FALSE; 
03D24:  BCF    xBF.1
....................  
....................       // Transmit ASAP data if the medium is available 
....................       if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset) 
03D26:  MOVLB  1
03D28:  BTFSC  xF8.1
03D2A:  BRA    3D30
03D2C:  BTFSS  xF8.2
03D2E:  BRA    3D4E
....................       { 
....................          if(MACIsTxReady()) 
03D30:  MOVLB  0
03D32:  CALL   17A4
03D36:  MOVF   01,F
03D38:  BZ    3D50
....................          { 
....................             vFlags = ACK; 
03D3A:  MOVLW  10
03D3C:  MOVLB  5
03D3E:  MOVWF  xC0
....................             bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset; 
03D40:  BCF    xBF.0
03D42:  MOVLB  1
03D44:  BTFSS  xF8.2
03D46:  BRA    3D4E
03D48:  MOVLB  5
03D4A:  BSF    xBF.0
03D4C:  MOVLB  1
03D4E:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // Perform any needed window updates and data transmissions 
....................       if(MyTCBStub.Flags.bTimer2Enabled) 
03D50:  MOVLB  1
03D52:  BTFSS  xF7.5
03D54:  BRA    3D86
....................       { 
....................          // See if the timeout has occured, and we need to send a new window update and pending data 
....................          if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0) 
03D56:  MOVLB  0
03D58:  CALL   2F9C
03D5C:  MOVF   00,W
03D5E:  MOVLB  1
03D60:  SUBWF  xF2,W
03D62:  MOVWF  00
03D64:  MOVF   01,W
03D66:  SUBWFB xF3,W
03D68:  MOVWF  03
03D6A:  MOVFF  00,5C3
03D6E:  MOVLB  5
03D70:  MOVWF  xC4
03D72:  BTFSC  FE8.7
03D74:  BRA    3D80
03D76:  MOVF   xC4,F
03D78:  BNZ   3D84
03D7A:  MOVF   xC3,W
03D7C:  SUBLW  00
03D7E:  BNC   3D84
....................             vFlags = ACK; 
03D80:  MOVLW  10
03D82:  MOVWF  xC0
03D84:  MOVLB  1
....................       } 
....................  
....................       // Process Delayed ACKnowledgement timer 
....................       if(MyTCBStub.Flags.bDelayedACKTimerEnabled) 
03D86:  BTFSS  xF7.6
03D88:  BRA    3DBA
....................       { 
....................          // See if the timeout has occured and delayed ACK needs to be sent 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
03D8A:  MOVLB  0
03D8C:  CALL   2F9C
03D90:  MOVF   00,W
03D92:  MOVLB  1
03D94:  SUBWF  xF4,W
03D96:  MOVWF  00
03D98:  MOVF   01,W
03D9A:  SUBWFB xF5,W
03D9C:  MOVWF  03
03D9E:  MOVFF  00,5C3
03DA2:  MOVLB  5
03DA4:  MOVWF  xC4
03DA6:  BTFSC  FE8.7
03DA8:  BRA    3DB4
03DAA:  MOVF   xC4,F
03DAC:  BNZ   3DB8
03DAE:  MOVF   xC3,W
03DB0:  SUBLW  00
03DB2:  BNC   3DB8
....................             vFlags = ACK; 
03DB4:  MOVLW  10
03DB6:  MOVWF  xC0
03DB8:  MOVLB  1
....................       } 
....................        
....................       // Process TCP_CLOSE_WAIT timer 
....................       if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
03DBA:  MOVF   xF6,W
03DBC:  SUBLW  0B
03DBE:  BNZ   3DF4
....................       { 
....................          // Automatically close the socket on our end if the application  
....................          // fails to call TCPDisconnect() is a reasonable amount of time. 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
03DC0:  MOVLB  0
03DC2:  CALL   2F9C
03DC6:  MOVF   00,W
03DC8:  MOVLB  1
03DCA:  SUBWF  xF4,W
03DCC:  MOVWF  00
03DCE:  MOVF   01,W
03DD0:  SUBWFB xF5,W
03DD2:  MOVWF  03
03DD4:  MOVFF  00,5C3
03DD8:  MOVLB  5
03DDA:  MOVWF  xC4
03DDC:  BTFSC  FE8.7
03DDE:  BRA    3DEA
03DE0:  MOVF   xC4,F
03DE2:  BNZ   3DF6
03DE4:  MOVF   xC3,W
03DE6:  SUBLW  00
03DE8:  BNC   3DF6
....................          { 
....................             vFlags = FIN | ACK; 
03DEA:  MOVLW  11
03DEC:  MOVWF  xC0
....................             MyTCBStub.smState = TCP_LAST_ACK; 
03DEE:  MOVLW  0C
03DF0:  MOVLB  1
03DF2:  MOVWF  xF6
03DF4:  MOVLB  5
....................          } 
....................       } 
....................  
....................       // Process listening server sockets that might have a SYN waiting in the SYNQueue[] 
....................       #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................          if(MyTCBStub.smState == TCP_LISTEN) 
03DF6:  MOVLB  1
03DF8:  MOVF   xF6,W
03DFA:  SUBLW  04
03DFC:  BTFSS  FD8.2
03DFE:  BRA    40B2
....................          { 
....................             for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
03E00:  MOVLB  5
03E02:  CLRF   xC2
03E04:  CLRF   xC1
03E06:  MOVF   xC2,F
03E08:  BTFSS  FD8.2
03E0A:  BRA    40B0
03E0C:  MOVF   xC1,W
03E0E:  SUBLW  02
03E10:  BTFSS  FD8.0
03E12:  BRA    40B0
....................             { 
....................                // Abort search if there are no more valid records 
....................                if(SYNQueue[w].wDestPort == 0u) 
03E14:  MOVFF  5C2,5F4
03E18:  MOVFF  5C1,5F3
03E1C:  CLRF   xF6
03E1E:  MOVLW  14
03E20:  MOVWF  xF5
03E22:  MOVLB  0
03E24:  CALL   2FC2
03E28:  MOVFF  01,5C3
03E2C:  MOVLW  10
03E2E:  MOVLB  5
03E30:  ADDWF  01,W
03E32:  MOVWF  01
03E34:  MOVLW  00
03E36:  ADDWFC 02,W
03E38:  MOVWF  03
03E3A:  MOVF   01,W
03E3C:  ADDLW  A4
03E3E:  MOVWF  FE9
03E40:  MOVLW  01
03E42:  ADDWFC 03,W
03E44:  MOVWF  FEA
03E46:  MOVFF  FEC,5C4
03E4A:  MOVF   FED,F
03E4C:  MOVFF  FEF,5C3
03E50:  MOVF   xC3,F
03E52:  BNZ   3E5A
03E54:  MOVF   xC4,F
03E56:  BNZ   3E5A
....................                   break; 
03E58:  BRA    40B0
....................                 
....................                // Stop searching if this SYN queue entry can be used by this socket 
....................                #if defined(STACK_USE_SSL_SERVER) 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead) 
....................                #else 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val) 
03E5A:  MOVFF  5C2,5F4
03E5E:  MOVFF  5C1,5F3
03E62:  CLRF   xF6
03E64:  MOVLW  14
03E66:  MOVWF  xF5
03E68:  MOVLB  0
03E6A:  CALL   2FC2
03E6E:  MOVFF  01,5C3
03E72:  MOVLW  10
03E74:  MOVLB  5
03E76:  ADDWF  01,W
03E78:  MOVWF  01
03E7A:  MOVLW  00
03E7C:  ADDWFC 02,W
03E7E:  MOVWF  03
03E80:  MOVF   01,W
03E82:  ADDLW  A4
03E84:  MOVWF  FE9
03E86:  MOVLW  01
03E88:  ADDWFC 03,W
03E8A:  MOVWF  FEA
03E8C:  MOVFF  FEC,5C4
03E90:  MOVF   FED,F
03E92:  MOVFF  FEF,5C3
03E96:  MOVLB  1
03E98:  MOVF   xF9,W
03E9A:  MOVLB  5
03E9C:  SUBWF  xC3,W
03E9E:  BTFSS  FD8.2
03EA0:  BRA    40A8
03EA2:  MOVLB  1
03EA4:  MOVF   xFA,W
03EA6:  MOVLB  5
03EA8:  SUBWF  xC4,W
03EAA:  BTFSS  FD8.2
03EAC:  BRA    40A8
....................                #endif 
....................                { 
....................                   // Set up our socket and generate a reponse SYN+ACK packet 
....................                   SyncTCB(); 
03EAE:  MOVLB  0
03EB0:  CALL   1064
....................                    
....................                   #if defined(STACK_USE_SSL_SERVER) 
....................                   // If this matches the SSL port, make sure that can be configured 
....................                   // before continuing.  If not, break and leave this in the queue 
....................                   if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP)) 
....................                      break; 
....................                   #endif 
....................                    
....................                   memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO)); 
03EB4:  MOVLW  01
03EB6:  MOVLB  5
03EB8:  MOVWF  xC4
03EBA:  MOVLW  92
03EBC:  MOVWF  xC3
03EBE:  MOVFF  5C2,5F4
03EC2:  MOVFF  5C1,5F3
03EC6:  CLRF   xF6
03EC8:  MOVLW  14
03ECA:  MOVWF  xF5
03ECC:  MOVLB  0
03ECE:  CALL   2FC2
03ED2:  MOVFF  02,5C6
03ED6:  MOVFF  01,5C5
03EDA:  MOVLW  A4
03EDC:  MOVLB  5
03EDE:  ADDWF  01,W
03EE0:  MOVWF  01
03EE2:  MOVLW  01
03EE4:  ADDWFC 02,W
03EE6:  MOVWF  03
03EE8:  MOVFF  01,5C7
03EEC:  MOVWF  xC8
03EEE:  MOVFF  5C4,FEA
03EF2:  MOVFF  5C3,FE9
03EF6:  MOVWF  FE2
03EF8:  MOVFF  01,FE1
03EFC:  MOVLW  0A
03EFE:  MOVWF  01
03F00:  MOVFF  FE6,FEE
03F04:  DECFSZ 01,F
03F06:  BRA    3F00
....................                   MyTCB.remotePort.Val = SYNQueue[w].wSourcePort; 
03F08:  MOVFF  5C2,5F4
03F0C:  MOVFF  5C1,5F3
03F10:  CLRF   xF6
03F12:  MOVLW  14
03F14:  MOVWF  xF5
03F16:  MOVLB  0
03F18:  CALL   2FC2
03F1C:  MOVFF  01,5C3
03F20:  MOVLW  0A
03F22:  MOVLB  5
03F24:  ADDWF  01,W
03F26:  MOVWF  01
03F28:  MOVLW  00
03F2A:  ADDWFC 02,W
03F2C:  MOVWF  03
03F2E:  MOVF   01,W
03F30:  ADDLW  A4
03F32:  MOVWF  FE9
03F34:  MOVLW  01
03F36:  ADDWFC 03,W
03F38:  MOVWF  FEA
03F3A:  MOVFF  FEC,18B
03F3E:  MOVF   FED,F
03F40:  MOVFF  FEF,18A
....................                   MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1; 
03F44:  MOVFF  5C2,5F4
03F48:  MOVFF  5C1,5F3
03F4C:  CLRF   xF6
03F4E:  MOVLW  14
03F50:  MOVWF  xF5
03F52:  MOVLB  0
03F54:  CALL   2FC2
03F58:  MOVFF  01,5C3
03F5C:  MOVLW  0C
03F5E:  MOVLB  5
03F60:  ADDWF  01,W
03F62:  MOVWF  01
03F64:  MOVLW  00
03F66:  ADDWFC 02,W
03F68:  MOVWF  03
03F6A:  MOVF   01,W
03F6C:  ADDLW  A4
03F6E:  MOVWF  FE9
03F70:  MOVLW  01
03F72:  ADDWFC 03,W
03F74:  MOVWF  FEA
03F76:  MOVFF  FEF,5C3
03F7A:  MOVFF  FEC,5C4
03F7E:  MOVFF  FEC,5C5
03F82:  MOVFF  FEC,5C6
03F86:  MOVLW  01
03F88:  ADDWF  xC3,W
03F8A:  MOVLB  1
03F8C:  MOVWF  x84
03F8E:  MOVLW  00
03F90:  MOVLB  5
03F92:  ADDWFC xC4,W
03F94:  MOVLB  1
03F96:  MOVWF  x85
03F98:  MOVLW  00
03F9A:  MOVLB  5
03F9C:  ADDWFC xC5,W
03F9E:  MOVLB  1
03FA0:  MOVWF  x86
03FA2:  MOVLW  00
03FA4:  MOVLB  5
03FA6:  ADDWFC xC6,W
03FA8:  MOVLB  1
03FAA:  MOVWF  x87
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
03FAC:  MOVF   x92,W
03FAE:  ADDWF  x94,W
03FB0:  MOVLB  5
03FB2:  MOVWF  xC3
03FB4:  MOVLB  1
03FB6:  MOVF   x93,W
03FB8:  ADDWFC x95,W
03FBA:  MOVLB  5
03FBC:  MOVWF  xC4
03FBE:  MOVLB  1
03FC0:  MOVF   x8A,W
03FC2:  MOVLB  5
03FC4:  ADDWF  xC3,F
03FC6:  MOVLB  1
03FC8:  MOVF   x8B,W
03FCA:  MOVLB  5
03FCC:  ADDWFC xC4,F
03FCE:  MOVF   xC3,W
03FD0:  MOVLB  1
03FD2:  XORWF  x8C,W
03FD4:  MOVWF  xF9
03FD6:  MOVLB  5
03FD8:  MOVF   xC4,W
03FDA:  MOVLB  1
03FDC:  XORWF  x8D,W
03FDE:  MOVWF  xFA
....................                   vFlags = SYN | ACK; 
03FE0:  MOVLW  12
03FE2:  MOVLB  5
03FE4:  MOVWF  xC0
....................                   MyTCBStub.smState = TCP_SYN_RECEIVED; 
03FE6:  MOVLW  06
03FE8:  MOVLB  1
03FEA:  MOVWF  xF6
....................                    
....................                   // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................                   TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
03FEC:  MOVFF  5C2,5F4
03FF0:  MOVFF  5C1,5F3
03FF4:  MOVLB  5
03FF6:  CLRF   xF6
03FF8:  MOVLW  14
03FFA:  MOVWF  xF5
03FFC:  MOVLB  0
03FFE:  CALL   2FC2
04002:  MOVFF  02,03
04006:  MOVF   01,W
04008:  ADDLW  A4
0400A:  MOVWF  01
0400C:  MOVLW  01
0400E:  ADDWFC 03,F
04010:  MOVFF  01,5C3
04014:  MOVLB  5
04016:  MOVFF  03,5C4
0401A:  MOVLW  01
0401C:  ADDWF  xC1,W
0401E:  MOVWF  xC5
04020:  MOVLW  00
04022:  ADDWFC xC2,W
04024:  MOVWF  xC6
04026:  MOVWF  xF4
04028:  MOVFF  5C5,5F3
0402C:  CLRF   xF6
0402E:  MOVLW  14
04030:  MOVWF  xF5
04032:  MOVLB  0
04034:  CALL   2FC2
04038:  MOVFF  02,03
0403C:  MOVF   01,W
0403E:  ADDLW  A4
04040:  MOVWF  01
04042:  MOVLW  01
04044:  ADDWFC 03,F
04046:  MOVFF  01,5C5
0404A:  MOVLB  5
0404C:  MOVFF  03,5C6
04050:  MOVLW  02
04052:  BSF    FD8.0
04054:  SUBFWB xC1,W
04056:  MOVWF  xC7
04058:  MOVLW  00
0405A:  SUBFWB xC2,W
0405C:  MOVWF  xC8
0405E:  MOVWF  xF4
04060:  MOVFF  5C7,5F3
04064:  CLRF   xF6
04066:  MOVLW  14
04068:  MOVWF  xF5
0406A:  MOVLB  0
0406C:  CALL   2FC2
04070:  MOVFF  02,5C8
04074:  MOVFF  01,5C7
04078:  MOVFF  5C4,63B
0407C:  MOVFF  5C3,63A
04080:  MOVLW  01
04082:  MOVLB  6
04084:  MOVWF  x3C
04086:  MOVFF  5C6,63E
0408A:  MOVFF  5C5,63D
0408E:  MOVWF  x3F
04090:  MOVFF  02,641
04094:  MOVFF  01,640
04098:  MOVLB  0
0409A:  CALL   0F7E
....................                   SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
0409E:  MOVLB  1
040A0:  CLRF   xDD
040A2:  CLRF   xDC
....................     
....................                   break; 
040A4:  MOVLB  5
040A6:  BRA    40B0
....................                } 
040A8:  INCF   xC1,F
040AA:  BTFSC  FD8.2
040AC:  INCF   xC2,F
040AE:  BRA    3E06
040B0:  MOVLB  1
....................             } 
....................          } 
....................       #endif 
....................  
....................       if(vFlags) 
040B2:  MOVLB  5
040B4:  MOVF   xC0,F
040B6:  BZ    40D4
....................          SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS); 
040B8:  BTFSS  xBF.0
040BA:  BRA    40C0
040BC:  MOVLW  00
040BE:  BRA    40C2
040C0:  MOVLW  01
040C2:  MOVWF  xC3
040C4:  MOVFF  5C0,609
040C8:  MOVFF  FE8,60A
040CC:  MOVLB  0
040CE:  CALL   3598
040D2:  MOVLB  5
....................  
....................       // The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED  
....................       // state don't need any timeout events, so see if the timer is enabled 
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
040D4:  MOVLB  1
040D6:  BTFSC  xF7.4
040D8:  BRA    41B4
....................       { 
....................          #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................             // Only the established state has any use for keep-alives 
....................             if(MyTCBStub.smState == TCP_ESTABLISHED) 
040DA:  MOVF   xF6,W
040DC:  SUBLW  07
040DE:  BNZ   41AE
....................             { 
....................                // If timeout has not occured, do not do anything. 
....................                if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
040E0:  MOVLB  0
040E2:  CALL   23FC
040E6:  MOVFF  03,5C6
040EA:  MOVFF  02,5C5
040EE:  MOVFF  01,5C4
040F2:  MOVFF  00,5C3
040F6:  MOVLB  1
040F8:  MOVF   xEE,W
040FA:  MOVLB  5
040FC:  SUBWF  00,W
040FE:  MOVWF  00
04100:  MOVLB  1
04102:  MOVF   xEF,W
04104:  MOVLB  5
04106:  SUBWFB 01,W
04108:  MOVWF  01
0410A:  MOVLB  1
0410C:  MOVF   xF0,W
0410E:  MOVLB  5
04110:  SUBWFB 02,W
04112:  MOVWF  02
04114:  MOVLB  1
04116:  MOVF   xF1,W
04118:  MOVLB  5
0411A:  SUBWFB 03,W
0411C:  MOVWF  03
0411E:  MOVWF  xC6
04120:  MOVFF  02,5C5
04124:  MOVFF  01,5C4
04128:  MOVFF  00,5C3
0412C:  BTFSS  FE8.7
0412E:  BRA    4132
....................                   continue; 
04130:  BRA    43C8
....................        
....................                // If timeout has occured and the connection appears to be dead (no  
....................                // responses from remote node at all), close the connection so the  
....................                // application doesn't sit around indefinitely with a useless socket  
....................                // that it thinks is still open 
....................                if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES) 
04132:  MOVLB  1
04134:  MOVF   xF7,W
04136:  ANDLW  07
04138:  SUBLW  06
0413A:  BNZ   416C
....................                { 
....................                   vFlags = MyTCBStub.Flags.bServer; 
0413C:  MOVLB  5
0413E:  CLRF   xC0
04140:  MOVLB  1
04142:  BTFSS  xF7.3
04144:  BRA    414C
04146:  MOVLB  5
04148:  INCF   xC0,F
0414A:  MOVLB  1
....................  
....................                   // Force an immediate FIN and RST transmission 
....................                   // Double calling TCPDisconnect() will also place us  
....................                   // back in the listening state immediately if a server socket. 
....................                   TCPDisconnect(hTCP); 
0414C:  MOVFF  5BE,5C3
04150:  MOVLB  0
04152:  RCALL  3C20
....................                   TCPDisconnect(hTCP); 
04154:  MOVFF  5BE,5C3
04158:  RCALL  3C20
....................                    
....................                   // Prevent client mode sockets from getting reused by other applications.   
....................                   // The application must call TCPDisconnect() with the handle to free this  
....................                   // socket (and the handle associated with it) 
....................                   if(!vFlags) 
0415A:  MOVLB  5
0415C:  MOVF   xC0,F
0415E:  BNZ   4168
....................                      MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED; 
04160:  MOVLW  0E
04162:  MOVLB  1
04164:  MOVWF  xF6
04166:  MOVLB  5
....................                    
....................                   continue; 
04168:  BRA    43C8
0416A:  MOVLB  1
....................                } 
....................                 
....................                // Otherwise, if a timeout occured, simply send a keep-alive packet 
....................                SyncTCB(); 
0416C:  MOVLB  0
0416E:  CALL   1064
....................                SendTCP(ACK, SENDTCP_KEEP_ALIVE); 
04172:  MOVLW  10
04174:  MOVLB  6
04176:  MOVWF  x09
04178:  MOVLW  02
0417A:  MOVWF  x0A
0417C:  MOVLB  0
0417E:  CALL   3598
....................                MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
04182:  CALL   23FC
04186:  MOVLW  B4
04188:  MOVLB  5
0418A:  ADDWF  00,W
0418C:  MOVLB  1
0418E:  MOVWF  xEE
04190:  MOVLW  C4
04192:  MOVLB  5
04194:  ADDWFC 01,W
04196:  MOVLB  1
04198:  MOVWF  xEF
0419A:  MOVLW  04
0419C:  MOVLB  5
0419E:  ADDWFC 02,W
041A0:  MOVLB  1
041A2:  MOVWF  xF0
041A4:  MOVLW  00
041A6:  MOVLB  5
041A8:  ADDWFC 03,W
041AA:  MOVLB  1
041AC:  MOVWF  xF1
....................             } 
....................          #endif 
....................          continue; 
041AE:  MOVLB  5
041B0:  BRA    43C8
041B2:  MOVLB  1
....................       } 
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
041B4:  MOVLB  0
041B6:  CALL   23FC
041BA:  MOVFF  03,5C6
041BE:  MOVFF  02,5C5
041C2:  MOVFF  01,5C4
041C6:  MOVFF  00,5C3
041CA:  MOVLB  1
041CC:  MOVF   xEE,W
041CE:  MOVLB  5
041D0:  SUBWF  00,W
041D2:  MOVWF  00
041D4:  MOVLB  1
041D6:  MOVF   xEF,W
041D8:  MOVLB  5
041DA:  SUBWFB 01,W
041DC:  MOVWF  01
041DE:  MOVLB  1
041E0:  MOVF   xF0,W
041E2:  MOVLB  5
041E4:  SUBWFB 02,W
041E6:  MOVWF  02
041E8:  MOVLB  1
041EA:  MOVF   xF1,W
041EC:  MOVLB  5
041EE:  SUBWFB 03,W
041F0:  MOVWF  03
041F2:  MOVWF  xC6
041F4:  MOVFF  02,5C5
041F8:  MOVFF  01,5C4
041FC:  MOVFF  00,5C3
04200:  BTFSS  FE8.7
04202:  BRA    4206
....................          continue; 
04204:  BRA    43C8
....................  
....................       // Load up extended TCB information 
....................       SyncTCB(); 
04206:  MOVLB  0
04208:  CALL   1064
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(MyTCBStub.smState) 
0420C:  MOVLB  1
0420E:  MOVF   xF6,W
04210:  XORLW  05
04212:  MOVLB  0
04214:  BZ    4234
04216:  XORLW  03
04218:  BZ    4258
0421A:  XORLW  01
0421C:  BZ    4286
0421E:  XORLW  0C
04220:  BZ    4286
04222:  XORLW  03
04224:  BZ    42A8
04226:  XORLW  01
04228:  BZ    42C8
0422A:  XORLW  03
0422C:  BZ    42D4
0422E:  XORLW  06
04230:  BZ    42F4
04232:  BRA    4316
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case TCP_GET_DNS_MODULE: 
....................             if(DNSBeginUsage()) 
....................             { 
....................                MyTCBStub.smState = TCP_DNS_RESOLVE; 
....................                if(MyTCB.flags.bRemoteHostIsROM) 
....................                   DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................                else 
....................                   DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................             } 
....................             break; 
....................              
....................          case TCP_DNS_RESOLVE: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................  
....................             // See if DNS resolution has finished.  Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
....................             { 
....................                if(DNSEndUsage()) 
....................                { 
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val; 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
....................                   MyTCB.retryCount = 0; 
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
....................                } 
....................                else 
....................                { 
....................                   MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND; 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                } 
....................             } 
....................             break; 
....................          } 
....................          #endif // #if defined(STACK_USE_DNS) 
....................              
....................          case TCP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             MyTCBStub.eventTime2 = (WORD)TickGetDiv256(); 
....................             ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr); 
....................             MyTCBStub.smState = TCP_GATEWAY_GET_ARP; 
....................             break; 
....................  
....................          case TCP_GATEWAY_GET_ARP: 
....................             // Wait for the MAC address to finish being obtained 
....................             if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr)) 
....................             { 
....................                // Time out if too much time is spent in this state 
....................                // Note that this will continuously send out ARP  
....................                // requests for an infinite time if the Gateway  
....................                // never responds 
....................                if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval) 
....................                { 
....................                   // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                   if(MyTCB.retryCount < 6u) 
....................                   { 
....................                      MyTCB.retryCount++; 
....................                      MyTCB.retryInterval <<= 1; 
....................                   } 
....................  
....................                   // Retransmit ARP request 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                } 
....................                break; 
....................             } 
....................              
....................             // Send out SYN connection request to remote node 
....................             // This automatically disables the Timer from  
....................             // continuously firing for this socket 
....................             vFlags = SYN; 
....................             bRetransmit = FALSE; 
....................             MyTCBStub.smState = TCP_SYN_SENT; 
....................             break; 
....................          #endif // #if defined(STACK_CLIENT_MODE) 
....................           
....................          case TCP_SYN_SENT: 
....................             // Keep sending SYN until we hear from remote node. 
....................             // This may be for infinite time, in that case 
....................             // caller must detect it and do something. 
....................             vFlags = SYN; 
04234:  MOVLW  02
04236:  MOVLB  5
04238:  MOVWF  xC0
....................             bRetransmit = TRUE; 
0423A:  BSF    xBF.0
....................  
....................             // Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant 
....................             if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1)) 
0423C:  MOVLB  1
0423E:  MOVF   xA1,W
04240:  SUBLW  03
04242:  BC    4256
....................             { 
....................                MyTCB.retryCount = TCP_MAX_RETRIES - 1; 
04244:  MOVLW  04
04246:  MOVWF  xA1
....................                MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1); 
04248:  CLRF   x7F
0424A:  MOVLW  07
0424C:  MOVWF  x7E
0424E:  MOVLW  A1
04250:  MOVWF  x7D
04252:  MOVLW  20
04254:  MOVWF  x7C
....................             } 
....................             break; 
04256:  BRA    4318
....................     
....................          case TCP_SYN_RECEIVED: 
....................             // We must receive ACK before timeout expires. 
....................             // If not, resend SYN+ACK. 
....................             // Abort, if maximum attempts counts are reached. 
....................             if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES) 
04258:  MOVLB  1
0425A:  MOVF   xA1,W
0425C:  SUBLW  01
0425E:  BNC   426C
....................             { 
....................                vFlags = SYN | ACK; 
04260:  MOVLW  12
04262:  MOVLB  5
04264:  MOVWF  xC0
....................                bRetransmit = TRUE; 
04266:  BSF    xBF.0
....................             } 
04268:  BRA    4282
0426A:  MOVLB  1
....................             else 
....................             { 
....................                if(MyTCBStub.Flags.bServer) 
0426C:  BTFSS  xF7.3
0426E:  BRA    427C
....................                { 
....................                   vFlags = RST | ACK; 
04270:  MOVLW  14
04272:  MOVLB  5
04274:  MOVWF  xC0
....................                   bCloseSocket = TRUE; 
04276:  BSF    xBF.1
....................                } 
04278:  BRA    4282
0427A:  MOVLB  1
....................                else 
....................                { 
....................                   vFlags = SYN; 
0427C:  MOVLW  02
0427E:  MOVLB  5
04280:  MOVWF  xC0
....................                } 
....................             } 
....................             break; 
04282:  MOVLB  1
04284:  BRA    4318
....................     
....................          case TCP_ESTABLISHED: 
....................          case TCP_CLOSE_WAIT: 
....................             // Retransmit any unacknowledged data 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
04286:  MOVLB  1
04288:  MOVF   xA1,W
0428A:  SUBLW  04
0428C:  BNC   429A
....................             { 
....................                vFlags = ACK; 
0428E:  MOVLW  10
04290:  MOVLB  5
04292:  MOVWF  xC0
....................                bRetransmit = TRUE; 
04294:  BSF    xBF.0
....................             } 
04296:  BRA    42A4
04298:  MOVLB  1
....................             else 
....................             { 
....................                // No response back for too long, close connection 
....................                // This could happen, for instance, if the communication  
....................                // medium was lost 
....................                MyTCBStub.smState = TCP_FIN_WAIT_1; 
0429A:  MOVLW  08
0429C:  MOVWF  xF6
....................                vFlags = FIN | ACK; 
0429E:  MOVLW  11
042A0:  MOVLB  5
042A2:  MOVWF  xC0
....................             } 
....................             break; 
042A4:  MOVLB  1
042A6:  BRA    4318
....................     
....................          case TCP_FIN_WAIT_1: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
042A8:  MOVLB  1
042AA:  MOVF   xA1,W
042AC:  SUBLW  04
042AE:  BNC   42BC
....................             { 
....................                // Send another FIN 
....................                vFlags = FIN | ACK; 
042B0:  MOVLW  11
042B2:  MOVLB  5
042B4:  MOVWF  xC0
....................                bRetransmit = TRUE; 
042B6:  BSF    xBF.0
....................             } 
042B8:  BRA    42C4
042BA:  MOVLB  1
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
042BC:  MOVLW  14
042BE:  MOVLB  5
042C0:  MOVWF  xC0
....................                bCloseSocket = TRUE; 
042C2:  BSF    xBF.1
....................             } 
....................             break; 
042C4:  MOVLB  1
042C6:  BRA    4318
....................     
....................          case TCP_FIN_WAIT_2: 
....................             // Close on our own, we can't seem to communicate  
....................             // with the remote node anymore 
....................             vFlags = RST | ACK; 
042C8:  MOVLW  14
042CA:  MOVLB  5
042CC:  MOVWF  xC0
....................             bCloseSocket = TRUE; 
042CE:  BSF    xBF.1
....................             break; 
042D0:  MOVLB  1
042D2:  BRA    4318
....................  
....................          case TCP_CLOSING: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
042D4:  MOVLB  1
042D6:  MOVF   xA1,W
042D8:  SUBLW  04
042DA:  BNC   42E8
....................             { 
....................                // Send another ACK+FIN (the FIN is retransmitted  
....................                // automatically since it hasn't been acknowledged by  
....................                // the remote node yet) 
....................                vFlags = ACK; 
042DC:  MOVLW  10
042DE:  MOVLB  5
042E0:  MOVWF  xC0
....................                bRetransmit = TRUE; 
042E2:  BSF    xBF.0
....................             } 
042E4:  BRA    42F0
042E6:  MOVLB  1
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
042E8:  MOVLW  14
042EA:  MOVLB  5
042EC:  MOVWF  xC0
....................                bCloseSocket = TRUE; 
042EE:  BSF    xBF.1
....................             } 
....................             break; 
042F0:  MOVLB  1
042F2:  BRA    4318
....................     
.................... //         case TCP_TIME_WAIT: 
.................... //            // Wait around for a while (2MSL) and then goto closed state 
.................... //            bCloseSocket = TRUE; 
.................... //            break; 
.................... //          
....................  
....................          case TCP_LAST_ACK: 
....................             // Send some more FINs or close anyway 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
042F4:  MOVLB  1
042F6:  MOVF   xA1,W
042F8:  SUBLW  04
042FA:  BNC   4308
....................             { 
....................                vFlags = FIN | ACK; 
042FC:  MOVLW  11
042FE:  MOVLB  5
04300:  MOVWF  xC0
....................                bRetransmit = TRUE; 
04302:  BSF    xBF.0
....................             } 
04304:  BRA    4310
04306:  MOVLB  1
....................             else 
....................             { 
....................                vFlags = RST | ACK; 
04308:  MOVLW  14
0430A:  MOVLB  5
0430C:  MOVWF  xC0
....................                bCloseSocket = TRUE; 
0430E:  BSF    xBF.1
....................             } 
....................             break; 
04310:  MOVLB  1
04312:  BRA    4318
04314:  MOVLB  0
....................           
....................          default: 
....................             break; 
04316:  MOVLB  1
....................       } 
....................  
....................       if(vFlags) 
04318:  MOVLB  5
0431A:  MOVF   xC0,F
0431C:  BZ    43BC
....................       { 
....................          // Transmit all unacknowledged data over again 
....................          if(bRetransmit) 
0431E:  BTFSS  xBF.0
04320:  BRA    43AA
....................          { 
....................             // Set the appropriate retry time 
....................             MyTCB.retryCount++; 
04322:  MOVLB  1
04324:  INCF   xA1,F
....................             MyTCB.retryInterval <<= 1; 
04326:  BCF    FD8.0
04328:  RLCF   x7C,F
0432A:  RLCF   x7D,F
0432C:  RLCF   x7E,F
0432E:  RLCF   x7F,F
....................        
....................             // Calculate how many bytes we have to roll back and retransmit 
....................             w = MyTCB.txUnackedTail - MyTCBStub.txTail; 
04330:  MOVF   xE8,W
04332:  SUBWF  x88,W
04334:  MOVLB  5
04336:  MOVWF  xC1
04338:  MOVLB  1
0433A:  MOVF   xE9,W
0433C:  SUBWFB x89,W
0433E:  MOVLB  5
04340:  MOVWF  xC2
....................             if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
04342:  MOVLB  1
04344:  MOVF   x89,W
04346:  SUBWF  xE9,W
04348:  BNC   436A
0434A:  BNZ   4352
0434C:  MOVF   xE8,W
0434E:  SUBWF  x88,W
04350:  BC    436A
....................                w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
04352:  MOVF   xE0,W
04354:  SUBWF  xE2,W
04356:  MOVWF  00
04358:  MOVF   xE1,W
0435A:  SUBWFB xE3,W
0435C:  MOVWF  03
0435E:  MOVF   00,W
04360:  MOVLB  5
04362:  ADDWF  xC1,F
04364:  MOVF   03,W
04366:  ADDWFC xC2,F
04368:  MOVLB  1
....................              
....................             // Perform roll back of local SEQuence counter, remote window  
....................             // adjustment, and cause all unacknowledged data to be  
....................             // retransmitted by moving the unacked tail pointer. 
....................             MyTCB.MySEQ -= w; 
0436A:  MOVLB  5
0436C:  MOVF   xC1,W
0436E:  MOVLB  1
04370:  SUBWF  x80,F
04372:  MOVLB  5
04374:  MOVF   xC2,W
04376:  MOVLB  1
04378:  SUBWFB x81,F
0437A:  MOVLW  00
0437C:  SUBWFB x82,F
0437E:  SUBWFB x83,F
....................             MyTCB.remoteWindow += w; 
04380:  MOVLB  5
04382:  MOVF   xC1,W
04384:  MOVLB  1
04386:  ADDWF  x8E,F
04388:  MOVLB  5
0438A:  MOVF   xC2,W
0438C:  MOVLB  1
0438E:  ADDWFC x8F,F
....................             MyTCB.txUnackedTail = MyTCBStub.txTail;       
04390:  MOVFF  1E9,189
04394:  MOVFF  1E8,188
....................             SendTCP(vFlags, 0); 
04398:  MOVFF  5C0,609
0439C:  MOVLB  6
0439E:  CLRF   x0A
043A0:  MOVLB  0
043A2:  CALL   3598
....................          } 
043A6:  BRA    43BA
043A8:  MOVLB  5
....................          else 
....................             SendTCP(vFlags, SENDTCP_RESET_TIMERS); 
043AA:  MOVFF  5C0,609
043AE:  MOVLW  01
043B0:  MOVLB  6
043B2:  MOVWF  x0A
043B4:  MOVLB  0
043B6:  CALL   3598
043BA:  MOVLB  5
....................  
....................       } 
....................        
....................       if(bCloseSocket) 
043BC:  BTFSS  xBF.1
043BE:  BRA    43C8
....................          CloseSocket(); 
043C0:  MOVLB  0
043C2:  CALL   1138
043C6:  MOVLB  5
....................    } 
....................     
....................     
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
043C8:  INCF   xBE,F
043CA:  BRA    3D0E
....................       // Process SYN Queue entry timeouts 
....................       for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
043CC:  CLRF   xC2
043CE:  CLRF   xC1
043D0:  MOVF   xC2,F
043D2:  BTFSS  FD8.2
043D4:  BRA    4550
043D6:  MOVF   xC1,W
043D8:  SUBLW  02
043DA:  BTFSS  FD8.0
043DC:  BRA    4550
....................       { 
....................          // Abort search if there are no more valid records 
....................          if(SYNQueue[w].wDestPort == 0u) 
043DE:  MOVFF  5C2,5F4
043E2:  MOVFF  5C1,5F3
043E6:  CLRF   xF6
043E8:  MOVLW  14
043EA:  MOVWF  xF5
043EC:  MOVLB  0
043EE:  CALL   2FC2
043F2:  MOVFF  01,5C3
043F6:  MOVLW  10
043F8:  MOVLB  5
043FA:  ADDWF  01,W
043FC:  MOVWF  01
043FE:  MOVLW  00
04400:  ADDWFC 02,W
04402:  MOVWF  03
04404:  MOVF   01,W
04406:  ADDLW  A4
04408:  MOVWF  FE9
0440A:  MOVLW  01
0440C:  ADDWFC 03,W
0440E:  MOVWF  FEA
04410:  MOVFF  FEC,5C4
04414:  MOVF   FED,F
04416:  MOVFF  FEF,5C3
0441A:  MOVF   xC3,F
0441C:  BNZ   4424
0441E:  MOVF   xC4,F
04420:  BNZ   4424
....................             break; 
04422:  BRA    4550
....................           
....................          // See if this SYN has timed out 
....................          if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull)) 
04424:  MOVLB  0
04426:  CALL   2F9C
0442A:  MOVFF  01,5C4
0442E:  MOVFF  00,5C3
04432:  MOVFF  5C2,5F4
04436:  MOVFF  5C1,5F3
0443A:  MOVLB  5
0443C:  CLRF   xF6
0443E:  MOVLW  14
04440:  MOVWF  xF5
04442:  MOVLB  0
04444:  CALL   2FC2
04448:  MOVFF  02,5C6
0444C:  MOVFF  01,5C5
04450:  MOVLW  12
04452:  MOVLB  5
04454:  ADDWF  01,W
04456:  MOVWF  01
04458:  MOVLW  00
0445A:  ADDWFC 02,W
0445C:  MOVWF  03
0445E:  MOVF   01,W
04460:  ADDLW  A4
04462:  MOVWF  FE9
04464:  MOVLW  01
04466:  ADDWFC 03,W
04468:  MOVWF  FEA
0446A:  MOVFF  FEC,03
0446E:  MOVF   FED,F
04470:  MOVF   FEF,W
04472:  SUBWF  xC3,F
04474:  MOVF   03,W
04476:  SUBWFB xC4,F
04478:  MOVF   xC4,W
0447A:  SUBLW  00
0447C:  BC    4548
0447E:  XORLW  FF
04480:  BNZ   4488
04482:  MOVF   xC3,W
04484:  SUBLW  6E
04486:  BC    4548
....................          { 
....................             // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................             TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
04488:  MOVFF  5C2,5F4
0448C:  MOVFF  5C1,5F3
04490:  CLRF   xF6
04492:  MOVLW  14
04494:  MOVWF  xF5
04496:  MOVLB  0
04498:  CALL   2FC2
0449C:  MOVFF  02,03
044A0:  MOVF   01,W
044A2:  ADDLW  A4
044A4:  MOVWF  01
044A6:  MOVLW  01
044A8:  ADDWFC 03,F
044AA:  MOVFF  01,5C3
044AE:  MOVLB  5
044B0:  MOVFF  03,5C4
044B4:  MOVLW  01
044B6:  ADDWF  xC1,W
044B8:  MOVWF  xC5
044BA:  MOVLW  00
044BC:  ADDWFC xC2,W
044BE:  MOVWF  xC6
044C0:  MOVWF  xF4
044C2:  MOVFF  5C5,5F3
044C6:  CLRF   xF6
044C8:  MOVLW  14
044CA:  MOVWF  xF5
044CC:  MOVLB  0
044CE:  CALL   2FC2
044D2:  MOVFF  02,03
044D6:  MOVF   01,W
044D8:  ADDLW  A4
044DA:  MOVWF  01
044DC:  MOVLW  01
044DE:  ADDWFC 03,F
044E0:  MOVFF  01,5C5
044E4:  MOVLB  5
044E6:  MOVFF  03,5C6
044EA:  MOVLW  02
044EC:  BSF    FD8.0
044EE:  SUBFWB xC1,W
044F0:  MOVWF  xC7
044F2:  MOVLW  00
044F4:  SUBFWB xC2,W
044F6:  MOVWF  xC8
044F8:  MOVWF  xF4
044FA:  MOVFF  5C7,5F3
044FE:  CLRF   xF6
04500:  MOVLW  14
04502:  MOVWF  xF5
04504:  MOVLB  0
04506:  CALL   2FC2
0450A:  MOVFF  02,5C8
0450E:  MOVFF  01,5C7
04512:  MOVFF  5C4,63B
04516:  MOVFF  5C3,63A
0451A:  MOVLW  01
0451C:  MOVLB  6
0451E:  MOVWF  x3C
04520:  MOVFF  5C6,63E
04524:  MOVFF  5C5,63D
04528:  MOVWF  x3F
0452A:  MOVFF  02,641
0452E:  MOVFF  01,640
04532:  MOVLB  0
04534:  CALL   0F7E
....................             SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
04538:  MOVLB  1
0453A:  CLRF   xDD
0453C:  CLRF   xDC
....................     
....................             // Since we deleted an entry, we need to roll back one  
....................             // index so next loop will process the correct record 
....................             w--;    
0453E:  MOVLB  5
04540:  MOVF   xC1,W
04542:  BTFSC  FD8.2
04544:  DECF   xC2,F
04546:  DECF   xC1,F
....................          } 
04548:  INCF   xC1,F
0454A:  BTFSC  FD8.2
0454C:  INCF   xC2,F
0454E:  BRA    43D0
....................       } 
....................    #endif 
04550:  MOVLB  0
04552:  GOTO   6C90 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
....................  
....................   Summary: 
....................      Handles incoming TCP segments. 
....................  
....................   Description: 
....................    This function handles incoming TCP segments.  When a segment arrives, it 
....................    is compared to open sockets using a hash of the remote port and IP.   
....................    On a match, the data is passed to HandleTCPSeg for further processing. 
....................  
....................   Precondition: 
....................    TCP is initialized and a TCP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remote - Remote NODE_INFO structure 
....................    localIP - This stack's IP address (for header checking) 
....................    len - Total length of the waiting TCP segment 
....................  
....................   Return Values: 
....................    TRUE - the segment was properly handled. 
....................    FALSE - otherwise 
....................   ***************************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
067A4:  MOVLB  5
067A6:  MOVFF  5BE,FE9
067AA:  MOVFF  5BF,FEA
067AE:  MOVFF  FEF,5D8
067B2:  MOVFF  FEC,5D9
067B6:  MOVFF  FEC,5DA
067BA:  MOVFF  FEC,5DB
....................    pseudoHeader.DestAddress        = *localIP; 
067BE:  MOVFF  5C0,FE9
067C2:  MOVFF  5C1,FEA
067C6:  MOVFF  FEF,5DC
067CA:  MOVFF  FEC,5DD
067CE:  MOVFF  FEC,5DE
067D2:  MOVFF  FEC,5DF
....................    pseudoHeader.Zero               = 0x0; 
067D6:  CLRF   xE0
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
067D8:  MOVLW  06
067DA:  MOVWF  xE1
....................    pseudoHeader.Length             = len; 
067DC:  MOVFF  5C3,5E3
067E0:  MOVFF  5C2,5E2
....................  
....................    SwapPseudoHeader(pseudoHeader); 
067E4:  MOVFF  5E3,653
067E8:  MOVFF  5E2,652
067EC:  MOVLB  0
067EE:  CALL   1A42
067F2:  MOVFF  02,5E3
067F6:  MOVFF  01,5E2
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
067FA:  MOVLW  05
067FC:  MOVLB  5
067FE:  MOVWF  xEA
06800:  MOVLW  D8
06802:  MOVWF  xE9
06804:  MOVFF  5EA,64F
06808:  MOVFF  FE8,64E
0680C:  MOVLB  6
0680E:  CLRF   x51
06810:  MOVLW  0C
06812:  MOVWF  x50
06814:  MOVLB  0
06816:  CALL   1B26
0681A:  MOVFF  01,5E4
0681E:  MOVLB  5
06820:  COMF   xE4,F
06822:  MOVFF  02,5E5
06826:  COMF   xE5,F
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
06828:  MOVFF  5C3,634
0682C:  MOVFF  5C2,633
06830:  MOVLB  0
06832:  CALL   3450
06836:  MOVFF  02,5E7
0683A:  MOVFF  01,5E6
....................  
....................    // Compare checksums. 
....................    if(checksum1.Val != checksum2.Val) 
0683E:  MOVLB  5
06840:  MOVF   xE6,W
06842:  SUBWF  xE4,W
06844:  BNZ   684C
06846:  MOVF   xE7,W
06848:  SUBWF  xE5,W
0684A:  BZ    685A
....................    { 
....................       MACDiscardRx(); 
0684C:  MOVLB  0
0684E:  CALL   25DA
....................       return TRUE; 
06852:  MOVLW  01
06854:  MOVWF  01
06856:  BRA    690E
06858:  MOVLB  5
....................    } 
....................  
.................... #if defined(DEBUG_GENERATE_RX_LOSS) 
....................    // Throw RX packets away randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_RX_LOSS) 
....................    { 
....................       MACDiscardRx(); 
....................       return TRUE; 
....................    } 
.................... #endif 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
0685A:  MOVLB  6
0685C:  CLRF   x0E
0685E:  CLRF   x0D
06860:  MOVLB  0
06862:  CALL   247A
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
06866:  MOVLW  05
06868:  MOVLB  5
0686A:  MOVWF  xEA
0686C:  MOVLW  C4
0686E:  MOVWF  xE9
06870:  MOVFF  5EA,656
06874:  MOVFF  FE8,655
06878:  MOVLB  6
0687A:  CLRF   x58
0687C:  MOVLW  14
0687E:  MOVWF  x57
06880:  MOVLB  0
06882:  CALL   0C28
....................    SwapTCPHeader(&TCPHeader); 
06886:  MOVLW  05
06888:  MOVLB  6
0688A:  MOVWF  x34
0688C:  MOVLW  C4
0688E:  MOVWF  x33
06890:  MOVLB  0
06892:  CALL   3272
....................  
....................  
....................    // Skip over options to retrieve data bytes 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
06896:  MOVLB  5
06898:  SWAPF  xD0,W
0689A:  ANDLW  0F
0689C:  MOVWF  02
0689E:  RLCF   02,W
068A0:  MOVWF  xE9
068A2:  CLRF   xEA
068A4:  RLCF   xEA,F
068A6:  RLCF   xE9,F
068A8:  RLCF   xEA,F
068AA:  MOVLW  FC
068AC:  ANDWF  xE9,F
068AE:  MOVLW  14
068B0:  SUBWF  xE9,W
068B2:  MOVWF  00
068B4:  MOVLW  00
068B6:  SUBWFB xEA,W
068B8:  MOVFF  00,5E8
....................    len = len - optionsSize - sizeof(TCPHeader); 
068BC:  MOVF   xE8,W
068BE:  SUBWF  xC2,W
068C0:  MOVWF  xE9
068C2:  MOVLW  00
068C4:  SUBWFB xC3,W
068C6:  MOVWF  xEA
068C8:  MOVLW  14
068CA:  SUBWF  xE9,W
068CC:  MOVWF  xC2
068CE:  MOVLW  00
068D0:  SUBWFB xEA,W
068D2:  MOVWF  xC3
....................  
....................    // Find matching socket. 
....................    if(FindMatchingTCPSocket(&TCPHeader, remote)) 
068D4:  MOVLW  05
068D6:  MOVWF  xEA
068D8:  MOVLW  C4
068DA:  MOVWF  xE9
068DC:  MOVFF  5BF,5EC
068E0:  MOVFF  5BE,5EB
068E4:  MOVLB  0
068E6:  GOTO   4CD4
068EA:  MOVF   01,F
068EC:  BZ    6906
....................    { 
....................       #if defined(STACK_USE_SSL) 
....................       PTR_BASE prevRxHead; 
....................       // For SSL connections, show HandleTCPSeg() the full data buffer 
....................       prevRxHead = MyTCBStub.rxHead; 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................       #endif 
....................        
....................       HandleTCPSeg(&TCPHeader, len); 
068EE:  MOVLW  05
068F0:  MOVLB  5
068F2:  MOVWF  xEA
068F4:  MOVLW  C4
068F6:  MOVWF  xE9
068F8:  MOVFF  5C3,5EC
068FC:  MOVFF  5C2,5EB
06900:  MOVLB  0
06902:  GOTO   541E
....................        
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Restore the buffer state 
....................          MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          MyTCBStub.rxHead = prevRxHead; 
....................  
....................          // Process the new SSL data, using the currently loaded stub 
....................          TCPSSLHandleIncoming(hCurrentTCP); 
....................       } 
....................       #endif 
....................    } 
.................... //   else 
.................... //   { 
.................... //      // NOTE: RFC 793 specifies that if the socket is closed and a segment  
.................... //      // arrives, we should send back a RST if the RST bit in the incoming  
.................... //      // packet is not set.  Instead, we will just silently ignore such a  
.................... //      // packet since this is what firewalls do on purpose to enhance  
.................... //      // security. 
.................... //      //if(!TCPHeader.Flags.bits.flagRST) 
.................... //      //   SendTCP(RST, SENDTCP_RESET_TIMERS); 
.................... //   } 
....................  
....................    // Finished with this packet, discard it and free the Ethernet RAM for new packets 
....................    MACDiscardRx(); 
06906:  CALL   25DA
....................  
....................    return TRUE; 
0690A:  MOVLW  01
0690C:  MOVWF  01
0690E:  GOTO   6DFA (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
....................  
....................   Summary: 
....................    Transmits a TPC segment. 
....................  
....................   Description: 
....................    This function assembles and transmits a TCP segment, including any  
....................    pending data.  It also supports retransmissions, keep-alives, and  
....................    other packet types. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    vTCPFlags - Additional TCP flags to include 
....................    vSendFlags - Any combinations of SENDTCP_* constants to modify the 
....................              transmit behavior or contents. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
.................... { 
....................    WORD_VAL        wVal; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD          len; 
....................     
....................    SyncTCB(); 
*
03598:  CALL   1064
....................  
....................    // FINs must be handled specially 
....................    if(vTCPFlags & FIN) 
0359C:  MOVLB  6
0359E:  MOVF   x09,W
035A0:  ANDLW  01
035A2:  MOVWF  00
035A4:  CLRF   03
035A6:  MOVF   00,W
035A8:  IORWF  03,W
035AA:  BZ    35B4
....................    { 
....................       MyTCBStub.Flags.bTXFIN = 1; 
035AC:  MOVLB  1
035AE:  BSF    xF8.3
....................       vTCPFlags &= ~FIN; 
035B0:  MOVLB  6
035B2:  BCF    x09.0
....................    } 
....................  
....................    // Status will now be synched, disable automatic future  
....................    // status transmissions 
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
035B4:  MOVLB  1
035B6:  BCF    xF7.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
035B8:  BCF    xF7.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
035BA:  BCF    xF7.7
....................    MyTCBStub.Flags.bTXASAP = 0; 
035BC:  BCF    xF8.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
035BE:  BCF    xF8.2
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
035C0:  BCF    xF8.0
....................  
....................    //  Make sure that we can write to the MAC transmit area 
....................    while(!IPIsTxReady()); 
035C2:  MOVLB  0
035C4:  CALL   17A4
035C8:  MOVF   01,F
035CA:  BZ    35C4
....................  
....................    // Put all socket application data in the TX space 
....................    if(vTCPFlags & (SYN | RST)) 
035CC:  MOVLB  6
035CE:  MOVF   x09,W
035D0:  ANDLW  06
035D2:  MOVWF  00
035D4:  CLRF   03
035D6:  MOVF   00,W
035D8:  IORWF  03,W
035DA:  BZ    35E2
....................    { 
....................       // Don't put any data in SYN and RST messages 
....................       len = 0; 
035DC:  CLRF   x32
035DE:  CLRF   x31
....................    } 
035E0:  BRA    3814
....................    else 
....................    { 
....................       // Begin copying any application data over to the TX space 
....................       if(MyTCBStub.txHead == MyTCB.txUnackedTail) 
035E2:  MOVLB  1
035E4:  MOVF   x88,W
035E6:  SUBWF  xE6,W
035E8:  BNZ   35FA
035EA:  MOVF   x89,W
035EC:  SUBWF  xE7,W
035EE:  BNZ   35FA
....................       { 
....................          // All caught up on data TX, no real data for this packet 
....................          len = 0; 
035F0:  MOVLB  6
035F2:  CLRF   x32
035F4:  CLRF   x31
....................       } 
035F6:  BRA    37E6
035F8:  MOVLB  1
....................       else if(MyTCBStub.txHead > MyTCB.txUnackedTail) 
035FA:  MOVF   x89,W
035FC:  SUBWF  xE7,W
035FE:  BNC   369E
03600:  BNZ   3608
03602:  MOVF   xE6,W
03604:  SUBWF  x88,W
03606:  BC    369E
....................       { 
....................          len = MyTCBStub.txHead - MyTCB.txUnackedTail; 
03608:  MOVF   x88,W
0360A:  SUBWF  xE6,W
0360C:  MOVLB  6
0360E:  MOVWF  x31
03610:  MOVLB  1
03612:  MOVF   x89,W
03614:  SUBWFB xE7,W
03616:  MOVLB  6
03618:  MOVWF  x32
....................  
....................          if(len > MyTCB.remoteWindow) 
0361A:  MOVLB  1
0361C:  MOVF   x8F,W
0361E:  MOVLB  6
03620:  SUBWF  x32,W
03622:  BNC   363E
03624:  BNZ   3636
03626:  MOVF   x31,W
03628:  MOVLB  1
0362A:  SUBWF  x8E,W
0362C:  BTFSS  FD8.0
0362E:  BRA    3634
03630:  MOVLB  6
03632:  BRA    363E
03634:  MOVLB  6
....................             len = MyTCB.remoteWindow; 
03636:  MOVFF  18F,632
0363A:  MOVFF  18E,631
....................  
....................          if(len > MyTCB.wRemoteMSS) 
0363E:  MOVLB  1
03640:  MOVF   xA0,W
03642:  MOVLB  6
03644:  SUBWF  x32,W
03646:  BNC   3668
03648:  BNZ   365A
0364A:  MOVF   x31,W
0364C:  MOVLB  1
0364E:  SUBWF  x9F,W
03650:  BTFSS  FD8.0
03652:  BRA    3658
03654:  MOVLB  6
03656:  BRA    3668
03658:  MOVLB  6
....................          { 
....................             len = MyTCB.wRemoteMSS; 
0365A:  MOVFF  1A0,632
0365E:  MOVFF  19F,631
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
03662:  MOVLB  1
03664:  BSF    xF8.2
03666:  MOVLB  6
....................          } 
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len); 
03668:  MOVLW  12
0366A:  MOVWF  x3B
0366C:  MOVLW  0D
0366E:  MOVWF  x3A
03670:  CLRF   x3C
03672:  MOVFF  189,63E
03676:  MOVFF  188,63D
0367A:  MOVFF  1FB,63F
0367E:  MOVFF  632,641
03682:  MOVFF  631,640
03686:  MOVLB  0
03688:  CALL   0F7E
....................          MyTCB.txUnackedTail += len; 
0368C:  MOVLB  6
0368E:  MOVF   x31,W
03690:  MOVLB  1
03692:  ADDWF  x88,F
03694:  MOVLB  6
03696:  MOVF   x32,W
03698:  MOVLB  1
0369A:  ADDWFC x89,F
....................       } 
0369C:  BRA    37E4
....................       else 
....................       { 
....................          pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail; 
0369E:  MOVF   x88,W
036A0:  SUBWF  xE2,W
036A2:  MOVLB  6
036A4:  MOVWF  x2F
036A6:  MOVLB  1
036A8:  MOVF   x89,W
036AA:  SUBWFB xE3,W
036AC:  MOVLB  6
036AE:  MOVWF  x30
....................          len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart; 
036B0:  MOVLB  1
036B2:  MOVF   xE6,W
036B4:  MOVLB  6
036B6:  ADDWF  x2F,W
036B8:  MOVWF  x33
036BA:  MOVLB  1
036BC:  MOVF   xE7,W
036BE:  MOVLB  6
036C0:  ADDWFC x30,W
036C2:  MOVWF  x34
036C4:  MOVLB  1
036C6:  MOVF   xE0,W
036C8:  MOVLB  6
036CA:  SUBWF  x33,W
036CC:  MOVWF  x31
036CE:  MOVLB  1
036D0:  MOVF   xE1,W
036D2:  MOVLB  6
036D4:  SUBWFB x34,W
036D6:  MOVWF  x32
....................  
....................          if(len > MyTCB.remoteWindow) 
036D8:  MOVLB  1
036DA:  MOVF   x8F,W
036DC:  MOVLB  6
036DE:  SUBWF  x32,W
036E0:  BNC   36FC
036E2:  BNZ   36F4
036E4:  MOVF   x31,W
036E6:  MOVLB  1
036E8:  SUBWF  x8E,W
036EA:  BTFSS  FD8.0
036EC:  BRA    36F2
036EE:  MOVLB  6
036F0:  BRA    36FC
036F2:  MOVLB  6
....................             len = MyTCB.remoteWindow; 
036F4:  MOVFF  18F,632
036F8:  MOVFF  18E,631
....................  
....................          if(len > MyTCB.wRemoteMSS) 
036FC:  MOVLB  1
036FE:  MOVF   xA0,W
03700:  MOVLB  6
03702:  SUBWF  x32,W
03704:  BNC   3726
03706:  BNZ   3718
03708:  MOVF   x31,W
0370A:  MOVLB  1
0370C:  SUBWF  x9F,W
0370E:  BTFSS  FD8.0
03710:  BRA    3716
03712:  MOVLB  6
03714:  BRA    3726
03716:  MOVLB  6
....................          { 
....................             len = MyTCB.wRemoteMSS; 
03718:  MOVFF  1A0,632
0371C:  MOVFF  19F,631
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
03720:  MOVLB  1
03722:  BSF    xF8.2
03724:  MOVLB  6
....................          } 
....................  
....................          if(pseudoHeader.Length > len) 
03726:  MOVF   x32,W
03728:  SUBWF  x30,W
0372A:  BNC   373C
0372C:  BNZ   3734
0372E:  MOVF   x2F,W
03730:  SUBWF  x31,W
03732:  BC    373C
....................             pseudoHeader.Length = len; 
03734:  MOVFF  632,630
03738:  MOVFF  631,62F
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
0373C:  MOVLW  12
0373E:  MOVWF  x3B
03740:  MOVLW  0D
03742:  MOVWF  x3A
03744:  CLRF   x3C
03746:  MOVFF  189,63E
0374A:  MOVFF  188,63D
0374E:  MOVFF  1FB,63F
03752:  MOVFF  630,641
03756:  MOVFF  62F,640
0375A:  MOVLB  0
0375C:  CALL   0F7E
....................          pseudoHeader.Length = len - pseudoHeader.Length; 
03760:  MOVLB  6
03762:  MOVF   x2F,W
03764:  SUBWF  x31,W
03766:  MOVWF  x2F
03768:  MOVF   x30,W
0376A:  SUBWFB x32,W
0376C:  MOVWF  x30
....................     
....................          // Copy any left over chunks of application data over 
....................          if(pseudoHeader.Length) 
0376E:  MOVF   x2F,W
03770:  IORWF  x30,W
03772:  BZ    37B4
....................          { 
....................             TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
03774:  MOVLB  1
03776:  MOVF   x88,W
03778:  SUBWF  xE2,W
0377A:  MOVWF  00
0377C:  MOVF   x89,W
0377E:  SUBWFB xE3,W
03780:  MOVWF  03
03782:  MOVF   00,W
03784:  ADDLW  0D
03786:  MOVLB  6
03788:  MOVWF  x33
0378A:  MOVLW  12
0378C:  ADDWFC 03,W
0378E:  MOVWF  x34
03790:  MOVWF  x3B
03792:  MOVFF  633,63A
03796:  CLRF   x3C
03798:  MOVFF  1E1,63E
0379C:  MOVFF  1E0,63D
037A0:  MOVFF  1FB,63F
037A4:  MOVFF  630,641
037A8:  MOVFF  62F,640
037AC:  MOVLB  0
037AE:  CALL   0F7E
037B2:  MOVLB  6
....................          } 
....................  
....................          MyTCB.txUnackedTail += len; 
037B4:  MOVF   x31,W
037B6:  MOVLB  1
037B8:  ADDWF  x88,F
037BA:  MOVLB  6
037BC:  MOVF   x32,W
037BE:  MOVLB  1
037C0:  ADDWFC x89,F
....................          if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
037C2:  MOVF   xE3,W
037C4:  SUBWF  x89,W
037C6:  BNC   37E4
037C8:  BNZ   37D0
037CA:  MOVF   xE2,W
037CC:  SUBWF  x88,W
037CE:  BNC   37E4
....................             MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart; 
037D0:  MOVF   xE0,W
037D2:  SUBWF  xE2,W
037D4:  MOVWF  00
037D6:  MOVF   xE1,W
037D8:  SUBWFB xE3,W
037DA:  MOVWF  03
037DC:  MOVF   00,W
037DE:  SUBWF  x88,F
037E0:  MOVF   03,W
037E2:  SUBWFB x89,F
037E4:  MOVLB  6
....................       } 
....................  
....................       // If we are to transmit a FIN, make sure we can put one in this packet 
....................       if(MyTCBStub.Flags.bTXFIN) 
037E6:  MOVLB  1
037E8:  BTFSS  xF8.3
037EA:  BRA    3816
....................       { 
....................          if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS)) 
037EC:  MOVF   x8E,W
037EE:  MOVLB  6
037F0:  SUBWF  x31,W
037F2:  BNZ   37FE
037F4:  MOVLB  1
037F6:  MOVF   x8F,W
037F8:  MOVLB  6
037FA:  SUBWF  x32,W
037FC:  BZ    3814
037FE:  MOVLB  1
03800:  MOVF   x9F,W
03802:  MOVLB  6
03804:  SUBWF  x31,W
03806:  BNZ   3812
03808:  MOVLB  1
0380A:  MOVF   xA0,W
0380C:  MOVLB  6
0380E:  SUBWF  x32,W
03810:  BZ    3814
....................             vTCPFlags |= FIN; 
03812:  BSF    x09.0
03814:  MOVLB  1
....................       } 
....................    } 
....................  
....................    // Ensure that all packets with data of some kind are  
....................    // retransmitted by TCPTick() until acknowledged 
....................    // Pure ACK packets with no data are not ACKed back in TCP 
....................    if(len || (vTCPFlags & (SYN | FIN))) 
03816:  MOVLB  6
03818:  MOVF   x31,W
0381A:  IORWF  x32,W
0381C:  BNZ   382C
0381E:  MOVF   x09,W
03820:  ANDLW  03
03822:  MOVWF  00
03824:  CLRF   03
03826:  MOVF   00,W
03828:  IORWF  03,W
0382A:  BZ    389A
....................    { 
....................       // Transmitting data, update remote window variable to reflect smaller  
....................       // window. 
....................       MyTCB.remoteWindow -= len; 
0382C:  MOVF   x31,W
0382E:  MOVLB  1
03830:  SUBWF  x8E,F
03832:  MOVLB  6
03834:  MOVF   x32,W
03836:  MOVLB  1
03838:  SUBWFB x8F,F
....................  
....................       // Push (PSH) all data for enhanced responsiveness on  
....................       // the remote end, especially with GUIs 
....................       if(len) 
0383A:  MOVLB  6
0383C:  MOVF   x31,W
0383E:  IORWF  x32,W
03840:  BZ    3844
....................          vTCPFlags |= PSH; 
03842:  BSF    x09.3
....................  
....................       if(vSendFlags & SENDTCP_RESET_TIMERS) 
03844:  MOVF   x0A,W
03846:  ANDLW  01
03848:  MOVWF  00
0384A:  CLRF   03
0384C:  MOVF   00,W
0384E:  IORWF  03,W
03850:  BZ    3864
....................       { 
....................          MyTCB.retryCount = 0; 
03852:  MOVLB  1
03854:  CLRF   xA1
....................          MyTCB.retryInterval = TCP_START_TIMEOUT_VAL; 
03856:  CLRF   x7F
03858:  CLRF   x7E
0385A:  MOVLW  7A
0385C:  MOVWF  x7D
0385E:  MOVLW  12
03860:  MOVWF  x7C
03862:  MOVLB  6
....................       }    
....................  
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
03864:  MOVLB  0
03866:  CALL   23FC
0386A:  MOVLB  1
0386C:  MOVF   x7C,W
0386E:  MOVLB  6
03870:  ADDWF  00,W
03872:  MOVLB  1
03874:  MOVWF  xEE
03876:  MOVF   x7D,W
03878:  MOVLB  6
0387A:  ADDWFC 01,W
0387C:  MOVLB  1
0387E:  MOVWF  xEF
03880:  MOVF   x7E,W
03882:  MOVLB  6
03884:  ADDWFC 02,W
03886:  MOVLB  1
03888:  MOVWF  xF0
0388A:  MOVF   x7F,W
0388C:  MOVLB  6
0388E:  ADDWFC 03,W
03890:  MOVLB  1
03892:  MOVWF  xF1
....................       MyTCBStub.Flags.bTimerEnabled = 1; 
03894:  BSF    xF7.4
....................    } 
03896:  BRA    392A
03898:  MOVLB  6
....................    else if(vSendFlags & SENDTCP_KEEP_ALIVE) 
0389A:  MOVF   x0A,W
0389C:  ANDLW  02
0389E:  MOVWF  00
038A0:  CLRF   03
038A2:  MOVF   00,W
038A4:  IORWF  03,W
038A6:  BZ    38D0
....................    { 
....................       // Increment Keep Alive TX counter to handle disconnection if not response is returned 
....................       MyTCBStub.Flags.vUnackedKeepalives++; 
038A8:  MOVLB  1
038AA:  MOVF   xF7,W
038AC:  ADDLW  01
038AE:  ANDLW  07
038B0:  MOVWF  00
038B2:  MOVLW  F8
038B4:  ANDWF  xF7,W
038B6:  IORWF  00,W
038B8:  MOVWF  xF7
....................        
....................       // Generate a dummy byte 
....................       MyTCB.MySEQ -= 1; 
038BA:  MOVLW  01
038BC:  SUBWF  x80,F
038BE:  MOVLW  00
038C0:  SUBWFB x81,F
038C2:  SUBWFB x82,F
038C4:  SUBWFB x83,F
....................       len = 1; 
038C6:  MOVLB  6
038C8:  CLRF   x32
038CA:  MOVLW  01
038CC:  MOVWF  x31
....................    } 
038CE:  BRA    392C
....................    else if(MyTCBStub.Flags.bTimerEnabled)  
038D0:  MOVLB  1
038D2:  BTFSS  xF7.4
038D4:  BRA    392A
....................    { 
....................       // If we have data to transmit, but the remote RX window is zero,  
....................       // so we aren't transmitting any right now then make sure to not  
....................       // extend the retry counter or timer.  This will stall our TX  
....................       // with a periodic ACK sent to the remote node. 
....................       if(!(vSendFlags & SENDTCP_RESET_TIMERS)) 
038D6:  MOVLB  6
038D8:  MOVF   x0A,W
038DA:  ANDLW  01
038DC:  MOVWF  00
038DE:  CLRF   03
038E0:  MOVF   00,W
038E2:  IORWF  03,W
038E4:  BNZ   38FA
....................       { 
....................          // Roll back retry counters since we can't send anything,  
....................          // but only if we incremented it in the first place 
....................          if(MyTCB.retryCount) 
038E6:  MOVLB  1
038E8:  MOVF   xA1,F
038EA:  BZ    38F8
....................          { 
....................             MyTCB.retryCount--; 
038EC:  DECF   xA1,F
....................             MyTCB.retryInterval >>= 1; 
038EE:  BCF    FD8.0
038F0:  RRCF   x7F,F
038F2:  RRCF   x7E,F
038F4:  RRCF   x7D,F
038F6:  RRCF   x7C,F
038F8:  MOVLB  6
....................          } 
....................       } 
....................     
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
038FA:  MOVLB  0
038FC:  CALL   23FC
03900:  MOVLB  1
03902:  MOVF   x7C,W
03904:  MOVLB  6
03906:  ADDWF  00,W
03908:  MOVLB  1
0390A:  MOVWF  xEE
0390C:  MOVF   x7D,W
0390E:  MOVLB  6
03910:  ADDWFC 01,W
03912:  MOVLB  1
03914:  MOVWF  xEF
03916:  MOVF   x7E,W
03918:  MOVLB  6
0391A:  ADDWFC 02,W
0391C:  MOVLB  1
0391E:  MOVWF  xF0
03920:  MOVF   x7F,W
03922:  MOVLB  6
03924:  ADDWFC 03,W
03926:  MOVLB  1
03928:  MOVWF  xF1
0392A:  MOVLB  6
....................    } 
....................     
....................  
....................    header.SourcePort         = MyTCB.localPort.Val; 
0392C:  MOVFF  18D,60E
03930:  MOVFF  18C,60D
....................    header.DestPort            = MyTCB.remotePort.Val; 
03934:  MOVFF  18B,610
03938:  MOVFF  18A,60F
....................    header.SeqNumber         = MyTCB.MySEQ; 
0393C:  MOVFF  183,614
03940:  MOVFF  182,613
03944:  MOVFF  181,612
03948:  MOVFF  180,611
....................    header.AckNumber         = MyTCB.RemoteSEQ; 
0394C:  MOVFF  187,618
03950:  MOVFF  186,617
03954:  MOVFF  185,616
03958:  MOVFF  184,615
....................    header.Flags.bits.Reserved2   = 0; 
0395C:  MOVLW  3F
0395E:  ANDWF  x1A,W
03960:  MOVWF  x1A
....................    header.DataOffset.Reserved3   = 0; 
03962:  MOVLW  F0
03964:  ANDWF  x19,W
03966:  MOVWF  x19
....................    header.Flags.byte         = vTCPFlags; 
03968:  MOVFF  609,61A
....................    header.UrgentPointer        = 0; 
0396C:  CLRF   x20
0396E:  CLRF   x1F
....................  
....................    // Update our send sequence number and ensure retransmissions  
....................    // of SYNs and FINs use the right sequence number 
....................    MyTCB.MySEQ += (DWORD)len; 
03970:  MOVFF  632,01
03974:  CLRF   02
03976:  CLRF   03
03978:  MOVF   x31,W
0397A:  MOVLB  1
0397C:  ADDWF  x80,F
0397E:  MOVF   01,W
03980:  ADDWFC x81,F
03982:  MOVF   02,W
03984:  ADDWFC x82,F
03986:  MOVF   03,W
03988:  ADDWFC x83,F
....................    if(vTCPFlags & SYN) 
0398A:  MOVLB  6
0398C:  MOVF   x09,W
0398E:  ANDLW  02
03990:  MOVWF  00
03992:  CLRF   03
03994:  MOVF   00,W
03996:  IORWF  03,W
03998:  BZ    39E0
....................    { 
....................       // SEG.ACK needs to be zero for the first SYN packet for compatibility  
....................       // with certain paranoid TCP/IP stacks, even though the ACK flag isn't  
....................       // set (indicating that the AckNumber field is unused). 
....................       if(!(vTCPFlags & ACK)) 
0399A:  MOVF   x09,W
0399C:  ANDLW  10
0399E:  MOVWF  00
039A0:  CLRF   03
039A2:  MOVF   00,W
039A4:  IORWF  03,W
039A6:  BNZ   39B0
....................          header.AckNumber = 0x00000000; 
039A8:  CLRF   x18
039AA:  CLRF   x17
039AC:  CLRF   x16
039AE:  CLRF   x15
....................  
....................       if(MyTCB.flags.bSYNSent) 
039B0:  MOVLB  1
039B2:  BTFSS  x9E.1
039B4:  BRA    39CC
....................          header.SeqNumber--; 
039B6:  MOVLW  FF
039B8:  MOVLB  6
039BA:  ADDWF  x11,F
039BC:  BTFSS  FD8.0
039BE:  ADDWF  x12,F
039C0:  BTFSS  FD8.0
039C2:  ADDWF  x13,F
039C4:  BTFSS  FD8.0
039C6:  ADDWF  x14,F
039C8:  BRA    39E0
039CA:  MOVLB  1
....................       else 
....................       { 
....................          MyTCB.MySEQ++; 
039CC:  MOVLW  01
039CE:  ADDWF  x80,F
039D0:  BTFSC  FD8.0
039D2:  INCF   x81,F
039D4:  BTFSC  FD8.2
039D6:  INCF   x82,F
039D8:  BTFSC  FD8.2
039DA:  INCF   x83,F
....................          MyTCB.flags.bSYNSent = 1; 
039DC:  BSF    x9E.1
039DE:  MOVLB  6
....................       } 
....................    } 
....................    if(vTCPFlags & FIN) 
039E0:  MOVF   x09,W
039E2:  ANDLW  01
039E4:  MOVWF  00
039E6:  CLRF   03
039E8:  MOVF   00,W
039EA:  IORWF  03,W
039EC:  BZ    39F4
....................    { 
....................         MyTCB.flags.bFINSent = 1;   // do not advance the seq no for FIN! 
039EE:  MOVLB  1
039F0:  BSF    x9E.0
039F2:  MOVLB  6
....................    } 
....................  
....................    // Calculate the amount of free space in the RX buffer area of this socket 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
039F4:  MOVLB  1
039F6:  MOVF   xED,W
039F8:  SUBWF  xEB,W
039FA:  BNC   3A36
039FC:  BNZ   3A04
039FE:  MOVF   xEC,W
03A00:  SUBWF  xEA,W
03A02:  BNC   3A36
....................       header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
03A04:  MOVF   xE2,W
03A06:  SUBWF  xE4,W
03A08:  MOVLB  6
03A0A:  MOVWF  x33
03A0C:  MOVLB  1
03A0E:  MOVF   xE3,W
03A10:  SUBWFB xE5,W
03A12:  MOVLB  6
03A14:  MOVWF  x34
03A16:  MOVLB  1
03A18:  MOVF   xEC,W
03A1A:  SUBWF  xEA,W
03A1C:  MOVWF  00
03A1E:  MOVF   xED,W
03A20:  SUBWFB xEB,W
03A22:  MOVWF  03
03A24:  MOVF   00,W
03A26:  MOVLB  6
03A28:  SUBWF  x33,W
03A2A:  MOVWF  x1B
03A2C:  MOVF   03,W
03A2E:  SUBWFB x34,W
03A30:  MOVWF  x1C
03A32:  BRA    3A54
03A34:  MOVLB  1
....................    else 
....................       header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
03A36:  MOVF   xEA,W
03A38:  SUBWF  xEC,W
03A3A:  MOVLB  6
03A3C:  MOVWF  x33
03A3E:  MOVLB  1
03A40:  MOVF   xEB,W
03A42:  SUBWFB xED,W
03A44:  MOVLB  6
03A46:  MOVWF  x34
03A48:  MOVLW  01
03A4A:  SUBWF  x33,W
03A4C:  MOVWF  x1B
03A4E:  MOVLW  00
03A50:  SUBWFB x34,W
03A52:  MOVWF  x1C
....................  
....................    // Calculate the amount of free space in the MAC RX buffer area and adjust window if needed 
....................    wVal.Val = MACGetFreeRxSize(); 
03A54:  MOVLB  0
03A56:  GOTO   2FE4
03A5A:  MOVFF  02,60C
03A5E:  MOVFF  01,60B
....................    if(wVal.Val < 64) 
03A62:  MOVLB  6
03A64:  MOVF   x0C,F
03A66:  BNZ   3A74
03A68:  MOVF   x0B,W
03A6A:  SUBLW  3F
03A6C:  BNC   3A74
....................     { 
....................       wVal.Val = 0; 
03A6E:  CLRF   x0C
03A70:  CLRF   x0B
....................     } 
03A72:  BRA    3A7C
....................     else 
....................     { 
....................       wVal.Val -= 64; 
03A74:  MOVLW  40
03A76:  SUBWF  x0B,F
03A78:  MOVLW  00
03A7A:  SUBWFB x0C,F
....................     } 
....................    // Force the remote node to throttle back if we are running low on general RX buffer space 
....................    if(header.Window > wVal.Val) 
03A7C:  MOVF   x0C,W
03A7E:  SUBWF  x1C,W
03A80:  BNC   3A92
03A82:  BNZ   3A8A
03A84:  MOVF   x1B,W
03A86:  SUBWF  x0B,W
03A88:  BC    3A92
....................       header.Window = wVal.Val; 
03A8A:  MOVFF  60C,61C
03A8E:  MOVFF  60B,61B
....................  
....................    SwapTCPHeader(&header); 
03A92:  MOVLW  06
03A94:  MOVWF  x34
03A96:  MOVLW  0D
03A98:  MOVWF  x33
03A9A:  MOVLB  0
03A9C:  CALL   3272
....................  
....................  
....................    len += sizeof(header); 
03AA0:  MOVLW  14
03AA2:  MOVLB  6
03AA4:  ADDWF  x31,F
03AA6:  MOVLW  00
03AA8:  ADDWFC x32,F
....................    header.DataOffset.Val   = sizeof(header) >> 2; 
03AAA:  MOVLW  0F
03AAC:  ANDWF  x19,W
03AAE:  IORLW  50
03AB0:  MOVWF  x19
....................  
....................    // Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet 
....................    if(vTCPFlags & SYN) 
03AB2:  MOVF   x09,W
03AB4:  ANDLW  02
03AB6:  MOVWF  00
03AB8:  CLRF   03
03ABA:  MOVF   00,W
03ABC:  IORWF  03,W
03ABE:  BZ    3AEE
....................    { 
....................       len += sizeof(options); 
03AC0:  MOVLW  04
03AC2:  ADDWF  x31,F
03AC4:  MOVLW  00
03AC6:  ADDWFC x32,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
03AC8:  MOVLW  02
03ACA:  MOVWF  x21
....................       options.Length = 0x04; 
03ACC:  MOVLW  04
03ACE:  MOVWF  x22
....................  
....................       // Load MSS and swap to big endian 
....................       options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8); 
03AD0:  MOVLW  18
03AD2:  MOVWF  x24
03AD4:  MOVLW  02
03AD6:  MOVWF  x23
....................  
....................      #if defined(__PCD__)  //__PCD__ __PCH__ __CCS__ bug 
....................       unsigned int8 scr8; 
....................       scr8 = header.DataOffset.Val; 
....................       scr8 += sizeof(options) >> 2; 
....................       header.DataOffset.Val = scr8; 
....................      #else  //standard code 
....................       header.DataOffset.Val   += sizeof(options) >> 2; 
03AD8:  SWAPF  x19,W
03ADA:  ANDLW  0F
03ADC:  ADDLW  01
03ADE:  MOVWF  00
03AE0:  SWAPF  00,W
03AE2:  ANDLW  F0
03AE4:  MOVWF  00
03AE6:  MOVLW  0F
03AE8:  ANDWF  x19,W
03AEA:  IORWF  00,W
03AEC:  MOVWF  x19
....................      #endif 
....................    } 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
03AEE:  MOVFF  22,628
03AF2:  MOVFF  21,627
03AF6:  MOVFF  20,626
03AFA:  MOVFF  1F,625
....................    pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr; 
03AFE:  MOVFF  195,62C
03B02:  MOVFF  194,62B
03B06:  MOVFF  193,62A
03B0A:  MOVFF  192,629
....................    pseudoHeader.Zero           = 0x0; 
03B0E:  CLRF   x2D
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
03B10:  MOVLW  06
03B12:  MOVWF  x2E
....................    pseudoHeader.Length         = len; 
03B14:  MOVFF  632,630
03B18:  MOVFF  631,62F
....................    SwapPseudoHeader(pseudoHeader); 
03B1C:  MOVFF  630,653
03B20:  MOVFF  62F,652
03B24:  MOVLB  0
03B26:  CALL   1A42
03B2A:  MOVFF  02,630
03B2E:  MOVFF  01,62F
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
03B32:  MOVLW  06
03B34:  MOVLB  6
03B36:  MOVWF  x34
03B38:  MOVLW  25
03B3A:  MOVWF  x33
03B3C:  MOVFF  634,64F
03B40:  MOVWF  x4E
03B42:  CLRF   x51
03B44:  MOVLW  0C
03B46:  MOVWF  x50
03B48:  MOVLB  0
03B4A:  CALL   1B26
03B4E:  MOVFF  01,61D
03B52:  MOVLB  6
03B54:  COMF   x1D,F
03B56:  MOVFF  02,61E
03B5A:  COMF   x1E,F
....................  
....................    // Write IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
03B5C:  MOVLW  11
03B5E:  MOVWF  x43
03B60:  MOVLW  E5
03B62:  MOVWF  x42
03B64:  MOVLB  0
03B66:  CALL   0B16
....................    IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len); 
03B6A:  MOVLW  01
03B6C:  MOVLB  6
03B6E:  MOVWF  x34
03B70:  MOVLW  92
03B72:  MOVWF  x33
03B74:  MOVLW  06
03B76:  MOVWF  x35
03B78:  MOVFF  632,637
03B7C:  MOVFF  631,636
03B80:  MOVLB  0
03B82:  CALL   1CCC
....................    MACPutArray((BYTE*)&header, sizeof(header)); 
03B86:  MOVLW  06
03B88:  MOVLB  6
03B8A:  MOVWF  x34
03B8C:  MOVLW  0D
03B8E:  MOVWF  x33
03B90:  MOVFF  634,658
03B94:  MOVWF  x57
03B96:  CLRF   x5A
03B98:  MOVLW  14
03B9A:  MOVWF  x59
03B9C:  MOVLB  0
03B9E:  CALL   0B7E
....................    if(vTCPFlags & SYN) 
03BA2:  MOVLB  6
03BA4:  MOVF   x09,W
03BA6:  ANDLW  02
03BA8:  MOVWF  00
03BAA:  CLRF   03
03BAC:  MOVF   00,W
03BAE:  IORWF  03,W
03BB0:  BZ    3BCE
....................       MACPutArray((BYTE*)&options, sizeof(options)); 
03BB2:  MOVLW  06
03BB4:  MOVWF  x34
03BB6:  MOVLW  21
03BB8:  MOVWF  x33
03BBA:  MOVFF  634,658
03BBE:  MOVWF  x57
03BC0:  CLRF   x5A
03BC2:  MOVLW  04
03BC4:  MOVWF  x59
03BC6:  MOVLB  0
03BC8:  CALL   0B7E
03BCC:  MOVLB  6
....................  
....................    // Update the TCP checksum 
....................    MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
03BCE:  MOVLW  11
03BD0:  MOVWF  x43
03BD2:  MOVLW  F9
03BD4:  MOVWF  x42
03BD6:  MOVLB  0
03BD8:  CALL   0BC4
....................    wVal.Val = CalcIPBufferChecksum(len); 
03BDC:  MOVFF  632,634
03BE0:  MOVFF  631,633
03BE4:  RCALL  3450
03BE6:  MOVFF  02,60C
03BEA:  MOVFF  01,60B
.................... #if defined(DEBUG_GENERATE_TX_LOSS) 
....................    // Damage TCP checksums on TX packets randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_TX_LOSS) 
....................    { 
....................       wVal.Val++; 
....................    } 
.................... #endif 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16); 
03BEE:  MOVLW  12
03BF0:  MOVLB  6
03BF2:  MOVWF  x43
03BF4:  MOVLW  09
03BF6:  MOVWF  x42
03BF8:  MOVLB  0
03BFA:  CALL   0B16
....................    MACPutArray((BYTE*)&wVal, sizeof(WORD)); 
03BFE:  MOVLW  06
03C00:  MOVLB  6
03C02:  MOVWF  x34
03C04:  MOVLW  0B
03C06:  MOVWF  x33
03C08:  MOVFF  634,658
03C0C:  MOVWF  x57
03C0E:  CLRF   x5A
03C10:  MOVLW  02
03C12:  MOVWF  x59
03C14:  MOVLB  0
03C16:  CALL   0B7E
....................  
....................    // Physically start the packet transmission over the network 
....................    MACFlush(); 
03C1A:  CALL   1DB6
03C1E:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
....................  
....................   Summary: 
....................    Finds a suitable socket for a TCP segment. 
....................  
....................   Description: 
....................    This function searches through the sockets and attempts to match one with 
....................    a given TCP header and NODE_INFO structure.  If a socket is found, its  
....................    index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are 
....................    loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    h - TCP header to be matched against 
....................    remote - The remote node who sent this header 
....................  
....................   Return Values: 
....................    TRUE - A match was found and is loaded in hCurrentTCP 
....................    FALSE - No suitable socket was found and hCurrentTCP is INVALID_SOCKET 
....................   ***************************************************************************/ 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    TCP_SOCKET partialMatch; 
....................    WORD hash; 
....................  
....................    // Prevent connections on invalid port 0 
....................    if(h->DestPort == 0u) 
*
04CD4:  MOVLW  02
04CD6:  MOVLB  5
04CD8:  ADDWF  xE9,W
04CDA:  MOVWF  FE9
04CDC:  MOVLW  00
04CDE:  ADDWFC xEA,W
04CE0:  MOVWF  FEA
04CE2:  MOVFF  FEC,5F4
04CE6:  MOVF   FED,F
04CE8:  MOVFF  FEF,5F3
04CEC:  MOVF   xF3,F
04CEE:  BNZ   4CFA
04CF0:  MOVF   xF4,F
04CF2:  BNZ   4CFA
....................       return FALSE; 
04CF4:  MOVLW  00
04CF6:  MOVWF  01
04CF8:  BRA    52F4
....................  
....................    partialMatch = INVALID_SOCKET; 
04CFA:  MOVLW  FE
04CFC:  MOVWF  xEE
....................    hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort; 
04CFE:  MOVLW  02
04D00:  ADDWF  xEB,W
04D02:  MOVWF  FE9
04D04:  MOVLW  00
04D06:  ADDWFC xEC,W
04D08:  MOVWF  FEA
04D0A:  MOVFF  FEC,5F4
04D0E:  MOVF   FED,F
04D10:  MOVFF  FEF,5F3
04D14:  MOVFF  5EB,FE9
04D18:  MOVFF  5EC,FEA
04D1C:  MOVFF  FEC,03
04D20:  MOVF   FED,F
04D22:  MOVF   FEF,W
04D24:  ADDWF  xF3,F
04D26:  MOVF   03,W
04D28:  ADDWFC xF4,F
04D2A:  MOVFF  5E9,FE9
04D2E:  MOVFF  5EA,FEA
04D32:  MOVFF  FEC,03
04D36:  MOVF   FED,F
04D38:  MOVF   FEF,W
04D3A:  ADDWF  xF3,F
04D3C:  MOVF   03,W
04D3E:  ADDWFC xF4,F
04D40:  MOVLW  02
04D42:  ADDWF  xE9,W
04D44:  MOVWF  FE9
04D46:  MOVLW  00
04D48:  ADDWFC xEA,W
04D4A:  MOVWF  FEA
04D4C:  MOVFF  FEC,03
04D50:  MOVF   FED,F
04D52:  MOVF   FEF,W
04D54:  XORWF  xF3,W
04D56:  MOVWF  xEF
04D58:  MOVF   03,W
04D5A:  XORWF  xF4,W
04D5C:  MOVWF  xF0
....................  
....................    // Loop through all sockets looking for a socket that is expecting this  
....................    // packet or can handle it. 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ ) 
04D5E:  CLRF   xED
04D60:  MOVF   xED,F
04D62:  BTFSS  FD8.2
04D64:  BRA    4E68
....................    { 
....................       SyncTCBStub(hTCP); 
04D66:  MOVFF  5ED,5F3
04D6A:  MOVLB  0
04D6C:  CALL   0A74
....................  
....................       if(MyTCBStub.smState == TCP_CLOSED) 
04D70:  MOVLB  1
04D72:  MOVF   xF6,W
04D74:  SUBLW  0D
04D76:  BNZ   4D7C
....................       { 
....................          continue; 
04D78:  BRA    4E62
....................       } 
04D7A:  BRA    4DC2
....................       else if(MyTCBStub.smState == TCP_LISTEN) 
04D7C:  MOVF   xF6,W
04D7E:  SUBLW  04
04D80:  BNZ   4DAC
....................       {// For listening ports, check if this is the correct port 
....................          if(MyTCBStub.remoteHash.Val == h->DestPort) 
04D82:  MOVLW  02
04D84:  MOVLB  5
04D86:  ADDWF  xE9,W
04D88:  MOVWF  FE9
04D8A:  MOVLW  00
04D8C:  ADDWFC xEA,W
04D8E:  MOVWF  FEA
04D90:  MOVFF  FEC,03
04D94:  MOVF   FED,F
04D96:  MOVF   FEF,W
04D98:  MOVLB  1
04D9A:  SUBWF  xF9,W
04D9C:  BNZ   4DA8
04D9E:  MOVF   03,W
04DA0:  SUBWF  xFA,W
04DA2:  BNZ   4DA8
....................             partialMatch = hTCP; 
04DA4:  MOVFF  5ED,5EE
....................           
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          // Check the SSL port as well for SSL Servers 
....................          // 0 is defined as an invalid port number 
....................          if(MyTCBStub.sslTxHead == h->DestPort) 
....................             partialMatch = hTCP; 
....................          #endif 
....................           
....................          continue; 
04DA8:  BRA    4E62
....................       } 
04DAA:  BRA    4DC2
....................       else if(MyTCBStub.remoteHash.Val != hash) 
04DAC:  MOVLB  5
04DAE:  MOVF   xEF,W
04DB0:  MOVLB  1
04DB2:  SUBWF  xF9,W
04DB4:  BNZ   4DC0
04DB6:  MOVLB  5
04DB8:  MOVF   xF0,W
04DBA:  MOVLB  1
04DBC:  SUBWF  xFA,W
04DBE:  BZ    4DC2
....................       {// Ignore if the hash doesn't match 
....................          continue; 
04DC0:  BRA    4E62
....................       } 
....................  
....................       SyncTCB(); 
04DC2:  MOVLB  0
04DC4:  CALL   1064
....................       if(   h->DestPort == MyTCB.localPort.Val && 
....................          h->SourcePort == MyTCB.remotePort.Val && 
....................          remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val) 
04DC8:  MOVLW  02
04DCA:  MOVLB  5
04DCC:  ADDWF  xE9,W
04DCE:  MOVWF  FE9
04DD0:  MOVLW  00
04DD2:  ADDWFC xEA,W
04DD4:  MOVWF  FEA
04DD6:  MOVFF  FEC,5F4
04DDA:  MOVF   FED,F
04DDC:  MOVFF  FEF,5F3
04DE0:  MOVLB  1
04DE2:  MOVF   x8C,W
04DE4:  MOVLB  5
04DE6:  SUBWF  xF3,W
04DE8:  BNZ   4E60
04DEA:  MOVLB  1
04DEC:  MOVF   x8D,W
04DEE:  MOVLB  5
04DF0:  SUBWF  xF4,W
04DF2:  BNZ   4E60
04DF4:  MOVFF  5E9,FE9
04DF8:  MOVFF  5EA,FEA
04DFC:  MOVFF  FEC,5F4
04E00:  MOVF   FED,F
04E02:  MOVFF  FEF,5F3
04E06:  MOVLB  1
04E08:  MOVF   x8A,W
04E0A:  MOVLB  5
04E0C:  SUBWF  xF3,W
04E0E:  BNZ   4E60
04E10:  MOVLB  1
04E12:  MOVF   x8B,W
04E14:  MOVLB  5
04E16:  SUBWF  xF4,W
04E18:  BNZ   4E60
04E1A:  MOVFF  5EB,FE9
04E1E:  MOVFF  5EC,FEA
04E22:  MOVFF  FEF,5F3
04E26:  MOVFF  FEC,5F4
04E2A:  MOVFF  FEC,5F5
04E2E:  MOVFF  FEC,5F6
04E32:  MOVLB  1
04E34:  MOVF   x92,W
04E36:  MOVLB  5
04E38:  SUBWF  xF3,W
04E3A:  BNZ   4E60
04E3C:  MOVLB  1
04E3E:  MOVF   x93,W
04E40:  MOVLB  5
04E42:  SUBWF  xF4,W
04E44:  BNZ   4E60
04E46:  MOVLB  1
04E48:  MOVF   x94,W
04E4A:  MOVLB  5
04E4C:  SUBWF  xF5,W
04E4E:  BNZ   4E60
04E50:  MOVLB  1
04E52:  MOVF   x95,W
04E54:  MOVLB  5
04E56:  SUBWF  xF6,W
04E58:  BNZ   4E60
....................       { 
....................          return TRUE; 
04E5A:  MOVLW  01
04E5C:  MOVWF  01
04E5E:  BRA    52F4
04E60:  MOVLB  1
....................       } 
04E62:  MOVLB  5
04E64:  INCF   xED,F
04E66:  BRA    4D60
....................    } 
....................  
....................  
....................    // If there is a partial match, then a listening socket is currently  
....................    // available.  Set up the extended TCB with the info needed  
....................    // to establish a connection and return this socket to the  
....................    // caller. 
....................    if(partialMatch != INVALID_SOCKET) 
04E68:  MOVF   xEE,W
04E6A:  SUBLW  FE
04E6C:  BZ    4EE2
....................    { 
....................       SyncTCBStub(partialMatch); 
04E6E:  MOVFF  5EE,5F3
04E72:  MOVLB  0
04E74:  CALL   0A74
....................       SyncTCB(); 
04E78:  CALL   1064
....................     
....................       // For SSL ports, begin the SSL Handshake 
....................       #if defined(STACK_USE_SSL_SERVER) 
....................       if(MyTCBStub.sslTxHead == h->DestPort) 
....................       { 
....................          // Try to start an SSL session.  If no stubs are available, 
....................          // we can't service this request right now, so ignore it. 
....................          if(!TCPStartSSLServer(partialMatch)) 
....................             partialMatch = INVALID_SOCKET; 
....................       } 
....................       #endif 
....................     
....................       // Make sure the above check didn't fail (this is unfortunately  
....................       // redundant for non-SSL sockets).  Otherwise, fall out to below 
....................       // and add to the SYN queue. 
....................       if(partialMatch != INVALID_SOCKET) 
04E7C:  MOVLB  5
04E7E:  MOVF   xEE,W
04E80:  SUBLW  FE
04E82:  BZ    4EE2
....................       { 
....................          MyTCBStub.remoteHash.Val = hash; 
04E84:  MOVFF  5F0,1FA
04E88:  MOVFF  5EF,1F9
....................        
....................          memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO)); 
04E8C:  MOVLW  01
04E8E:  MOVWF  xF4
04E90:  MOVLW  92
04E92:  MOVFF  5F4,FEA
04E96:  MOVWF  FE9
04E98:  MOVFF  5EC,FE2
04E9C:  MOVFF  5EB,FE1
04EA0:  MOVLW  0A
04EA2:  MOVWF  01
04EA4:  MOVFF  FE6,FEE
04EA8:  DECFSZ 01,F
04EAA:  BRA    4EA4
....................          MyTCB.remotePort.Val = h->SourcePort; 
04EAC:  MOVFF  5E9,FE9
04EB0:  MOVFF  5EA,FEA
04EB4:  MOVFF  FEC,18B
04EB8:  MOVF   FED,F
04EBA:  MOVFF  FEF,18A
....................          MyTCB.localPort.Val = h->DestPort; 
04EBE:  MOVLW  02
04EC0:  ADDWF  xE9,W
04EC2:  MOVWF  FE9
04EC4:  MOVLW  00
04EC6:  ADDWFC xEA,W
04EC8:  MOVWF  FEA
04ECA:  MOVFF  FEC,18D
04ECE:  MOVF   FED,F
04ED0:  MOVFF  FEF,18C
....................          MyTCB.txUnackedTail   = MyTCBStub.bufferTxStart; 
04ED4:  MOVFF  1E1,189
04ED8:  MOVFF  1E0,188
....................        
....................          // All done, and we have a match 
....................          return TRUE; 
04EDC:  MOVLW  01
04EDE:  MOVWF  01
04EE0:  BRA    52F4
....................       } 
....................    } 
....................  
....................    // No available sockets are listening on this port.  (Or, for 
....................    // SSL requests, perhaps no SSL sessions were available.  However, 
....................    // there may be a server socket which is currently busy but  
....................    // could handle this packet, so we should check. 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    { 
....................       WORD wQueueInsertPos; 
....................        
....................       // See if this is a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
04EE2:  MOVLW  0D
04EE4:  ADDWF  xE9,W
04EE6:  MOVWF  FE9
04EE8:  MOVLW  00
04EEA:  ADDWFC xEA,W
04EEC:  MOVWF  FEA
04EEE:  BTFSC  FEF.1
04EF0:  BRA    4EF8
....................          return FALSE; 
04EF2:  MOVLW  00
04EF4:  MOVWF  01
04EF6:  BRA    52F4
....................  
....................       // See if there is space in our SYN queue 
....................       if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort) 
04EF8:  MOVLB  1
04EFA:  MOVF   xDC,W
04EFC:  IORWF  xDD,W
04EFE:  BZ    4F0A
....................          return FALSE; 
04F00:  MOVLW  00
04F02:  MOVWF  01
04F04:  MOVLB  5
04F06:  BRA    52F4
04F08:  MOVLB  1
....................        
....................       // See if we have this SYN already in our SYN queue. 
....................       // If not already in the queue, find out where we  
....................       // should insert this SYN to the queue 
....................       for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++) 
04F0A:  MOVLB  5
04F0C:  CLRF   xF2
04F0E:  CLRF   xF1
04F10:  MOVF   xF2,F
04F12:  BTFSS  FD8.2
04F14:  BRA    50E2
04F16:  MOVF   xF1,W
04F18:  SUBLW  02
04F1A:  BTFSS  FD8.0
04F1C:  BRA    50E2
....................       { 
....................          // Exit loop if we found a free record 
....................          if(SYNQueue[wQueueInsertPos].wDestPort == 0u) 
04F1E:  MOVFF  5F2,5F4
04F22:  MOVFF  5F1,5F3
04F26:  CLRF   xF6
04F28:  MOVLW  14
04F2A:  MOVWF  xF5
04F2C:  MOVLB  0
04F2E:  CALL   2FC2
04F32:  MOVFF  01,5F3
04F36:  MOVLW  10
04F38:  MOVLB  5
04F3A:  ADDWF  01,W
04F3C:  MOVWF  01
04F3E:  MOVLW  00
04F40:  ADDWFC 02,W
04F42:  MOVWF  03
04F44:  MOVF   01,W
04F46:  ADDLW  A4
04F48:  MOVWF  FE9
04F4A:  MOVLW  01
04F4C:  ADDWFC 03,W
04F4E:  MOVWF  FEA
04F50:  MOVFF  FEC,5F4
04F54:  MOVF   FED,F
04F56:  MOVFF  FEF,5F3
04F5A:  MOVF   xF3,F
04F5C:  BNZ   4F64
04F5E:  MOVF   xF4,F
04F60:  BNZ   4F64
....................             break; 
04F62:  BRA    50E2
....................  
....................          // Check if this SYN packet is already in the SYN queue 
....................          if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort) 
04F64:  MOVFF  5F2,5F4
04F68:  MOVFF  5F1,5F3
04F6C:  CLRF   xF6
04F6E:  MOVLW  14
04F70:  MOVWF  xF5
04F72:  MOVLB  0
04F74:  CALL   2FC2
04F78:  MOVFF  01,5F3
04F7C:  MOVLW  10
04F7E:  MOVLB  5
04F80:  ADDWF  01,W
04F82:  MOVWF  01
04F84:  MOVLW  00
04F86:  ADDWFC 02,W
04F88:  MOVWF  03
04F8A:  MOVF   01,W
04F8C:  ADDLW  A4
04F8E:  MOVWF  FE9
04F90:  MOVLW  01
04F92:  ADDWFC 03,W
04F94:  MOVWF  FEA
04F96:  MOVFF  FEC,5F4
04F9A:  MOVF   FED,F
04F9C:  MOVFF  FEF,5F3
04FA0:  MOVLW  02
04FA2:  ADDWF  xE9,W
04FA4:  MOVWF  FE9
04FA6:  MOVLW  00
04FA8:  ADDWFC xEA,W
04FAA:  MOVWF  FEA
04FAC:  MOVFF  FEC,03
04FB0:  MOVF   FED,F
04FB2:  MOVF   FEF,W
04FB4:  SUBWF  xF3,W
04FB6:  BNZ   4FBE
04FB8:  MOVF   03,W
04FBA:  SUBWF  xF4,W
04FBC:  BZ    4FC0
....................             continue; 
04FBE:  BRA    50DA
....................          if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort) 
04FC0:  MOVFF  5F2,5F4
04FC4:  MOVFF  5F1,5F3
04FC8:  CLRF   xF6
04FCA:  MOVLW  14
04FCC:  MOVWF  xF5
04FCE:  MOVLB  0
04FD0:  CALL   2FC2
04FD4:  MOVFF  01,5F3
04FD8:  MOVLW  0A
04FDA:  MOVLB  5
04FDC:  ADDWF  01,W
04FDE:  MOVWF  01
04FE0:  MOVLW  00
04FE2:  ADDWFC 02,W
04FE4:  MOVWF  03
04FE6:  MOVF   01,W
04FE8:  ADDLW  A4
04FEA:  MOVWF  FE9
04FEC:  MOVLW  01
04FEE:  ADDWFC 03,W
04FF0:  MOVWF  FEA
04FF2:  MOVFF  FEC,5F4
04FF6:  MOVF   FED,F
04FF8:  MOVFF  FEF,5F3
04FFC:  MOVFF  5E9,FE9
05000:  MOVFF  5EA,FEA
05004:  MOVFF  FEC,03
05008:  MOVF   FED,F
0500A:  MOVF   FEF,W
0500C:  SUBWF  xF3,W
0500E:  BNZ   5016
05010:  MOVF   03,W
05012:  SUBWF  xF4,W
05014:  BZ    5018
....................             continue; 
05016:  BRA    50DA
....................          if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val) 
05018:  MOVFF  5F2,5F4
0501C:  MOVFF  5F1,5F3
05020:  CLRF   xF6
05022:  MOVLW  14
05024:  MOVWF  xF5
05026:  MOVLB  0
05028:  CALL   2FC2
0502C:  MOVFF  02,5F4
05030:  MOVFF  01,5F3
05034:  MOVLW  A4
05036:  MOVLB  5
05038:  ADDWF  01,W
0503A:  MOVWF  FE9
0503C:  MOVLW  01
0503E:  ADDWFC 02,W
05040:  MOVWF  FEA
05042:  MOVFF  FEF,5F5
05046:  MOVFF  FEC,5F6
0504A:  MOVFF  FEC,5F7
0504E:  MOVFF  FEC,5F8
05052:  MOVFF  5EB,FE9
05056:  MOVFF  5EC,FEA
0505A:  MOVFF  FEF,00
0505E:  MOVFF  FEC,01
05062:  MOVFF  FEC,02
05066:  MOVFF  FEC,03
0506A:  MOVF   00,W
0506C:  SUBWF  xF5,W
0506E:  BNZ   5082
05070:  MOVF   01,W
05072:  SUBWF  xF6,W
05074:  BNZ   5082
05076:  MOVF   02,W
05078:  SUBWF  xF7,W
0507A:  BNZ   5082
0507C:  MOVF   03,W
0507E:  SUBWF  xF8,W
05080:  BZ    5084
....................             continue; 
05082:  BRA    50DA
....................  
....................          // SYN matches SYN queue entry.  Update timestamp and do nothing. 
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
05084:  MOVFF  5F2,5F4
05088:  MOVFF  5F1,5F3
0508C:  CLRF   xF6
0508E:  MOVLW  14
05090:  MOVWF  xF5
05092:  MOVLB  0
05094:  CALL   2FC2
05098:  MOVFF  01,5F3
0509C:  MOVLW  12
0509E:  MOVLB  5
050A0:  ADDWF  01,W
050A2:  MOVWF  01
050A4:  MOVLW  00
050A6:  ADDWFC 02,W
050A8:  MOVWF  03
050AA:  MOVF   01,W
050AC:  ADDLW  A4
050AE:  MOVWF  01
050B0:  MOVLW  01
050B2:  ADDWFC 03,F
050B4:  MOVFF  01,5F3
050B8:  MOVFF  03,5F4
050BC:  MOVLB  0
050BE:  CALL   2F9C
050C2:  MOVFF  5F4,FEA
050C6:  MOVFF  5F3,FE9
050CA:  MOVFF  00,FEF
050CE:  MOVFF  01,FEC
....................          return FALSE; 
050D2:  MOVLW  00
050D4:  MOVWF  01
050D6:  MOVLB  5
050D8:  BRA    52F4
050DA:  INCF   xF1,F
050DC:  BTFSC  FD8.2
050DE:  INCF   xF2,F
050E0:  BRA    4F10
....................       } 
....................        
....................       // Check to see if we have any server sockets which  
....................       // are currently connected, but could handle this SYN  
....................       // request at a later time if the client disconnects. 
....................       for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
050E2:  CLRF   xED
050E4:  MOVF   xED,F
050E6:  BTFSS  FD8.2
050E8:  BRA    52F0
....................       { 
....................          SyncTCBStub(hTCP); 
050EA:  MOVFF  5ED,5F3
050EE:  MOVLB  0
050F0:  CALL   0A74
....................          if(!MyTCBStub.Flags.bServer) 
050F4:  MOVLB  1
050F6:  BTFSC  xF7.3
050F8:  BRA    50FC
....................             continue; 
050FA:  BRA    52EA
....................  
....................          SyncTCB(); 
050FC:  MOVLB  0
050FE:  CALL   1064
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort)) 
....................          #else 
....................          if(MyTCB.localPort.Val != h->DestPort) 
05102:  MOVLW  02
05104:  MOVLB  5
05106:  ADDWF  xE9,W
05108:  MOVWF  FE9
0510A:  MOVLW  00
0510C:  ADDWFC xEA,W
0510E:  MOVWF  FEA
05110:  MOVFF  FEC,03
05114:  MOVF   FED,F
05116:  MOVF   FEF,W
05118:  MOVLB  1
0511A:  SUBWF  x8C,W
0511C:  BNZ   5124
0511E:  MOVF   03,W
05120:  SUBWF  x8D,W
05122:  BZ    5126
....................          #endif 
....................             continue; 
05124:  BRA    52EA
....................  
....................          // Generate the SYN queue entry 
....................          memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO)); 
05126:  MOVFF  5F2,5F4
0512A:  MOVFF  5F1,5F3
0512E:  MOVLB  5
05130:  CLRF   xF6
05132:  MOVLW  14
05134:  MOVWF  xF5
05136:  MOVLB  0
05138:  CALL   2FC2
0513C:  MOVFF  02,5F4
05140:  MOVFF  01,5F3
05144:  MOVLW  A4
05146:  MOVLB  5
05148:  ADDWF  01,W
0514A:  MOVWF  01
0514C:  MOVLW  01
0514E:  ADDWFC 02,W
05150:  MOVWF  03
05152:  MOVFF  01,5F5
05156:  MOVWF  xF6
05158:  MOVWF  FEA
0515A:  MOVFF  01,FE9
0515E:  MOVFF  5EC,FE2
05162:  MOVFF  5EB,FE1
05166:  MOVLW  0A
05168:  MOVWF  01
0516A:  MOVFF  FE6,FEE
0516E:  DECFSZ 01,F
05170:  BRA    516A
....................          SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort; 
05172:  MOVFF  5F2,5F4
05176:  MOVFF  5F1,5F3
0517A:  CLRF   xF6
0517C:  MOVLW  14
0517E:  MOVWF  xF5
05180:  MOVLB  0
05182:  CALL   2FC2
05186:  MOVFF  01,5F3
0518A:  MOVLW  0A
0518C:  MOVLB  5
0518E:  ADDWF  01,W
05190:  MOVWF  01
05192:  MOVLW  00
05194:  ADDWFC 02,W
05196:  MOVWF  03
05198:  MOVF   01,W
0519A:  ADDLW  A4
0519C:  MOVWF  01
0519E:  MOVLW  01
051A0:  ADDWFC 03,F
051A2:  MOVFF  03,5F4
051A6:  MOVFF  5E9,FE9
051AA:  MOVFF  5EA,FEA
051AE:  MOVFF  FEC,03
051B2:  MOVF   FED,F
051B4:  MOVFF  FEF,5F5
051B8:  MOVFF  5F4,FEA
051BC:  MOVFF  01,FE9
051C0:  MOVFF  03,FEC
051C4:  MOVF   FED,F
051C6:  MOVFF  5F5,FEF
....................          SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber; 
051CA:  MOVFF  5F2,5F4
051CE:  MOVFF  5F1,5F3
051D2:  CLRF   xF6
051D4:  MOVLW  14
051D6:  MOVWF  xF5
051D8:  MOVLB  0
051DA:  CALL   2FC2
051DE:  MOVFF  01,5F3
051E2:  MOVLW  0C
051E4:  MOVLB  5
051E6:  ADDWF  01,W
051E8:  MOVWF  01
051EA:  MOVLW  00
051EC:  ADDWFC 02,W
051EE:  MOVWF  03
051F0:  MOVF   01,W
051F2:  ADDLW  A4
051F4:  MOVWF  01
051F6:  MOVLW  01
051F8:  ADDWFC 03,F
051FA:  MOVFF  01,5F3
051FE:  MOVFF  03,5F4
05202:  MOVLW  04
05204:  ADDWF  xE9,W
05206:  MOVWF  FE9
05208:  MOVLW  00
0520A:  ADDWFC xEA,W
0520C:  MOVWF  FEA
0520E:  MOVFF  FEF,00
05212:  MOVFF  FEC,01
05216:  MOVFF  FEC,02
0521A:  MOVFF  FEC,03
0521E:  MOVFF  5F4,FEA
05222:  MOVFF  5F3,FE9
05226:  MOVFF  00,FEF
0522A:  MOVFF  01,FEC
0522E:  MOVFF  02,FEC
05232:  MOVFF  03,FEC
....................          SYNQueue[wQueueInsertPos].wDestPort = h->DestPort; 
05236:  MOVFF  5F2,5F4
0523A:  MOVFF  5F1,5F3
0523E:  CLRF   xF6
05240:  MOVLW  14
05242:  MOVWF  xF5
05244:  MOVLB  0
05246:  CALL   2FC2
0524A:  MOVFF  01,5F3
0524E:  MOVLW  10
05250:  MOVLB  5
05252:  ADDWF  01,W
05254:  MOVWF  01
05256:  MOVLW  00
05258:  ADDWFC 02,W
0525A:  MOVWF  03
0525C:  MOVF   01,W
0525E:  ADDLW  A4
05260:  MOVWF  01
05262:  MOVLW  01
05264:  ADDWFC 03,F
05266:  MOVFF  03,5F4
0526A:  MOVLW  02
0526C:  ADDWF  xE9,W
0526E:  MOVWF  FE9
05270:  MOVLW  00
05272:  ADDWFC xEA,W
05274:  MOVWF  FEA
05276:  MOVFF  FEC,03
0527A:  MOVF   FED,F
0527C:  MOVFF  FEF,5F5
05280:  MOVFF  5F4,FEA
05284:  MOVFF  01,FE9
05288:  MOVFF  03,FEC
0528C:  MOVF   FED,F
0528E:  MOVFF  5F5,FEF
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
05292:  MOVFF  5F2,5F4
05296:  MOVFF  5F1,5F3
0529A:  CLRF   xF6
0529C:  MOVLW  14
0529E:  MOVWF  xF5
052A0:  MOVLB  0
052A2:  CALL   2FC2
052A6:  MOVFF  01,5F3
052AA:  MOVLW  12
052AC:  MOVLB  5
052AE:  ADDWF  01,W
052B0:  MOVWF  01
052B2:  MOVLW  00
052B4:  ADDWFC 02,W
052B6:  MOVWF  03
052B8:  MOVF   01,W
052BA:  ADDLW  A4
052BC:  MOVWF  01
052BE:  MOVLW  01
052C0:  ADDWFC 03,F
052C2:  MOVFF  01,5F3
052C6:  MOVFF  03,5F4
052CA:  MOVLB  0
052CC:  CALL   2F9C
052D0:  MOVFF  5F4,FEA
052D4:  MOVFF  5F3,FE9
052D8:  MOVFF  00,FEF
052DC:  MOVFF  01,FEC
....................  
....................          return FALSE; 
052E0:  MOVLW  00
052E2:  MOVWF  01
052E4:  MOVLB  5
052E6:  BRA    52F4
052E8:  MOVLB  1
052EA:  MOVLB  5
052EC:  INCF   xED,F
052EE:  BRA    50E4
....................       } 
....................    } 
....................    #endif 
....................        
....................    return FALSE; 
052F0:  MOVLW  00
052F2:  MOVWF  01
052F4:  MOVLB  0
052F6:  GOTO   68EA (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SwapTCPHeader(TCP_HEADER* header) 
....................  
....................   Summary: 
....................    Swaps endian-ness of a TCP header. 
....................  
....................   Description: 
....................    This function swaps the endian-ness of a given TCP header for comparison. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    header - The TCP header that is to be swapped 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................    header->SourcePort      = swaps(header->SourcePort); 
*
03272:  MOVLB  6
03274:  MOVFF  633,01
03278:  MOVFF  634,03
0327C:  MOVFF  633,635
03280:  MOVFF  634,636
03284:  MOVFF  633,FE9
03288:  MOVFF  634,FEA
0328C:  MOVFF  FEC,653
03290:  MOVF   FED,F
03292:  MOVFF  FEF,652
03296:  MOVLB  0
03298:  CALL   1A42
0329C:  MOVFF  636,FEA
032A0:  MOVFF  635,FE9
032A4:  MOVFF  02,FEC
032A8:  MOVF   FED,F
032AA:  MOVFF  01,FEF
....................    header->DestPort        = swaps(header->DestPort); 
032AE:  MOVLW  02
032B0:  MOVLB  6
032B2:  ADDWF  x33,W
032B4:  MOVWF  01
032B6:  MOVLW  00
032B8:  ADDWFC x34,W
032BA:  MOVWF  03
032BC:  MOVFF  01,635
032C0:  MOVWF  x36
032C2:  MOVLW  02
032C4:  ADDWF  x33,W
032C6:  MOVWF  FE9
032C8:  MOVLW  00
032CA:  ADDWFC x34,W
032CC:  MOVWF  FEA
032CE:  MOVFF  FEC,653
032D2:  MOVF   FED,F
032D4:  MOVFF  FEF,652
032D8:  MOVLB  0
032DA:  CALL   1A42
032DE:  MOVFF  636,FEA
032E2:  MOVFF  635,FE9
032E6:  MOVFF  02,FEC
032EA:  MOVF   FED,F
032EC:  MOVFF  01,FEF
....................    header->SeqNumber       = swapl(header->SeqNumber); 
032F0:  MOVLW  04
032F2:  MOVLB  6
032F4:  ADDWF  x33,W
032F6:  MOVWF  01
032F8:  MOVLW  00
032FA:  ADDWFC x34,W
032FC:  MOVWF  03
032FE:  MOVFF  01,635
03302:  MOVWF  x36
03304:  MOVLW  04
03306:  ADDWF  x33,W
03308:  MOVWF  FE9
0330A:  MOVLW  00
0330C:  ADDWFC x34,W
0330E:  MOVWF  FEA
03310:  MOVFF  FEF,63B
03314:  MOVFF  FEC,63C
03318:  MOVFF  FEC,63D
0331C:  MOVFF  FEC,63E
03320:  MOVLB  0
03322:  RCALL  30FC
03324:  MOVFF  636,FEA
03328:  MOVFF  635,FE9
0332C:  MOVFF  00,FEF
03330:  MOVFF  01,FEC
03334:  MOVFF  02,FEC
03338:  MOVFF  03,FEC
....................    header->AckNumber       = swapl(header->AckNumber); 
0333C:  MOVLW  08
0333E:  MOVLB  6
03340:  ADDWF  x33,W
03342:  MOVWF  01
03344:  MOVLW  00
03346:  ADDWFC x34,W
03348:  MOVWF  03
0334A:  MOVFF  01,635
0334E:  MOVWF  x36
03350:  MOVLW  08
03352:  ADDWF  x33,W
03354:  MOVWF  FE9
03356:  MOVLW  00
03358:  ADDWFC x34,W
0335A:  MOVWF  FEA
0335C:  MOVFF  FEF,63B
03360:  MOVFF  FEC,63C
03364:  MOVFF  FEC,63D
03368:  MOVFF  FEC,63E
0336C:  MOVLB  0
0336E:  RCALL  30FC
03370:  MOVFF  636,FEA
03374:  MOVFF  635,FE9
03378:  MOVFF  00,FEF
0337C:  MOVFF  01,FEC
03380:  MOVFF  02,FEC
03384:  MOVFF  03,FEC
....................    header->Window          = swaps(header->Window); 
03388:  MOVLW  0E
0338A:  MOVLB  6
0338C:  ADDWF  x33,W
0338E:  MOVWF  01
03390:  MOVLW  00
03392:  ADDWFC x34,W
03394:  MOVWF  03
03396:  MOVFF  01,635
0339A:  MOVWF  x36
0339C:  MOVLW  0E
0339E:  ADDWF  x33,W
033A0:  MOVWF  FE9
033A2:  MOVLW  00
033A4:  ADDWFC x34,W
033A6:  MOVWF  FEA
033A8:  MOVFF  FEC,653
033AC:  MOVF   FED,F
033AE:  MOVFF  FEF,652
033B2:  MOVLB  0
033B4:  CALL   1A42
033B8:  MOVFF  636,FEA
033BC:  MOVFF  635,FE9
033C0:  MOVFF  02,FEC
033C4:  MOVF   FED,F
033C6:  MOVFF  01,FEF
....................    header->Checksum        = swaps(header->Checksum); 
033CA:  MOVLW  10
033CC:  MOVLB  6
033CE:  ADDWF  x33,W
033D0:  MOVWF  01
033D2:  MOVLW  00
033D4:  ADDWFC x34,W
033D6:  MOVWF  03
033D8:  MOVFF  01,635
033DC:  MOVWF  x36
033DE:  MOVLW  10
033E0:  ADDWF  x33,W
033E2:  MOVWF  FE9
033E4:  MOVLW  00
033E6:  ADDWFC x34,W
033E8:  MOVWF  FEA
033EA:  MOVFF  FEC,653
033EE:  MOVF   FED,F
033F0:  MOVFF  FEF,652
033F4:  MOVLB  0
033F6:  CALL   1A42
033FA:  MOVFF  636,FEA
033FE:  MOVFF  635,FE9
03402:  MOVFF  02,FEC
03406:  MOVF   FED,F
03408:  MOVFF  01,FEF
....................    header->UrgentPointer   = swaps(header->UrgentPointer); 
0340C:  MOVLW  12
0340E:  MOVLB  6
03410:  ADDWF  x33,W
03412:  MOVWF  01
03414:  MOVLW  00
03416:  ADDWFC x34,W
03418:  MOVWF  03
0341A:  MOVFF  01,635
0341E:  MOVWF  x36
03420:  MOVLW  12
03422:  ADDWF  x33,W
03424:  MOVWF  FE9
03426:  MOVLW  00
03428:  ADDWFC x34,W
0342A:  MOVWF  FEA
0342C:  MOVFF  FEC,653
03430:  MOVF   FED,F
03432:  MOVFF  FEF,652
03436:  MOVLB  0
03438:  CALL   1A42
0343C:  MOVFF  636,FEA
03440:  MOVFF  635,FE9
03444:  MOVFF  02,FEC
03448:  MOVF   FED,F
0344A:  MOVFF  01,FEF
0344E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void CloseSocket(void) 
....................  
....................   Summary: 
....................    Closes a TCP socket. 
....................  
....................   Description: 
....................    This function closes a TCP socket.  All socket state information is  
....................    reset, and any buffered bytes are discarded.  The socket is no longer 
....................    accessible by the application after this point. 
....................  
....................   Precondition: 
....................    The TCPStub corresponding to the socket to be closed is synced. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void CloseSocket(void) 
.................... { 
....................    SyncTCB(); 
*
01138:  RCALL  1064
....................  
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
0113A:  MOVFF  18D,1FA
0113E:  MOVFF  18C,1F9
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
01142:  MOVFF  1E1,1E7
01146:  MOVFF  1E0,1E6
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
0114A:  MOVFF  1E1,1E9
0114E:  MOVFF  1E0,1E8
....................    MyTCBStub.rxHead = MyTCBStub.bufferRxStart; 
01152:  MOVFF  1E3,1EB
01156:  MOVFF  1E2,1EA
....................    MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
0115A:  MOVFF  1E3,1ED
0115E:  MOVFF  1E2,1EC
....................    MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED; 
01162:  MOVLB  1
01164:  BTFSS  xF7.3
01166:  BRA    116C
01168:  MOVLW  04
0116A:  BRA    116E
0116C:  MOVLW  0D
0116E:  MOVWF  xF6
....................    MyTCBStub.Flags.vUnackedKeepalives = 0; 
01170:  MOVLW  F8
01172:  ANDWF  xF7,W
01174:  MOVWF  xF7
....................    MyTCBStub.Flags.bTimerEnabled = 0; 
01176:  BCF    xF7.4
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
01178:  BCF    xF7.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
0117A:  BCF    xF7.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
0117C:  BCF    xF7.7
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
0117E:  BCF    xF8.0
....................    MyTCBStub.Flags.bTXASAP = 0; 
01180:  BCF    xF8.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
01182:  BCF    xF8.2
....................    MyTCBStub.Flags.bTXFIN = 0; 
01184:  BCF    xF8.3
....................    MyTCBStub.Flags.bSocketReset = 1; 
01186:  BSF    xF8.4
....................  
....................    #if defined(STACK_USE_SSL) 
....................    // If SSL is active, then we need to close it 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       SSLTerminate(MyTCBStub.sslStubID); 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................  
....................       // Swap the SSL port and local port back to proper values 
....................       MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val; 
....................       MyTCB.localSSLPort.Val = MyTCB.localPort.Val; 
....................       MyTCB.localPort.Val = MyTCBStub.remoteHash.Val; 
....................    } 
....................  
....................    // Reset the SSL buffer pointers 
....................    MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart; 
....................    MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SSL_SERVER) 
....................    MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val; 
....................    #endif 
....................  
....................    MyTCB.flags.bFINSent = 0; 
01188:  BCF    x9E.0
....................    MyTCB.flags.bSYNSent = 0; 
0118A:  BCF    x9E.1
....................    MyTCB.flags.bRXNoneACKed1 = 0; 
0118C:  BCF    x9E.3
....................    MyTCB.flags.bRXNoneACKed2 = 0; 
0118E:  BCF    x9E.4
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
01190:  MOVFF  1E1,189
01194:  MOVFF  1E0,188
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand(); 
01198:  MOVLW  01
0119A:  MOVLB  6
0119C:  MOVWF  x0A
0119E:  MOVLW  80
011A0:  MOVWF  x09
011A2:  MOVWF  01
011A4:  MOVFF  60A,03
011A8:  MOVWF  x0B
011AA:  MOVFF  60A,60C
011AE:  MOVLB  0
011B0:  CALL   0312
011B4:  MOVFF  60C,FEA
011B8:  MOVFF  60B,FE9
011BC:  MOVFF  02,FEC
011C0:  MOVF   FED,F
011C2:  MOVFF  01,FEF
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand(); 
011C6:  MOVLW  01
011C8:  MOVLB  6
011CA:  MOVWF  x0A
011CC:  MOVLW  80
011CE:  MOVWF  x09
011D0:  MOVLW  02
011D2:  ADDWF  x09,W
011D4:  MOVWF  01
011D6:  MOVLW  00
011D8:  ADDWFC x0A,W
011DA:  MOVWF  03
011DC:  MOVFF  01,60B
011E0:  MOVWF  x0C
011E2:  MOVLB  0
011E4:  CALL   0312
011E8:  MOVFF  60C,FEA
011EC:  MOVFF  60B,FE9
011F0:  MOVFF  02,FEC
011F4:  MOVF   FED,F
011F6:  MOVFF  01,FEF
....................    MyTCB.sHoleSize = -1; 
011FA:  MOVLB  1
011FC:  SETF   x9D
011FE:  SETF   x9C
....................    MyTCB.remoteWindow = 1; 
01200:  CLRF   x8F
01202:  MOVLW  01
01204:  MOVWF  x8E
01206:  MOVLB  0
01208:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static WORD GetMaxSegSizeOption(void) 
....................  
....................   Summary: 
....................    Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header  
....................    for the current socket. 
....................  
....................   Description: 
....................    Parses the current TCP packet header and extracts the Maximum Segment Size  
....................    option.   
....................  
....................   Precondition: 
....................    Must be called while a TCP packet is present and being processed via  
....................    HandleTCPSeg() and only if the the TCP SYN flag is set. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    Maximum segment size option value.  If illegal or not present, a failsafe  
....................    value of 536 is returned.  If the option is larger than the  
....................    TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned. 
....................  
....................   Remarks: 
....................    The internal MAC Read Pointer is moved but not restored. 
....................   ***************************************************************************/ 
.................... static WORD GetMaxSegSizeOption(void) 
.................... { 
....................    BYTE vOptionsBytes; 
....................    BYTE vOption; 
....................    WORD wMSS; 
....................  
....................    // Find out how many options bytes are in this packet. 
....................    IPSetRxBuffer(2+2+4+4);   // Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4) 
*
052FA:  MOVLB  6
052FC:  CLRF   x0E
052FE:  MOVLW  0C
05300:  MOVWF  x0D
05302:  MOVLB  0
05304:  CALL   247A
....................    vOptionsBytes = MACGet(); 
05308:  CALL   0C9E
0530C:  MOVFF  01,609
....................    vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER); 
05310:  MOVLB  6
05312:  MOVF   x09,W
05314:  ANDLW  F0
05316:  MOVWF  x0D
05318:  CLRF   x0E
0531A:  RRCF   x0E,F
0531C:  RRCF   x0D,F
0531E:  RRCF   x0E,F
05320:  RRCF   x0D,F
05322:  MOVLW  3F
05324:  ANDWF  x0E,F
05326:  MOVLW  14
05328:  SUBWF  x0D,W
0532A:  MOVWF  x09
....................  
....................    // Return minimum Maximum Segment Size value of 536 bytes if none are  
....................    // present 
....................    if(vOptionsBytes == 0u) 
0532C:  MOVF   x09,F
0532E:  BNZ   533A
....................       return 536; 
05330:  MOVLW  18
05332:  MOVWF  01
05334:  MOVLW  02
05336:  MOVWF  02
05338:  BRA    541A
....................        
....................    // Seek to beginning of options 
....................    MACGetArray(NULL, 7); 
0533A:  CLRF   x56
0533C:  CLRF   x55
0533E:  CLRF   x58
05340:  MOVLW  07
05342:  MOVWF  x57
05344:  MOVLB  0
05346:  CALL   0C28
....................  
....................    // Search for the Maximum Segment Size option    
....................    while(vOptionsBytes--) 
0534A:  MOVLB  6
0534C:  MOVF   x09,W
0534E:  DECF   x09,F
05350:  XORLW  00
05352:  BTFSC  FD8.2
05354:  BRA    5412
....................    { 
....................       vOption = MACGet(); 
05356:  MOVLB  0
05358:  CALL   0C9E
0535C:  MOVFF  01,60A
....................        
....................       if(vOption == 0u)   // End of Options list 
05360:  MOVLB  6
05362:  MOVF   x0A,F
05364:  BNZ   5368
....................          break; 
05366:  BRA    5412
....................        
....................       if(vOption == 1u)   // NOP option 
05368:  DECFSZ x0A,W
0536A:  BRA    536E
....................          continue; 
0536C:  BRA    534C
....................           
....................       if(vOption == 2u)   // Maximum Segment Size option 
0536E:  MOVF   x0A,W
05370:  SUBLW  02
05372:  BNZ   53DE
....................       { 
....................          if(vOptionsBytes < 3u) 
05374:  MOVF   x09,W
05376:  SUBLW  02
05378:  BNC   537C
....................             break; 
0537A:  BRA    5412
....................  
....................          wMSS = 0; 
0537C:  CLRF   x0C
0537E:  CLRF   x0B
....................              
....................          // Get option length 
....................          vOption = MACGet(); 
05380:  MOVLB  0
05382:  CALL   0C9E
05386:  MOVFF  01,60A
....................          if(vOption == 4u) 
0538A:  MOVLB  6
0538C:  MOVF   x0A,W
0538E:  SUBLW  04
05390:  BNZ   53A6
....................          {// Retrieve MSS and swap value to little endian 
....................             ((BYTE*)&wMSS)[1] = MACGet(); 
05392:  MOVLB  0
05394:  CALL   0C9E
05398:  MOVFF  01,60C
....................             ((BYTE*)&wMSS)[0] = MACGet(); 
0539C:  CALL   0C9E
053A0:  MOVFF  01,60B
053A4:  MOVLB  6
....................          } 
....................           
....................          if(wMSS < 536u) 
053A6:  MOVF   x0C,W
053A8:  SUBLW  02
053AA:  BNC   53B6
053AC:  BNZ   53B4
053AE:  MOVF   x0B,W
053B0:  SUBLW  17
053B2:  BNC   53B6
....................             break; 
053B4:  BRA    5412
....................          if(wMSS > TCP_MAX_SEG_SIZE_TX) 
053B6:  MOVF   x0C,W
053B8:  SUBLW  04
053BA:  BC    53D2
053BC:  XORLW  FF
053BE:  BNZ   53C6
053C0:  MOVF   x0B,W
053C2:  SUBLW  B4
053C4:  BC    53D2
....................             return TCP_MAX_SEG_SIZE_TX; 
053C6:  MOVLW  B4
053C8:  MOVWF  01
053CA:  MOVLW  05
053CC:  MOVWF  02
053CE:  BRA    541A
053D0:  BRA    53DC
....................          else  
....................             return wMSS; 
053D2:  MOVFF  60B,01
053D6:  MOVFF  60C,02
053DA:  BRA    541A
....................       } 
053DC:  BRA    5410
....................       else 
....................       { // Assume this is a multi byte option and throw it way 
....................          if(vOptionsBytes < 2u) 
053DE:  MOVF   x09,W
053E0:  SUBLW  01
053E2:  BNC   53E6
....................             break; 
053E4:  BRA    5412
....................          vOption = MACGet(); 
053E6:  MOVLB  0
053E8:  CALL   0C9E
053EC:  MOVFF  01,60A
....................          if(vOptionsBytes < vOption) 
053F0:  MOVLB  6
053F2:  MOVF   x0A,W
053F4:  SUBWF  x09,W
053F6:  BC    53FA
....................             break; 
053F8:  BRA    5412
....................          MACGetArray(NULL, vOption); 
053FA:  CLRF   x56
053FC:  CLRF   x55
053FE:  CLRF   x58
05400:  MOVFF  60A,657
05404:  MOVLB  0
05406:  CALL   0C28
....................          vOptionsBytes -= vOption; 
0540A:  MOVLB  6
0540C:  MOVF   x0A,W
0540E:  SUBWF  x09,F
....................       } 
05410:  BRA    534C
....................        
....................    } 
....................     
....................    // Did not find MSS option, return worst case default 
....................    return 536; 
05412:  MOVLW  18
05414:  MOVWF  01
05416:  MOVLW  02
05418:  MOVWF  02
0541A:  MOVLB  0
0541C:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
....................  
....................   Summary: 
....................    Processes an incoming TCP segment. 
....................  
....................   Description: 
....................    Once an incoming segment has been matched to a socket, this function 
....................    performs the necessary processing with the data.  Depending on the  
....................    segment and the state, this may include copying data to the TCP buffer, 
....................    re-assembling out-of order packets, continuing an initialization or  
....................    closing handshake, or closing the socket altogether. 
....................  
....................   Precondition: 
....................    TCP is initialized and the current TCP stub is already synced. 
....................  
....................   Parameters: 
....................    h - The TCP header for this packet 
....................    len - The total buffer length of this segment 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
.................... { 
....................    DWORD dwTemp; 
....................    PTR_BASE wTemp; 
....................    LONG lMissingBytes; 
....................    WORD wMissingBytes; 
....................    WORD wFreeSpace; 
....................    BYTE localHeaderFlags; 
....................    DWORD localAckNumber; 
....................    DWORD localSeqNumber; 
....................    WORD wSegmentLength; 
....................    BOOL bSegmentAcceptable; 
....................    WORD wNewWindow; 
....................  
....................  
....................    // Cache a few variables in local RAM.   
....................    // PIC18s take a fair amount of code and execution time to  
....................    // dereference pointers frequently. 
....................    localHeaderFlags = h->Flags.byte; 
0541E:  MOVLW  0D
05420:  MOVLB  5
05422:  ADDWF  xE9,W
05424:  MOVWF  FE9
05426:  MOVLW  00
05428:  ADDWFC xEA,W
0542A:  MOVWF  FEA
0542C:  MOVFF  FEF,5FB
....................    localAckNumber = h->AckNumber; 
05430:  MOVLW  08
05432:  ADDWF  xE9,W
05434:  MOVWF  FE9
05436:  MOVLW  00
05438:  ADDWFC xEA,W
0543A:  MOVWF  FEA
0543C:  MOVFF  FEF,5FC
05440:  MOVFF  FEC,5FD
05444:  MOVFF  FEC,5FE
05448:  MOVFF  FEC,5FF
....................    localSeqNumber = h->SeqNumber; 
0544C:  MOVLW  04
0544E:  ADDWF  xE9,W
05450:  MOVWF  FE9
05452:  MOVLW  00
05454:  ADDWFC xEA,W
05456:  MOVWF  FEA
05458:  MOVFF  FEF,600
0545C:  MOVFF  FEC,601
05460:  MOVFF  FEC,602
05464:  MOVFF  FEC,603
....................  
....................    // We received a packet, reset the keep alive timer and count 
....................    #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................       MyTCBStub.Flags.vUnackedKeepalives = 0; 
05468:  MOVLW  F8
0546A:  MOVLB  1
0546C:  ANDWF  xF7,W
0546E:  MOVWF  xF7
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
05470:  BTFSC  xF7.4
05472:  BRA    54A2
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
05474:  MOVLB  0
05476:  CALL   23FC
0547A:  MOVLW  B4
0547C:  MOVLB  6
0547E:  ADDWF  00,W
05480:  MOVLB  1
05482:  MOVWF  xEE
05484:  MOVLW  C4
05486:  MOVLB  6
05488:  ADDWFC 01,W
0548A:  MOVLB  1
0548C:  MOVWF  xEF
0548E:  MOVLW  04
05490:  MOVLB  6
05492:  ADDWFC 02,W
05494:  MOVLB  1
05496:  MOVWF  xF0
05498:  MOVLW  00
0549A:  MOVLB  6
0549C:  ADDWFC 03,W
0549E:  MOVLB  1
054A0:  MOVWF  xF1
....................    #endif 
....................  
....................    // Handle TCP_LISTEN and TCP_SYN_SENT states 
....................    // Both of these states will return, so code following this  
....................    // state machine need not check explicitly for these two  
....................    // states. 
....................    switch(MyTCBStub.smState) 
054A2:  MOVF   xF6,W
054A4:  XORLW  04
054A6:  MOVLB  0
054A8:  BZ    54B0
054AA:  XORLW  01
054AC:  BZ    556C
054AE:  BRA    56D2
....................    { 
....................       case TCP_LISTEN: 
....................          // First: check RST flag 
....................          if(localHeaderFlags & RST) 
054B0:  MOVLB  5
054B2:  MOVF   xFB,W
054B4:  ANDLW  04
054B6:  MOVWF  00
054B8:  CLRF   03
054BA:  MOVF   00,W
054BC:  IORWF  03,W
054BE:  BZ    54CC
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
054C0:  MOVLB  0
054C2:  CALL   1138
....................             return; 
054C6:  GOTO   679A
054CA:  MOVLB  5
....................          } 
....................  
....................          // Second: check ACK flag, which would be invalid 
....................          if(localHeaderFlags & ACK) 
054CC:  MOVF   xFB,W
054CE:  ANDLW  10
054D0:  MOVWF  00
054D2:  CLRF   03
054D4:  MOVF   00,W
054D6:  IORWF  03,W
054D8:  BZ    5502
....................          { 
....................             // Use a believable sequence number and reset the remote node 
....................             MyTCB.MySEQ = localAckNumber; 
054DA:  MOVFF  5FF,183
054DE:  MOVFF  5FE,182
054E2:  MOVFF  5FD,181
054E6:  MOVFF  5FC,180
....................             SendTCP(RST, 0); 
054EA:  MOVLW  04
054EC:  MOVLB  6
054EE:  MOVWF  x09
054F0:  CLRF   x0A
054F2:  MOVLB  0
054F4:  CALL   3598
....................             CloseSocket();   // Unbind remote IP address/port info 
054F8:  CALL   1138
....................             return; 
054FC:  GOTO   679A
05500:  MOVLB  5
....................          } 
....................  
....................          // Third: check for SYN flag, which is what we're looking for 
....................          if(localHeaderFlags & SYN) 
05502:  MOVF   xFB,W
05504:  ANDLW  02
05506:  MOVWF  00
05508:  CLRF   03
0550A:  MOVF   00,W
0550C:  IORWF  03,W
0550E:  BZ    555E
....................          { 
....................             // We now have a sequence number for the remote node 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
05510:  MOVLW  01
05512:  MOVLB  6
05514:  ADDWF  x00,W
05516:  MOVLB  1
05518:  MOVWF  x84
0551A:  MOVLW  00
0551C:  MOVLB  6
0551E:  ADDWFC x01,W
05520:  MOVLB  1
05522:  MOVWF  x85
05524:  MOVLW  00
05526:  MOVLB  6
05528:  ADDWFC x02,W
0552A:  MOVLB  1
0552C:  MOVWF  x86
0552E:  MOVLW  00
05530:  MOVLB  6
05532:  ADDWFC x03,W
05534:  MOVLB  1
05536:  MOVWF  x87
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
05538:  MOVLB  0
0553A:  RCALL  52FA
0553C:  MOVFF  02,1A0
05540:  MOVFF  01,19F
....................  
....................             // Set Initial Send Sequence (ISS) number 
....................             // Nothing to do on this step... ISS already set in CloseSocket() 
....................              
....................             // Respond with SYN + ACK 
....................             SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
05544:  MOVLW  12
05546:  MOVLB  6
05548:  MOVWF  x09
0554A:  MOVLW  01
0554C:  MOVWF  x0A
0554E:  MOVLB  0
05550:  CALL   3598
....................             MyTCBStub.smState = TCP_SYN_RECEIVED; 
05554:  MOVLW  06
05556:  MOVLB  1
05558:  MOVWF  xF6
....................          } 
0555A:  BRA    5566
0555C:  MOVLB  5
....................          else 
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
0555E:  MOVLB  0
05560:  CALL   1138
05564:  MOVLB  1
....................          } 
....................  
....................          // Fourth: check for other text and control 
....................          // Nothing to do since we don't support this 
....................          return; 
05566:  MOVLB  0
05568:  GOTO   679A
....................  
....................       case TCP_SYN_SENT: 
....................          // Second: check the RST bit 
....................          // This is out of order because this stack has no API for  
....................          // notifying the application that the connection seems to  
....................          // be failing.  Instead, the application must time out and  
....................          // the stack will just keep trying in the mean time. 
....................          if(localHeaderFlags & RST) 
0556C:  MOVLB  5
0556E:  MOVF   xFB,W
05570:  ANDLW  04
05572:  MOVWF  00
05574:  CLRF   03
05576:  MOVF   00,W
05578:  IORWF  03,W
0557A:  BZ    5584
....................             return; 
0557C:  MOVLB  0
0557E:  GOTO   679A
05582:  MOVLB  5
....................  
....................          // First: check ACK bit 
....................          if(localHeaderFlags & ACK) 
05584:  MOVF   xFB,W
05586:  ANDLW  10
05588:  MOVWF  00
0558A:  CLRF   03
0558C:  MOVF   00,W
0558E:  IORWF  03,W
05590:  BZ    5600
....................          { 
....................             if(localAckNumber != MyTCB.MySEQ) 
05592:  MOVLB  1
05594:  MOVF   x80,W
05596:  MOVLB  5
05598:  SUBWF  xFC,W
0559A:  BNZ   55BA
0559C:  MOVLB  1
0559E:  MOVF   x81,W
055A0:  MOVLB  5
055A2:  SUBWF  xFD,W
055A4:  BNZ   55BA
055A6:  MOVLB  1
055A8:  MOVF   x82,W
055AA:  MOVLB  5
055AC:  SUBWF  xFE,W
055AE:  BNZ   55BA
055B0:  MOVLB  1
055B2:  MOVF   x83,W
055B4:  MOVLB  5
055B6:  SUBWF  xFF,W
055B8:  BZ    5600
....................             { 
....................                // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................                // number for arivial of any other SYN+ACK packets 
....................                localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
055BA:  MOVFF  183,603
055BE:  MOVFF  182,602
055C2:  MOVFF  181,601
055C6:  MOVFF  180,600
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
055CA:  MOVFF  5FF,183
055CE:  MOVFF  5FE,182
055D2:  MOVFF  5FD,181
055D6:  MOVFF  5FC,180
....................                SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
055DA:  MOVLW  04
055DC:  MOVLB  6
055DE:  MOVWF  x09
055E0:  MOVLW  01
055E2:  MOVWF  x0A
055E4:  MOVLB  0
055E6:  CALL   3598
....................                MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
055EA:  MOVFF  603,183
055EE:  MOVFF  602,182
055F2:  MOVFF  601,181
055F6:  MOVFF  600,180
....................                return; 
055FA:  GOTO   679A
055FE:  MOVLB  5
....................             } 
....................          } 
....................  
....................          // Third: check the security and precedence 
....................          // No such feature in this stack.  We want to accept all connections. 
....................  
....................          // Fourth: check the SYN bit 
....................          if(localHeaderFlags & SYN) 
05600:  MOVF   xFB,W
05602:  ANDLW  02
05604:  MOVWF  00
05606:  CLRF   03
05608:  MOVF   00,W
0560A:  IORWF  03,W
0560C:  BZ    56CC
....................          { 
....................             // We now have an initial sequence number and window size 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
0560E:  MOVLW  01
05610:  MOVLB  6
05612:  ADDWF  x00,W
05614:  MOVLB  1
05616:  MOVWF  x84
05618:  MOVLW  00
0561A:  MOVLB  6
0561C:  ADDWFC x01,W
0561E:  MOVLB  1
05620:  MOVWF  x85
05622:  MOVLW  00
05624:  MOVLB  6
05626:  ADDWFC x02,W
05628:  MOVLB  1
0562A:  MOVWF  x86
0562C:  MOVLW  00
0562E:  MOVLB  6
05630:  ADDWFC x03,W
05632:  MOVLB  1
05634:  MOVWF  x87
....................             MyTCB.remoteWindow = h->Window; 
05636:  MOVLW  0E
05638:  MOVLB  5
0563A:  ADDWF  xE9,W
0563C:  MOVWF  FE9
0563E:  MOVLW  00
05640:  ADDWFC xEA,W
05642:  MOVWF  FEA
05644:  MOVFF  FEC,18F
05648:  MOVF   FED,F
0564A:  MOVFF  FEF,18E
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
0564E:  MOVLB  0
05650:  RCALL  52FA
05652:  MOVFF  02,1A0
05656:  MOVFF  01,19F
....................  
....................             if(localHeaderFlags & ACK) 
0565A:  MOVLB  5
0565C:  MOVF   xFB,W
0565E:  ANDLW  10
05660:  MOVWF  00
05662:  CLRF   03
05664:  MOVF   00,W
05666:  IORWF  03,W
05668:  BZ    56B4
....................             { 
....................                SendTCP(ACK, SENDTCP_RESET_TIMERS); 
0566A:  MOVLW  10
0566C:  MOVLB  6
0566E:  MOVWF  x09
05670:  MOVLW  01
05672:  MOVWF  x0A
05674:  MOVLB  0
05676:  CALL   3598
....................                MyTCBStub.smState = TCP_ESTABLISHED; 
0567A:  MOVLW  07
0567C:  MOVLB  1
0567E:  MOVWF  xF6
....................                // Set up keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
05680:  MOVLB  0
05682:  CALL   23FC
05686:  MOVLW  B4
05688:  MOVLB  6
0568A:  ADDWF  00,W
0568C:  MOVLB  1
0568E:  MOVWF  xEE
05690:  MOVLW  C4
05692:  MOVLB  6
05694:  ADDWFC 01,W
05696:  MOVLB  1
05698:  MOVWF  xEF
0569A:  MOVLW  04
0569C:  MOVLB  6
0569E:  ADDWFC 02,W
056A0:  MOVLB  1
056A2:  MOVWF  xF0
056A4:  MOVLW  00
056A6:  MOVLB  6
056A8:  ADDWFC 03,W
056AA:  MOVLB  1
056AC:  MOVWF  xF1
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
056AE:  BCF    xF7.4
....................             } 
056B0:  BRA    56CA
056B2:  MOVLB  5
....................             else 
....................             { 
....................                SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
056B4:  MOVLW  12
056B6:  MOVLB  6
056B8:  MOVWF  x09
056BA:  MOVLW  01
056BC:  MOVWF  x0A
056BE:  MOVLB  0
056C0:  CALL   3598
....................                MyTCBStub.smState = TCP_SYN_RECEIVED; 
056C4:  MOVLW  06
056C6:  MOVLB  1
056C8:  MOVWF  xF6
056CA:  MOVLB  5
....................             } 
....................          } 
....................  
....................          // Fifth: drop the segment if neither SYN or RST is set 
....................          return; 
056CC:  MOVLB  0
056CE:  GOTO   679A
....................  
....................       default: 
....................          break; 
....................    } 
....................  
....................    // 
....................    // First: check the sequence number 
....................    // 
....................    wSegmentLength = len; 
056D2:  MOVFF  5EC,605
056D6:  MOVFF  5EB,604
....................    if(localHeaderFlags & FIN) 
056DA:  MOVLB  5
056DC:  MOVF   xFB,W
056DE:  ANDLW  01
056E0:  MOVWF  00
056E2:  CLRF   03
056E4:  MOVF   00,W
056E6:  IORWF  03,W
056E8:  BZ    56F4
....................       wSegmentLength++; 
056EA:  MOVLB  6
056EC:  INCF   x04,F
056EE:  BTFSC  FD8.2
056F0:  INCF   x05,F
056F2:  MOVLB  5
....................    if(localHeaderFlags & SYN) 
056F4:  MOVF   xFB,W
056F6:  ANDLW  02
056F8:  MOVWF  00
056FA:  CLRF   03
056FC:  MOVF   00,W
056FE:  IORWF  03,W
05700:  BZ    570C
....................       wSegmentLength++; 
05702:  MOVLB  6
05704:  INCF   x04,F
05706:  BTFSC  FD8.2
05708:  INCF   x05,F
0570A:  MOVLB  5
....................  
....................    // Calculate the RX FIFO space 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
0570C:  MOVLB  1
0570E:  MOVF   xED,W
05710:  SUBWF  xEB,W
05712:  BNC   5754
05714:  BNZ   571C
05716:  MOVF   xEC,W
05718:  SUBWF  xEA,W
0571A:  BNC   5754
....................       wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
0571C:  MOVF   xE2,W
0571E:  SUBWF  xE4,W
05720:  MOVLB  6
05722:  MOVWF  x09
05724:  MOVLB  1
05726:  MOVF   xE3,W
05728:  SUBWFB xE5,W
0572A:  MOVLB  6
0572C:  MOVWF  x0A
0572E:  MOVLB  1
05730:  MOVF   xEC,W
05732:  SUBWF  xEA,W
05734:  MOVWF  00
05736:  MOVF   xED,W
05738:  SUBWFB xEB,W
0573A:  MOVWF  03
0573C:  MOVF   00,W
0573E:  MOVLB  6
05740:  SUBWF  x09,W
05742:  MOVLB  5
05744:  MOVWF  xF9
05746:  MOVF   03,W
05748:  MOVLB  6
0574A:  SUBWFB x0A,W
0574C:  MOVLB  5
0574E:  MOVWF  xFA
05750:  BRA    5778
05752:  MOVLB  1
....................    else 
....................       wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
05754:  MOVF   xEA,W
05756:  SUBWF  xEC,W
05758:  MOVLB  6
0575A:  MOVWF  x09
0575C:  MOVLB  1
0575E:  MOVF   xEB,W
05760:  SUBWFB xED,W
05762:  MOVLB  6
05764:  MOVWF  x0A
05766:  MOVLW  01
05768:  SUBWF  x09,W
0576A:  MOVLB  5
0576C:  MOVWF  xF9
0576E:  MOVLW  00
05770:  MOVLB  6
05772:  SUBWFB x0A,W
05774:  MOVLB  5
05776:  MOVWF  xFA
....................  
....................    // Calculate the number of bytes ahead of our head pointer this segment skips 
....................    lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ; 
05778:  MOVLB  1
0577A:  MOVF   x84,W
0577C:  MOVLB  6
0577E:  SUBWF  x00,W
05780:  MOVWF  00
05782:  MOVLB  1
05784:  MOVF   x85,W
05786:  MOVLB  6
05788:  SUBWFB x01,W
0578A:  MOVWF  01
0578C:  MOVLB  1
0578E:  MOVF   x86,W
05790:  MOVLB  6
05792:  SUBWFB x02,W
05794:  MOVWF  02
05796:  MOVLB  1
05798:  MOVF   x87,W
0579A:  MOVLB  6
0579C:  SUBWFB x03,W
0579E:  MOVFF  FE8,5F6
057A2:  MOVFF  02,5F5
057A6:  MOVFF  01,5F4
057AA:  MOVFF  00,5F3
....................    wMissingBytes = (WORD)lMissingBytes; 
057AE:  MOVFF  5F4,5F8
057B2:  MOVFF  5F3,5F7
....................     
....................    // Run TCP acceptability tests to verify that this packet has a valid sequence number 
....................    bSegmentAcceptable = FALSE; 
057B6:  BCF    x06.0
....................    if(wSegmentLength) 
057B8:  MOVF   x04,W
057BA:  IORWF  x05,W
057BC:  BTFSC  FD8.2
057BE:  BRA    5914
....................    { 
....................       // Check to see if we have free space, and if so, if any of the data falls within the freespace 
....................       if(wFreeSpace) 
057C0:  MOVLB  5
057C2:  MOVF   xF9,W
057C4:  IORWF  xFA,W
057C6:  BTFSC  FD8.2
057C8:  BRA    5910
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
057CA:  BTFSC  xF6.7
057CC:  BRA    57EC
057CE:  MOVF   xF6,F
057D0:  BNZ   57EC
057D2:  MOVF   xF5,F
057D4:  BNZ   57EC
057D6:  MOVF   xF4,W
057D8:  SUBWF  xFA,W
057DA:  BNC   57EC
057DC:  BNZ   57E4
057DE:  MOVF   xF9,W
057E0:  SUBWF  xF3,W
057E2:  BC    57EC
....................             bSegmentAcceptable = TRUE; 
057E4:  MOVLB  6
057E6:  BSF    x06.0
057E8:  BRA    58A4
057EA:  MOVLB  5
....................          else 
....................          { 
....................             // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND 
....................             if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength))) 
057EC:  MOVFF  604,00
057F0:  MOVFF  605,01
057F4:  CLRF   02
057F6:  CLRF   03
057F8:  MOVF   00,W
057FA:  ADDWF  xF3,W
057FC:  MOVLB  6
057FE:  MOVWF  x09
05800:  MOVF   x05,W
05802:  MOVLB  5
05804:  ADDWFC xF4,W
05806:  MOVLB  6
05808:  MOVWF  x0A
0580A:  MOVF   02,W
0580C:  MOVLB  5
0580E:  ADDWFC xF5,W
05810:  MOVLB  6
05812:  MOVWF  x0B
05814:  MOVF   03,W
05816:  MOVLB  5
05818:  ADDWFC xF6,W
0581A:  MOVLB  6
0581C:  MOVWF  x0C
0581E:  BTFSC  FE8.7
05820:  BRA    58A4
05822:  MOVF   x0C,F
05824:  BNZ   5834
05826:  MOVF   x0B,F
05828:  BNZ   5834
0582A:  MOVF   x0A,F
0582C:  BNZ   5834
0582E:  MOVF   x09,W
05830:  SUBLW  00
05832:  BC    58A4
05834:  MOVF   x04,W
05836:  MOVLB  5
05838:  SUBWF  xF9,W
0583A:  MOVWF  00
0583C:  MOVLB  6
0583E:  MOVF   x05,W
05840:  MOVLB  5
05842:  SUBWFB xFA,W
05844:  MOVWF  03
05846:  MOVF   00,W
05848:  MOVFF  03,01
0584C:  CLRF   02
0584E:  CLRF   03
05850:  BTFSS  01.7
05852:  BRA    5858
05854:  DECF   02,F
05856:  DECF   03,F
05858:  BTFSS  xF6.7
0585A:  BRA    5862
0585C:  BTFSS  03.7
0585E:  BRA    58A0
05860:  BRA    586A
05862:  BTFSS  03.7
05864:  BRA    586A
05866:  MOVLB  6
05868:  BRA    58A4
0586A:  MOVF   xF6,W
0586C:  SUBWF  03,W
0586E:  BTFSC  FD8.0
05870:  BRA    5876
05872:  MOVLB  6
05874:  BRA    58A4
05876:  BNZ   58A0
05878:  MOVF   xF5,W
0587A:  SUBWF  02,W
0587C:  BTFSC  FD8.0
0587E:  BRA    5884
05880:  MOVLB  6
05882:  BRA    58A4
05884:  BNZ   58A0
05886:  MOVF   xF4,W
05888:  SUBWF  01,W
0588A:  BTFSC  FD8.0
0588C:  BRA    5892
0588E:  MOVLB  6
05890:  BRA    58A4
05892:  BNZ   58A0
05894:  MOVF   xF3,W
05896:  SUBWF  00,W
05898:  BTFSC  FD8.0
0589A:  BRA    58A0
0589C:  MOVLB  6
0589E:  BRA    58A4
....................                bSegmentAcceptable = TRUE; 
058A0:  MOVLB  6
058A2:  BSF    x06.0
....................          } 
....................           
....................          if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0)) 
058A4:  MOVFF  5F9,00
058A8:  MOVFF  5FA,01
058AC:  CLRF   02
058AE:  CLRF   03
058B0:  MOVLB  5
058B2:  BTFSS  xF6.7
058B4:  BRA    58BC
058B6:  BTFSS  03.7
058B8:  BRA    58DE
058BA:  BRA    58C0
058BC:  BTFSC  03.7
058BE:  BRA    5910
058C0:  MOVF   xF6,W
058C2:  SUBWF  03,W
058C4:  BNC   5910
058C6:  BNZ   58DE
058C8:  MOVF   xF5,W
058CA:  SUBWF  02,W
058CC:  BNC   5910
058CE:  BNZ   58DE
058D0:  MOVF   xF4,W
058D2:  SUBWF  01,W
058D4:  BNC   5910
058D6:  BNZ   58DE
058D8:  MOVF   00,W
058DA:  SUBWF  xF3,W
058DC:  BC    5910
058DE:  MOVLB  6
058E0:  MOVF   x04,W
058E2:  MOVLB  5
058E4:  ADDWF  xF7,W
058E6:  MOVLB  6
058E8:  MOVWF  x09
058EA:  MOVF   x05,W
058EC:  MOVLB  5
058EE:  ADDWFC xF8,W
058F0:  MOVLB  6
058F2:  MOVWF  x0A
058F4:  BTFSS  FE8.7
058F6:  BRA    58FC
058F8:  MOVLB  5
058FA:  BRA    5910
058FC:  MOVF   x0A,F
058FE:  BNZ   590C
05900:  MOVF   x09,W
05902:  SUBLW  00
05904:  BTFSS  FD8.0
05906:  BRA    590C
05908:  MOVLB  5
0590A:  BRA    5910
....................             bSegmentAcceptable = TRUE; 
0590C:  BSF    x06.0
0590E:  MOVLB  5
....................       } 
....................       // Segments with data are not acceptable if we have no free space 
....................    } 
05910:  BRA    594E
05912:  MOVLB  6
....................    else 
....................    { 
....................       // Zero length packets are acceptable if they fall within our free space window 
....................       // SEG.SEQ = RCV.NXT 
....................       if(lMissingBytes == 0) 
05914:  MOVLB  5
05916:  MOVF   xF3,F
05918:  BNZ   592E
0591A:  MOVF   xF4,F
0591C:  BNZ   592E
0591E:  MOVF   xF5,F
05920:  BNZ   592E
05922:  MOVF   xF6,F
05924:  BNZ   592E
....................       { 
....................          bSegmentAcceptable = TRUE; 
05926:  MOVLB  6
05928:  BSF    x06.0
....................       } 
0592A:  BRA    594C
0592C:  MOVLB  5
....................       else 
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
0592E:  BTFSC  xF6.7
05930:  BRA    594E
05932:  MOVF   xF6,F
05934:  BNZ   594E
05936:  MOVF   xF5,F
05938:  BNZ   594E
0593A:  MOVF   xF4,W
0593C:  SUBWF  xFA,W
0593E:  BNC   594E
05940:  BNZ   5948
05942:  MOVF   xF9,W
05944:  SUBWF  xF3,W
05946:  BC    594E
....................             bSegmentAcceptable = TRUE; 
05948:  MOVLB  6
0594A:  BSF    x06.0
0594C:  MOVLB  5
....................       } 
....................    } 
....................     
....................    if(!bSegmentAcceptable) 
0594E:  MOVLB  6
05950:  BTFSC  x06.0
05952:  BRA    597E
....................    { 
....................       // Unacceptable segment, drop it and respond appropriately 
....................       if(!(localHeaderFlags & RST))  
05954:  MOVLB  5
05956:  MOVF   xFB,W
05958:  ANDLW  04
0595A:  MOVWF  00
0595C:  CLRF   03
0595E:  MOVF   00,W
05960:  IORWF  03,W
05962:  BNZ   5976
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
05964:  MOVLW  10
05966:  MOVLB  6
05968:  MOVWF  x09
0596A:  MOVLW  01
0596C:  MOVWF  x0A
0596E:  MOVLB  0
05970:  CALL   3598
05974:  MOVLB  5
....................       return; 
05976:  MOVLB  0
05978:  GOTO   679A
0597C:  MOVLB  6
....................    } 
....................  
....................  
....................    // 
....................    // Second: check the RST bit 
....................    // 
....................    // 
....................    // Fourth: check the SYN bit 
....................    // 
....................    // Note, that since the third step is not implemented, we can  
....................    // combine this second and fourth step into a single operation. 
....................    if(localHeaderFlags & (RST | SYN)) 
0597E:  MOVLB  5
05980:  MOVF   xFB,W
05982:  ANDLW  06
05984:  MOVWF  00
05986:  CLRF   03
05988:  MOVF   00,W
0598A:  IORWF  03,W
0598C:  BZ    599A
....................    { 
....................       CloseSocket(); 
0598E:  MOVLB  0
05990:  CALL   1138
....................       return; 
05994:  GOTO   679A
05998:  MOVLB  5
....................    } 
....................  
....................    // 
....................    // Third: check the security and precedence 
....................    // 
....................    // Feature not supported.  Let's process this segment. 
....................  
....................    // 
....................    // Fifth: check the ACK bit 
....................    // 
....................    if(!(localHeaderFlags & ACK)) 
0599A:  MOVF   xFB,W
0599C:  ANDLW  10
0599E:  MOVWF  00
059A0:  CLRF   03
059A2:  MOVF   00,W
059A4:  IORWF  03,W
059A6:  BNZ   59B0
....................       return; 
059A8:  MOVLB  0
059AA:  GOTO   679A
059AE:  MOVLB  5
....................  
....................    switch(MyTCBStub.smState) 
059B0:  MOVLB  1
059B2:  MOVF   xF6,W
059B4:  XORLW  06
059B6:  MOVLB  0
059B8:  BZ    59D6
059BA:  XORLW  01
059BC:  BZ    5A4C
059BE:  XORLW  0F
059C0:  BZ    5A4C
059C2:  XORLW  01
059C4:  BZ    5A4C
059C6:  XORLW  02
059C8:  BZ    5A4C
059CA:  XORLW  01
059CC:  BZ    5A4C
059CE:  XORLW  06
059D0:  BTFSC  FD8.2
059D2:  BRA    5F9C
059D4:  BRA    5FFA
....................    { 
....................       case TCP_SYN_RECEIVED: 
....................          if(localAckNumber != MyTCB.MySEQ) 
059D6:  MOVLB  1
059D8:  MOVF   x80,W
059DA:  MOVLB  5
059DC:  SUBWF  xFC,W
059DE:  BNZ   59FE
059E0:  MOVLB  1
059E2:  MOVF   x81,W
059E4:  MOVLB  5
059E6:  SUBWF  xFD,W
059E8:  BNZ   59FE
059EA:  MOVLB  1
059EC:  MOVF   x82,W
059EE:  MOVLB  5
059F0:  SUBWF  xFE,W
059F2:  BNZ   59FE
059F4:  MOVLB  1
059F6:  MOVF   x83,W
059F8:  MOVLB  5
059FA:  SUBWF  xFF,W
059FC:  BZ    5A44
....................          { 
....................             // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................             // number for arivial of any other correct packets 
....................             localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
059FE:  MOVFF  183,603
05A02:  MOVFF  182,602
05A06:  MOVFF  181,601
05A0A:  MOVFF  180,600
....................             MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
05A0E:  MOVFF  5FF,183
05A12:  MOVFF  5FE,182
05A16:  MOVFF  5FD,181
05A1A:  MOVFF  5FC,180
....................             SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
05A1E:  MOVLW  04
05A20:  MOVLB  6
05A22:  MOVWF  x09
05A24:  MOVLW  01
05A26:  MOVWF  x0A
05A28:  MOVLB  0
05A2A:  CALL   3598
....................             MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
05A2E:  MOVFF  603,183
05A32:  MOVFF  602,182
05A36:  MOVFF  601,181
05A3A:  MOVFF  600,180
....................             return; 
05A3E:  GOTO   679A
05A42:  MOVLB  5
....................          } 
....................          MyTCBStub.smState = TCP_ESTABLISHED; 
05A44:  MOVLW  07
05A46:  MOVLB  1
05A48:  MOVWF  xF6
05A4A:  MOVLB  0
....................          // No break 
....................  
....................       case TCP_ESTABLISHED: 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSE_WAIT: 
....................       case TCP_CLOSING: 
....................          // Calculate what the highest possible SEQ number in our TX FIFO is 
....................          wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail; 
05A4C:  MOVLB  1
05A4E:  MOVF   x88,W
05A50:  SUBWF  xE6,W
05A52:  MOVLB  5
05A54:  MOVWF  xF1
05A56:  MOVLB  1
05A58:  MOVF   x89,W
05A5A:  SUBWFB xE7,W
05A5C:  MOVLB  5
05A5E:  MOVWF  xF2
....................          if((SHORT)wTemp < (SHORT)0) 
05A60:  BTFSS  xF2.7
05A62:  BRA    5A7C
....................             wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
05A64:  MOVLB  1
05A66:  MOVF   xE0,W
05A68:  SUBWF  xE2,W
05A6A:  MOVWF  00
05A6C:  MOVF   xE1,W
05A6E:  SUBWFB xE3,W
05A70:  MOVWF  03
05A72:  MOVF   00,W
05A74:  MOVLB  5
05A76:  ADDWF  xF1,F
05A78:  MOVF   03,W
05A7A:  ADDWFC xF2,F
....................          dwTemp = MyTCB.MySEQ + (DWORD)wTemp; 
05A7C:  CLRF   02
05A7E:  CLRF   03
05A80:  MOVF   xF1,W
05A82:  MOVLB  1
05A84:  ADDWF  x80,W
05A86:  MOVLB  5
05A88:  MOVWF  xED
05A8A:  MOVF   xF2,W
05A8C:  MOVLB  1
05A8E:  ADDWFC x81,W
05A90:  MOVLB  5
05A92:  MOVWF  xEE
05A94:  MOVF   02,W
05A96:  MOVLB  1
05A98:  ADDWFC x82,W
05A9A:  MOVLB  5
05A9C:  MOVWF  xEF
05A9E:  MOVF   03,W
05AA0:  MOVLB  1
05AA2:  ADDWFC x83,W
05AA4:  MOVLB  5
05AA6:  MOVWF  xF0
....................  
....................          // Drop the packet if it ACKs something we haven't sent 
....................             dwTemp = (LONG)localAckNumber - (LONG)dwTemp; 
05AA8:  MOVF   xED,W
05AAA:  SUBWF  xFC,W
05AAC:  MOVWF  00
05AAE:  MOVF   xEE,W
05AB0:  SUBWFB xFD,W
05AB2:  MOVWF  01
05AB4:  MOVF   xEF,W
05AB6:  SUBWFB xFE,W
05AB8:  MOVWF  02
05ABA:  MOVF   xF0,W
05ABC:  SUBWFB xFF,W
05ABE:  MOVWF  xF0
05AC0:  MOVFF  02,5EF
05AC4:  MOVFF  01,5EE
05AC8:  MOVFF  00,5ED
....................             if((LONG)dwTemp > 0) 
05ACC:  BTFSC  xF0.7
05ACE:  BRA    5B34
05AD0:  MOVF   xF0,F
05AD2:  BNZ   5AE2
05AD4:  MOVF   xEF,F
05AD6:  BNZ   5AE2
05AD8:  MOVF   xEE,F
05ADA:  BNZ   5AE2
05ADC:  MOVF   xED,W
05ADE:  SUBLW  00
05AE0:  BC    5B34
....................             {   // acknowledged more than we've sent?? 
....................                 if(!MyTCB.flags.bFINSent || dwTemp != 1) 
05AE2:  MOVLB  1
05AE4:  BTFSS  x9E.0
05AE6:  BRA    5B0E
05AE8:  MOVLB  5
05AEA:  DECFSZ xED,W
05AEC:  BRA    5AF0
05AEE:  BRA    5AF4
05AF0:  MOVLB  1
05AF2:  BRA    5B0E
05AF4:  MOVF   xEE,F
05AF6:  BTFSC  FD8.2
05AF8:  BRA    5AFE
05AFA:  MOVLB  1
05AFC:  BRA    5B0E
05AFE:  MOVF   xEF,F
05B00:  BTFSC  FD8.2
05B02:  BRA    5B08
05B04:  MOVLB  1
05B06:  BRA    5B0E
05B08:  MOVF   xF0,F
05B0A:  BZ    5B24
05B0C:  MOVLB  1
....................                 { 
....................                     SendTCP(ACK, 0); 
05B0E:  MOVLW  10
05B10:  MOVLB  6
05B12:  MOVWF  x09
05B14:  CLRF   x0A
05B16:  MOVLB  0
05B18:  CALL   3598
....................                     return; 
05B1C:  GOTO   679A
....................                 } 
05B20:  BRA    5B36
05B22:  MOVLB  5
....................                 else 
....................                 { 
....................                     localAckNumber--;   // since we don't count the FIN anyway 
05B24:  MOVLW  FF
05B26:  ADDWF  xFC,F
05B28:  BTFSS  FD8.0
05B2A:  ADDWF  xFD,F
05B2C:  BTFSS  FD8.0
05B2E:  ADDWF  xFE,F
05B30:  BTFSS  FD8.0
05B32:  ADDWF  xFF,F
05B34:  MOVLB  0
....................                 } 
....................             } 
....................  
....................          // Throw away all ACKnowledged TX data: 
....................          // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent) 
....................          dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
05B36:  MOVLB  1
05B38:  MOVF   xE8,W
05B3A:  SUBWF  x88,W
05B3C:  MOVWF  00
05B3E:  MOVF   xE9,W
05B40:  SUBWFB x89,W
05B42:  MOVWF  03
05B44:  MOVF   00,W
05B46:  MOVFF  03,01
05B4A:  CLRF   02
05B4C:  CLRF   03
05B4E:  BTFSS  01.7
05B50:  BRA    5B56
05B52:  DECF   02,F
05B54:  DECF   03,F
05B56:  MOVF   00,W
05B58:  SUBWF  x80,W
05B5A:  MOVWF  00
05B5C:  MOVF   01,W
05B5E:  SUBWFB x81,W
05B60:  MOVWF  01
05B62:  MOVF   02,W
05B64:  SUBWFB x82,W
05B66:  MOVWF  02
05B68:  MOVF   03,W
05B6A:  SUBWFB x83,W
05B6C:  MOVFF  FE8,5F0
05B70:  MOVFF  02,5EF
05B74:  MOVFF  01,5EE
05B78:  MOVFF  00,5ED
....................          if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
05B7C:  MOVF   x89,W
05B7E:  SUBWF  xE9,W
05B80:  BNC   5BA8
05B82:  BNZ   5B8A
05B84:  MOVF   xE8,W
05B86:  SUBWF  x88,W
05B88:  BC    5BA8
....................             dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
05B8A:  MOVF   xE0,W
05B8C:  SUBWF  xE2,W
05B8E:  MOVWF  00
05B90:  MOVF   xE1,W
05B92:  SUBWFB xE3,W
05B94:  MOVWF  03
05B96:  MOVF   00,W
05B98:  MOVLB  5
05B9A:  SUBWF  xED,F
05B9C:  MOVF   03,W
05B9E:  SUBWFB xEE,F
05BA0:  MOVLW  00
05BA2:  SUBWFB xEF,F
05BA4:  SUBWFB xF0,F
05BA6:  MOVLB  1
....................     
....................          // Calcluate how many bytes were ACKed with this packet 
....................          dwTemp = localAckNumber - dwTemp; 
05BA8:  MOVLB  5
05BAA:  MOVF   xED,W
05BAC:  SUBWF  xFC,W
05BAE:  MOVWF  xED
05BB0:  MOVF   xEE,W
05BB2:  SUBWFB xFD,W
05BB4:  MOVWF  xEE
05BB6:  MOVF   xEF,W
05BB8:  SUBWFB xFE,W
05BBA:  MOVWF  xEF
05BBC:  MOVF   xF0,W
05BBE:  SUBWFB xFF,W
05BC0:  MOVWF  xF0
....................          if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart)) 
05BC2:  BTFSC  xF0.7
05BC4:  BRA    5D1E
05BC6:  MOVF   xF0,F
05BC8:  BNZ   5BDA
05BCA:  MOVF   xEF,F
05BCC:  BNZ   5BDA
05BCE:  MOVF   xEE,F
05BD0:  BNZ   5BDA
05BD2:  MOVF   xED,W
05BD4:  SUBLW  00
05BD6:  BTFSC  FD8.0
05BD8:  BRA    5D1E
05BDA:  MOVLB  1
05BDC:  MOVF   xE0,W
05BDE:  SUBWF  xE2,W
05BE0:  MOVWF  00
05BE2:  MOVF   xE1,W
05BE4:  SUBWFB xE3,W
05BE6:  MOVWF  03
05BE8:  MOVFF  00,01
05BEC:  MOVLB  5
05BEE:  MOVF   xF0,F
05BF0:  BTFSS  FD8.2
05BF2:  BRA    5D1E
05BF4:  MOVF   xEF,F
05BF6:  BTFSS  FD8.2
05BF8:  BRA    5D1E
05BFA:  MOVF   xEE,W
05BFC:  SUBWF  03,W
05BFE:  BTFSS  FD8.0
05C00:  BRA    5D1E
05C02:  BNZ   5C0C
05C04:  MOVF   xED,W
05C06:  SUBWF  01,W
05C08:  BTFSS  FD8.0
05C0A:  BRA    5D1E
....................          { 
....................             MyTCB.flags.bRXNoneACKed1 = 0; 
05C0C:  MOVLB  1
05C0E:  BCF    x9E.3
....................             MyTCB.flags.bRXNoneACKed2 = 0; 
05C10:  BCF    x9E.4
....................             MyTCBStub.Flags.bHalfFullFlush = FALSE; 
05C12:  BCF    xF8.0
....................     
....................             // Bytes ACKed, free up the TX FIFO space 
....................             wTemp = MyTCBStub.txTail; 
05C14:  MOVFF  1E9,5F2
05C18:  MOVFF  1E8,5F1
....................             MyTCBStub.txTail += dwTemp; 
05C1C:  MOVLB  5
05C1E:  MOVF   xED,W
05C20:  MOVLB  1
05C22:  ADDWF  xE8,F
05C24:  MOVLB  5
05C26:  MOVF   xEE,W
05C28:  MOVLB  1
05C2A:  ADDWFC xE9,F
....................             if(MyTCB.txUnackedTail >= wTemp) 
05C2C:  MOVLB  5
05C2E:  MOVF   xF2,W
05C30:  MOVLB  1
05C32:  SUBWF  x89,W
05C34:  BNC   5C74
05C36:  BNZ   5C42
05C38:  MOVLB  5
05C3A:  MOVF   xF1,W
05C3C:  MOVLB  1
05C3E:  SUBWF  x88,W
05C40:  BNC   5C74
....................             { 
....................                if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
05C42:  MOVF   x89,W
05C44:  SUBWF  xE9,W
05C46:  BNC   5C72
05C48:  BNZ   5C50
05C4A:  MOVF   xE8,W
05C4C:  SUBWF  x88,W
05C4E:  BC    5C72
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail; 
05C50:  MOVF   x88,W
05C52:  SUBWF  xE8,W
05C54:  MOVWF  00
05C56:  MOVF   x89,W
05C58:  SUBWFB xE9,W
05C5A:  MOVWF  03
05C5C:  MOVF   00,W
05C5E:  ADDWF  x80,F
05C60:  MOVF   03,W
05C62:  ADDWFC x81,F
05C64:  MOVLW  00
05C66:  ADDWFC x82,F
05C68:  ADDWFC x83,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
05C6A:  MOVFF  1E9,189
05C6E:  MOVFF  1E8,188
....................                } 
....................             } 
05C72:  BRA    5CD6
....................             else 
....................             { 
....................                wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
05C74:  MOVF   xE0,W
05C76:  SUBWF  xE2,W
05C78:  MOVWF  00
05C7A:  MOVF   xE1,W
05C7C:  SUBWFB xE3,W
05C7E:  MOVWF  03
05C80:  MOVF   00,W
05C82:  ADDWF  x88,W
05C84:  MOVLB  5
05C86:  MOVWF  xF1
05C88:  MOVF   03,W
05C8A:  MOVLB  1
05C8C:  ADDWFC x89,W
05C8E:  MOVLB  5
05C90:  MOVWF  xF2
....................                if(wTemp < MyTCBStub.txTail) 
05C92:  MOVF   xF2,W
05C94:  MOVLB  1
05C96:  SUBWF  xE9,W
05C98:  BNC   5CD6
05C9A:  BNZ   5CAC
05C9C:  MOVF   xE8,W
05C9E:  MOVLB  5
05CA0:  SUBWF  xF1,W
05CA2:  BTFSS  FD8.0
05CA4:  BRA    5CAA
05CA6:  MOVLB  1
05CA8:  BRA    5CD6
05CAA:  MOVLB  1
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - wTemp; 
05CAC:  MOVLB  5
05CAE:  MOVF   xF1,W
05CB0:  MOVLB  1
05CB2:  SUBWF  xE8,W
05CB4:  MOVWF  00
05CB6:  MOVLB  5
05CB8:  MOVF   xF2,W
05CBA:  MOVLB  1
05CBC:  SUBWFB xE9,W
05CBE:  MOVWF  03
05CC0:  MOVF   00,W
05CC2:  ADDWF  x80,F
05CC4:  MOVF   03,W
05CC6:  ADDWFC x81,F
05CC8:  MOVLW  00
05CCA:  ADDWFC x82,F
05CCC:  ADDWFC x83,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
05CCE:  MOVFF  1E9,189
05CD2:  MOVFF  1E8,188
....................                } 
....................             } 
....................             if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart) 
05CD6:  MOVF   xE3,W
05CD8:  SUBWF  xE9,W
05CDA:  BNC   5CF8
05CDC:  BNZ   5CE4
05CDE:  MOVF   xE2,W
05CE0:  SUBWF  xE8,W
05CE2:  BNC   5CF8
....................                MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
05CE4:  MOVF   xE0,W
05CE6:  SUBWF  xE2,W
05CE8:  MOVWF  00
05CEA:  MOVF   xE1,W
05CEC:  SUBWFB xE3,W
05CEE:  MOVWF  03
05CF0:  MOVF   00,W
05CF2:  SUBWF  xE8,F
05CF4:  MOVF   03,W
05CF6:  SUBWFB xE9,F
....................             if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
05CF8:  MOVF   xE3,W
05CFA:  SUBWF  x89,W
05CFC:  BNC   5D1A
05CFE:  BNZ   5D06
05D00:  MOVF   xE2,W
05D02:  SUBWF  x88,W
05D04:  BNC   5D1A
....................                MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
05D06:  MOVF   xE0,W
05D08:  SUBWF  xE2,W
05D0A:  MOVWF  00
05D0C:  MOVF   xE1,W
05D0E:  SUBWFB xE3,W
05D10:  MOVWF  03
05D12:  MOVF   00,W
05D14:  SUBWF  x88,F
05D16:  MOVF   03,W
05D18:  SUBWFB x89,F
....................          } 
05D1A:  BRA    5DD4
05D1C:  MOVLB  5
....................          else 
....................          { 
....................             // See if we have outstanding TX data that is waiting for an ACK 
....................             if(MyTCBStub.txTail != MyTCB.txUnackedTail) 
05D1E:  MOVLB  1
05D20:  MOVF   x88,W
05D22:  SUBWF  xE8,W
05D24:  BNZ   5D2C
05D26:  MOVF   x89,W
05D28:  SUBWF  xE9,W
05D2A:  BZ    5DD4
....................             { 
....................                if(MyTCB.flags.bRXNoneACKed1) 
05D2C:  BTFSS  x9E.3
05D2E:  BRA    5DD2
....................                { 
....................                   if(MyTCB.flags.bRXNoneACKed2) 
05D30:  BTFSS  x9E.4
05D32:  BRA    5DD0
....................                   { 
....................                      // Set up to perform a fast retransmission 
....................                      // Roll back unacknowledged TX tail pointer to cause retransmit to occur 
....................                      MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
05D34:  MOVF   xE8,W
05D36:  SUBWF  x88,W
05D38:  MOVWF  00
05D3A:  MOVF   xE9,W
05D3C:  SUBWFB x89,W
05D3E:  MOVWF  03
05D40:  MOVF   00,W
05D42:  MOVFF  03,01
05D46:  CLRF   02
05D48:  CLRF   03
05D4A:  BTFSS  01.7
05D4C:  BRA    5D52
05D4E:  DECF   02,F
05D50:  DECF   03,F
05D52:  MOVF   00,W
05D54:  SUBWF  x80,W
05D56:  MOVWF  00
05D58:  MOVF   01,W
05D5A:  SUBWFB x81,W
05D5C:  MOVWF  01
05D5E:  MOVF   02,W
05D60:  SUBWFB x82,W
05D62:  MOVWF  02
05D64:  MOVF   03,W
05D66:  SUBWFB x83,W
05D68:  MOVWF  x83
05D6A:  MOVFF  02,182
05D6E:  MOVFF  01,181
05D72:  MOVFF  00,180
....................                      if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
05D76:  MOVF   x89,W
05D78:  SUBWF  xE9,W
05D7A:  BNC   5DC6
05D7C:  BNZ   5D84
05D7E:  MOVF   xE8,W
05D80:  SUBWF  x88,W
05D82:  BC    5DC6
....................                         MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
05D84:  MOVF   xE0,W
05D86:  SUBWF  xE2,W
05D88:  MOVWF  00
05D8A:  MOVF   xE1,W
05D8C:  SUBWFB xE3,W
05D8E:  MOVWF  03
05D90:  MOVF   00,W
05D92:  MOVFF  03,01
05D96:  CLRF   02
05D98:  CLRF   03
05D9A:  BTFSS  01.7
05D9C:  BRA    5DA2
05D9E:  DECF   02,F
05DA0:  DECF   03,F
05DA2:  MOVF   00,W
05DA4:  SUBWF  x80,W
05DA6:  MOVWF  00
05DA8:  MOVF   01,W
05DAA:  SUBWFB x81,W
05DAC:  MOVWF  01
05DAE:  MOVF   02,W
05DB0:  SUBWFB x82,W
05DB2:  MOVWF  02
05DB4:  MOVF   03,W
05DB6:  SUBWFB x83,W
05DB8:  MOVWF  x83
05DBA:  MOVFF  02,182
05DBE:  MOVFF  01,181
05DC2:  MOVFF  00,180
....................                      MyTCB.txUnackedTail = MyTCBStub.txTail; 
05DC6:  MOVFF  1E9,189
05DCA:  MOVFF  1E8,188
....................                      MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
05DCE:  BSF    xF8.2
....................                   } 
....................                   MyTCB.flags.bRXNoneACKed2 = 1; 
05DD0:  BSF    x9E.4
....................                } 
....................                MyTCB.flags.bRXNoneACKed1 = 1; 
05DD2:  BSF    x9E.3
....................             } 
....................          } 
....................  
....................          // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore 
....................          if(MyTCBStub.txTail == MyTCBStub.txHead) 
05DD4:  MOVF   xE6,W
05DD6:  SUBWF  xE8,W
05DD8:  BNZ   5E46
05DDA:  MOVF   xE7,W
05DDC:  SUBWF  xE9,W
05DDE:  BNZ   5E46
....................          { 
....................             // Make sure there isn't a "FIN byte in our TX FIFO" 
....................             if(MyTCBStub.Flags.bTXFIN == 0u) 
05DE0:  BTFSC  xF8.3
05DE2:  BRA    5E16
....................             { 
....................                // Convert retransmission timer to keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
05DE4:  MOVLB  0
05DE6:  CALL   23FC
05DEA:  MOVLW  B4
05DEC:  MOVLB  6
05DEE:  ADDWF  00,W
05DF0:  MOVLB  1
05DF2:  MOVWF  xEE
05DF4:  MOVLW  C4
05DF6:  MOVLB  6
05DF8:  ADDWFC 01,W
05DFA:  MOVLB  1
05DFC:  MOVWF  xEF
05DFE:  MOVLW  04
05E00:  MOVLB  6
05E02:  ADDWFC 02,W
05E04:  MOVLB  1
05E06:  MOVWF  xF0
05E08:  MOVLW  00
05E0A:  MOVLB  6
05E0C:  ADDWFC 03,W
05E0E:  MOVLB  1
05E10:  MOVWF  xF1
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
05E12:  BCF    xF7.4
....................             } 
05E14:  BRA    5E46
....................             else 
....................             { 
....................                // "Throw away" FIN byte from our TX FIFO if it has been ACKed 
....................                if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
05E16:  MOVLB  5
05E18:  MOVF   xFC,W
05E1A:  MOVLB  1
05E1C:  SUBWF  x80,W
05E1E:  BNZ   5E46
05E20:  MOVLB  5
05E22:  MOVF   xFD,W
05E24:  MOVLB  1
05E26:  SUBWF  x81,W
05E28:  BNZ   5E46
05E2A:  MOVLB  5
05E2C:  MOVF   xFE,W
05E2E:  MOVLB  1
05E30:  SUBWF  x82,W
05E32:  BNZ   5E46
05E34:  MOVLB  5
05E36:  MOVF   xFF,W
05E38:  MOVLB  1
05E3A:  SUBWF  x83,W
05E3C:  BNZ   5E46
05E3E:  BTFSS  x9E.0
05E40:  BRA    5E46
....................                { 
....................                   MyTCBStub.Flags.bTimerEnabled = 0; 
05E42:  BCF    xF7.4
....................                   MyTCBStub.Flags.bTXFIN = 0; 
05E44:  BCF    xF8.3
....................                } 
....................             } 
....................          } 
....................  
....................          // The window size advirtised in this packet is adjusted to account  
....................          // for any bytes that we have transmitted but haven't been ACKed yet  
....................          // by this segment. 
....................          wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber)); 
05E46:  MOVLW  0E
05E48:  MOVLB  5
05E4A:  ADDWF  xE9,W
05E4C:  MOVWF  FE9
05E4E:  MOVLW  00
05E50:  ADDWFC xEA,W
05E52:  MOVWF  FEA
05E54:  MOVFF  FEC,60A
05E58:  MOVF   FED,F
05E5A:  MOVFF  FEF,609
05E5E:  MOVF   xFC,W
05E60:  MOVLB  1
05E62:  SUBWF  x80,W
05E64:  MOVWF  00
05E66:  MOVLB  5
05E68:  MOVF   xFD,W
05E6A:  MOVLB  1
05E6C:  SUBWFB x81,W
05E6E:  MOVWF  01
05E70:  MOVLB  5
05E72:  MOVF   xFE,W
05E74:  MOVLB  1
05E76:  SUBWFB x82,W
05E78:  MOVLB  5
05E7A:  MOVF   xFF,W
05E7C:  MOVLB  1
05E7E:  SUBWFB x83,W
05E80:  MOVF   00,W
05E82:  MOVLB  6
05E84:  SUBWF  x09,W
05E86:  MOVWF  x07
05E88:  MOVF   01,W
05E8A:  SUBWFB x0A,W
05E8C:  MOVWF  x08
....................  
....................          // Update the local stored copy of the RemoteWindow. 
....................          // If previously we had a zero window, and now we don't, then  
....................          // immediately send whatever was pending. 
....................          if((MyTCB.remoteWindow == 0u) && wNewWindow) 
05E8E:  MOVLB  1
05E90:  MOVF   x8E,F
05E92:  BNZ   5EAA
05E94:  MOVF   x8F,F
05E96:  BNZ   5EAA
05E98:  MOVLB  6
05E9A:  MOVF   x07,W
05E9C:  IORWF  x08,W
05E9E:  BTFSS  FD8.2
05EA0:  BRA    5EA6
05EA2:  MOVLB  1
05EA4:  BRA    5EAA
....................             MyTCBStub.Flags.bTXASAP = 1; 
05EA6:  MOVLB  1
05EA8:  BSF    xF8.1
....................          MyTCB.remoteWindow = wNewWindow; 
05EAA:  MOVFF  608,18F
05EAE:  MOVFF  607,18E
....................  
....................          // A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more 
....................          if(MyTCBStub.smState == TCP_FIN_WAIT_1) 
05EB2:  MOVF   xF6,W
05EB4:  SUBLW  08
05EB6:  BNZ   5F1A
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
05EB8:  MOVLB  5
05EBA:  MOVF   xFC,W
05EBC:  MOVLB  1
05EBE:  SUBWF  x80,W
05EC0:  BNZ   5F18
05EC2:  MOVLB  5
05EC4:  MOVF   xFD,W
05EC6:  MOVLB  1
05EC8:  SUBWF  x81,W
05ECA:  BNZ   5F18
05ECC:  MOVLB  5
05ECE:  MOVF   xFE,W
05ED0:  MOVLB  1
05ED2:  SUBWF  x82,W
05ED4:  BNZ   5F18
05ED6:  MOVLB  5
05ED8:  MOVF   xFF,W
05EDA:  MOVLB  1
05EDC:  SUBWF  x83,W
05EDE:  BNZ   5F18
05EE0:  BTFSS  x9E.0
05EE2:  BRA    5F18
....................             { 
....................                // Reset our timer for forced closure if the remote node  
....................                // doesn't send us a FIN in a timely manner. 
....................                MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT; 
05EE4:  MOVLB  0
05EE6:  CALL   23FC
05EEA:  MOVLW  5A
05EEC:  MOVLB  6
05EEE:  ADDWF  00,W
05EF0:  MOVLB  1
05EF2:  MOVWF  xEE
05EF4:  MOVLW  62
05EF6:  MOVLB  6
05EF8:  ADDWFC 01,W
05EFA:  MOVLB  1
05EFC:  MOVWF  xEF
05EFE:  MOVLW  02
05F00:  MOVLB  6
05F02:  ADDWFC 02,W
05F04:  MOVLB  1
05F06:  MOVWF  xF0
05F08:  MOVLW  00
05F0A:  MOVLB  6
05F0C:  ADDWFC 03,W
05F0E:  MOVLB  1
05F10:  MOVWF  xF1
....................                MyTCBStub.Flags.bTimerEnabled = 1; 
05F12:  BSF    xF7.4
....................                MyTCBStub.smState = TCP_FIN_WAIT_2; 
05F14:  MOVLW  09
05F16:  MOVWF  xF6
....................             } 
....................          } 
05F18:  BRA    5F98
....................          else if(MyTCBStub.smState == TCP_FIN_WAIT_2) 
05F1A:  MOVF   xF6,W
05F1C:  SUBLW  09
05F1E:  BNZ   5F5C
....................          { 
....................             // RFC noncompliance: 
....................             // The remote node should not keep sending us data  
....................             // indefinitely after we send a FIN to it.   
....................             // However, some bad stacks may still keep sending  
....................             // us data indefinitely after ACKing our FIN.  To  
....................             // prevent this from locking up our socket, let's  
....................             // send a RST right now and close forcefully on  
....................             // our side. 
....................             if(!(localHeaderFlags & FIN)) 
05F20:  MOVLB  5
05F22:  MOVF   xFB,W
05F24:  ANDLW  01
05F26:  MOVWF  00
05F28:  CLRF   03
05F2A:  MOVF   00,W
05F2C:  IORWF  03,W
05F2E:  BNZ   5F58
....................             { 
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
05F30:  MOVFF  5FF,183
05F34:  MOVFF  5FE,182
05F38:  MOVFF  5FD,181
05F3C:  MOVFF  5FC,180
....................                SendTCP(RST | ACK, 0); 
05F40:  MOVLW  14
05F42:  MOVLB  6
05F44:  MOVWF  x09
05F46:  CLRF   x0A
05F48:  MOVLB  0
05F4A:  CALL   3598
....................                CloseSocket(); 
05F4E:  CALL   1138
....................                return; 
05F52:  GOTO   679A
05F56:  MOVLB  5
....................             } 
....................          } 
05F58:  BRA    5F9A
05F5A:  MOVLB  1
....................          else if(MyTCBStub.smState == TCP_CLOSING) 
05F5C:  MOVF   xF6,W
05F5E:  SUBLW  0A
05F60:  BNZ   5F98
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if(MyTCB.MySEQ == localAckNumber) 
05F62:  MOVLB  5
05F64:  MOVF   xFC,W
05F66:  MOVLB  1
05F68:  SUBWF  x80,W
05F6A:  BNZ   5F92
05F6C:  MOVLB  5
05F6E:  MOVF   xFD,W
05F70:  MOVLB  1
05F72:  SUBWF  x81,W
05F74:  BNZ   5F92
05F76:  MOVLB  5
05F78:  MOVF   xFE,W
05F7A:  MOVLB  1
05F7C:  SUBWF  x82,W
05F7E:  BNZ   5F92
05F80:  MOVLB  5
05F82:  MOVF   xFF,W
05F84:  MOVLB  1
05F86:  SUBWF  x83,W
05F88:  BNZ   5F92
....................             { 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                CloseSocket(); 
05F8A:  MOVLB  0
05F8C:  CALL   1138
05F90:  MOVLB  1
....................             } 
....................  
....................             return; 
05F92:  MOVLB  0
05F94:  GOTO   679A
05F98:  MOVLB  5
....................          } 
....................  
....................          break; 
05F9A:  BRA    5FFC
....................  
....................       case TCP_LAST_ACK: 
....................          // Check to see if our FIN has been ACKnowledged 
....................          if(MyTCB.MySEQ + 1 == localAckNumber) 
05F9C:  MOVLW  01
05F9E:  MOVLB  1
05FA0:  ADDWF  x80,W
05FA2:  MOVLB  6
05FA4:  MOVWF  x09
05FA6:  MOVLW  00
05FA8:  MOVLB  1
05FAA:  ADDWFC x81,W
05FAC:  MOVLB  6
05FAE:  MOVWF  x0A
05FB0:  MOVLW  00
05FB2:  MOVLB  1
05FB4:  ADDWFC x82,W
05FB6:  MOVLB  6
05FB8:  MOVWF  x0B
05FBA:  MOVLW  00
05FBC:  MOVLB  1
05FBE:  ADDWFC x83,W
05FC0:  MOVLB  6
05FC2:  MOVWF  x0C
05FC4:  MOVLB  5
05FC6:  MOVF   xFC,W
05FC8:  MOVLB  6
05FCA:  SUBWF  x09,W
05FCC:  BNZ   5FF4
05FCE:  MOVLB  5
05FD0:  MOVF   xFD,W
05FD2:  MOVLB  6
05FD4:  SUBWF  x0A,W
05FD6:  BNZ   5FF4
05FD8:  MOVLB  5
05FDA:  MOVF   xFE,W
05FDC:  MOVLB  6
05FDE:  SUBWF  x0B,W
05FE0:  BNZ   5FF4
05FE2:  MOVLB  5
05FE4:  MOVF   xFF,W
05FE6:  MOVLB  6
05FE8:  SUBWF  x0C,W
05FEA:  BNZ   5FF4
....................             CloseSocket(); 
05FEC:  MOVLB  0
05FEE:  CALL   1138
05FF2:  MOVLB  6
....................          return; 
05FF4:  MOVLB  0
05FF6:  GOTO   679A
....................  
.................... //      case TCP_TIME_WAIT: 
.................... //         // Nothing is supposed to arrive here.  If it does, reset the quiet timer. 
.................... //         SendTCP(ACK, SENDTCP_RESET_TIMERS); 
.................... //         return; 
....................  
....................       default: 
....................          break; 
05FFA:  MOVLB  5
....................    } 
....................  
....................    // 
....................    // Sixth: Check the URG bit 
....................    // 
....................    // Urgent packets are not supported in this stack, so we 
....................    // will throw them away instead 
....................    if(localHeaderFlags & URG) 
05FFC:  MOVF   xFB,W
05FFE:  ANDLW  20
06000:  MOVWF  00
06002:  CLRF   03
06004:  MOVF   00,W
06006:  IORWF  03,W
06008:  BZ    6012
....................       return; 
0600A:  MOVLB  0
0600C:  GOTO   679A
06010:  MOVLB  5
....................  
....................    // 
....................    // Seventh: Process the segment text 
....................    // 
....................    // Throw data away if in a state that doesn't accept data 
....................    if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
06012:  MOVLB  1
06014:  MOVF   xF6,W
06016:  SUBLW  0B
06018:  BNZ   6022
....................       return; 
0601A:  MOVLB  0
0601C:  GOTO   679A
06020:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_CLOSING) 
06022:  MOVF   xF6,W
06024:  SUBLW  0A
06026:  BNZ   6030
....................       return; 
06028:  MOVLB  0
0602A:  GOTO   679A
0602E:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_LAST_ACK) 
06030:  MOVF   xF6,W
06032:  SUBLW  0C
06034:  BNZ   603E
....................       return; 
06036:  MOVLB  0
06038:  GOTO   679A
0603C:  MOVLB  1
.................... //   if(MyTCBStub.smState == TCP_TIME_WAIT) 
.................... //      return; 
....................  
....................    // Copy any valid segment data into our RX FIFO, if any 
....................    if(len) 
0603E:  MOVLB  5
06040:  MOVF   xEB,W
06042:  IORWF  xEC,W
06044:  BTFSC  FD8.2
06046:  BRA    65F8
....................    { 
....................       // See if there are bytes we must skip 
....................       if((SHORT)wMissingBytes <= 0) 
06048:  BTFSC  xF8.7
0604A:  BRA    605A
0604C:  MOVF   xF8,F
0604E:  BTFSS  FD8.2
06050:  BRA    6284
06052:  MOVF   xF7,W
06054:  SUBLW  00
06056:  BTFSS  FD8.0
06058:  BRA    6284
....................       { 
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes); 
0605A:  MOVLW  0C
0605C:  ADDWF  xE9,W
0605E:  MOVWF  FE9
06060:  MOVLW  00
06062:  ADDWFC xEA,W
06064:  MOVWF  FEA
06066:  MOVFF  FEF,00
0606A:  SWAPF  00,W
0606C:  ANDLW  0F
0606E:  MOVWF  02
06070:  RLCF   02,W
06072:  MOVLB  6
06074:  MOVWF  x09
06076:  CLRF   x0A
06078:  RLCF   x0A,F
0607A:  RLCF   x09,F
0607C:  RLCF   x0A,F
0607E:  MOVLW  FC
06080:  ANDWF  x09,F
06082:  MOVLB  5
06084:  MOVF   xF7,W
06086:  MOVLB  6
06088:  SUBWF  x09,F
0608A:  MOVLB  5
0608C:  MOVF   xF8,W
0608E:  MOVLB  6
06090:  SUBWFB x0A,F
06092:  MOVFF  60A,60E
06096:  MOVFF  609,60D
0609A:  MOVLB  0
0609C:  CALL   247A
....................          len += wMissingBytes;       
060A0:  MOVLB  5
060A2:  MOVF   xF7,W
060A4:  ADDWF  xEB,F
060A6:  MOVF   xF8,W
060A8:  ADDWFC xEC,F
....................     
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          // and request a retransmit by sending a duplicate ACK 
....................          if(len > wFreeSpace) 
060AA:  MOVF   xFA,W
060AC:  SUBWF  xEC,W
060AE:  BNC   60C0
060B0:  BNZ   60B8
060B2:  MOVF   xEB,W
060B4:  SUBWF  xF9,W
060B6:  BC    60C0
....................             len = wFreeSpace; 
060B8:  MOVFF  5FA,5EC
060BC:  MOVFF  5F9,5EB
....................     
....................          MyTCB.RemoteSEQ += (DWORD)len; 
060C0:  MOVFF  5EC,01
060C4:  CLRF   02
060C6:  CLRF   03
060C8:  MOVF   xEB,W
060CA:  MOVLB  1
060CC:  ADDWF  x84,F
060CE:  MOVF   01,W
060D0:  ADDWFC x85,F
060D2:  MOVF   02,W
060D4:  ADDWFC x86,F
060D6:  MOVF   03,W
060D8:  ADDWFC x87,F
....................        
....................          // Copy the application data from the packet into the socket RX FIFO 
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd) 
060DA:  MOVLB  5
060DC:  MOVF   xEB,W
060DE:  MOVLB  1
060E0:  ADDWF  xEA,W
060E2:  MOVLB  6
060E4:  MOVWF  x09
060E6:  MOVLB  5
060E8:  MOVF   xEC,W
060EA:  MOVLB  1
060EC:  ADDWFC xEB,W
060EE:  MOVLB  6
060F0:  MOVWF  x0A
060F2:  MOVLB  1
060F4:  MOVF   xE5,W
060F6:  MOVLB  6
060F8:  SUBWF  x0A,W
060FA:  BNC   61A8
060FC:  BNZ   610E
060FE:  MOVF   x09,W
06100:  MOVLB  1
06102:  SUBWF  xE4,W
06104:  BTFSS  FD8.0
06106:  BRA    610C
06108:  MOVLB  6
0610A:  BRA    61A8
0610C:  MOVLB  6
....................          { 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1; 
0610E:  MOVLB  1
06110:  MOVF   xEA,W
06112:  SUBWF  xE4,W
06114:  MOVLB  6
06116:  MOVWF  x09
06118:  MOVLB  1
0611A:  MOVF   xEB,W
0611C:  SUBWFB xE5,W
0611E:  MOVLB  6
06120:  MOVWF  x0A
06122:  MOVLW  01
06124:  ADDWF  x09,W
06126:  MOVLB  5
06128:  MOVWF  xF1
0612A:  MOVLW  00
0612C:  MOVLB  6
0612E:  ADDWFC x0A,W
06130:  MOVLB  5
06132:  MOVWF  xF2
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
06134:  MOVFF  1EB,63B
06138:  MOVFF  1EA,63A
0613C:  MOVFF  1FB,63C
06140:  MOVLB  6
06142:  SETF   x3E
06144:  SETF   x3D
06146:  CLRF   x3F
06148:  MOVFF  5F2,641
0614C:  MOVFF  5F1,640
06150:  MOVLB  0
06152:  CALL   0F7E
....................             TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
06156:  MOVLB  5
06158:  MOVF   xF1,W
0615A:  SUBWF  xEB,W
0615C:  MOVLB  6
0615E:  MOVWF  x09
06160:  MOVLB  5
06162:  MOVF   xF2,W
06164:  SUBWFB xEC,W
06166:  MOVLB  6
06168:  MOVWF  x0A
0616A:  MOVFF  1E3,63B
0616E:  MOVFF  1E2,63A
06172:  MOVFF  1FB,63C
06176:  SETF   x3E
06178:  SETF   x3D
0617A:  CLRF   x3F
0617C:  MOVWF  x41
0617E:  MOVFF  609,640
06182:  MOVLB  0
06184:  CALL   0F7E
....................             MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp); 
06188:  MOVLB  5
0618A:  MOVF   xF1,W
0618C:  SUBWF  xEB,W
0618E:  MOVWF  00
06190:  MOVF   xF2,W
06192:  SUBWFB xEC,W
06194:  MOVWF  03
06196:  MOVF   00,W
06198:  MOVLB  1
0619A:  ADDWF  xE2,W
0619C:  MOVWF  xEA
0619E:  MOVF   03,W
061A0:  ADDWFC xE3,W
061A2:  MOVWF  xEB
....................          } 
061A4:  BRA    61D8
061A6:  MOVLB  6
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
061A8:  MOVFF  1EB,63B
061AC:  MOVFF  1EA,63A
061B0:  MOVFF  1FB,63C
061B4:  SETF   x3E
061B6:  SETF   x3D
061B8:  CLRF   x3F
061BA:  MOVFF  5EC,641
061BE:  MOVFF  5EB,640
061C2:  MOVLB  0
061C4:  CALL   0F7E
....................             MyTCBStub.rxHead += len; 
061C8:  MOVLB  5
061CA:  MOVF   xEB,W
061CC:  MOVLB  1
061CE:  ADDWF  xEA,F
061D0:  MOVLB  5
061D2:  MOVF   xEC,W
061D4:  MOVLB  1
061D6:  ADDWFC xEB,F
....................          } 
....................        
....................          // See if we have a hole and other data waiting already in the RX FIFO 
....................          if(MyTCB.sHoleSize != -1) 
061D8:  INCFSZ x9C,W
061DA:  BRA    61E2
061DC:  INCFSZ x9D,W
061DE:  BRA    61E2
061E0:  BRA    6280
....................          { 
....................             MyTCB.sHoleSize -= len; 
061E2:  MOVLB  5
061E4:  MOVF   xEB,W
061E6:  MOVLB  1
061E8:  SUBWF  x9C,F
061EA:  MOVLB  5
061EC:  MOVF   xEC,W
061EE:  MOVLB  1
061F0:  SUBWFB x9D,F
....................             wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize; 
061F2:  MOVF   x9C,W
061F4:  ADDWF  x90,W
061F6:  MOVWF  01
061F8:  MOVF   x9D,W
061FA:  ADDWFC x91,W
061FC:  MOVFF  01,5F1
06200:  MOVLB  5
06202:  MOVWF  xF2
....................        
....................             // See if we just closed up a hole, and if so, advance head pointer 
....................             if((SHORT)wTemp < (SHORT)0) 
06204:  BTFSS  xF2.7
06206:  BRA    6210
....................             { 
....................                MyTCB.sHoleSize = -1; 
06208:  MOVLB  1
0620A:  SETF   x9D
0620C:  SETF   x9C
....................             } 
0620E:  BRA    6280
....................             else if(MyTCB.sHoleSize <= 0) 
06210:  MOVLB  1
06212:  BTFSC  x9D.7
06214:  BRA    6220
06216:  MOVF   x9D,F
06218:  BNZ   6280
0621A:  MOVF   x9C,W
0621C:  SUBLW  00
0621E:  BNC   6280
....................             { 
....................                MyTCB.RemoteSEQ += wTemp; 
06220:  MOVLB  5
06222:  MOVF   xF1,W
06224:  MOVLB  1
06226:  ADDWF  x84,F
06228:  MOVLB  5
0622A:  MOVF   xF2,W
0622C:  MOVLB  1
0622E:  ADDWFC x85,F
06230:  MOVLW  00
06232:  ADDWFC x86,F
06234:  ADDWFC x87,F
....................                MyTCBStub.rxHead += wTemp; 
06236:  MOVLB  5
06238:  MOVF   xF1,W
0623A:  MOVLB  1
0623C:  ADDWF  xEA,F
0623E:  MOVLB  5
06240:  MOVF   xF2,W
06242:  MOVLB  1
06244:  ADDWFC xEB,F
....................                if(MyTCBStub.rxHead > MyTCBStub.bufferEnd) 
06246:  MOVF   xE5,W
06248:  SUBWF  xEB,W
0624A:  BNC   627C
0624C:  BNZ   6254
0624E:  MOVF   xEA,W
06250:  SUBWF  xE4,W
06252:  BC    627C
....................                   MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;                      
06254:  MOVF   xE2,W
06256:  SUBWF  xE4,W
06258:  MOVLB  6
0625A:  MOVWF  x09
0625C:  MOVLB  1
0625E:  MOVF   xE3,W
06260:  SUBWFB xE5,W
06262:  MOVLB  6
06264:  MOVWF  x0A
06266:  MOVLW  01
06268:  ADDWF  x09,W
0626A:  MOVWF  01
0626C:  MOVLW  00
0626E:  ADDWFC x0A,W
06270:  MOVWF  03
06272:  MOVF   01,W
06274:  MOVLB  1
06276:  SUBWF  xEA,F
06278:  MOVF   03,W
0627A:  SUBWFB xEB,F
....................                MyTCB.sHoleSize = -1; 
0627C:  SETF   x9D
0627E:  SETF   x9C
....................             } 
....................          } 
....................       } // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it 
06280:  BRA    65F6
06282:  MOVLB  5
....................       else if((SHORT)wMissingBytes > 0) 
06284:  BTFSC  xF8.7
06286:  BRA    65F8
06288:  MOVF   xF8,F
0628A:  BNZ   6294
0628C:  MOVF   xF7,W
0628E:  SUBLW  00
06290:  BTFSC  FD8.0
06292:  BRA    65F8
....................       { 
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          if(len + wMissingBytes > wFreeSpace) 
06294:  MOVF   xF7,W
06296:  ADDWF  xEB,W
06298:  MOVLB  6
0629A:  MOVWF  x09
0629C:  MOVLB  5
0629E:  MOVF   xF8,W
062A0:  ADDWFC xEC,W
062A2:  MOVLB  6
062A4:  MOVWF  x0A
062A6:  MOVLB  5
062A8:  MOVF   xFA,W
062AA:  MOVLB  6
062AC:  SUBWF  x0A,W
062AE:  BNC   62D2
062B0:  BNZ   62C2
062B2:  MOVF   x09,W
062B4:  MOVLB  5
062B6:  SUBWF  xF9,W
062B8:  BTFSS  FD8.0
062BA:  BRA    62C0
062BC:  MOVLB  6
062BE:  BRA    62D2
062C0:  MOVLB  6
....................             len = wFreeSpace - wMissingBytes; 
062C2:  MOVLB  5
062C4:  MOVF   xF7,W
062C6:  SUBWF  xF9,W
062C8:  MOVWF  xEB
062CA:  MOVF   xF8,W
062CC:  SUBWFB xFA,W
062CE:  MOVWF  xEC
062D0:  MOVLB  6
....................        
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer(h->DataOffset.Val << 2); 
062D2:  MOVLW  0C
062D4:  MOVLB  5
062D6:  ADDWF  xE9,W
062D8:  MOVWF  FE9
062DA:  MOVLW  00
062DC:  ADDWFC xEA,W
062DE:  MOVWF  FEA
062E0:  MOVFF  FEF,00
062E4:  SWAPF  00,W
062E6:  ANDLW  0F
062E8:  MOVWF  02
062EA:  RLCF   02,W
062EC:  MOVLB  6
062EE:  MOVWF  x09
062F0:  CLRF   x0A
062F2:  RLCF   x0A,F
062F4:  RLCF   x09,F
062F6:  RLCF   x0A,F
062F8:  MOVLW  FC
062FA:  ANDWF  x09,F
062FC:  MOVFF  60A,60E
06300:  MOVFF  609,60D
06304:  MOVLB  0
06306:  CALL   247A
....................     
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd) 
0630A:  MOVLB  5
0630C:  MOVF   xF7,W
0630E:  MOVLB  1
06310:  ADDWF  xEA,W
06312:  MOVLB  6
06314:  MOVWF  x09
06316:  MOVLB  5
06318:  MOVF   xF8,W
0631A:  MOVLB  1
0631C:  ADDWFC xEB,W
0631E:  MOVLB  6
06320:  MOVWF  x0A
06322:  MOVLB  5
06324:  MOVF   xEB,W
06326:  MOVLB  6
06328:  ADDWF  x09,F
0632A:  MOVLB  5
0632C:  MOVF   xEC,W
0632E:  MOVLB  6
06330:  ADDWFC x0A,F
06332:  MOVLB  1
06334:  MOVF   xE5,W
06336:  MOVLB  6
06338:  SUBWF  x0A,W
0633A:  BTFSS  FD8.0
0633C:  BRA    6452
0633E:  BNZ   6350
06340:  MOVF   x09,W
06342:  MOVLB  1
06344:  SUBWF  xE4,W
06346:  BTFSS  FD8.0
06348:  BRA    634E
0634A:  MOVLB  6
0634C:  BRA    6452
0634E:  MOVLB  6
....................          { 
....................             // Calculate number of data bytes to copy before wraparound 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes; 
06350:  MOVLB  1
06352:  MOVF   xEA,W
06354:  SUBWF  xE4,W
06356:  MOVLB  6
06358:  MOVWF  x09
0635A:  MOVLB  1
0635C:  MOVF   xEB,W
0635E:  SUBWFB xE5,W
06360:  MOVLB  6
06362:  MOVWF  x0A
06364:  MOVLW  01
06366:  ADDWF  x09,F
06368:  MOVLW  00
0636A:  ADDWFC x0A,F
0636C:  MOVLB  5
0636E:  MOVF   xF7,W
06370:  MOVLB  6
06372:  SUBWF  x09,W
06374:  MOVLB  5
06376:  MOVWF  xF1
06378:  MOVF   xF8,W
0637A:  MOVLB  6
0637C:  SUBWFB x0A,W
0637E:  MOVLB  5
06380:  MOVWF  xF2
....................             if((SHORT)wTemp >= 0) 
06382:  BTFSC  xF2.7
06384:  BRA    63F0
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
06386:  MOVF   xF7,W
06388:  MOVLB  1
0638A:  ADDWF  xEA,W
0638C:  MOVLB  6
0638E:  MOVWF  x09
06390:  MOVLB  5
06392:  MOVF   xF8,W
06394:  MOVLB  1
06396:  ADDWFC xEB,W
06398:  MOVLB  6
0639A:  MOVWF  x0A
0639C:  MOVWF  x3B
0639E:  MOVFF  609,63A
063A2:  MOVFF  1FB,63C
063A6:  SETF   x3E
063A8:  SETF   x3D
063AA:  CLRF   x3F
063AC:  MOVFF  5F2,641
063B0:  MOVFF  5F1,640
063B4:  MOVLB  0
063B6:  CALL   0F7E
....................                TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
063BA:  MOVLB  5
063BC:  MOVF   xF1,W
063BE:  SUBWF  xEB,W
063C0:  MOVLB  6
063C2:  MOVWF  x09
063C4:  MOVLB  5
063C6:  MOVF   xF2,W
063C8:  SUBWFB xEC,W
063CA:  MOVLB  6
063CC:  MOVWF  x0A
063CE:  MOVFF  1E3,63B
063D2:  MOVFF  1E2,63A
063D6:  MOVFF  1FB,63C
063DA:  SETF   x3E
063DC:  SETF   x3D
063DE:  CLRF   x3F
063E0:  MOVWF  x41
063E2:  MOVFF  609,640
063E6:  MOVLB  0
063E8:  CALL   0F7E
....................             } 
063EC:  BRA    644E
063EE:  MOVLB  5
....................             else 
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
063F0:  MOVF   xF7,W
063F2:  MOVLB  1
063F4:  ADDWF  xEA,W
063F6:  MOVLB  6
063F8:  MOVWF  x09
063FA:  MOVLB  5
063FC:  MOVF   xF8,W
063FE:  MOVLB  1
06400:  ADDWFC xEB,W
06402:  MOVLB  6
06404:  MOVWF  x0A
06406:  MOVLB  1
06408:  MOVF   xE2,W
0640A:  SUBWF  xE4,W
0640C:  MOVLB  6
0640E:  MOVWF  x0B
06410:  MOVLB  1
06412:  MOVF   xE3,W
06414:  SUBWFB xE5,W
06416:  MOVLB  6
06418:  MOVWF  x0C
0641A:  MOVLW  01
0641C:  ADDWF  x0B,W
0641E:  MOVWF  01
06420:  MOVLW  00
06422:  ADDWFC x0C,W
06424:  MOVWF  03
06426:  MOVF   01,W
06428:  SUBWF  x09,F
0642A:  MOVF   03,W
0642C:  SUBWFB x0A,F
0642E:  MOVFF  60A,63B
06432:  MOVFF  609,63A
06436:  MOVFF  1FB,63C
0643A:  SETF   x3E
0643C:  SETF   x3D
0643E:  CLRF   x3F
06440:  MOVFF  5EC,641
06444:  MOVFF  5EB,640
06448:  MOVLB  0
0644A:  CALL   0F7E
....................             } 
....................          } 
0644E:  BRA    6488
06450:  MOVLB  6
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
06452:  MOVLB  5
06454:  MOVF   xF7,W
06456:  MOVLB  1
06458:  ADDWF  xEA,W
0645A:  MOVLB  6
0645C:  MOVWF  x09
0645E:  MOVLB  5
06460:  MOVF   xF8,W
06462:  MOVLB  1
06464:  ADDWFC xEB,W
06466:  MOVLB  6
06468:  MOVWF  x0A
0646A:  MOVWF  x3B
0646C:  MOVFF  609,63A
06470:  MOVFF  1FB,63C
06474:  SETF   x3E
06476:  SETF   x3D
06478:  CLRF   x3F
0647A:  MOVFF  5EC,641
0647E:  MOVFF  5EB,640
06482:  MOVLB  0
06484:  CALL   0F7E
....................          } 
....................        
....................          // Record the hole is here 
....................          if(MyTCB.sHoleSize == -1) 
06488:  MOVLB  1
0648A:  INCFSZ x9C,W
0648C:  BRA    64A4
0648E:  INCFSZ x9D,W
06490:  BRA    64A4
....................          { 
....................             MyTCB.sHoleSize = wMissingBytes; 
06492:  MOVFF  5F8,19D
06496:  MOVFF  5F7,19C
....................             MyTCB.wFutureDataSize = len; 
0649A:  MOVFF  5EC,191
0649E:  MOVFF  5EB,190
....................          } 
064A2:  BRA    65F6
....................          else 
....................          { 
....................             // We already have a hole, see if we can shrink the hole  
....................             // or extend the future data size 
....................             if(wMissingBytes < (WORD)MyTCB.sHoleSize) 
064A4:  MOVLB  5
064A6:  MOVF   xF8,W
064A8:  MOVLB  1
064AA:  SUBWF  x9D,W
064AC:  BNC   6564
064AE:  BNZ   64C0
064B0:  MOVF   x9C,W
064B2:  MOVLB  5
064B4:  SUBWF  xF7,W
064B6:  BTFSS  FD8.0
064B8:  BRA    64BE
064BA:  MOVLB  1
064BC:  BRA    6564
064BE:  MOVLB  1
....................             { 
....................                if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize)) 
064C0:  MOVLB  5
064C2:  MOVF   xEB,W
064C4:  ADDWF  xF7,W
064C6:  MOVLB  6
064C8:  MOVWF  x09
064CA:  MOVLB  5
064CC:  MOVF   xEC,W
064CE:  ADDWFC xF8,W
064D0:  MOVLB  6
064D2:  MOVWF  x0A
064D4:  MOVLB  1
064D6:  MOVF   x90,W
064D8:  ADDWF  x9C,W
064DA:  MOVWF  01
064DC:  MOVF   x91,W
064DE:  ADDWFC x9D,W
064E0:  MOVWF  03
064E2:  MOVF   03,W
064E4:  MOVLB  6
064E6:  SUBWF  x0A,W
064E8:  BNC   64F2
064EA:  BNZ   6522
064EC:  MOVF   x09,W
064EE:  SUBWF  01,W
064F0:  BNC   6522
064F2:  MOVLB  5
064F4:  MOVF   xEB,W
064F6:  ADDWF  xF7,W
064F8:  MOVLB  6
064FA:  MOVWF  x09
064FC:  MOVLB  5
064FE:  MOVF   xEC,W
06500:  ADDWFC xF8,W
06502:  MOVLB  6
06504:  MOVWF  x0A
06506:  MOVLB  1
06508:  SUBWF  x9D,W
0650A:  BNC   652E
0650C:  BTFSC  FD8.2
0650E:  BRA    6514
06510:  MOVLB  6
06512:  BRA    6522
06514:  MOVF   x9C,W
06516:  MOVLB  6
06518:  SUBWF  x09,W
0651A:  BTFSS  FD8.0
0651C:  BRA    6522
0651E:  MOVLB  1
06520:  BRA    652E
....................                   MyTCB.wFutureDataSize = len; 
06522:  MOVFF  5EC,191
06526:  MOVFF  5EB,190
0652A:  BRA    655A
0652C:  MOVLB  1
....................                else 
....................                   MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes; 
0652E:  MOVF   x90,W
06530:  ADDWF  x9C,W
06532:  MOVLB  6
06534:  MOVWF  x09
06536:  MOVLB  1
06538:  MOVF   x91,W
0653A:  ADDWFC x9D,W
0653C:  MOVLB  6
0653E:  MOVWF  x0A
06540:  MOVLB  5
06542:  MOVF   xF7,W
06544:  MOVLB  6
06546:  SUBWF  x09,W
06548:  MOVLB  1
0654A:  MOVWF  x90
0654C:  MOVLB  5
0654E:  MOVF   xF8,W
06550:  MOVLB  6
06552:  SUBWFB x0A,W
06554:  MOVLB  1
06556:  MOVWF  x91
06558:  MOVLB  6
....................                MyTCB.sHoleSize = wMissingBytes; 
0655A:  MOVFF  5F8,19D
0655E:  MOVFF  5F7,19C
....................             } 
06562:  BRA    65FA
....................             else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
06564:  MOVLB  5
06566:  MOVF   xEB,W
06568:  ADDWF  xF7,W
0656A:  MOVLB  6
0656C:  MOVWF  x09
0656E:  MOVLB  5
06570:  MOVF   xEC,W
06572:  ADDWFC xF8,W
06574:  MOVLB  6
06576:  MOVWF  x0A
06578:  MOVLB  1
0657A:  MOVF   x90,W
0657C:  ADDWF  x9C,W
0657E:  MOVWF  01
06580:  MOVF   x91,W
06582:  ADDWFC x9D,W
06584:  MOVWF  03
06586:  MOVF   03,W
06588:  MOVLB  6
0658A:  SUBWF  x0A,W
0658C:  BNC   65FA
0658E:  BNZ   6596
06590:  MOVF   x09,W
06592:  SUBWF  01,W
06594:  BC    65FA
....................             { 
....................                // Make sure that there isn't a second hole between  
....................                // our future data and this TCP segment's future data 
....................                if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
06596:  MOVLB  1
06598:  MOVF   x90,W
0659A:  ADDWF  x9C,W
0659C:  MOVWF  01
0659E:  MOVF   x91,W
065A0:  ADDWFC x9D,W
065A2:  MOVWF  03
065A4:  MOVF   01,W
065A6:  MOVLB  5
065A8:  MOVF   xF8,W
065AA:  SUBWF  03,W
065AC:  BNC   65F8
065AE:  BNZ   65B6
065B0:  MOVF   xF7,W
065B2:  SUBWF  01,W
065B4:  BNC   65F8
....................                   MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize; 
065B6:  MOVF   xEB,W
065B8:  ADDWF  xF7,W
065BA:  MOVLB  6
065BC:  MOVWF  x09
065BE:  MOVLB  5
065C0:  MOVF   xEC,W
065C2:  ADDWFC xF8,W
065C4:  MOVLB  6
065C6:  MOVWF  x0A
065C8:  MOVLB  1
065CA:  MOVF   x9C,W
065CC:  MOVLB  6
065CE:  SUBWF  x09,F
065D0:  MOVLB  1
065D2:  MOVF   x9D,W
065D4:  MOVLB  6
065D6:  SUBWFB x0A,F
065D8:  MOVLB  1
065DA:  MOVF   x90,W
065DC:  MOVLB  6
065DE:  SUBWF  x09,W
065E0:  MOVWF  00
065E2:  MOVLB  1
065E4:  MOVF   x91,W
065E6:  MOVLB  6
065E8:  SUBWFB x0A,W
065EA:  MOVWF  03
065EC:  MOVF   00,W
065EE:  MOVLB  1
065F0:  ADDWF  x90,F
065F2:  MOVF   03,W
065F4:  ADDWFC x91,F
065F6:  MOVLB  5
065F8:  MOVLB  6
....................             } 
....................              
....................          } 
....................       } 
....................    } 
....................  
....................    // Send back an ACK of the data (+SYN | FIN) we just received,  
....................    // if any.  To minimize bandwidth waste, we are implementing  
....................    // the delayed acknowledgement algorithm here, only sending  
....................    // back an immediate ACK if this is the second segment received.   
....................    // Otherwise, a 200ms timer will cause the ACK to be transmitted. 
....................    if(wSegmentLength) 
065FA:  MOVF   x04,W
065FC:  IORWF  x05,W
065FE:  BZ    6652
....................    { 
....................       // For non-established sockets, let's delete all data in  
....................       // the RX buffer immediately after receiving it.  This is  
....................       // not really how TCP was intended to operate since a  
....................       // socket cannot receive any response after it sends a FIN, 
....................       // but our TCP application API doesn't readily accomodate 
....................       // receiving data after calling TCPDisconnect(), which  
....................       // invalidates the application TCP handle.  By deleting all  
....................       // data, we'll ensure that the RX window is nonzero and  
....................       // the remote node will be able to send us a FIN response,  
....................       // which needs an RX window of at least 1. 
....................       if(MyTCBStub.smState != TCP_ESTABLISHED) 
06600:  MOVLB  1
06602:  MOVF   xF6,W
06604:  SUBLW  07
06606:  BZ    6610
....................          MyTCBStub.rxTail = MyTCBStub.rxHead; 
06608:  MOVFF  1EB,1ED
0660C:  MOVFF  1EA,1EC
....................  
....................       if(MyTCBStub.Flags.bOneSegmentReceived) 
06610:  BTFSS  xF7.7
06612:  BRA    662C
....................       { 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
06614:  MOVLW  10
06616:  MOVLB  6
06618:  MOVWF  x09
0661A:  MOVLW  01
0661C:  MOVWF  x0A
0661E:  MOVLB  0
06620:  CALL   3598
....................          SyncTCB(); 
06624:  CALL   1064
....................          // bOneSegmentReceived is cleared in SendTCP(), so no need here 
....................       } 
06628:  BRA    6650
0662A:  MOVLB  1
....................       else 
....................       { 
....................          MyTCBStub.Flags.bOneSegmentReceived = TRUE;    
0662C:  BSF    xF7.7
....................        
....................          // Do not send an ACK immediately back.  Instead, we will  
....................          // perform delayed acknowledgements.  To do this, we will  
....................          // just start a timer 
....................          if(!MyTCBStub.Flags.bDelayedACKTimerEnabled) 
0662E:  BTFSC  xF7.6
06630:  BRA    664E
....................          { 
....................             MyTCBStub.Flags.bDelayedACKTimerEnabled = 1; 
06632:  BSF    xF7.6
....................             MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8); 
06634:  MOVLB  0
06636:  CALL   2F9C
0663A:  MOVLW  0C
0663C:  MOVLB  6
0663E:  ADDWF  00,W
06640:  MOVLB  1
06642:  MOVWF  xF4
06644:  MOVLW  00
06646:  MOVLB  6
06648:  ADDWFC 01,W
0664A:  MOVLB  1
0664C:  MOVWF  xF5
0664E:  MOVLB  0
06650:  MOVLB  6
....................          } 
....................       } 
....................    } 
....................  
....................    // 
....................    // Eighth: check the FIN bit 
....................    // 
....................    if(localHeaderFlags & FIN) 
06652:  MOVLB  5
06654:  MOVF   xFB,W
06656:  ANDLW  01
06658:  MOVWF  00
0665A:  CLRF   03
0665C:  MOVF   00,W
0665E:  IORWF  03,W
06660:  BTFSC  FD8.2
06662:  BRA    679E
....................    { 
....................       // Note: Since we don't have a good means of storing "FIN bytes"  
....................       // in our TCP RX FIFO, we must ensure that FINs are processed  
....................       // in-order. 
....................       if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength) 
06664:  MOVLW  01
06666:  MOVLB  1
06668:  ADDWF  x84,W
0666A:  MOVLB  6
0666C:  MOVWF  x09
0666E:  MOVLW  00
06670:  MOVLB  1
06672:  ADDWFC x85,W
06674:  MOVLB  6
06676:  MOVWF  x0A
06678:  MOVLW  00
0667A:  MOVLB  1
0667C:  ADDWFC x86,W
0667E:  MOVLB  6
06680:  MOVWF  x0B
06682:  MOVLW  00
06684:  MOVLB  1
06686:  ADDWFC x87,W
06688:  MOVLB  6
0668A:  MOVWF  x0C
0668C:  MOVFF  604,00
06690:  MOVFF  605,01
06694:  CLRF   02
06696:  CLRF   03
06698:  MOVF   x00,W
0669A:  ADDWF  00,F
0669C:  MOVF   x01,W
0669E:  ADDWFC 01,F
066A0:  MOVF   x02,W
066A2:  ADDWFC 02,F
066A4:  MOVF   x03,W
066A6:  ADDWFC 03,F
066A8:  MOVF   00,W
066AA:  SUBWF  x09,W
066AC:  BTFSS  FD8.2
066AE:  BRA    679C
066B0:  MOVF   01,W
066B2:  SUBWF  x0A,W
066B4:  BTFSS  FD8.2
066B6:  BRA    679C
066B8:  MOVF   02,W
066BA:  SUBWF  x0B,W
066BC:  BTFSS  FD8.2
066BE:  BRA    679C
066C0:  MOVF   03,W
066C2:  SUBWF  x0C,W
066C4:  BTFSS  FD8.2
066C6:  BRA    679C
....................       { 
....................          // FINs are treated as one byte of data for ACK sequencing 
....................          MyTCB.RemoteSEQ++; 
066C8:  MOVLW  01
066CA:  MOVLB  1
066CC:  ADDWF  x84,F
066CE:  BTFSC  FD8.0
066D0:  INCF   x85,F
066D2:  BTFSC  FD8.2
066D4:  INCF   x86,F
066D6:  BTFSC  FD8.2
066D8:  INCF   x87,F
....................           
....................          switch(MyTCBStub.smState) 
066DA:  MOVF   xF6,W
066DC:  XORLW  06
066DE:  MOVLB  0
066E0:  BZ    66F0
066E2:  XORLW  01
066E4:  BZ    6708
066E6:  XORLW  0F
066E8:  BZ    672A
066EA:  XORLW  01
066EC:  BZ    6774
066EE:  BRA    6788
....................          { 
....................             case TCP_SYN_RECEIVED: 
....................                // RFC in exact: Our API has no need for the user  
....................                // to explicitly close a socket that never really  
....................                // got opened fully in the first place, so just  
....................                // transmit a FIN automatically and jump to  
....................                // TCP_LAST_ACK 
....................                MyTCBStub.smState = TCP_LAST_ACK; 
066F0:  MOVLW  0C
066F2:  MOVLB  1
066F4:  MOVWF  xF6
....................                SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
066F6:  MOVLW  11
066F8:  MOVLB  6
066FA:  MOVWF  x09
066FC:  MOVLW  01
066FE:  MOVWF  x0A
06700:  MOVLB  0
06702:  CALL   3598
....................                return; 
06706:  BRA    679A
....................  
....................             case TCP_ESTABLISHED: 
....................                // Go to TCP_CLOSE_WAIT state 
....................                MyTCBStub.smState = TCP_CLOSE_WAIT; 
06708:  MOVLW  0B
0670A:  MOVLB  1
0670C:  MOVWF  xF6
....................                 
....................                // For legacy applications that don't call  
....................                // TCPDisconnect() as needed and expect the TCP/IP  
....................                // Stack to automatically close sockets when the  
....................                // remote node sends a FIN, let's start a timer so  
....................                // that we will eventually close the socket automatically 
....................                MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8); 
0670E:  MOVLB  0
06710:  CALL   2F9C
06714:  MOVLW  18
06716:  MOVLB  6
06718:  ADDWF  00,W
0671A:  MOVLB  1
0671C:  MOVWF  xF4
0671E:  MOVLW  00
06720:  MOVLB  6
06722:  ADDWFC 01,W
06724:  MOVLB  1
06726:  MOVWF  xF5
....................                break; 
06728:  BRA    678A
....................     
....................             case TCP_FIN_WAIT_1: 
....................                if(MyTCB.MySEQ == localAckNumber) 
0672A:  MOVLB  5
0672C:  MOVF   xFC,W
0672E:  MOVLB  1
06730:  SUBWF  x80,W
06732:  BNZ   676A
06734:  MOVLB  5
06736:  MOVF   xFD,W
06738:  MOVLB  1
0673A:  SUBWF  x81,W
0673C:  BNZ   676A
0673E:  MOVLB  5
06740:  MOVF   xFE,W
06742:  MOVLB  1
06744:  SUBWF  x82,W
06746:  BNZ   676A
06748:  MOVLB  5
0674A:  MOVF   xFF,W
0674C:  MOVLB  1
0674E:  SUBWF  x83,W
06750:  BNZ   676A
....................                { 
....................                   // RFC not recommended: We should be going to  
....................                   // the TCP_TIME_WAIT state right here and  
....................                   // starting a 2MSL timer, but since we have so  
....................                   // few precious sockets, we can't afford to  
....................                   // leave a socket waiting around doing nothing  
....................                   // for a long time.  If the remote node does  
....................                   // not recieve this ACK, it'll have to figure  
....................                   // out on it's own that the connection is now  
....................                   // closed. 
....................                   SendTCP(ACK, 0); 
06752:  MOVLW  10
06754:  MOVLB  6
06756:  MOVWF  x09
06758:  CLRF   x0A
0675A:  MOVLB  0
0675C:  CALL   3598
....................                   CloseSocket(); 
06760:  CALL   1138
....................                   return; 
06764:  BRA    679A
....................                } 
06766:  BRA    6770
06768:  MOVLB  1
....................                else 
....................                { 
....................                   MyTCBStub.smState = TCP_CLOSING; 
0676A:  MOVLW  0A
0676C:  MOVWF  xF6
0676E:  MOVLB  0
....................                } 
....................                break; 
06770:  MOVLB  1
06772:  BRA    678A
....................     
....................             case TCP_FIN_WAIT_2: 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                SendTCP(ACK, 0); 
06774:  MOVLW  10
06776:  MOVLB  6
06778:  MOVWF  x09
0677A:  CLRF   x0A
0677C:  MOVLB  0
0677E:  CALL   3598
....................                CloseSocket(); 
06782:  CALL   1138
....................                return; 
06786:  BRA    679A
....................  
....................             default: 
....................                break; 
06788:  MOVLB  1
....................          } 
....................  
....................          // Acknowledge receipt of FIN 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
0678A:  MOVLW  10
0678C:  MOVLB  6
0678E:  MOVWF  x09
06790:  MOVLW  01
06792:  MOVWF  x0A
06794:  MOVLB  0
06796:  CALL   3598
0679A:  MOVLB  6
0679C:  MOVLB  5
....................       } 
....................    } 
0679E:  MOVLB  0
067A0:  GOTO   6906 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Buffer Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize,  
....................                      WORD wMinTXSize, BYTE vFlags) 
....................  
....................   Summary: 
....................    Adjusts the relative sizes of the RX and TX buffers. 
....................  
....................   Description: 
....................    This function can be used to adjust the relative sizes of the RX and 
....................    TX FIFO depending on the immediate needs of an application.  Since a  
....................    larger FIFO can allow more data to be sent in a given packet, adjusting  
....................    the relative sizes on the fly can allow for optimal transmission speed  
....................    for one-sided application protocols.  For example, HTTP typically  
....................    begins by receiving large amounts of data from the client, then switches 
....................    to serving large amounts of data back.  Adjusting the FIFO at these  
....................    points can increase performance substantially.  Once the FIFO is 
....................    adjusted, a window update is sent. 
....................     
....................    If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and  
....................    TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the 
....................    remaining space equally. 
....................     
....................    Received data can be preserved as long as the buffer is expanding and  
....................    has not wrapped. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - The socket to be adjusted 
....................    wMinRXSize   - Minimum number of byte for the RX FIFO 
....................    wMinTXSize    - Minimum number of bytes for the RX FIFO 
....................    vFlags      - Any combination of TCP_ADJUST_GIVE_REST_TO_RX,  
....................               TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX. 
....................               TCP_ADJUST_PRESERVE_TX is not currently supported. 
....................  
....................   Return Values: 
....................    TRUE - The FIFOs were adjusted successfully 
....................    FALSE - Minimum RX, Minimum TX, or flags couldn't be accommodated and 
....................          therefore the socket was left unchanged. 
....................  
....................   Side Effects: 
....................    Any unacknowledged or untransmitted data in the TX FIFO is always 
....................    deleted. 
....................  
....................   Remarks: 
....................    At least one byte must always be allocated to the RX buffer so that 
....................    a FIN can be received.  The function automatically corrects for this. 
....................   ***************************************************************************/ 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags) 
.................... { 
....................    PTR_BASE ptrTemp, ptrHead; 
....................    WORD wTXAllocation; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    // Load up info on this socket 
....................    SyncTCBStub(hTCP); 
....................  
....................    // RX has to be at least 1 byte to receive SYN and FIN bytes  
....................    // from the remote node, even if they aren't stored in the RX FIFO 
....................    if(wMinRXSize == 0u) 
....................       wMinRXSize = 1; 
....................        
....................    // SSL connections need to be able to send or receive at least  
....................    // a full Alert record, MAC, and FIN 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP) && wMinRXSize < 25u) 
....................       wMinRXSize = 25; 
....................    if(TCPIsSSL(hTCP) && wMinTXSize < 25u) 
....................       wMinTXSize = 25; 
....................    #endif 
....................     
....................    // Make sure space is available for minimums 
....................    ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1; 
....................    if(wMinRXSize + wMinTXSize > ptrTemp) 
....................       return FALSE; 
....................  
....................    SyncTCB(); 
....................  
....................    // Set both allocation flags if none set 
....................    if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX))) 
....................       vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX; 
....................        
....................  
....................    // Allocate minimums 
....................    wTXAllocation = wMinTXSize; 
....................    ptrTemp -= wMinRXSize + wMinTXSize; 
....................  
....................    // Allocate extra 
....................    if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX) 
....................    { 
....................       if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX) 
....................       { 
....................          // Do a 50%/50% split with any odd byte always going to the RX FIFO 
....................          wTXAllocation += ptrTemp>>1; 
....................       } 
....................       else 
....................       { 
....................          wTXAllocation += ptrTemp; 
....................       } 
....................    } 
....................  
....................    // Calculate new bufferRxStart pointer 
....................    ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1; 
....................  
....................    // Find the head pointer to use 
....................    ptrHead = MyTCBStub.rxHead; 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       ptrHead = MyTCBStub.sslRxHead; 
....................    #endif 
....................     
....................    // If there's out-of-order data pending, adjust the head pointer to compensate 
....................    if(MyTCB.sHoleSize != -1) 
....................    { 
....................       ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................       if(ptrHead > MyTCBStub.bufferEnd) 
....................          ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    } 
....................  
....................    // Determine if resizing will lose any RX data 
....................    if(MyTCBStub.rxTail < ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.rxTail) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................  
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else if(MyTCBStub.rxTail > ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.bufferRxStart) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................              
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       // No data to preserve, but we may need to move  
....................       // the pointers to stay in the RX space 
....................       MyTCBStub.rxTail = ptrTemp; 
....................       MyTCBStub.rxHead = ptrTemp; 
....................        
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslRxHead = ptrTemp; 
....................       #endif 
....................    } 
....................     
....................    // If we need to preserve data that wrapped in the ring, we must copy 
....................    if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX)) 
....................    { 
....................       TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium,  
....................          MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, 
....................          ptrHead - MyTCBStub.bufferRxStart); 
....................  
....................       // Move the pointers if they were in front of the tail 
....................       #if defined(STACK_USE_SSL) 
....................       if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................       #endif 
....................       if(MyTCBStub.rxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................    } 
....................     
....................    // Move the RX buffer pointer - it's the one that divides the two 
....................    MyTCBStub.bufferRxStart = ptrTemp; 
....................  
....................    // Empty the TX buffer 
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       MyTCBStub.sslTxHead = MyTCBStub.txHead + 5; 
....................    #endif 
....................     
....................    // Send a window update to notify remote node of change 
....................    if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................  
....................    return TRUE; 
....................  
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource,  
....................                      BYTE vSourceType, WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM). 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    ptrDest      - Address to write to 
....................    vDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    ptrSource   - Address to copy from 
....................    vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM) 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer.  However, if they do  
....................    overlap there must be at least 4 bytes of non-overlap to ensure correct  
....................    results due to hardware DMA requirements. 
....................   ***************************************************************************/ 
.................... static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength) 
.................... { 
....................    #if defined(SPIRAM_CS_TRIS) 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................    #endif 
....................        
....................    switch(vSourceType) 
*
00F7E:  MOVLB  6
00F80:  MOVF   x3F,W
00F82:  XORLW  01
00F84:  MOVLB  0
00F86:  BZ    0F8E
00F88:  XORLW  01
00F8A:  BZ    1000
00F8C:  BRA    1062
....................    { 
....................       case TCP_PIC_RAM: 
....................          switch(vDestType) 
00F8E:  MOVLB  6
00F90:  MOVF   x3C,W
00F92:  XORLW  01
00F94:  MOVLB  0
00F96:  BZ    0F9E
00F98:  XORLW  01
00F9A:  BZ    0FD0
00F9C:  BRA    0FFE
....................          { 
....................             case TCP_PIC_RAM: 
....................                memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength); 
00F9E:  MOVFF  63B,FEA
00FA2:  MOVFF  63A,FE9
00FA6:  MOVFF  63E,FE2
00FAA:  MOVFF  63D,FE1
00FAE:  MOVFF  641,02
00FB2:  MOVFF  640,01
00FB6:  MOVF   01,F
00FB8:  BZ    0FBE
00FBA:  INCF   02,F
00FBC:  BRA    0FC2
00FBE:  MOVF   02,F
00FC0:  BZ    0FCE
00FC2:  MOVFF  FE6,FEE
00FC6:  DECFSZ 01,F
00FC8:  BRA    0FC2
00FCA:  DECFSZ 02,F
00FCC:  BRA    0FC2
....................                break; 
00FCE:  BRA    0FFE
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
00FD0:  MOVLB  6
00FD2:  INCFSZ x3A,W
00FD4:  BRA    0FDC
00FD6:  INCFSZ x3B,W
00FD8:  BRA    0FDC
00FDA:  BRA    0FEA
....................                   MACSetWritePtr(ptrDest); 
00FDC:  MOVFF  63B,643
00FE0:  MOVFF  63A,642
00FE4:  MOVLB  0
00FE6:  RCALL  0B16
00FE8:  MOVLB  6
....................                MACPutArray((BYTE*)ptrSource, wLength); 
00FEA:  MOVFF  63E,658
00FEE:  MOVFF  63D,657
00FF2:  MOVFF  641,65A
00FF6:  MOVFF  640,659
00FFA:  MOVLB  0
00FFC:  RCALL  0B7E
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                SPIRAMPutArray(ptrDest, (BYTE*)ptrSource, wLength); 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
00FFE:  BRA    1062
....................     
....................       case TCP_ETH_RAM: 
....................          switch(vDestType) 
01000:  MOVLB  6
01002:  MOVF   x3C,W
01004:  XORLW  01
01006:  MOVLB  0
01008:  BZ    1010
0100A:  XORLW  01
0100C:  BZ    1040
0100E:  BRA    1060
....................          { 
....................             case TCP_PIC_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
01010:  MOVLB  6
01012:  INCFSZ x3D,W
01014:  BRA    101C
01016:  INCFSZ x3E,W
01018:  BRA    101C
0101A:  BRA    102A
....................                   MACSetReadPtr(ptrSource); 
0101C:  MOVFF  63E,643
01020:  MOVFF  63D,642
01024:  MOVLB  0
01026:  RCALL  0BC4
01028:  MOVLB  6
....................                MACGetArray((BYTE*)ptrDest, wLength); 
0102A:  MOVFF  63B,656
0102E:  MOVFF  63A,655
01032:  MOVFF  641,658
01036:  MOVFF  640,657
0103A:  MOVLB  0
0103C:  RCALL  0C28
....................                break; 
0103E:  BRA    1060
....................     
....................             case TCP_ETH_RAM: 
....................                MACMemCopyAsync(ptrDest, ptrSource, wLength); 
01040:  MOVFF  63B,643
01044:  MOVFF  63A,642
01048:  MOVFF  63E,645
0104C:  MOVFF  63D,644
01050:  MOVFF  641,647
01054:  MOVFF  640,646
01058:  RCALL  0CC8
....................                while(!MACIsMemCopyDone()); 
0105A:  RCALL  0F56
0105C:  MOVF   01,F
0105E:  BZ    105A
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
....................                   MACSetReadPtr(ptrSource); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   MACGetArray(vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
01060:  BRA    1062
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          switch(vDestType) 
....................          { 
....................             case TCP_PIC_RAM: 
....................                SPIRAMGetArray(ptrSource, (BYTE*)ptrDest, wLength); 
....................                break; 
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
....................                   MACSetWritePtr(ptrDest); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   ptrSource += w; 
....................                   MACPutArray(vBuffer, w); 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................     
....................             case TCP_SPI_RAM: 
....................                // Copy all of the data over in chunks 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                       
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrSource += w; 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................          } 
....................          break; 
....................       #endif          
....................    } 
01062:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource,  
....................                         WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM).  This function is to be used when  
....................    copying from ROM. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    wDest      - Address to write to 
....................    wDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    wSource      - Address to copy from 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer. 
....................     
....................    This function is aliased to TCPRAMCopy on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength) 
.................... { 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................     
....................    switch(wDestType) 
....................    { 
....................       case TCP_PIC_RAM: 
....................          memcpypgm2ram((void*)(BYTE*)wDest, (ROM void*)wSource, wLength); 
....................          break; 
....................     
....................       case TCP_ETH_RAM: 
....................          if(wDest!=(PTR_BASE)-1) 
....................             MACSetWritePtr(wDest); 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             MACPutArray(vBuffer, w); 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             SPIRAMPutArray(wDest, vBuffer, w); 
....................             wDest += w; 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................       #endif 
....................    } 
.................... } 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    SSL Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    host      - Expected host name on certificate (currently ignored) 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, BYTE * buffer, BYTE suppDataType) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP         - TCP connection to secure 
....................    host         - Expected host name on certificate (currently ignored) 
....................    buffer         - Buffer for supplementary data return 
....................    suppDataType    - Type of supplementary data to copy 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Begins an SSL server session. 
....................  
....................   Description: 
....................    This function sets up an SSL server session when a new connection is 
....................    established on an SSL port. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................  
....................   Return Values: 
....................    TRUE      - an SSL connection was initiated 
....................    FALSE      - Insufficient SSL resources (stubs) were available 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return TRUE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Swap the localPort and localSSLPort 
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
....................    MyTCB.localPort.Val = MyTCB.localSSLPort.Val; 
....................    MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;    
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_NO_MESSAGE; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
....................  
....................   Summary: 
....................    Listens for SSL connection on a specific port. 
....................  
....................   Description: 
....................    This function adds an additional listening port to a TCP connection.   
....................    Connections made on this alternate port will be secured via SSL. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is listening. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    port      - SSL port to listen on 
....................  
....................   Return Values: 
....................    TRUE      - SSL port was added. 
....................    FALSE      - The socket was not a listening socket. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.smState != TCP_LISTEN) 
....................       return FALSE; 
....................     
....................    SyncTCB(); 
....................     
....................    MyTCB.localSSLPort.Val = port; 
....................    MyTCBStub.sslTxHead = port; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif // SSL Server 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
....................  
....................   Summary: 
....................    Requests an SSL message to be transmitted. 
....................  
....................   Description: 
....................    This function is called to request that a specific SSL message be 
....................    transmitted.  This message should only be called by the SSL module. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to use 
....................    msg         - One of the SSL_MESSAGE types to transmit. 
....................  
....................   Return Values: 
....................    TRUE      - The message was requested. 
....................    FALSE      - Another message is already pending transmission. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE) 
....................    { 
....................       MyTCBStub.sslReqMessage = msg; 
....................       return TRUE; 
....................    } 
....................     
....................    return FALSE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if an SSL session is still handshaking. 
....................  
....................   Description: 
....................    Call this function after calling TCPStartSSLClient until FALSE is 
....................    returned.  Then your application may continue with its normal data 
....................    transfer (which is now secured). 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - SSL handshake is still progressing 
....................    FALSE      - SSL handshake has completed 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    return MyTCBStub.Flags.bSSLHandshaking;    
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsSSL(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a TCP connection is secured with SSL. 
....................  
....................   Description: 
....................    Call this function to determine whether or not a TCP connection is  
....................    secured with SSL. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - Connection is secured via SSL 
....................    FALSE      - Connection is not secured 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    return TRUE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Clears the SSL handshake flag. 
....................  
....................   Description: 
....................    This function clears the flag indicating that an SSL handshake is 
....................    complete. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to set 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bSSLHandshaking = 0; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
....................  
....................   Summary: 
....................    Decrypts and MACs data arriving via SSL. 
....................  
....................   Description: 
....................    This function decrypts data in the TCP buffer and calculates the MAC over 
....................    the data.  All data is left in the exact same location in the TCP buffer. 
....................    It is called to help process incoming SSL records. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to decrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    len       - Number of bytes to crypt 
....................    inPlace      - TRUE to write back in place, FALSE to write at end of 
....................                currently visible data. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
.................... { 
....................    PTR_BASE wSrc, wDest, wBlockLen, wTemp; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    wSrc = MyTCBStub.rxTail; 
....................    wDest = wSrc; 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       wBlockLen = sizeof(buffer); 
....................       if(wBlockLen > len) // Don't do more than we should 
....................          wBlockLen = len; 
....................        
....................       // Read those bytes to a buffer 
....................       if(wSrc + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part read 
....................          wTemp = MyTCBStub.bufferEnd - wSrc + 1; 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp); 
....................          TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp); 
....................          wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen); 
....................          wSrc += wBlockLen; 
....................       } 
....................        
....................       // Decrypt and hash 
....................       ARCFOURCrypt(ctx, buffer, wBlockLen); 
....................       SSLMACAdd(buffer, wBlockLen); 
....................        
....................       // Write decrypted bytes back 
....................       if(wDest + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part write 
....................          wTemp = MyTCBStub.bufferEnd - wDest + 1; 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp); 
....................          TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp); 
....................          wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen); 
....................          wDest += wBlockLen; 
....................       } 
....................        
....................       // Update the length remaining 
....................       len -= wBlockLen; 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx,  
....................                            BYTE* MACSecret, WORD len) 
....................  
....................   Summary: 
....................    Encrypts and MACs data in place in the TCP TX buffer. 
....................  
....................   Description: 
....................    This function encrypts data in the TCP buffer while calcuating a MAC.   
....................    When encryption is finished, the MAC is appended to the buffer and  
....................    the record will be ready to transmit. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to encrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    MACSecret   - MAC encryption secret to use 
....................    len       - Number of bytes to crypt 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len) 
.................... { 
....................    PTR_BASE pos; 
....................    WORD blockLen; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    pos = MyTCBStub.txHead; 
....................    for(blockLen = 0; blockLen < 5u; blockLen++) 
....................    {// Skips first 5 bytes for the header 
....................       if(++pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       blockLen = sizeof(buffer); 
....................       if(blockLen > len) // Don't do more than we should 
....................          blockLen = len; 
....................       if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end 
....................          blockLen = MyTCBStub.bufferRxStart - pos; 
....................        
....................       // Read those bytes to a buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen); 
....................        
....................       // Hash and encrypt 
....................       SSLMACAdd(buffer, blockLen); 
....................       ARCFOURCrypt(ctx, buffer, blockLen); 
....................        
....................       // Put them back 
....................       TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................        
....................       // Update the pointers 
....................       pos += blockLen; 
....................       len -= blockLen; 
....................       if(pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Calculate and add the MAC 
....................    SSLMACCalc(MACSecret, buffer); 
....................    ARCFOURCrypt(ctx, buffer, 16); 
....................  
....................    // Write the MAC to the TX FIFO 
....................    // Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC 
....................    // TCPPut* functions use this to prevent writing too much data.  Therefore, the 
....................    // functionality is duplicated here. 
....................     
....................    len = 16; 
....................    blockLen = 0; 
....................    // See if we need a two part put 
....................    if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart) 
....................    { 
....................       blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................       len -= blockLen; 
....................       MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len); 
....................    MyTCBStub.sslTxHead += len; 
....................  
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
....................  
....................   Summary: 
....................    Writes an SSL record header and sends an SSL record. 
....................  
....................   Description: 
....................    This function writes an SSL record header to the pending TCP SSL data,  
....................    then indicates that the data is ready to be sent by moving the txHead 
....................    pointer. 
....................     
....................    If the record is complete, set recDone to TRUE.  The sslTxHead  
....................    pointer will be moved forward 5 bytes to leave space for a future  
....................    record header.  If the record is only partially sent, use FALSE and 
....................    to leave the pointer where it is so that more data can be added 
....................    to the record.  Partial records can only be used for the  
....................    SERVER_CERTIFICATE handshake message. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to write the header and transmit with 
....................    hdr         - Record header (5 bytes) to send or NULL to just  
....................               move the pointerctx 
....................    recDone      - TRUE if the record is done, FALSE otherwise 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................     
....................    // Write the header if needed 
....................    if(hdr) 
....................    {// This is a new record, so insert the header 
....................       for(i = 0; i < 5u; i++) 
....................       { 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(BYTE)); 
....................          if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
....................     
....................    // Move the txHead pointer to indicate what data is ready 
....................    // Also, flush just the header, then all the data.  This shotguns two  
....................    // packets down the line, therefore causing immediate ACKs by the  
....................    // remote node.  Reconnect handshakes are as much as 60% faster now. 
....................    TCPFlush(hTCP); 
....................    MyTCBStub.txHead = MyTCBStub.sslTxHead; 
....................    TCPFlush(hTCP); 
....................     
....................    // If this record is done, move the sslTxHead forward 
....................    // to accomodate the next record header 
....................    if(recDone) 
....................    { 
....................       for(i = 0; i < 5u; i++) 
....................       {// Skip first 5 bytes in TX for the record header 
....................          if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes are pending for a future SSL record. 
....................  
....................   Description: 
....................    This function determines how many bytes are pending for a future SSL 
....................    record. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL connection. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Non-SSL connections have no pending SSL data 
....................    //if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................    //   return 0; 
....................           
....................    // Determine how many bytes are waiting to be written in this record 
....................    if(MyTCBStub.sslTxHead > MyTCBStub.txHead) 
....................       return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5; 
....................    else 
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Hands newly arrive TCP data to the SSL module for processing. 
....................  
....................   Description: 
....................    This function processes incoming TCP data as an SSL record and  
....................    performs any necessary repositioning and decrypting. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to handle incoming data on 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
.................... { 
....................    PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest; 
....................    WORD wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Sync the stub 
....................    SyncTCBStub(hTCP); 
....................  
....................    // If new data is waiting 
....................    if(MyTCBStub.sslRxHead != MyTCBStub.rxHead) 
....................    { 
....................       // Reconfigure pointers for SSL use 
....................       prevRxTail = MyTCBStub.rxTail; 
....................       nextRxHead = MyTCBStub.rxHead; 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................       MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................        
....................       do 
....................       { 
....................          startRxTail = MyTCBStub.rxTail; 
....................  
....................          // Handle incoming data.  This function performs deframing of the  
....................          // SSL records, decryption, and MAC verification. 
....................          wSSLBytesThatPoofed = TCPIsGetReady(hTCP); 
....................          wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID); 
....................          wSSLBytesThatPoofed -= TCPIsGetReady(hTCP); 
....................  
....................          // Now need to move data to fill the SSL header/MAC/padding hole,  
....................          // if there is one 
....................          if(wSSLBytesThatPoofed) 
....................          {    
....................             // Sync the TCP so we can see if there is a TCP hole 
....................             SyncTCB(); 
....................  
....................             // Calculate how big the SSL hole is 
....................             if(MyTCB.sHoleSize == -1) 
....................             {// Just need to move pending SSL data 
....................                wToMove = TCPIsGetReady(hTCP); 
....................             } 
....................             else 
....................             {// A TCP hole exists, so move all data 
....................                wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................             } 
....................              
....................             // Start with the destination as the startRxTail and source as current rxTail 
....................             wDest = startRxTail; 
....................             wSrc = MyTCBStub.rxTail; 
....................              
....................             // If data exists between the end of the buffer and  
....................             // the destination, then move it forward 
....................             if(wSrc > wDest) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wSrc + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest += wLen; 
....................                wSrc = MyTCBStub.bufferRxStart; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data remains to be moved, fill in to end of buffer 
....................             if(wToMove) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wDest + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest = MyTCBStub.bufferRxStart; 
....................                wSrc += wLen; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data still remains, copy from from front + len to front 
....................             if(wToMove) 
....................             { 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
....................                         wSrc, MyTCBStub.vMemoryMedium, wToMove); 
....................             } 
....................  
....................             // Since bytes poofed, we need to move the head pointers  
....................             // backwards by an equal amount. 
....................             MyTCBStub.rxHead -= wSSLBytesThatPoofed; 
....................             if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart) 
....................                MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................             MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          } 
....................              
....................          // Move tail pointer forward by the number of decrypted bytes ready  
....................          // for the application (but not poofed bytes) 
....................          MyTCBStub.rxTail = startRxTail + wDecryptedBytes; 
....................          if(MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
....................             MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................          nextRxHead += wDecryptedBytes; 
....................           
....................          // Loop until SSLRxRecord() runs out of data and stops doing  
....................          // anything 
....................       } while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail)); 
....................  
....................       // Restore TCP buffer pointers to point to the decrypted application data  
....................       // only 
....................       if(nextRxHead > MyTCBStub.bufferEnd) 
....................          nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................       MyTCBStub.rxTail = prevRxTail; 
....................       MyTCBStub.rxHead = nextRxHead; 
....................    } 
.................... }    
.................... #endif 
....................  
....................  
.................... #endif //#if defined(STACK_USE_TCP) 
....................  
....................     
....................    void TCPTouch(TCP_SOCKET s) 
....................    { 
....................       SyncTCBStub(s); 
....................       if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       { 
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
....................          SyncTCB(); 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "_DNS.c" //ccs had to rename this driver to not conflict an s7600 driver in the default include path - a bug in the compiler 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "MPFS.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Microchip File System (MPFS) File Access API 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides single API for accessing web pages and other files  
....................  *    from internal program memory or an external serial EEPROM memory 
....................  *    -Reference: AN833 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MPFS.c 
....................  * Dependencies:    SPIEEPROM 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01     Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     3/31/05      Changed MPFS_ENTRY and mpfs_Flags for C30 
....................  * Darren Rook/CCS      4/13/11     When using CCS and program memory,  
....................                                        MPFS_Start[] is not defined/extern'd. 
....................                                        Instead CCS will use #import. 
....................  * Darren Rook/CCS      4/13/11     typedefing MPFS as rom* is causing CCS 
....................                                        compiler problems.  So it was 
....................                                        typedef'd to __address__.  That means 
....................                                        places where it was dereferencing MPFS 
....................                                        was replaced with read_program_memory(). 
....................  * Darren Rook/CCS      4/13/11     MPFSFormat() not included if using program 
....................                                        memory. 
....................  * Darren Rook/CCS      4/13/11     Added MPFS_RETURN_OFFSET option. 
....................  * Darren Rook/CCS      4/13/11     MPFSPutEnd() added SPIFlashStopWrite(). 
....................  * Darren Rook/CCS      5/18/11     When using PCD, not using  
....................  *                                     ReadProgramMemory() algo because 
....................  *                                     CCS is using #import() and the  
....................  *                                     data gets aligned differently. 
.................... ********************************************************************/ 
.................... #ifndef __MPFS_C 
.................... #define __MPFS_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION       "v5.42"      // TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "../GenericTypeDefs.h" 
.................... #include "../Compiler.h" 
.................... #include "../HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES      (1u)    
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
....................    // Represents data stored in Ethernet buffer RAM 
....................    #define TCP_ETH_RAM   0u 
....................    // The base address for TCP data in Ethernet RAM 
....................    #define TCP_ETH_RAM_BASE_ADDRESS         (BASE_TCB_ADDR) 
....................    // Represents data stored in local PIC RAM 
....................    #define TCP_PIC_RAM   1u 
....................    // The base address for TCP data in PIC RAM 
....................    #define TCP_PIC_RAM_BASE_ADDRESS         ((PTR_BASE)&TCPBufferInPIC[0]) 
....................    // Represents data stored in external SPI RAM 
....................    #define TCP_SPI_RAM   2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "../TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #define STACK_USE_SMTP_CLIENT 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #define STACK_CLIENT_MODE 
....................    #define STACK_USE_TCP 
....................    #define STACK_USE_DNS 
.................... #endif 
....................   
.................... #ifndef STACK_USE_MDD 
....................    #if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
....................       #define STACK_USE_SNMP_SERVER 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
....................       #define STACK_USE_MPFS2 
....................    #endif 
....................  
....................    #if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................    #endif 
.................... #endif 
....................     
....................    // FTP is not supported in MPFS2 or when MPFS is stored in internal program  
....................    // memory (instead of external EEPROM). 
....................    #if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
....................       #error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
....................    #endif 
....................     
....................    // When IP Gleaning is enabled, ICMP must also be enabled. 
....................    #if defined(STACK_USE_IP_GLEANING) 
....................        #if !defined(STACK_USE_ICMP_SERVER) 
....................            #define STACK_USE_ICMP_SERVER 
....................        #endif 
....................    #endif 
....................     
....................    // Include modules required by specific HTTP demos 
....................    #if !defined(STACK_USE_HTTP2_SERVER) 
....................       #undef STACK_USE_HTTP_EMAIL_DEMO 
....................       #undef STACK_USE_HTTP_MD5_DEMO 
....................       #undef STACK_USE_HTTP_APP_RECONFIG 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_EMAIL_DEMO) 
....................       #if !defined(STACK_USE_SMTP_CLIENT) 
....................          #error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
....................       #endif 
....................    #endif 
....................    #if defined(STACK_USE_HTTP_MD5_DEMO) 
....................       #if !defined(STACK_USE_MD5) 
....................          #define STACK_USE_MD5 
....................       #endif 
....................    #endif 
....................     
....................    // Can't do MPFS upload without POST or external memory 
....................    #if defined(HTTP_MPFS_UPLOAD) 
....................       #if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
....................          #undef HTTP_MPFS_UPLOAD 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that the DNS client is enabled if services require it 
....................    #if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_CLIENT_MODE is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_ICMP_CLIENT) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
....................       #if !defined(STACK_CLIENT_MODE) 
....................           #define STACK_CLIENT_MODE 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_TCP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
....................       defined(STACK_USE_HTTP2_SERVER) || \ 
....................       defined(STACK_USE_CCS_FTP_SERVER) || \ 
....................       defined(STACK_USE_FTP_SERVER) || \ 
....................       defined(STACK_USE_TELNET_SERVER) || \ 
....................       defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
....................       defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
....................       defined(STACK_USE_SMTP_CLIENT) || \ 
....................       defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) || \ 
....................       defined(STACK_USE_SSL_CLIENT) || \ 
....................       defined(STACK_USE_SSL_SERVER) 
....................        #if !defined(STACK_USE_TCP) 
....................            #define STACK_USE_TCP 
....................        #endif 
....................    #endif 
....................     
....................    // If TCP is not enabled, clear all memory allocations 
....................    #if !defined(STACK_USE_TCP) 
....................       #undef TCP_ETH_RAM_SIZE 
....................       #undef TCP_PIC_RAM_SIZE 
....................       #undef TCP_SPI_RAM_SIZE 
....................       #define TCP_ETH_RAM_SIZE 0u 
....................       #define TCP_PIC_RAM_SIZE 0u 
....................       #define TCP_SPI_RAM_SIZE 0u 
....................    #endif 
....................     
....................    // If PIC RAM is used to store TCP socket FIFOs and TCBs,  
....................    // let's allocate it so the linker dynamically chooses  
....................    // where to locate it and prevents other variables from  
....................    // overlapping with it 
....................    #if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata TCPSocketMemory 
....................       #endif 
....................       static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
....................       #if defined(__18CXX) && !defined(HI_TECH_C) 
....................          #pragma udata 
....................       #endif 
....................    #endif 
....................     
....................    // Make sure that STACK_USE_UDP is defined if a service  
....................    // depends on it 
....................    #if defined(STACK_USE_DHCP_CLIENT) || \ 
....................       defined(STACK_USE_DHCP_SERVER) || \ 
....................       defined(STACK_USE_DNS) || \ 
....................       defined(STACK_USE_NBNS) || \ 
....................       defined(STACK_USE_SNMP_SERVER) || \ 
....................       defined(STACK_USE_TFTP_CLIENT) || \ 
....................       defined(STACK_USE_ANNOUNCE) || \ 
....................       defined(STACK_USE_CCS_ANNOUNCE) || \ 
....................       defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
....................       defined(STACK_USE_SNTP_CLIENT) || \ 
....................       defined(STACK_USE_BERKELEY_API) 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif 
....................    #endif 
....................  
....................    // When using SSL server, enable RSA decryption 
....................    #if defined(STACK_USE_SSL_SERVER) 
....................       #define STACK_USE_RSA_DECRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................     
....................    // When using SSL client, enable RSA encryption 
....................    #if defined(STACK_USE_SSL_CLIENT) 
....................       #define STACK_USE_RSA_ENCRYPT 
....................       #define STACK_USE_SSL 
....................    #endif 
....................  
....................    // If using SSL (either), include the rest of the support modules 
....................    #if defined(STACK_USE_SSL) 
....................       #define STACK_USE_ARCFOUR 
....................       #define STACK_USE_MD5 
....................       #define STACK_USE_SHA1 
....................       #define STACK_USE_RANDOM 
....................    #endif 
....................  
....................    // When using either RSA operation, include the RSA module 
....................    #if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
....................       #define STACK_USE_RSA 
....................       #define STACK_USE_BIGINT 
....................    #endif 
....................  
....................    // Enable the LCD if configured in the hardware profile 
....................    #if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
....................       #define USE_LCD 
....................    #endif 
....................     
....................    #if !defined(SPI_FLASH_BLOCK_SIZE) 
....................       #define SPI_FLASH_BLOCK_SIZE 4096 
....................    #endif 
....................     
....................    // SPI Flash MPFS images must start on a block boundary 
....................    #if (defined(STACK_USE_MPFS2)) && \ 
....................       defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & (SPI_FLASH_BLOCK_SIZE-1)) != 0) 
....................       #error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
....................    #endif 
....................     
....................    // HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................       #if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
....................          #error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
....................       #endif 
....................    #endif 
....................  
.................... #include "StackTsk.h" 
.................... #include "Helpers.h" 
.................... #include "Delay.h" 
.................... #include "Tick.h" 
.................... #include "MAC.h" 
.................... #include "IP.h" 
.................... #include "ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
....................    #include "BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    #include "RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
....................    #include "ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    #include "Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
....................    #include "Hashes.h" 
.................... #endif 
....................  
....................    #include "XEEPROM.h" 
....................    #include "SPIFlash.h" 
....................    #include "SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    #include "BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
....................    #include "LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    #include "UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
....................    #include "UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
....................    #include "FTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................    #ifdef STACK_USE_MDD 
....................       #include "FileSystem.h" 
....................       #include "_HTTP2.h" 
....................    #else 
....................       #include "HTTP2.h" 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................    #include "ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
....................    #include "Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) 
....................    #include "ccs_announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.h" 
....................    #include "../../snmp/mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
....................    #include "NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    #include "DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
....................    #include "Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
....................    #include "Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    #include "UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    #include "TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................    #include "SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_MPFS) 
....................  
.................... #ifndef debug_mpfs 
....................    #define debug_mpfs(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) 
....................    #define debug_mpfs_putc(c) 
.................... #endif 
....................  
.................... // This file system supports short file names i.e. 8 + 3. 
.................... #define MAX_FILE_NAME_LEN   (12u) 
....................  
.................... #define MPFS_DATA          (0x00u) 
.................... #define MPFS_DELETED       (0x01u) 
.................... #define MPFS_DLE           (0x03u) 
.................... #define MPFS_ETX           (0x04u) 
....................  
.................... /* 
....................    If you want the entries in the MPFS .bin file to not have any offset, and 
....................    instead have MPFSOpen() return the entry with MPFS_Start start added to it, 
....................    then define MPFS_RETURN_OFFSET.  CCS added this option so that a universal 
....................    .bin could be created that would be portable to several different memory 
....................    types. 
....................     
....................    If you do not define this option, then you have to use the /r option with 
....................    the MPFS generator tool to add the offset in entry. 
.................... */ 
.................... #define MPFS_RETURN_OFFSET 
....................  
.................... /* 
....................  * MPFS Structure: 
....................  * 
....................  * MPFS_Start: 
....................  *      <MPFS_DATA><Address1><FileName1> 
....................  *      <MPFS_DATA><Address2><FileName2> 
....................  *      ... 
....................  *      <MPFS_ETX><Addressn><FileNamen> 
....................  * Address1: 
....................  *      <Data1>[<Data2>...<Datan>]<MPFS_ETX><MPFS_INVALID> 
....................  *      ... 
....................  * 
....................  * Note: If File data contains either MPFS_DLE or MPFS_ETX 
....................  *       extra MPFS_DLE is stuffed before that byte. 
....................  */ 
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) || defined(__PCD__) 
....................    /* __CCS__ __PCD__ change - when using program memory also pack it, i  
....................       am guessing their tool for putting image into const array in C/progmemory 
....................       also stores it unpacked */ 
....................  #if defined(__PCD__) //__PCH__ __PCD__ __CCS__ change 
....................    typedef struct __attribute__((__packed__)) _MPFS_ENTRY 
....................    { 
....................        BYTE Flag; 
....................        MPFS Address; 
....................        BYTE Name[MAX_FILE_NAME_LEN]; 
....................    } MPFS_ENTRY; 
....................    static DWORD ReadProgramMemory(DWORD address); 
....................  #else 
....................    typedef struct  _MPFS_ENTRY 
....................    { 
....................        BYTE Flag __attribute__((__packed__)); 
....................        MPFS Address __attribute__((__packed__)); 
....................        BYTE Name[MAX_FILE_NAME_LEN] __attribute__((__packed__)); 
....................    } MPFS_ENTRY; 
....................  #endif 
.................... #else   //Use program memory 
....................    typedef struct  _MPFS_ENTRY 
....................    { 
....................        BYTE Flag; 
....................        MPFS Address; 
....................        BYTE Name[MAX_FILE_NAME_LEN]; 
....................    } MPFS_ENTRY; 
....................    #if defined(__C30__) 
....................       static DWORD ReadProgramMemory(DWORD address); 
....................    #endif 
.................... #endif 
....................  
.................... static union 
.................... { 
....................     struct 
....................     { 
....................         unsigned char bNotAvailable : 1; 
....................     } bits; 
....................     BYTE Val; 
.................... } mpfsFlags; 
....................  
.................... BYTE mpfsOpenCount; 
....................  
.................... #if !defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH) 
....................    // An address where MPFS data starts in program memory. 
....................   #if !defined(__PCH__) && !defined(__PCD__) //ccs will use #import 
....................     extern ROM MPFS_ENTRY MPFS_Start[]; 
....................   #endif 
.................... #else 
....................    #define MPFS_Start     MPFS_RESERVE_BLOCK 
.................... #endif 
....................  
.................... MPFS _currentHandle; 
.................... MPFS _currentFile; 
.................... WORD _currentCount; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE, if MPFS Storage access is initialized and 
....................  *                          MPFS is ready to be used. 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL MPFSInit(void) 
.................... { 
....................    debug_mpfs(debug_mpfs_putc, "\r\nMPFSInit()"); 
....................     mpfsOpenCount = 0; 
....................     mpfsFlags.Val = 0; 
....................  
.................... #if defined(MPFS_USE_EEPROM) 
....................     // Initialize the EEPROM access routines. 
....................     XEEInit(); 
.................... #elif defined(MPFS_USE_SPI_FLASH) 
....................    // Initialize the SPI Flash access routines. 
....................    SPIFlashInit(); 
.................... #endif 
....................  
....................     return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSOpen(BYTE* file) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           file        - NULL terminated file name. 
....................  * 
....................  * Output:          A handle if file is found 
....................  *                  MPFS_INVALID if file is not found. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... MPFS MPFSOpen(BYTE* file) 
.................... { 
....................     MPFS_ENTRY entry; 
....................     MPFS FAT; 
....................     BYTE fileNameLen; 
....................      
....................     debug_mpfs(debug_mpfs_putc, "\r\nMPFSOpen() '%s' ", file); 
....................  
....................     if( mpfsFlags.bits.bNotAvailable ) 
*
07AE8:  MOVLB  2
07AEA:  BTFSS  x09.0
07AEC:  BRA    7AF8
....................     { 
....................         debug_mpfs(debug_mpfs_putc, "NOT AVAILABLE"); 
....................         return MPFS_NOT_AVAILABLE; 
07AEE:  CLRF   00
07AF0:  CLRF   01
07AF2:  CLRF   02
07AF4:  CLRF   03
07AF6:  BRA    7C56
....................     } 
....................  
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) 
....................     FAT = MPFS_Start; 
.................... #else 
....................     FAT = (MPFS)MPFS_Start; 
07AF8:  MOVLB  6
07AFA:  CLRF   x48
07AFC:  CLRF   x47
07AFE:  MOVLW  B6
07B00:  MOVWF  x46
07B02:  MOVLW  E4
07B04:  MOVWF  x45
.................... #endif 
....................  
....................     // If string is empty, do not attempt to find it in FAT. 
....................     if ( *file == '\0' ) 
07B06:  MOVFF  633,03
07B0A:  MOVFF  632,FE9
07B0E:  MOVFF  633,FEA
07B12:  MOVF   FEF,F
07B14:  BNZ   7B24
....................         return MPFS_INVALID; 
07B16:  SETF   00
07B18:  SETF   01
07B1A:  SETF   02
07B1C:  SETF   03
07B1E:  MOVLB  2
07B20:  BRA    7C56
07B22:  MOVLB  6
....................  
....................     //debug_mpfs("p1='%s'0x%LX ", file, file); 
....................  
....................     file = (BYTE*)strupr((char*)file); 
07B24:  MOVFF  633,64F
07B28:  MOVFF  632,64E
07B2C:  MOVLB  0
07B2E:  RCALL  79BC
07B30:  MOVFF  02,633
07B34:  MOVFF  01,632
....................      
....................     //debug_mpfs("p2='%s'0x%LX ", file, file); 
....................  
....................     debug_mpfs(debug_mpfs_putc, "START=0x%LX ", FAT); 
....................  
....................     for(;;) 
....................     { 
....................         // Bring current FAT entry into RAM. 
....................       #if defined(MPFS_USE_EEPROM) 
....................            XEEReadArray(FAT, (unsigned char*)&entry, sizeof(entry)); 
....................       #elif defined(MPFS_USE_SPI_FLASH) 
....................            SPIFlashReadArray(FAT, (BYTE*)&entry, sizeof(entry)); 
....................       #else 
....................          #if defined(__C30__) 
....................               memcpypgm2ram(&entry, (ROM void*)(WORD)FAT, sizeof(entry)); 
....................          #else 
....................               memcpypgm2ram(&entry, (ROM void*)FAT, sizeof(entry)); 
07B38:  MOVLW  06
07B3A:  MOVLB  6
07B3C:  MOVWF  x4F
07B3E:  MOVLW  34
07B40:  MOVWF  x4E
07B42:  MOVFF  648,653
07B46:  MOVFF  647,652
07B4A:  MOVFF  646,651
07B4E:  MOVFF  645,650
07B52:  CLRF   x55
07B54:  MOVLW  11
07B56:  MOVWF  x54
07B58:  MOVLB  0
07B5A:  RCALL  7A42
....................          #endif 
....................       #endif 
....................  
....................        debug_mpfs(debug_mpfs_putc, "FLAG=0x%X ", entry.Flag); 
....................  
....................         // Make sure that it is a valid entry. 
....................         if (entry.Flag == MPFS_DATA) 
07B5C:  MOVLB  6
07B5E:  MOVF   x34,F
07B60:  BNZ   7BFA
....................         { 
....................             // Does the file name match ? 
....................             fileNameLen = strlen((char*)file); 
07B62:  MOVFF  633,64F
07B66:  MOVFF  632,64E
07B6A:  MOVLB  0
07B6C:  CALL   7068
07B70:  MOVFF  01,649
....................              
....................             if ( fileNameLen > MAX_FILE_NAME_LEN ) 
07B74:  MOVLB  6
07B76:  MOVF   x49,W
07B78:  SUBLW  0C
07B7A:  BC    7B80
....................                 fileNameLen = MAX_FILE_NAME_LEN; 
07B7C:  MOVLW  0C
07B7E:  MOVWF  x49
....................  
....................             //debug_mpfs("f='%s' (%u) vs '%s' ", entry.Name, fileNameLen, file); 
....................  
....................             if( memcmp((void*)file, (void*)entry.Name, fileNameLen) == 0 ) 
07B80:  MOVLW  06
07B82:  MOVWF  x4F
07B84:  MOVLW  39
07B86:  MOVWF  x4E
07B88:  MOVFF  633,651
07B8C:  MOVFF  632,650
07B90:  MOVFF  64F,653
07B94:  MOVWF  x52
07B96:  CLRF   x55
07B98:  MOVFF  649,654
07B9C:  MOVLB  0
07B9E:  BRA    7A62
07BA0:  MOVLB  6
07BA2:  CLRF   x51
07BA4:  MOVFF  01,650
07BA8:  BTFSC  01.7
07BAA:  DECF   x51,F
07BAC:  MOVF   x50,F
07BAE:  BNZ   7BEC
07BB0:  MOVF   x51,F
07BB2:  BNZ   7BEC
....................             { 
....................              #if defined(__PCD__) 
....................                #warning 4.121 temporary bug fix 
....................                memcpy(&_currentFile, &entry.Address, 4); 
....................               #if defined(MPFS_RETURN_OFFSET) 
....................                 _currentFile += MPFS_Start; 
....................               #endif 
....................                 mpfsOpenCount++; 
....................                 debug_mpfs(debug_mpfs_putc, "found_0x%LX ", _currentFile); 
....................                 return _currentFile; 
....................              #else 
....................               #if defined(MPFS_RETURN_OFFSET) 
....................                 entry.Address += MPFS_Start; 
07BB4:  MOVLW  E4
07BB6:  ADDWF  x35,F
07BB8:  MOVLW  B6
07BBA:  ADDWFC x36,F
07BBC:  MOVLW  00
07BBE:  ADDWFC x37,F
07BC0:  ADDWFC x38,F
....................               #endif 
....................                 _currentFile = (MPFS)entry.Address; 
07BC2:  MOVFF  638,20D
07BC6:  MOVFF  637,20C
07BCA:  MOVFF  636,20B
07BCE:  MOVFF  635,20A
....................                 mpfsOpenCount++; 
07BD2:  MOVLB  0
07BD4:  INCF   xF8,F
....................                 debug_mpfs(debug_mpfs_putc, "found_0x%LX ", _currentFile); 
....................                 return entry.Address; 
07BD6:  MOVFF  635,00
07BDA:  MOVFF  636,01
07BDE:  MOVFF  637,02
07BE2:  MOVFF  638,03
07BE6:  MOVLB  2
07BE8:  BRA    7C56
07BEA:  MOVLB  6
....................              #endif 
....................             } 
....................  
....................             // File does not match.  Try next entry... 
....................             FAT += sizeof(entry); 
07BEC:  MOVLW  11
07BEE:  ADDWF  x45,F
07BF0:  MOVLW  00
07BF2:  ADDWFC x46,F
07BF4:  ADDWFC x47,F
07BF6:  ADDWFC x48,F
....................         } 
07BF8:  BRA    7C46
....................         else if ( entry.Flag == MPFS_ETX ) 
07BFA:  MOVF   x34,W
07BFC:  SUBLW  04
07BFE:  BNZ   7C38
....................         { 
....................             #warning 4.121 temporary bug fix 
....................             unsigned int32 entry_Address; 
....................             memcpy(&entry_Address, &entry.Address, 4); 
07C00:  MOVFF  635,64A
07C04:  MOVFF  636,64B
07C08:  MOVFF  637,64C
07C0C:  MOVFF  638,64D
....................             if ( entry_Address != (MPFS)MPFS_INVALID ) 
07C10:  INCFSZ x4A,W
07C12:  BRA    7C22
07C14:  INCFSZ x4B,W
07C16:  BRA    7C22
07C18:  INCFSZ x4C,W
07C1A:  BRA    7C22
07C1C:  INCFSZ x4D,W
07C1E:  BRA    7C22
07C20:  BRA    7C34
....................             { 
....................                 FAT = (MPFS)entry_Address; //original, doesn't work 4.121 pcd 
07C22:  MOVFF  64D,648
07C26:  MOVFF  64C,647
07C2A:  MOVFF  64B,646
07C2E:  MOVFF  64A,645
....................                 debug_mpfs(debug_mpfs_putc, "(etx 0x%LX) ", FAT); 
....................             } 
07C32:  BRA    7C36
....................             else 
....................             { 
....................                 debug_mpfs(debug_mpfs_putc, "invalid_etx "); 
....................                 break; 
07C34:  BRA    7C4C
....................             } 
....................         } 
07C36:  BRA    7C46
....................        else 
....................        { 
....................            debug_mpfs(debug_mpfs_putc, "invalid_flag "); 
....................            return (MPFS)MPFS_INVALID; 
07C38:  SETF   00
07C3A:  SETF   01
07C3C:  SETF   02
07C3E:  SETF   03
07C40:  MOVLB  2
07C42:  BRA    7C56
07C44:  MOVLB  6
....................        } 
07C46:  MOVLB  0
07C48:  BRA    7B38
07C4A:  MOVLB  6
....................     } 
....................     debug_mpfs(debug_mpfs_putc, "not_found "); 
....................     return (MPFS)MPFS_INVALID; 
07C4C:  SETF   00
07C4E:  SETF   01
07C50:  SETF   02
07C52:  SETF   03
07C54:  MOVLB  2
07C56:  MOVLB  0
07C58:  RETURN 0
.................... } 
....................  
.................... MPFS MPFSOpenROM(ROM BYTE* file)  
.................... { 
....................    BYTE nameRAM[MAX_FILE_NAME_LEN+1]; 
....................     
....................    memcpypgm2ram(nameRAM, (ROM void*)file, strlenpgm((ROM char*)file)); 
....................    nameRAM[strlenpgm((ROM char*)file)] = '\0'; 
....................     
....................    return MPFSOpen(nameRAM); 
.................... }    
....................  
.................... /********************************************************************* 
....................  * Function:        void MPFSClose(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           handle      - File handle to be closed 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void MPFSClose(void) 
.................... { 
....................     debug_mpfs(debug_mpfs_putc, "\r\nMPFSClose()"); 
....................     _currentCount = 0; 
*
079AA:  MOVLB  2
079AC:  CLRF   x0F
079AE:  CLRF   x0E
....................     mpfsFlags.bits.bNotAvailable = FALSE; 
079B0:  BCF    x09.0
....................     if ( mpfsOpenCount ) 
079B2:  MOVLB  0
079B4:  MOVF   xF8,F
079B6:  BZ    79BA
....................         mpfsOpenCount--; 
079B8:  DECF   xF8,F
079BA:  RETURN 0
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSGetBegin(MPFS hFile) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  * 
....................  * Input:           hFile      - handle of file that is to be read 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS storage media for subsequent reads. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
.................... BOOL MPFSGetBegin(MPFS hFile) 
.................... { 
....................     _currentHandle = hFile; 
....................     return (XEEBeginRead(hFile) == XEE_SUCCESS); 
.................... } 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE MPFSGet(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  *                  MPFSGetBegin() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Data byte from current address. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Reads a byte from current address. 
....................  * 
....................  * Note:            Caller must call MPFSIsEOF() to check for end of 
....................  *                  file condition 
....................  ********************************************************************/ 
.................... BYTE MPFSGet(void) 
.................... { 
....................     BYTE t; 
....................      
....................    #if defined(MPFS_USE_EEPROM) 
....................       t = XEERead(); 
....................       _currentHandle++; 
....................    #elif defined(MPFS_USE_SPI_FLASH) 
....................       //SPIFlashReadArray(_currentHandle++, (BYTE*)&t, 1);  //orig 
....................       SPIFlashReadArray(_currentHandle, (BYTE*)&t, 1);   //ccs workaround 
....................       _currentHandle++; //ccs workaround 
....................    #else 
....................       #if defined(__C30__) && !defined(__PCD__) //__CCS__ change 
....................          { 
....................             DWORD_VAL i; 
....................     
....................             // The uppermost byte, ((DWORD_VAL*)&_currentHandle)->v[3]), is the byte lane to read from. 
....................             // 16 bit PICs have a 24 bit wide Flash program word.  Bytes 0-2 are the actual address, but  
....................             // odd addresses aren't implemented. 
....................             i.Val = ReadProgramMemory(_currentHandle & 0x00FFFFFF); 
....................             t = i.v[((DWORD_VAL*)&_currentHandle)->v[3]++]; 
....................             if(((DWORD_VAL*)&_currentHandle)->v[3] >= 3) 
....................             { 
....................                _currentHandle = (_currentHandle + 2) & 0x00FFFFFF; 
....................             } 
....................          } 
....................       #else 
....................           //t = (BYTE)*_currentHandle; //__ccs__ change because MPFS isn't rom pointer 
....................           memcpypgm2ram(&t, _currentHandle, 1); //__ccs__ change because MPFS isn't rom pointer 
*
080FA:  MOVLW  06
080FC:  MOVLB  6
080FE:  MOVWF  x4F
08100:  MOVLW  3A
08102:  MOVWF  x4E
08104:  MOVFF  FC,653
08108:  MOVFF  FB,652
0810C:  MOVFF  FA,651
08110:  MOVFF  F9,650
08114:  CLRF   x55
08116:  MOVLW  01
08118:  MOVWF  x54
0811A:  MOVLB  0
0811C:  RCALL  7A42
....................           _currentHandle++; 
0811E:  MOVLW  01
08120:  ADDWF  xF9,F
08122:  BTFSC  FD8.0
08124:  INCF   xFA,F
08126:  BTFSC  FD8.2
08128:  INCF   xFB,F
0812A:  BTFSC  FD8.2
0812C:  INCF   xFC,F
....................       #endif 
....................    #endif 
....................  
....................     if(t == MPFS_DLE) 
0812E:  MOVLB  6
08130:  MOVF   x3A,W
08132:  SUBLW  03
08134:  BNZ   816C
....................     { 
....................       #if defined(MPFS_USE_EEPROM) 
....................           t = XEERead(); 
....................           _currentHandle++; 
....................       #elif defined(MPFS_USE_SPI_FLASH) 
....................          //SPIFlashReadArray(_currentHandle++, (BYTE*)&t, 1); //orig 
....................          SPIFlashReadArray(_currentHandle, (BYTE*)&t, 1);   //ccs workaround 
....................          _currentHandle++; //ccs workaround 
....................       #else 
....................          #if defined(__C30__) && !defined(__PCD__) //__CCS__ change 
....................             { 
....................                DWORD_VAL i; 
....................        
....................             // The uppermost byte, ((DWORD_VAL*)&_currentHandle)->v[3]), is the byte lane to read from. 
....................             // 16 bit PICs have a 24 bit wide Flash program word.  Bytes 0-2 are the actual address, but  
....................             // odd addresses aren't implemented. 
....................             i.Val = ReadProgramMemory(_currentHandle & 0x00FFFFFF); 
....................             t = i.v[((DWORD_VAL*)&_currentHandle)->v[3]++]; 
....................             if(((DWORD_VAL*)&_currentHandle)->v[3] >= 3) 
....................             { 
....................                _currentHandle = (_currentHandle + 2) & 0x00FFFFFF; 
....................             } 
....................             } 
....................          #else 
....................              //t = (BYTE)*_currentHandle; //__ccs__ change because MPFS isn't rom pointer 
....................              memcpypgm2ram(&t, _currentHandle, 1); //__ccs__ change because MPFS isn't rom pointer 
08136:  MOVLW  06
08138:  MOVWF  x4F
0813A:  MOVLW  3A
0813C:  MOVWF  x4E
0813E:  MOVFF  FC,653
08142:  MOVFF  FB,652
08146:  MOVFF  FA,651
0814A:  MOVFF  F9,650
0814E:  CLRF   x55
08150:  MOVLW  01
08152:  MOVWF  x54
08154:  MOVLB  0
08156:  RCALL  7A42
....................              _currentHandle++; 
08158:  MOVLW  01
0815A:  ADDWF  xF9,F
0815C:  BTFSC  FD8.0
0815E:  INCF   xFA,F
08160:  BTFSC  FD8.2
08162:  INCF   xFB,F
08164:  BTFSC  FD8.2
08166:  INCF   xFC,F
....................          #endif 
....................       #endif 
....................     } 
08168:  BRA    817C
0816A:  MOVLB  6
....................     else if(t == MPFS_ETX) 
0816C:  MOVF   x3A,W
0816E:  SUBLW  04
08170:  BNZ   817E
....................     { 
....................         _currentHandle = MPFS_INVALID; 
08172:  MOVLB  0
08174:  SETF   xFC
08176:  SETF   xFB
08178:  SETF   xFA
0817A:  SETF   xF9
0817C:  MOVLB  6
....................     } 
....................  
....................    //printf(UserPutc, " ret=%X\r\n", t); 
....................     return t; 
0817E:  MOVFF  63A,01
08182:  MOVLB  0
08184:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(__C30__) && !defined(MPFS_USE_EEPROM) 
.................... /********************************************************************* 
....................  * Function:        static DWORD ReadProgramMemory(DWORD address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Program memory address to read from.  Should be  
....................  *               an even number. 
....................  * 
....................  * Output:          Program word at the specified address.  For the  
....................  *               PIC24, dsPIC, etc. which have a 24 bit program  
....................  *               word size, the upper byte is 0x00. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Modifies and restores TBLPAG.  Make sure that if  
....................  *               using interrupts and the PSV feature of the CPU  
....................  *               in an ISR that the TBLPAG register is preloaded  
....................  *               with the correct value (rather than assuming  
....................  *               TBLPAG is always pointing to the .const section. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static DWORD ReadProgramMemory(DWORD address)  
.................... { 
....................    DWORD dwResult; 
....................    WORD wTBLPAGSave; 
....................  
....................    wTBLPAGSave = TBLPAG; 
....................    TBLPAG = ((WORD*)&address)[1]; 
....................    ((WORD*)&dwResult)[1] = __builtin_tblrdh((WORD)address); 
....................    ((WORD*)&dwResult)[0] = __builtin_tblrdl((WORD)address); 
....................    TBLPAG = wTBLPAGSave; 
....................  
.................... //printf("[0x%LX=%LX] ", address, dwResult); 
....................  
....................    return dwResult; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSGetEnd(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  *                  MPFSGetBegin() = TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current mpfs handle. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Ends on-going read cycle. 
....................  *                  MPFS handle that is returned must be used 
....................  *                  for subsequent begin gets.. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
.................... MPFS MPFSGetEnd(void) 
.................... { 
....................     XEEEndRead(); 
....................     return _currentHandle; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSFormat(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A valid MPFS handle that can be used for MPFSPut 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS image to get re-written 
....................  *                  Declares MPFS as in use. 
....................  * 
....................  * Note:            MPFS will be unaccessible until MPFSClose is 
....................  *                  called. 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) //ccs added this condition 
.................... MPFS MPFSFormat(void) 
.................... { 
....................    debug_mpfs(debug_mpfs_putc, "\r\nMPFSFormat() "); 
....................     mpfsFlags.bits.bNotAvailable = TRUE; 
....................    #if defined(MPFS_USE_SPI_FLASH) 
....................       SPIFlashBeginWrite(MPFS_RESERVE_BLOCK); 
....................    #endif 
....................     return (MPFS)MPFS_RESERVE_BLOCK; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSPutBegin(MPFS handle) 
....................  * 
....................  * PreCondition:    MPFSInit() and MPFSFormat() are already called. 
....................  * 
....................  * Input:           handle  - handle to where put to begin 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS image to get re-written 
....................  * 
....................  * Note:            MPFS will be unaccessible until MPFSClose is 
....................  *                  called. 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
.................... BOOL MPFSPutBegin(MPFS handle) 
.................... { 
....................     //_currentCount = 0; 
....................     _currentHandle = handle; 
....................     _currentCount = (BYTE)handle; 
....................     _currentCount &= (MPFS_WRITE_PAGE_SIZE-1); 
....................     return (XEEBeginWrite(handle) == XEE_SUCCESS); 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSPut(BYTE b) 
....................  * 
....................  * PreCondition:    MPFSFormat() or MPFSCreate() must be called 
....................  *                  MPFSPutBegin() is already called. 
....................  * 
....................  * Input:           b       - data to write. 
....................  * 
....................  * Output:          TRUE if successfull 
....................  *                  !TRUE if failed. 
....................  * 
....................  * Side Effects:    Original MPFS handle is no longer valid. 
....................  *                  Updated MPFS handle must be obtained by calling 
....................  *                  MPFSPutEnd(). 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Actual write may not get started until internal 
....................  *                  write page is full.  To ensure that previously 
....................  *                  data gets written, caller must call MPFSPutEnd() 
....................  *                  after last call to MPFSPut(). 
....................  ********************************************************************/ 
.................... BOOL MPFSPut(BYTE b) 
.................... { 
.................... #if defined(MPFS_USE_EEPROM) 
....................     if ( XEEWrite(b) ) 
....................         return FALSE; 
....................  
....................     _currentCount++; 
....................     _currentHandle++; 
....................     if ( _currentCount >= MPFS_WRITE_PAGE_SIZE ) 
....................     { 
....................         MPFSPutEnd(); 
....................         XEEBeginWrite(_currentHandle); 
....................     } 
.................... #elif defined(MPFS_USE_SPI_FLASH) 
....................    SPIFlashWrite(b); 
.................... #endif 
....................     return TRUE; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSPutEnd(void) 
....................  * 
....................  * PreCondition:    MPFSPutBegin() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Up-to-date MPFS handle 
....................  * 
....................  * Side Effects:    Original MPFS handle is no longer valid. 
....................  *                  Updated MPFS handle must be obtained by calling 
....................  *                  MPFSPutEnd(). 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Actual write may not get started until internal 
....................  *                  write page is full.  To ensure that previously 
....................  *                  data gets written, caller must call MPFSPutEnd() 
....................  *                  after last call to MPFSPut(). 
....................  ********************************************************************/ 
.................... MPFS MPFSPutEnd(void) 
.................... { 
....................    debug_mpfs(debug_mpfs_putc, "\r\nMPFSPutEnd() "); 
.................... #if defined(MPFS_USE_EEPROM) 
....................     _currentCount = 0; 
....................     XEEEndWrite(); 
....................     while(XEEIsBusy()); 
.................... #elif defined(MPFS_USE_SPI_FLASH) 
....................    SPIFlashStopWrite(); 
.................... #endif 
....................     return _currentHandle; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSSeek(MPFS offset) 
....................  * 
....................  * PreCondition:    MPFSGetBegin() is already called. 
....................  * 
....................  * Input:           offset      - Offset from current pointer 
....................  * 
....................  * Output:          New MPFS handle located to given offset 
....................  * 
....................  * Side Effects:    None. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None. 
....................  ********************************************************************/ 
.................... MPFS MPFSSeek(MPFS offset) 
.................... { 
....................     MPFS i; 
....................  
....................     MPFSGetBegin(_currentFile); 
....................  
....................     i = (MPFS)0; 
....................     while(i++ != offset) 
....................         MPFSGet(); 
....................  
....................     MPFSGetEnd(); 
....................  
....................     return _currentHandle; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSGetLong(DWORD *ul) 
....................  * 
....................  * PreCondition:    MPFSOpen() and MPFSBeginGet() 
....................  * 
....................  * Input:           ul: pointer to an DWORD to read 
....................  * 
....................  * Output:          TRUE on success 
....................  *               FALSE on EOF 
....................  *  
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Reads an DWORD value from an MPFS file 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL MPFSGetLong(DWORD *ul) 
.................... { 
....................    BYTE* b = (BYTE*)ul; 
....................    *(b) = MPFSGet();    
....................    if(MPFSIsEOF()) 
....................       return FALSE; 
....................    *(b+1) = MPFSGet();    
....................    *(b+2) = MPFSGet();    
....................    *(b+3) = MPFSGet();    
....................  
....................    return TRUE; 
.................... } 
....................  
.................... #endif //#if defined(STACK_USE_MPFS) 
.................... #endif //__MPFS_C 
....................  
.................... #endif 
....................  
.................... #if (defined(STACK_USE_HTTP2) || defined(STACK_USE_HTTP2_SERVER)) && !defined(__HTTP2_C) 
....................     #include "HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP) || defined(STACK_USE_HTTP_SERVER) 
....................     #include "HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///                              HTTP2.C    
.................... ///                                                      
.................... /// Simple webserver for the Microchip TCP/IP stack. Using web pages 
.................... /// stored on a MultiMediaCard. 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES 
.................... /// 
.................... /// **** CONFIGURATION **** 
.................... /// 
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c 
.................... ///        in your application.  Defining this to be true will cause 
.................... ///        the stack to include the HTTP portion and execute the init 
.................... ///        and process any HTTP tasks. 
.................... /// 
.................... /// 
.................... /// STACK_USE_HTTP2 - Same as STACK_USE_HTTP except this will cause 
.................... ///         web pages to be loaded from files stored on the MMC, not 
.................... ///        stored in program memory. 
.................... /// 
.................... /// HTTP_USE_AUTHENTICATION - If set to TRUE (default is FALSE), you can 
.................... ///      have some websites password protected.  In your file system (FAT 
.................... ///      or MPFS) create a new file at the root called 'htaccess.txt'.  The 
.................... ///      format of this file should be as follows: 
.................... ///         user|password|file1|file2|file3 
.................... ///      You can password protect entire directories (if your file system  
.................... ///      provides directory support).  To password protect the entire file 
.................... ///      system then use / as your filename.  Even though you can provide a 
.................... ///      user name and password into htaccess.txt file, the HTTP stack will also 
.................... ///      call http_check_authentication() to verify the username and password. 
.................... ///      It will check both locations, and if the username/password from the 
.................... ///      file matches the user input, or http_check_authentication() returns 
.................... ///      TRUE then authentication is granted.  The reason it checks both is in 
.................... ///      case you want ot password protect a file in the field without having 
.................... ///      to re-program the firmware, you just have to modify htaccess.txt to 
.................... ///      add authentication.  If you want to have the HTTP stack ignore the 
.................... ///      username/password from htaccess.txt then leave those fields blank. 
.................... /// 
.................... ///      If authentication fails the webserver will display the error401.htm 
.................... ///      page. 
.................... /// 
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP 
.................... ///        connections. 
.................... /// 
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the 
.................... ///        HTTP server.  You probably will be fine with just 1.  The 
.................... ///        more sockets you use the more RAM is used to hold buffers 
.................... ///        and state configuration. 
.................... /// 
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several 
.................... ///        buffers.  This limits the size of your GET or POST requests 
.................... ///        and all CGI POST data: 
.................... ///            If using GET, then max amount of cgi data is this value 
.................... ///            minus everything else on the initial GET command (which 
.................... ///            also includes the filename).  I believe the max specified 
.................... ///            by W3C is 255. 
.................... ///            If using POST, then this is the maximum size for one 
.................... ///            key=value pair (including the '=' sign). 
.................... ///        These values do not inlude any escape characters. 
.................... /// 
.................... /// HTTP_ESCAPED_STR_SIZE - Size allocated, per socket, for http_format_char() 
.................... ///         results. 
.................... /// 
.................... /// 
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape 
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have 
.................... ///      two escape characters after the %.  An example of each: 
.................... ///         If FALSE: %A 
.................... ///         If TRUE: %0A 
.................... /// 
.................... /// 
.................... /// **** HOW IT WORKS **** 
.................... /// 
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will 
.................... /// then listen for GET or POST requests.  When it gets a GET or POST 
.................... /// request it passes the page request to the callback function 
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or 
.................... /// a pointer to the constant memory area that holds the page in program 
.................... /// memory.  If it was a POST request it waits until the HTTP header is 
.................... /// done and then saves the POST data into a buffer, and passes the 
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will 
.................... /// parse the CGI post data and act upon it.  When done, the HTTP 
.................... /// server then responds by sending the page.  If the page is to have                                            
.................... /// variable data, it can be represented by an escape code - %0 or %1 
.................... /// for example.  When the HTTP stack sees such an escape code it calls 
.................... /// the callback function http_format_char() to format the escape code 
.................... /// into the needed variable data (such as ADC readings).  After the 
.................... /// HTTP stack is done sending the request it will close the port. 
.................... /// If the page didn't exist it will send a 404 File 
.................... /// not found error.  If there was a problem/timeout parsing the request 
.................... /// the HTTP stack will send a 500 Internal Server Error response. 
.................... /// 
.................... /// **** CALL BACK FUNCTIONS **** 
.................... /// 
.................... /// Your main application must provide the following callback functions to 
.................... /// fill application dependent needs: 
.................... /// 
.................... /// http_exec_cgi(char* file, char *key, char *val); 
.................... ///    A call-back function provided by your application that processes incoming 
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is 
.................... ///    the file name. 
.................... /// 
.................... /// int http_format_char(char* file, char id, char *str, int8 max_ret); 
.................... ///    Given an escaped character in the HTML file, convert to 
.................... ///    variable data.  id is the escaped character, *str is where to save the 
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str. 
.................... ///    Returns the number of bytes written to *str.  file is 
.................... ///    the file name. 
.................... /// 
.................... /// int1 http_check_authentication(char *fileName, char *user, char *pwd); 
.................... ///   If someone has tried to access a password protected file, the http server 
.................... ///   will call this function so the application can determine if the user has 
.................... ///   access.  fileName is the requested file, user is the username the user 
.................... ///   entered, and pwd is the password the user entered.  The function should 
.................... ///   return TRUE if access is granted, FALSE if not.  This function is only 
.................... ///   needed if HTTP_USE_AUTHENTICATION is defined as TRUE. 
.................... /// 
.................... /// **** LIMITATIONS **** 
.................... /// 
.................... /// When creating web pages with forms, keep your form names (keys) simple 
.................... /// because the HTTP stack does not format the escape characters.  For example, 
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord". 
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving 
.................... /// the value, but not the key.  Therefore keep your keys simple. 
.................... /// 
.................... /// 
.................... /// **** FILE SUPPORT *** 
.................... /// Two file systems are supported--FAT on an MMC and Microchip's MPFS on the 
.................... /// external eeprom chip. 
.................... ///  
.................... /// Three files must be supplied on the MMC or MPFS image.  Error404.htm will 
.................... /// be called when the file requested in the URL does not exist.Error500.htm will 
.................... /// be called on an internal server error or timeout.  Internet Exploder requires 
.................... /// that custom error pages be greater than 512 bytes in length or the browser 
.................... /// will insert its own error page in its place.  Index.htm will be called 
.................... /// when no file is explicitly specified in the URL. Other files may be included 
.................... /// on the mmc or MPFS image.  File types that are supported are .htm, .html, 
.................... /// .xml, .txt, .jpg, .png, and .gif. Filenames should be in DOS 8.3 format.  
.................... /// 
.................... ////////////////////////////////////////////////////////////////////////////////                     
.................... /// 
.................... /// * Author         Date           Comment 
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... /// 
.................... /// * Darren Rook    Apr 12 2007    Added HTTP_USE_AUTHENTICATION. 
.................... ///                                 If file system is missing, will display a 
.................... ///                                 500 error file from memory. 
.................... ///                                 If client gets root (/) and index.htm is 
.................... ///                                 missing, show 404 page. 
.................... ///                                 Fixed bug in TCPPutFileParseConst() where 
.................... ///                                 it was checking for EOF after reading a  
.................... ///                                 char, it should check for EOF before reading 
.................... ///                                 from stream. 
.................... /// 
.................... /// * Nick LaBonte   Feb 22 2007    Added support for MPFS 
.................... /// 
.................... /// * Nick LaBonte   Jan 2007       Added MMC file support, removed HTTP_USE_CHUNKS 
.................... /// 
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST 
.................... /// 
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix 
.................... ///                                 many bugs.  The biggest bug is that 
.................... ///                                 it can send pages and receive CGI that 
.................... ///                                 is larger than 1 TCP packet.  Also 
.................... ///                                 added the HTTP_USE_CHUNKS, 
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and 
.................... ///                                 HTTP_USE_CONTENT_TYPE parameters. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2014 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... ////                                                                   //// 
.................... //// http://www.ccsinfo.com                                            //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef debug_html 
....................  #define debug_html_putc(c) 
....................  #define debug_html(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #else 
....................  #define __DO_DEBUG_HTML 
.................... #endif 
....................  
.................... #ifndef debug_mpfs2 
.................... #define debug_mpfs2(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #error Must define a file system to use 
.................... #endif 
....................  
.................... #ifndef HTTP_ESCAPED_STR_SIZE 
.................... #define HTTP_ESCAPED_STR_SIZE 40 
.................... #endif 
....................  
.................... #ifndef HTTP_SEND_BYTES_PER_CHUNK 
.................... #define HTTP_SEND_BYTES_PER_CHUNK   128 
.................... #endif 
....................  
.................... #ifndef HTTP_INTERRUPT_TASKS 
.................... #define HTTP_INTERRUPT_TASKS() 
.................... #endif 
....................  
.................... #define HTTP_404_ERROR_FNAME "error404.htm" 
.................... #define HTTP_500_ERROR_FNAME "error500.htm" 
.................... #define HTML_INDEX_FNAME "index.htm" 
....................  
.................... #ifndef HTTP_SERVER_HTACCESS_FILE 
.................... #define HTTP_SERVER_HTACCESS_FILE "htaccess.txt" 
.................... #endif 
....................  
.................... //this will be displayed if the http_500_error[] file cannot be found on the 
.................... //file system.  useful if the file system has crashed. 
.................... #define HTML_500_FILE_CONTENTS "<html><body><h1>500 Error</h1><hr><p>Internal server error.</p></body></html>" 
....................  
.................... /* 
.................... Very similar to standard strncpy(), but it adds a null termination on n+1, and n 
.................... is the entire size of the string including null termination. 
.................... */ 
.................... void _strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................    strncpy(s1,s2,n-1); 
*
07D38:  MOVLW  01
07D3A:  MOVLB  5
07D3C:  SUBWF  xCB,W
07D3E:  MOVWF  xCD
07D40:  MOVLW  00
07D42:  SUBWFB xCC,W
07D44:  MOVWF  xCE
07D46:  MOVFF  5C8,5F8
07D4A:  MOVFF  5C7,5F7
07D4E:  MOVFF  5CA,5FA
07D52:  MOVFF  5C9,5F9
07D56:  MOVWF  xFC
07D58:  MOVFF  5CD,5FB
07D5C:  MOVLB  0
07D5E:  RCALL  7CA8
....................    s1[n-1]=0; 
07D60:  MOVLW  01
07D62:  MOVLB  5
07D64:  SUBWF  xCB,W
07D66:  MOVWF  xCD
07D68:  MOVLW  00
07D6A:  SUBWFB xCC,W
07D6C:  MOVWF  xCE
07D6E:  MOVF   xC7,W
07D70:  ADDWF  xCD,W
07D72:  MOVWF  FE9
07D74:  MOVF   xC8,W
07D76:  ADDWFC xCE,W
07D78:  MOVWF  FEA
07D7A:  CLRF   FEF
07D7C:  MOVLB  0
07D7E:  RETURN 0
.................... } 
....................  
.................... //static int1 FTPWriteMMC = 0; 
....................  
.................... //key=val pair string, & delimited 
.................... void http_parse_cgi_str(char* file, char *cgistr); 
....................  
.................... unsigned int8 http_socket[HTTP_NUM_SOCKETS]; 
....................  
.................... enum { 
....................    HTTP_IGNORE = 0, 
....................    HTTP_LISTEN_WAIT, 
....................    HTTP_CONNECTED, 
....................    HTTP_GET_HEADERS, 
....................    HTTP_CHECK_AUTHENTICATION, 
....................    HTTP_GET_POST, 
....................    HTTP_GET_POST_CONTINUE, 
....................    HTTP_SEND_RESPONSE, 
....................    HTTP_SEND_RESPONSE_CONTINUE, 
....................    HTTP_CLOSE, 
....................    HTTP_CLOSE_WAITING, 
....................    HTTP_CLOSED, 
....................    HTTP_DISABLED = 0xFF, 
.................... } http_state[HTTP_NUM_SOCKETS]; 
....................  
.................... unsigned int FileExists(char *file) 
*
07C5A:  MOVLB  5
07C5C:  CLRF   xDA
07C5E:  CLRF   xD9
.................... { 
....................    unsigned int ret=FALSE; 
....................    MPFS handle; 
....................   
....................    handle=MPFSOpen(file); 
07C60:  MOVFF  5D8,633
07C64:  MOVFF  5D7,632
07C68:  MOVLB  0
07C6A:  RCALL  7AE8
07C6C:  MOVFF  03,5DE
07C70:  MOVFF  02,5DD
07C74:  MOVFF  01,5DC
07C78:  MOVFF  00,5DB
....................    if (handle != MPFS_INVALID) 
07C7C:  MOVLB  5
07C7E:  INCFSZ xDB,W
07C80:  BRA    7C90
07C82:  INCFSZ xDC,W
07C84:  BRA    7C90
07C86:  INCFSZ xDD,W
07C88:  BRA    7C90
07C8A:  INCFSZ xDE,W
07C8C:  BRA    7C90
07C8E:  BRA    7C9C
....................    { 
....................       ret=TRUE; 
07C90:  CLRF   xDA
07C92:  MOVLW  01
07C94:  MOVWF  xD9
....................       MPFSGetEnd();  
....................       MPFSClose(); 
07C96:  MOVLB  0
07C98:  RCALL  79AA
07C9A:  MOVLB  5
....................    } 
....................   
....................    return(ret); 
07C9C:  MOVFF  5D9,01
07CA0:  MOVFF  5DA,02
07CA4:  MOVLB  0
07CA6:  RETURN 0
.................... } 
....................  
.................... #if HTTP_USE_AUTHENTICATION 
....................    char http_401_error[]="error401.htm"; 
....................  
....................  
.................... /* 
.................... src holds a string in base64 (null terminated), this will convert that string  
.................... to ascii and save to dest (null terminated).  if src is NULL, then it will use 
.................... dest for the source and save the result over source. 
.................... */ 
.................... void Base64ToString(char *dest, char *src) 
.................... { 
....................    unsigned int32 j; 
....................    unsigned int8 i,scr; 
....................     
....................    if (!src) 
*
0829E:  MOVLB  6
082A0:  MOVF   x34,W
082A2:  IORWF  x35,W
082A4:  BNZ   82AE
....................       src=dest; 
082A6:  MOVFF  633,635
082AA:  MOVFF  632,634
....................     
....................    while(*src) 
082AE:  MOVFF  635,03
082B2:  MOVFF  634,FE9
082B6:  MOVFF  635,FEA
082BA:  MOVF   FEF,F
082BC:  BTFSC  FD8.2
082BE:  BRA    83EE
....................    { 
....................       j=0; 
082C0:  CLRF   x39
082C2:  CLRF   x38
082C4:  CLRF   x37
082C6:  CLRF   x36
....................       for (i=0;i<4;i++) 
082C8:  CLRF   x3A
082CA:  MOVF   x3A,W
082CC:  SUBLW  03
082CE:  BTFSS  FD8.0
082D0:  BRA    83B8
....................       { 
....................          scr=*src; 
082D2:  MOVFF  634,FE9
082D6:  MOVFF  635,FEA
082DA:  MOVFF  FEF,63B
....................          //printf("'%c'->",scr); 
....................          if (scr) 
082DE:  MOVF   x3B,F
082E0:  BZ    82E8
....................             src++; 
082E2:  INCF   x34,F
082E4:  BTFSC  FD8.2
082E6:  INCF   x35,F
....................          if ((scr>='A')&&(scr<='Z')) 
082E8:  MOVF   x3B,W
082EA:  SUBLW  40
082EC:  BC    82FA
082EE:  MOVF   x3B,W
082F0:  SUBLW  5A
082F2:  BNC   82FA
....................             scr-='A'; 
082F4:  MOVLW  41
082F6:  SUBWF  x3B,F
082F8:  BRA    8346
....................          else if ((scr>='a')&&(scr<='z')) 
082FA:  MOVF   x3B,W
082FC:  SUBLW  60
082FE:  BC    831A
08300:  MOVF   x3B,W
08302:  SUBLW  7A
08304:  BNC   831A
....................             scr+=26-'a'; 
08306:  MOVLW  B9
08308:  ADDWF  x3B,W
0830A:  MOVWF  01
0830C:  MOVLW  FF
0830E:  MOVWF  03
08310:  BTFSC  FD8.0
08312:  INCF   03,F
08314:  MOVFF  01,63B
08318:  BRA    8346
....................          else if ((scr>='0')&&(scr<='9')) 
0831A:  MOVF   x3B,W
0831C:  SUBLW  2F
0831E:  BC    832C
08320:  MOVF   x3B,W
08322:  SUBLW  39
08324:  BNC   832C
....................             scr+=52-'0'; 
08326:  MOVLW  04
08328:  ADDWF  x3B,F
0832A:  BRA    8346
....................          else if (scr==' ') 
0832C:  MOVF   x3B,W
0832E:  SUBLW  20
08330:  BNZ   8338
....................             scr=62; 
08332:  MOVLW  3E
08334:  MOVWF  x3B
08336:  BRA    8346
....................          else if (scr=='/') 
08338:  MOVF   x3B,W
0833A:  SUBLW  2F
0833C:  BNZ   8344
....................             scr=63; 
0833E:  MOVLW  3F
08340:  MOVWF  x3B
08342:  BRA    8346
....................          else 
....................             scr=0; 
08344:  CLRF   x3B
....................              
....................          j *= (int32)64; //bit shift left 6 times 
08346:  RLCF   x36,W
08348:  MOVWF  00
0834A:  RLCF   x37,W
0834C:  MOVWF  01
0834E:  RLCF   x38,W
08350:  MOVWF  02
08352:  RLCF   x39,W
08354:  MOVWF  03
08356:  RLCF   00,F
08358:  RLCF   01,F
0835A:  RLCF   02,F
0835C:  RLCF   03,F
0835E:  RLCF   00,F
08360:  RLCF   01,F
08362:  RLCF   02,F
08364:  RLCF   03,F
08366:  RLCF   00,F
08368:  RLCF   01,F
0836A:  RLCF   02,F
0836C:  RLCF   03,F
0836E:  RLCF   00,F
08370:  RLCF   01,F
08372:  RLCF   02,F
08374:  RLCF   03,F
08376:  RLCF   00,F
08378:  RLCF   01,F
0837A:  RLCF   02,F
0837C:  RLCF   03,F
0837E:  MOVLW  C0
08380:  ANDWF  00,F
08382:  MOVFF  03,639
08386:  MOVFF  02,638
0838A:  MOVFF  01,637
0838E:  MOVFF  00,636
....................          j &= (int32)0xFFFFFFC0; 
08392:  MOVF   x36,W
08394:  ANDLW  C0
08396:  MOVFF  637,01
0839A:  MOVFF  638,02
0839E:  MOVFF  639,03
083A2:  MOVFF  639,639
083A6:  MOVFF  638,638
083AA:  MOVFF  637,637
083AE:  MOVWF  x36
....................          j |= scr; 
083B0:  MOVF   x3B,W
083B2:  IORWF  x36,F
083B4:  INCF   x3A,F
083B6:  BRA    82CA
....................          //printf("%U [%LX]\r\n", scr,j); 
....................       } 
....................       dest[0]=make8(j,2); 
083B8:  MOVFF  632,FE9
083BC:  MOVFF  633,FEA
083C0:  MOVFF  638,FEF
....................       dest[1]=make8(j,1); 
083C4:  MOVLW  01
083C6:  ADDWF  x32,W
083C8:  MOVWF  FE9
083CA:  MOVLW  00
083CC:  ADDWFC x33,W
083CE:  MOVWF  FEA
083D0:  MOVFF  637,FEF
....................       dest[2]=make8(j,0); 
083D4:  MOVLW  02
083D6:  ADDWF  x32,W
083D8:  MOVWF  FE9
083DA:  MOVLW  00
083DC:  ADDWFC x33,W
083DE:  MOVWF  FEA
083E0:  MOVFF  636,FEF
....................       //printf("APPEND: '%c%c%c'\r\n", dest[0],dest[1],dest[2]); 
....................       dest+=3; 
083E4:  MOVLW  03
083E6:  ADDWF  x32,F
083E8:  MOVLW  00
083EA:  ADDWFC x33,F
083EC:  BRA    82AE
....................    } 
....................    *dest=0; 
083EE:  MOVFF  632,FE9
083F2:  MOVFF  633,FEA
083F6:  CLRF   FEF
083F8:  MOVLB  0
083FA:  GOTO   85F8 (RETURN)
.................... } 
....................  
.................... /* 
.................... Reads the htaccess file (already opened in fHandle), saving max chars to 
.................... *result.  If it reads a '|' then it returns FALSE, if it hits EOF then it  
.................... returns TRUE.  If result is NULL then it won't save, it will just point the  
.................... file to the next element. 
.................... */ 
.................... static unsigned int8 HTTPParseHtaccess(MPFS *pFHandle, char *result, unsigned int16 max) 
*
08186:  MOVLB  6
08188:  CLRF   x39
.................... { 
....................    char c; 
....................    unsigned int8 ret=FALSE; 
....................     
....................    max--;   //save one for null termination 
0818A:  MOVF   x36,W
0818C:  BTFSC  FD8.2
0818E:  DECF   x37,F
08190:  DECF   x36,F
....................     
....................    do 
....................    { 
....................       if (MPFSIsEOF()) 
08192:  MOVLB  0
08194:  INCFSZ xF9,W
08196:  BRA    81AE
08198:  INCFSZ xFA,W
0819A:  BRA    81AE
0819C:  INCFSZ xFB,W
0819E:  BRA    81AE
081A0:  INCFSZ xFC,W
081A2:  BRA    81AE
....................       { 
....................          ret=TRUE; 
081A4:  MOVLW  01
081A6:  MOVLB  6
081A8:  MOVWF  x39
....................          break; 
081AA:  BRA    81F6
081AC:  MOVLB  0
....................       } 
....................       c =  MPFSGet(); 
081AE:  RCALL  80FA
081B0:  MOVFF  01,638
....................       if (result && max && (c!='|') && (c>=' ')) 
081B4:  MOVLB  6
081B6:  MOVF   x34,W
081B8:  IORWF  x35,W
081BA:  BZ    81F0
081BC:  MOVF   x36,W
081BE:  IORWF  x37,W
081C0:  BZ    81F0
081C2:  MOVF   x38,W
081C4:  SUBLW  7C
081C6:  BZ    81F0
081C8:  BTFSC  x38.7
081CA:  BRA    81F0
081CC:  MOVF   x38,W
081CE:  SUBLW  1F
081D0:  BC    81F0
....................       { 
....................          *result++ = c; 
081D2:  MOVFF  635,03
081D6:  MOVF   x34,W
081D8:  INCF   x34,F
081DA:  BTFSC  FD8.2
081DC:  INCF   x35,F
081DE:  MOVWF  FE9
081E0:  MOVFF  03,FEA
081E4:  MOVFF  638,FEF
....................          max--; 
081E8:  MOVF   x36,W
081EA:  BTFSC  FD8.2
081EC:  DECF   x37,F
081EE:  DECF   x36,F
....................       } 
....................    } while(c!='|'); 
081F0:  MOVF   x38,W
081F2:  SUBLW  7C
081F4:  BNZ   8192
....................     
....................    if (result) 
081F6:  MOVF   x34,W
081F8:  IORWF  x35,W
081FA:  BZ    8206
....................       *result = 0; 
081FC:  MOVFF  634,FE9
08200:  MOVFF  635,FEA
08204:  CLRF   FEF
....................     
....................    return(ret); 
08206:  MOVFF  639,01
0820A:  MOVLB  0
0820C:  RETURN 0
.................... }    
....................  
.................... /* 
.................... Upon request of a file, this function should be called before serving the file 
.................... to the user.  It checks to see if the file requires authentication, and if it 
.................... does it sees if the user provided username/password combination passes.  *page 
.................... contains the requested page, *user contains the username/password combination 
.................... from the HTTP header (in base64).  If the user hasn't provided a  
.................... username/password then user will be set to NULL.  This function will return  
.................... TRUE if authentication fails, in which case the server will respond with  
.................... Error 401. 
.................... If you are using MPFS, it must be free at this time and be able to open a file 
.................... else the results will be TRUE.   
.................... If the htaccess format is not valid this will always return TRUE. 
.................... If it cannot find htaccess file it will assume that no file requires  
.................... authentication. 
.................... */ 
.................... unsigned int8 HTTPRequiresAuthentication(char *page, char *user) 
*
08462:  MOVLW  01
08464:  MOVLB  6
08466:  MOVWF  x31
.................... { 
....................    static char htaccess[] = HTTP_SERVER_HTACCESS_FILE; 
....................    static char token[]=":"; 
....................    char *pwd; 
....................    MPFS fHandle; 
....................    char userFromFile[30], pwdFromFile[30], fileToCheck[30]; 
....................    unsigned int8 eof,i; 
....................    unsigned int8 ret=TRUE; 
....................  
....................  
....................    //printf("\r\nCHECK FILE '%s'\r\n", page); 
....................    
....................   //#if STACK_USE_MPFS 
....................   #if 0 
....................    if (MPFSIsInUse()) 
....................    { 
....................       //printf("\r\nMPFSINUSE\r\n"); 
....................       return(TRUE); 
....................    } 
....................   #endif 
....................     
....................    fHandle = MPFSOpen(htaccess); 
08468:  MOVLW  02
0846A:  MOVWF  x33
0846C:  MOVLW  1F
0846E:  MOVWF  x32
08470:  MOVLB  0
08472:  CALL   7AE8
08476:  MOVFF  03,5D4
0847A:  MOVFF  02,5D3
0847E:  MOVFF  01,5D2
08482:  MOVFF  00,5D1
....................    if (fHandle == MPFS_INVALID) 
08486:  MOVLB  5
08488:  INCFSZ xD1,W
0848A:  BRA    849E
0848C:  INCFSZ xD2,W
0848E:  BRA    849E
08490:  INCFSZ xD3,W
08492:  BRA    849E
08494:  INCFSZ xD4,W
08496:  BRA    849E
....................    { 
....................       //printf("\r\nNOHTACCESS '%s'\r\n", htaccess); 
....................       return(FALSE); 
08498:  MOVLW  00
0849A:  MOVWF  01
0849C:  BRA    871C
....................    } 
....................     
....................    MPFSGetBegin(fHandle); 
0849E:  MOVFF  5D4,FC
084A2:  MOVFF  5D3,FB
084A6:  MOVFF  5D2,FA
084AA:  MOVFF  5D1,F9
....................     
....................    if (HTTPParseHtaccess(&fHandle, userFromFile, sizeof(userFromFile))) 
084AE:  MOVLW  05
084B0:  MOVLB  6
084B2:  MOVWF  x33
084B4:  MOVLW  D1
084B6:  MOVWF  x32
084B8:  MOVLW  05
084BA:  MOVWF  x35
084BC:  MOVLW  D5
084BE:  MOVWF  x34
084C0:  CLRF   x37
084C2:  MOVLW  1E
084C4:  MOVWF  x36
084C6:  MOVLB  0
084C8:  RCALL  8186
084CA:  MOVF   01,F
084CC:  BZ    84D0
....................       goto __HTTPRequiresAuthentication_Cleanup; 
084CE:  BRA    870C
....................    if (HTTPParseHtaccess(&fHandle, pwdFromFile, sizeof(pwdFromFile))) 
084D0:  MOVLW  05
084D2:  MOVLB  6
084D4:  MOVWF  x33
084D6:  MOVLW  D1
084D8:  MOVWF  x32
084DA:  MOVLW  05
084DC:  MOVWF  x35
084DE:  MOVLW  F3
084E0:  MOVWF  x34
084E2:  CLRF   x37
084E4:  MOVLW  1E
084E6:  MOVWF  x36
084E8:  MOVLB  0
084EA:  RCALL  8186
084EC:  MOVF   01,F
084EE:  BZ    84F2
....................       goto __HTTPRequiresAuthentication_Cleanup; 
084F0:  BRA    870C
....................    
....................    for(;;) 
....................    { 
....................       //printf("\r\nFINDING FILE\r\n"); 
....................       eof = HTTPParseHtaccess(&fHandle, fileToCheck, sizeof(fileToCheck)); 
084F2:  MOVLW  05
084F4:  MOVLB  6
084F6:  MOVWF  x33
084F8:  MOVLW  D1
084FA:  MOVWF  x32
084FC:  MOVLW  06
084FE:  MOVWF  x35
08500:  MOVLW  11
08502:  MOVWF  x34
08504:  CLRF   x37
08506:  MOVLW  1E
08508:  MOVWF  x36
0850A:  MOVLB  0
0850C:  RCALL  8186
0850E:  MOVFF  01,62F
....................             
....................       strupr(fileToCheck); 
08512:  MOVLW  06
08514:  MOVLB  6
08516:  MOVWF  x4F
08518:  MOVLW  11
0851A:  MOVWF  x4E
0851C:  MOVLB  0
0851E:  CALL   79BC
....................        
....................       //strip any any whitespace chars at the end of the file 
....................       i=strlen(fileToCheck); 
08522:  MOVLW  06
08524:  MOVLB  6
08526:  MOVWF  x4F
08528:  MOVLW  11
0852A:  MOVWF  x4E
0852C:  MOVLB  0
0852E:  CALL   7068
08532:  MOVFF  01,630
....................       while(i--) 
08536:  MOVLB  6
08538:  MOVF   x30,W
0853A:  DECF   x30,F
0853C:  XORLW  00
0853E:  BZ    856E
....................       { 
....................          if (fileToCheck[i] <= ' ') 
08540:  CLRF   03
08542:  MOVF   x30,W
08544:  ADDLW  11
08546:  MOVWF  FE9
08548:  MOVLW  06
0854A:  ADDWFC 03,W
0854C:  MOVWF  FEA
0854E:  BTFSC  FEF.7
08550:  BRA    8558
08552:  MOVF   FEF,W
08554:  SUBLW  20
08556:  BNC   856A
....................             fileToCheck[i]=0; 
08558:  CLRF   03
0855A:  MOVF   x30,W
0855C:  ADDLW  11
0855E:  MOVWF  FE9
08560:  MOVLW  06
08562:  ADDWFC 03,W
08564:  MOVWF  FEA
08566:  CLRF   FEF
08568:  BRA    856C
....................          else 
....................             break; 
0856A:  BRA    856E
0856C:  BRA    8538
....................       } 
....................  
....................       //printf("\r\nFILE (%U) = '%s'\r\n", eof, fileToCheck); 
....................       if ( 
....................             (fileToCheck[0] == '*') || //wildcard, match all files 
....................             (strcmp(fileToCheck, page)==0) ||  //file is a perfect match 
....................             (  //check for subdirectory 
....................                (fileToCheck[i]=='/') &&   //if file ends in /, it is a directory 
....................                (strstr(page, fileToCheck)==page) 
....................             ) 
0856E:  MOVF   x11,W
08570:  SUBLW  2A
08572:  BZ    85E8
08574:  MOVLW  06
08576:  MOVWF  x33
08578:  MOVLW  11
0857A:  MOVWF  x32
0857C:  MOVFF  5CC,635
08580:  MOVFF  5CB,634
08584:  MOVLB  0
08586:  CALL   715C
0858A:  MOVLB  6
0858C:  CLRF   x33
0858E:  MOVFF  01,632
08592:  BTFSC  01.7
08594:  DECF   x33,F
08596:  MOVF   x32,F
08598:  BNZ   859E
0859A:  MOVF   x33,F
0859C:  BZ    85E8
0859E:  CLRF   03
085A0:  MOVF   x30,W
085A2:  ADDLW  11
085A4:  MOVWF  FE9
085A6:  MOVLW  06
085A8:  ADDWFC 03,W
085AA:  MOVWF  FEA
085AC:  MOVF   FEF,W
085AE:  SUBLW  2F
085B0:  BTFSS  FD8.2
085B2:  BRA    86FC
085B4:  MOVFF  5CC,633
085B8:  MOVFF  5CB,632
085BC:  MOVLW  06
085BE:  MOVWF  x35
085C0:  MOVLW  11
085C2:  MOVWF  x34
085C4:  MOVLB  0
085C6:  BRA    820E
085C8:  MOVFF  02,633
085CC:  MOVFF  01,632
085D0:  MOVLB  5
085D2:  MOVF   xCB,W
085D4:  MOVLB  6
085D6:  SUBWF  01,W
085D8:  BTFSS  FD8.2
085DA:  BRA    86FC
085DC:  MOVLB  5
085DE:  MOVF   xCC,W
085E0:  MOVLB  6
085E2:  SUBWF  x33,W
085E4:  BTFSS  FD8.2
085E6:  BRA    86FC
....................          ) 
....................       { 
....................          //printf("\r\nCONVERTING 64: '%s'->", user); 
....................          Base64ToString(user, NULL);          
085E8:  MOVFF  5CE,633
085EC:  MOVFF  5CD,632
085F0:  CLRF   x35
085F2:  CLRF   x34
085F4:  MOVLB  0
085F6:  BRA    829E
....................          //printf("'%s'\r\n", user); 
....................          user=strtok(user,token); 
085F8:  MOVFF  5CE,633
085FC:  MOVFF  5CD,632
08600:  MOVLW  02
08602:  MOVLB  6
08604:  MOVWF  x35
08606:  MOVLW  2C
08608:  MOVWF  x34
0860A:  MOVLB  0
0860C:  CALL   70A4
08610:  MOVFF  02,5CE
08614:  MOVFF  01,5CD
....................          pwd=strtok(0,token); 
08618:  MOVLB  6
0861A:  CLRF   x33
0861C:  CLRF   x32
0861E:  MOVLW  02
08620:  MOVWF  x35
08622:  MOVLW  2C
08624:  MOVWF  x34
08626:  MOVLB  0
08628:  CALL   70A4
0862C:  MOVFF  02,5D0
08630:  MOVFF  01,5CF
....................          return 
....................             ( 
....................                !( 
....................                   ( 
....................                      strlen(userFromFile) &&  
....................                      strlen(pwdFromFile) &&  
....................                      (stricmp(userFromFile,user)==0) && 
....................                      (stricmp(pwdFromFile,pwd)==0) 
....................                   ) || 
....................                   http_check_authentication(page,user,pwd) 
....................                 ) 
....................             ); 
08634:  MOVLW  05
08636:  MOVLB  6
08638:  MOVWF  x4F
0863A:  MOVLW  D5
0863C:  MOVWF  x4E
0863E:  MOVLB  0
08640:  CALL   7068
08644:  MOVF   01,W
08646:  IORWF  02,W
08648:  BZ    86CA
0864A:  MOVLW  05
0864C:  MOVLB  6
0864E:  MOVWF  x4F
08650:  MOVLW  F3
08652:  MOVWF  x4E
08654:  MOVLB  0
08656:  CALL   7068
0865A:  MOVF   01,W
0865C:  IORWF  02,W
0865E:  BZ    86CA
08660:  MOVLW  05
08662:  MOVLB  6
08664:  MOVWF  x39
08666:  MOVLW  D5
08668:  MOVWF  x38
0866A:  MOVFF  5CE,63B
0866E:  MOVFF  5CD,63A
08672:  MOVLB  0
08674:  CALL   7846
08678:  MOVLB  6
0867A:  CLRF   x33
0867C:  MOVFF  01,632
08680:  BTFSC  01.7
08682:  DECF   x33,F
08684:  MOVF   x32,F
08686:  BTFSC  FD8.2
08688:  BRA    868E
0868A:  MOVLB  0
0868C:  BRA    86CA
0868E:  MOVF   x33,F
08690:  BTFSC  FD8.2
08692:  BRA    8698
08694:  MOVLB  0
08696:  BRA    86CA
08698:  MOVLW  05
0869A:  MOVWF  x39
0869C:  MOVLW  F3
0869E:  MOVWF  x38
086A0:  MOVFF  5D0,63B
086A4:  MOVFF  5CF,63A
086A8:  MOVLB  0
086AA:  CALL   7846
086AE:  MOVLB  6
086B0:  CLRF   x33
086B2:  MOVFF  01,632
086B6:  BTFSC  01.7
086B8:  DECF   x33,F
086BA:  MOVF   x32,F
086BC:  BTFSC  FD8.2
086BE:  BRA    86C4
086C0:  MOVLB  0
086C2:  BRA    86CA
086C4:  MOVF   x33,F
086C6:  BZ    86EA
086C8:  MOVLB  0
086CA:  MOVFF  5CC,633
086CE:  MOVFF  5CB,632
086D2:  MOVFF  5CE,635
086D6:  MOVFF  5CD,634
086DA:  MOVFF  5D0,637
086DE:  MOVFF  5CF,636
086E2:  BRA    83FE
086E4:  MOVF   01,F
086E6:  BZ    86EE
086E8:  MOVLB  6
086EA:  MOVLW  00
086EC:  BRA    86F2
086EE:  MOVLW  01
086F0:  MOVLB  6
086F2:  MOVWF  01
086F4:  MOVLB  5
086F6:  BRA    871C
....................          //if (user && pwd && (strcmp(user,validUser)==0) && (strcmp(pwd,validPwd)==0)) 
....................          //   ret=FALSE; 
....................          break; 
086F8:  BRA    870E
086FA:  MOVLB  6
....................       } 
....................        
....................       if (eof) 
086FC:  MOVF   x2F,F
086FE:  BZ    8708
....................       { 
....................          ret=FALSE; 
08700:  CLRF   x31
....................          break; 
08702:  MOVLB  5
08704:  BRA    870E
08706:  MOVLB  6
....................       }       
08708:  MOVLB  0
0870A:  BRA    84F2
0870C:  MOVLB  5
....................    } 
....................  
.................... __HTTPRequiresAuthentication_Cleanup: 
....................    MPFSGetEnd(); 
....................    MPFSClose(); 
0870E:  MOVLB  0
08710:  CALL   79AA
....................    return(ret); 
08714:  MOVLB  6
08716:  MOVFF  631,01
0871A:  MOVLB  5
0871C:  MOVLB  0
0871E:  GOTO   A758 (RETURN)
.................... } 
.................... #endif //HTTP_USE_AUTHENTICATION 
....................  
.................... //strips out any escape characters that the HTTP client may have inserted. 
.................... // (+ is replaced with space) 
.................... // (%xx is replaced with character representation of xx) 
.................... void http_escape_chars(char *str) 
.................... { 
....................    char new[3]; 
....................    char c; 
....................    char val; 
....................  
....................    new[2]=0; 
*
0775A:  MOVLB  5
0775C:  CLRF   xD8
....................  
....................    while((c=*str) != 0) 
0775E:  MOVFF  5D5,03
07762:  MOVFF  5D4,FE9
07766:  MOVFF  5D5,FEA
0776A:  MOVFF  FEF,5D9
0776E:  CLRF   03
07770:  MOVF   xD9,W
07772:  MOVWF  00
07774:  BTFSC  FE8.7
07776:  DECF   03,F
07778:  XORLW  00
0777A:  BNZ   7780
0777C:  MOVF   03,F
0777E:  BZ    7842
....................    { 
....................       if (c=='+') 
07780:  MOVF   xD9,W
07782:  SUBLW  2B
07784:  BNZ   779E
....................          *str++=' '; 
07786:  MOVFF  5D5,03
0778A:  MOVF   xD4,W
0778C:  INCF   xD4,F
0778E:  BTFSC  FD8.2
07790:  INCF   xD5,F
07792:  MOVWF  FE9
07794:  MOVFF  03,FEA
07798:  MOVLW  20
0779A:  MOVWF  FEF
0779C:  BRA    783E
....................       else if (c=='%') 
0779E:  MOVF   xD9,W
077A0:  SUBLW  25
077A2:  BNZ   7838
....................       { 
....................          memcpy(new, str + 1, 2); 
077A4:  MOVLW  01
077A6:  ADDWF  xD4,W
077A8:  MOVWF  xDB
077AA:  MOVLW  00
077AC:  ADDWFC xD5,W
077AE:  MOVWF  FE2
077B0:  MOVFF  5DB,FE1
077B4:  MOVFF  FE6,5D6
077B8:  MOVFF  FE6,5D7
....................          val = strtoul(new, 0, 16); 
077BC:  MOVLW  05
077BE:  MOVWF  xDC
077C0:  MOVLW  D6
077C2:  MOVWF  xDB
077C4:  CLRF   xDE
077C6:  CLRF   xDD
077C8:  CLRF   xE0
077CA:  MOVLW  10
077CC:  MOVWF  xDF
077CE:  MOVLB  0
077D0:  BRA    7222
077D2:  MOVFF  00,5DA
....................          *str++ = val; 
077D6:  MOVLB  5
077D8:  MOVFF  5D5,03
077DC:  MOVF   xD4,W
077DE:  INCF   xD4,F
077E0:  BTFSC  FD8.2
077E2:  INCF   xD5,F
077E4:  MOVWF  FE9
077E6:  MOVFF  03,FEA
077EA:  MOVFF  5DA,FEF
....................          memmove(str, str + 2, strlen(str) - 1); 
077EE:  MOVLW  02
077F0:  ADDWF  xD4,W
077F2:  MOVWF  xDB
077F4:  MOVLW  00
077F6:  ADDWFC xD5,W
077F8:  MOVWF  xDC
077FA:  MOVFF  5D5,64F
077FE:  MOVFF  5D4,64E
07802:  MOVLB  0
07804:  RCALL  7068
07806:  MOVFF  02,5DE
0780A:  MOVFF  01,5DD
0780E:  MOVLW  01
07810:  MOVLB  5
07812:  SUBWF  xDD,F
07814:  MOVLW  00
07816:  SUBWFB xDE,F
07818:  MOVFF  5D5,5FA
0781C:  MOVFF  5D4,5F9
07820:  MOVFF  5DC,5FC
07824:  MOVFF  5DB,5FB
07828:  MOVFF  5DE,5FE
0782C:  MOVFF  5DD,5FD
07830:  MOVLB  0
07832:  RCALL  7636
....................       } 
07834:  BRA    783E
07836:  MOVLB  5
....................       else 
....................          str++; 
07838:  INCF   xD4,F
0783A:  BTFSC  FD8.2
0783C:  INCF   xD5,F
0783E:  MOVLB  5
07840:  BRA    775E
....................    } 
07842:  MOVLB  0
07844:  RETURN 0
.................... } 
....................  
.................... void http_parse_cgi_string(char* file, char *ptr) 
.................... { 
....................    char *pKey, *pValue, c; 
....................  
....................    pKey=ptr; 
*
0886E:  MOVFF  5CE,5D0
08872:  MOVFF  5CD,5CF
....................  
....................    for(;;) 
....................    { 
....................       c = *ptr; 
08876:  MOVLB  5
08878:  MOVFF  5CD,FE9
0887C:  MOVFF  5CE,FEA
08880:  MOVFF  FEF,5D3
....................       if ((c=='&') || (c==0)) 
08884:  MOVF   xD3,W
08886:  SUBLW  26
08888:  BZ    889C
0888A:  CLRF   03
0888C:  MOVF   xD3,W
0888E:  MOVWF  00
08890:  BTFSC  FE8.7
08892:  DECF   03,F
08894:  XORLW  00
08896:  BNZ   88FE
08898:  MOVF   03,F
0889A:  BNZ   88FE
....................       { 
....................          *ptr=0; 
0889C:  MOVFF  5CD,FE9
088A0:  MOVFF  5CE,FEA
088A4:  CLRF   FEF
....................          http_escape_chars(pKey); 
088A6:  MOVFF  5D0,5D5
088AA:  MOVFF  5CF,5D4
088AE:  MOVLB  0
088B0:  CALL   775A
....................          http_escape_chars(pValue); 
088B4:  MOVFF  5D2,5D5
088B8:  MOVFF  5D1,5D4
088BC:  CALL   775A
....................          http_exec_cgi(file, pKey, pValue); 
088C0:  MOVFF  5CC,5D5
088C4:  MOVFF  5CB,5D4
088C8:  MOVFF  5D0,5D7
088CC:  MOVFF  5CF,5D6
088D0:  MOVFF  5D2,5D9
088D4:  MOVFF  5D1,5D8
088D8:  BRA    8722
....................          pKey=ptr+1; 
088DA:  MOVLW  01
088DC:  MOVLB  5
088DE:  ADDWF  xCD,W
088E0:  MOVWF  xCF
088E2:  MOVLW  00
088E4:  ADDWFC xCE,W
088E6:  MOVWF  xD0
....................          if (c==0) 
088E8:  CLRF   03
088EA:  MOVF   xD3,W
088EC:  MOVWF  00
088EE:  BTFSC  FE8.7
088F0:  DECF   03,F
088F2:  XORLW  00
088F4:  BNZ   88FC
088F6:  MOVF   03,F
088F8:  BNZ   88FC
....................             break; 
088FA:  BRA    8922
....................       } 
088FC:  BRA    891A
....................       else if (c=='=') 
088FE:  MOVF   xD3,W
08900:  SUBLW  3D
08902:  BNZ   891A
....................       { 
....................          *ptr=0; 
08904:  MOVFF  5CD,FE9
08908:  MOVFF  5CE,FEA
0890C:  CLRF   FEF
....................          pValue=ptr+1; 
0890E:  MOVLW  01
08910:  ADDWF  xCD,W
08912:  MOVWF  xD1
08914:  MOVLW  00
08916:  ADDWFC xCE,W
08918:  MOVWF  xD2
....................       } 
....................       ptr++; 
0891A:  INCF   xCD,F
0891C:  BTFSC  FD8.2
0891E:  INCF   xCE,F
08920:  BRA    8878
....................    } 
08922:  MOVLB  0
08924:  RETURN 0
.................... } 
....................  
.................... unsigned int8 g_HttpCurrSocket; 
.................... unsigned int8 g_HttpCurrConn; 
....................  
.................... #define tcp_http_tx_left()  TCPIsPutReady(g_HttpCurrSocket) 
....................  
.................... unsigned int tcp_http_putc(char c) 
.................... { 
....................    //putc(c); 
....................    return(TCPPut(g_HttpCurrSocket,c)); 
*
08CBC:  MOVFF  22E,5ED
08CC0:  MOVFF  5EC,5EE
08CC4:  BRA    8B98
08CC6:  CLRF   03
08CC8:  MOVFF  03,02
08CCC:  RETURN 0
.................... } 
....................  
.................... MPFS lastHTTPPutConstPos[HTTP_NUM_SOCKETS]; 
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS]; 
....................  
.................... typedef enum 
.................... { 
....................    MIME_TYPE_HTM, 
....................    MIME_TYPE_HTML, 
....................    MIME_TYPE_TXT, 
....................    MIME_TYPE_XML, 
....................    MIME_TYPE_GIF, 
....................    MIME_TYPE_JPG, 
....................    MIME_TYPE_PNG, 
....................    MIME_TYPE_ICO 
.................... } MIME_T; 
....................  
.................... //static int1 is_image[HTTP_NUM_SOCKETS]; 
.................... MIME_T g_HTTPMimeType[HTTP_NUM_SOCKETS]; 
.................... #if HTTP_LAST_MODIFIED_CHECK 
....................  int1 g_lastModifiedCheck[HTTP_NUM_SOCKETS]; 
.................... #endif 
.................... #define IsImage(t)   (g_HTTPMimeType[t]>=MIME_TYPE_GIF) 
....................  
.................... #define HTTP_NUM_MIME_TYPES   8 
....................  
.................... ROM char gc_MimeTypes[HTTP_NUM_MIME_TYPES][5] =  //filename extensions 
.................... { 
....................    "htm", 
....................    "html", 
....................    "txt", 
....................    "xml", 
....................    "gif", 
....................    "jpg", 
....................    "png", 
....................    "ico" 
.................... }; 
....................  
.................... ROM char gc_MimeTypesHeader[HTTP_NUM_MIME_TYPES][13] = 
.................... { 
....................    "text/html", 
....................    "text/html", 
....................    "text/plain", 
....................    "text/xml", 
....................    "image/gif", 
....................    "image/jpeg", 
....................    "image/png", 
....................    "image/x-icon" 
.................... }; 
....................  
.................... MIME_T HTTPFindMimeType(char *fname) 
.................... { 
....................    unsigned int8 i; 
....................    char str[5]; 
....................    char extension[5]; 
....................  
....................    if(strlen(strchr(fname,'.'))<6) 
*
089BC:  MOVFF  5CA,5D7
089C0:  MOVFF  5C9,5D6
089C4:  MOVLW  2E
089C6:  MOVLB  5
089C8:  MOVWF  xD8
089CA:  MOVLB  0
089CC:  RCALL  8926
089CE:  MOVFF  02,5D7
089D2:  MOVFF  01,5D6
089D6:  MOVFF  02,64F
089DA:  MOVFF  01,64E
089DE:  CALL   7068
089E2:  MOVFF  02,5D7
089E6:  MOVFF  01,5D6
089EA:  MOVLB  5
089EC:  MOVF   xD7,F
089EE:  BNZ   8A38
089F0:  MOVF   xD6,W
089F2:  SUBLW  05
089F4:  BNC   8A38
....................    { 
....................       strncpy (extension, (strchr(fname,  '.'))+1,  4); 
089F6:  MOVFF  5CA,5D7
089FA:  MOVFF  5C9,5D6
089FE:  MOVLW  2E
08A00:  MOVWF  xD8
08A02:  MOVLB  0
08A04:  RCALL  8926
08A06:  MOVFF  02,5D7
08A0A:  MOVFF  01,5D6
08A0E:  MOVLW  01
08A10:  MOVLB  5
08A12:  ADDWF  xD6,F
08A14:  MOVLW  00
08A16:  ADDWFC xD7,F
08A18:  MOVLW  05
08A1A:  MOVWF  xF8
08A1C:  MOVLW  D1
08A1E:  MOVWF  xF7
08A20:  MOVFF  5D7,5FA
08A24:  MOVFF  5D6,5F9
08A28:  CLRF   xFC
08A2A:  MOVLW  04
08A2C:  MOVWF  xFB
08A2E:  MOVLB  0
08A30:  CALL   7CA8
....................    } 
08A34:  BRA    8A3C
08A36:  MOVLB  5
....................    else 
....................       extension[0] = 0; 
08A38:  CLRF   xD1
08A3A:  MOVLB  0
....................  
....................  
....................    for (i=0; i<HTTP_NUM_MIME_TYPES; i++) 
08A3C:  MOVLB  5
08A3E:  CLRF   xCB
08A40:  MOVF   xCB,W
08A42:  SUBLW  07
08A44:  BNC   8AA2
....................    { 
....................       //sprintf(str, "%s", gc_MimeTypes[i]); 
....................       strcpypgm2ram(str, &gc_MimeTypes[i][0]); 
08A46:  MOVF   xCB,W
08A48:  MULLW  05
08A4A:  MOVF   FF3,W
08A4C:  CLRF   xD7
08A4E:  MOVWF  xD6
08A50:  MOVLW  BC
08A52:  ADDWF  xD6,F
08A54:  MOVLW  B6
08A56:  ADDWFC xD7,F
08A58:  MOVLW  05
08A5A:  MOVWF  xDE
08A5C:  MOVLW  CC
08A5E:  MOVWF  xDD
08A60:  MOVFF  5D7,5E0
08A64:  MOVFF  5D6,5DF
08A68:  MOVLB  0
08A6A:  RCALL  896A
....................       debug_html(debug_html_putc, "\r\nHTML Ext check %u '%s' '%s' vs '%s'(0x%LX) ", i, fname, extension, str, &gc_MimeTypes[i][0]); 
....................       if (stricmp(str, extension) == 0) 
08A6C:  MOVLW  05
08A6E:  MOVLB  6
08A70:  MOVWF  x39
08A72:  MOVLW  CC
08A74:  MOVWF  x38
08A76:  MOVLW  05
08A78:  MOVWF  x3B
08A7A:  MOVLW  D1
08A7C:  MOVWF  x3A
08A7E:  MOVLB  0
08A80:  CALL   7846
08A84:  MOVLB  5
08A86:  CLRF   xD7
08A88:  MOVFF  01,5D6
08A8C:  BTFSC  01.7
08A8E:  DECF   xD7,F
08A90:  MOVF   xD6,F
08A92:  BNZ   8A9E
08A94:  MOVF   xD7,F
08A96:  BNZ   8A9E
....................          return(i); 
08A98:  MOVFF  5CB,01
08A9C:  BRA    8AA6
08A9E:  INCF   xCB,F
08AA0:  BRA    8A40
....................    } 
....................     
....................    return(MIME_TYPE_TXT); 
08AA2:  MOVLW  02
08AA4:  MOVWF  01
08AA6:  MOVLB  0
08AA8:  GOTO   AB90 (RETURN)
.................... } 
....................  
.................... typedef enum 
.................... { 
....................    TCP_PUT_CONST_EC_FINISH = 0, 
....................    TCP_PUT_CONST_EC_CONTINUE, 
....................    TCP_PUT_CONST_EC_ESCAPE 
.................... } TCP_PUT_CONST_EC; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileVarChunk(ptr) 
.................... // 
.................... // send a chunked response from ram 
.................... // 
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated 
.................... //          with the continue position before exit. 
.................... // 
.................... // Returns a status code: 
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed 
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr) 
.................... //because of a compiler error this had to be a double pointer an int16, when 
.................... //it should be a char. 
....................  
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(unsigned int16 **retPtr) 
.................... { 
....................    unsigned int16 txLeft, n; 
....................    char *ptr, ec; 
....................  
....................    ptr=*retPtr; 
*
08E06:  MOVLB  5
08E08:  MOVFF  5D9,FE9
08E0C:  MOVFF  5DA,FEA
08E10:  MOVFF  FEC,5E0
08E14:  MOVF   FED,F
08E16:  MOVFF  FEF,5DF
....................  
....................    n=strlen(ptr); 
08E1A:  MOVFF  5E0,64F
08E1E:  MOVFF  5DF,64E
08E22:  MOVLB  0
08E24:  CALL   7068
08E28:  MOVFF  02,5DE
08E2C:  MOVFF  01,5DD
....................     
....................    if (!n){ 
08E30:  MOVLB  5
08E32:  MOVF   xDD,W
08E34:  IORWF  xDE,W
08E36:  BNZ   8E3E
....................       return(TCP_PUT_CONST_EC_FINISH); 
08E38:  MOVLW  00
08E3A:  MOVWF  01
08E3C:  BRA    8EB6
....................    } 
....................  
....................    txLeft = tcp_http_tx_left(); 
08E3E:  MOVFF  22E,5F1
08E42:  MOVLB  0
08E44:  RCALL  8AAC
08E46:  MOVFF  02,5DC
08E4A:  MOVFF  01,5DB
....................    
....................    if (n > txLeft) 
08E4E:  MOVLB  5
08E50:  MOVF   xDC,W
08E52:  SUBWF  xDE,W
08E54:  BNC   8E64
08E56:  BNZ   8E5E
08E58:  MOVF   xDD,W
08E5A:  SUBWF  xDB,W
08E5C:  BC    8E64
....................       ec = TCP_PUT_CONST_EC_CONTINUE;    
08E5E:  MOVLW  01
08E60:  MOVWF  xE1
08E62:  BRA    8E6E
....................    else 
....................    { 
....................       txLeft = n; 
08E64:  MOVFF  5DE,5DC
08E68:  MOVFF  5DD,5DB
....................       ec = TCP_PUT_CONST_EC_FINISH; 
08E6C:  CLRF   xE1
....................    } 
....................  
....................    //TCPPutFileChunkStart(txLeft); 
....................  
....................    while (txLeft--) 
08E6E:  MOVFF  5DC,03
08E72:  MOVF   xDB,W
08E74:  BTFSC  FD8.2
08E76:  DECF   xDC,F
08E78:  DECF   xDB,F
08E7A:  IORWF  03,W
08E7C:  BZ    8E9C
....................       tcp_http_putc(*(ptr++)); 
08E7E:  MOVFF  5E0,03
08E82:  MOVF   xDF,W
08E84:  INCF   xDF,F
08E86:  BTFSC  FD8.2
08E88:  INCF   xE0,F
08E8A:  MOVWF  FE9
08E8C:  MOVFF  03,FEA
08E90:  MOVFF  FEF,5EC
08E94:  MOVLB  0
08E96:  RCALL  8CBC
08E98:  MOVLB  5
08E9A:  BRA    8E6E
....................  
....................    //TCPPutFileChunkStop(); 
....................  
....................    *retPtr=ptr; 
08E9C:  MOVFF  5DA,03
08EA0:  MOVFF  5D9,FE9
08EA4:  MOVFF  03,FEA
08EA8:  MOVFF  5E0,FEC
08EAC:  MOVF   FED,F
08EAE:  MOVFF  5DF,FEF
....................  
....................    return(ec); 
08EB2:  MOVFF  5E1,01
08EB6:  MOVLB  0
08EB8:  RETURN 0
.................... } 
....................  
....................  
.................... /* 
....................    Allows negative seek offset. 
.................... */ 
.................... void myMPFSSeek(MPFS *handle, signed int16 offset) 
.................... { 
....................     MPFSGetBegin(*handle); 
*
09038:  MOVLB  5
0903A:  MOVFF  5EE,FE9
0903E:  MOVFF  5EF,FEA
09042:  MOVFF  FEF,F9
09046:  MOVFF  FEC,FA
0904A:  MOVFF  FEC,FB
0904E:  MOVFF  FEC,FC
....................     if(offset < 0){ 
09052:  BTFSS  xF1.7
09054:  BRA    908E
....................       while(offset++!=0){ 
09056:  MOVFF  5F1,5F3
0905A:  MOVF   xF0,W
0905C:  INCF   xF0,F
0905E:  BTFSC  FD8.2
09060:  INCF   xF1,F
09062:  MOVWF  xF2
09064:  MOVF   xF2,F
09066:  BNZ   906C
09068:  MOVF   xF3,F
0906A:  BZ    908C
....................           _currentHandle--; 
0906C:  MOVLW  FF
0906E:  MOVLB  0
09070:  ADDWF  xF9,F
09072:  BTFSS  FD8.0
09074:  ADDWF  xFA,F
09076:  BTFSS  FD8.0
09078:  ADDWF  xFB,F
0907A:  BTFSS  FD8.0
0907C:  ADDWF  xFC,F
....................           _currentCount--; 
0907E:  MOVLB  2
09080:  MOVF   x0E,W
09082:  BTFSC  FD8.2
09084:  DECF   x0F,F
09086:  DECF   x0E,F
09088:  MOVLB  5
0908A:  BRA    9056
....................        } 
....................     }else if(offset >0){ 
0908C:  BRA    90D0
0908E:  BTFSC  xF1.7
09090:  BRA    90D0
09092:  MOVF   xF1,F
09094:  BNZ   909C
09096:  MOVF   xF0,W
09098:  SUBLW  00
0909A:  BC    90D0
....................       while(offset--!=0){ 
0909C:  MOVFF  5F1,5F3
090A0:  MOVF   xF0,W
090A2:  BTFSC  FD8.2
090A4:  DECF   xF1,F
090A6:  DECF   xF0,F
090A8:  MOVWF  xF2
090AA:  MOVF   xF2,F
090AC:  BNZ   90B2
090AE:  MOVF   xF3,F
090B0:  BZ    90D0
....................          _currentHandle++; 
090B2:  MOVLW  01
090B4:  MOVLB  0
090B6:  ADDWF  xF9,F
090B8:  BTFSC  FD8.0
090BA:  INCF   xFA,F
090BC:  BTFSC  FD8.2
090BE:  INCF   xFB,F
090C0:  BTFSC  FD8.2
090C2:  INCF   xFC,F
....................          _currentCount++; 
090C4:  MOVLB  2
090C6:  INCF   x0E,F
090C8:  BTFSC  FD8.2
090CA:  INCF   x0F,F
090CC:  MOVLB  5
090CE:  BRA    909C
....................       } 
....................     } 
....................  
....................    *handle = MPFSGetEnd(); 
090D0:  MOVFF  5EE,FE9
090D4:  MOVFF  5EF,FEA
090D8:  MOVFF  F9,FEF
090DC:  MOVFF  FA,FEC
090E0:  MOVFF  FB,FEC
090E4:  MOVFF  FC,FEC
090E8:  MOVLB  0
090EA:  GOTO   9292 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSFileTell(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          beginning of current file 
....................  * 
....................  * Side Effects:    None. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None. 
....................  ********************************************************************/ 
.................... #define MPFSFileTell()  (_currentFile) 
....................  
.................... //Now these are global--not initialized to 0 
.................... //save a couple hundred bytes of ROM this way 
.................... char HTTPbuffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
.................... MPFS http_page_req[HTTP_NUM_SOCKETS]; 
....................  
.................... #if HTTP_USE_AUTHENTICATION 
....................  char http_get_cache[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
....................  char http_auth_user[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
.................... #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileParseConst(fstream, n, doSend) 
.................... // 
.................... // Reads file from mmc.  Stops when it reaches an escape sequence, 
.................... // n chars or an end of file 
.................... // 
.................... // fstream - file sream to read (will be sent as an http/1.1 chunk).  The stream 
.................... //        will be updated for the next call. 
.................... // 
.................... // n - max number of chars to read from file.  will save the total number 
.................... //    of chars passed to this pointer. 
.................... // 
.................... // doSend - if TRUE, then send data to TCP socket 
.................... // 
.................... // returns the last char read 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... #if 0 //original slow 
.................... char TCPPutFileParseConst(MPFS *fstream, unsigned int16 *n, int8 doSend, int1 isPix) 
.................... { 
....................    char stopC, checkC; 
....................    unsigned int16 fileSize = 1, max; 
....................    int1 premature = TRUE; 
....................    max = *n; 
....................    MPFSGetBegin(*fstream); 
....................    while (TRUE) 
....................    { 
....................       if(MPFSIsEOF())//EOF 
....................       { 
....................          premature = FALSE; 
....................          break;    
....................       } 
....................       stopC= MPFSGet(); 
....................       if (stopC == '%'&&!isPix) 
....................       { 
....................          checkC= MPFSGet(); 
....................          if (checkC == '%') 
....................          { 
....................             if (fileSize < max) 
....................             { 
....................                if (doSend) 
....................                   tcp_http_putc('%'); 
....................                fileSize++; 
....................             } 
....................             else 
....................                break; 
....................          } 
....................          else 
....................             break;   //ESCAPE 
....................       } 
....................       else 
....................       { 
....................          if (MPFSIsEOF()) 
....................          { 
....................             premature = FALSE; 
....................             break; 
....................          } 
....................          if (((fileSize) < max)) 
....................          { 
....................             //if (doSend&&!fateof(fstream)) 
....................             if (doSend) 
....................             { 
....................                tcp_http_putc(stopC); 
....................             } 
....................             fileSize++; 
....................          } 
....................          else 
....................             break; 
....................       } 
....................       /* 
....................       if(fateof(fstream))//EOF 
....................       { 
....................          premature = FALSE; 
....................          break;    
....................       } 
....................       */ 
....................    } 
....................     
....................    *fstream = MPFSGetEnd(); 
....................    if (premature==TRUE){ 
....................       myMPFSSeek(fstream, -1);  //addy--; 
....................    } 
....................   
....................    *n = fileSize; 
....................    *fstream = MPFSGetEnd(); 
....................    return(stopC); 
.................... } 
.................... #endif 
.................... //new fast 
.................... char TCPPutFileParseConst(MPFS *fstream, unsigned int16 max, int1 isPix) 
090EE:  MOVLB  5
090F0:  BCF    xEB.0
.................... { 
....................    char c; 
....................    unsigned int8 *p; 
....................    unsigned int16 readCount; 
....................    int1 escape = FALSE; 
....................     
....................    debug_mpfs2(debug_putc, "\r\nTCPPutFileParseConst() c=%X max=%LX f=%LX p=%U ", g_HttpCurrConn, max, *fstream, isPix); 
....................     
....................    /*  
....................       this will cause httpTask() to only process 128 bytes at 
....................       a time and allow other processes to run while reading 
....................       page from EE. 
....................    */ 
....................    if (max > (unsigned int16)HTTP_SEND_BYTES_PER_CHUNK) 
090F2:  MOVF   xE4,F
090F4:  BNZ   90FC
090F6:  MOVF   xE3,W
090F8:  SUBLW  80
090FA:  BC    9102
....................       max = HTTP_SEND_BYTES_PER_CHUNK; 
090FC:  CLRF   xE4
090FE:  MOVLW  80
09100:  MOVWF  xE3
....................     
....................    MPFSGetBegin(*fstream); 
09102:  MOVFF  5E1,FE9
09106:  MOVFF  5E2,FEA
0910A:  MOVFF  FEF,F9
0910E:  MOVFF  FEC,FA
09112:  MOVFF  FEC,FB
09116:  MOVFF  FEC,FC
....................  
....................    while (max && !escape && !MPFSIsEOF()) 
0911A:  MOVF   xE3,W
0911C:  IORWF  xE4,W
0911E:  BTFSC  FD8.2
09120:  BRA    9232
09122:  BTFSC  xEB.0
09124:  BRA    9232
09126:  MOVLB  0
09128:  INCFSZ xF9,W
0912A:  BRA    913E
0912C:  INCFSZ xFA,W
0912E:  BRA    913E
09130:  INCFSZ xFB,W
09132:  BRA    913E
09134:  INCFSZ xFC,W
09136:  BRA    913E
09138:  MOVLB  5
0913A:  BRA    9232
0913C:  MOVLB  0
....................    { 
....................       p = &HTTPbuffer[g_HttpCurrConn][0]; 
0913E:  MOVLB  2
09140:  MOVF   x2F,W
09142:  MULLW  FE
09144:  MOVF   FF3,W
09146:  MOVLB  5
09148:  CLRF   xED
0914A:  MOVWF  xEC
0914C:  MOVLW  37
0914E:  ADDWF  xEC,W
09150:  MOVWF  01
09152:  MOVLW  02
09154:  ADDWFC xED,W
09156:  MOVFF  01,5E7
0915A:  MOVWF  xE8
....................     
....................       readCount = MIN(max, HTTP_GET_PARAM_MAX_SIZE); 
0915C:  MOVF   xE4,F
0915E:  BNZ   9166
09160:  MOVF   xE3,W
09162:  SUBLW  FE
09164:  BC    916C
09166:  CLRF   03
09168:  MOVLW  FE
0916A:  BRA    9172
0916C:  MOVFF  5E4,03
09170:  MOVF   xE3,W
09172:  MOVWF  xE9
09174:  MOVFF  03,5EA
....................     
....................       readCount = MPFSGetBytes(p, readCount); 
09178:  MOVFF  5E8,5ED
0917C:  MOVFF  5E7,5EC
09180:  MOVFF  5EA,5EF
09184:  MOVFF  5E9,5EE
09188:  MOVLB  0
0918A:  BRA    8EBA
0918C:  MOVFF  02,5EA
09190:  MOVFF  01,5E9
....................        
....................       debug_mpfs2(debug_putc, "r=%LX(%LX) ", readCount, _currentHandle); 
....................           
....................       while (readCount && !escape) 
09194:  MOVLB  5
09196:  MOVF   xE9,W
09198:  IORWF  xEA,W
0919A:  BZ    9230
0919C:  BTFSC  xEB.0
0919E:  BRA    9230
....................       { 
....................          readCount--; 
091A0:  MOVF   xE9,W
091A2:  BTFSC  FD8.2
091A4:  DECF   xEA,F
091A6:  DECF   xE9,F
....................          c = *p++; 
091A8:  MOVFF  5E8,03
091AC:  MOVF   xE7,W
091AE:  INCF   xE7,F
091B0:  BTFSC  FD8.2
091B2:  INCF   xE8,F
091B4:  MOVWF  FE9
091B6:  MOVFF  03,FEA
091BA:  MOVFF  FEF,5E6
....................          if ((c == '%') && !isPix) 
091BE:  MOVF   xE6,W
091C0:  SUBLW  25
091C2:  BNZ   9218
091C4:  MOVF   xE5,F
091C6:  BNZ   9218
....................          { 
....................             if (readCount) 
091C8:  MOVF   xE9,W
091CA:  IORWF  xEA,W
091CC:  BZ    91EE
....................             { 
....................                readCount--; 
091CE:  MOVF   xE9,W
091D0:  BTFSC  FD8.2
091D2:  DECF   xEA,F
091D4:  DECF   xE9,F
....................                c = *p++; 
091D6:  MOVFF  5E8,03
091DA:  MOVF   xE7,W
091DC:  INCF   xE7,F
091DE:  BTFSC  FD8.2
091E0:  INCF   xE8,F
091E2:  MOVWF  FE9
091E4:  MOVFF  03,FEA
091E8:  MOVFF  FEF,5E6
....................                debug_mpfs2(debug_putc, "+%%="); 
....................             } 
091EC:  BRA    9210
....................             else 
....................             { 
....................                c = MPFSGet(); 
091EE:  MOVLB  0
091F0:  CALL   80FA
091F4:  MOVFF  01,5E6
....................                _MpfsEofLoc++; 
091F8:  MOVLW  01
091FA:  ADDWF  xFD,F
091FC:  BTFSC  FD8.0
091FE:  INCF   xFE,F
09200:  BTFSC  FD8.2
09202:  INCF   xFF,F
09204:  BTFSS  FD8.2
09206:  BRA    920E
09208:  MOVLB  1
0920A:  INCF   x00,F
0920C:  MOVLB  0
0920E:  MOVLB  5
....................                debug_mpfs2(debug_putc, "-%%="); 
....................             } 
....................             debug_mpfs2(debug_putc, "%X", c); 
....................             if (c != '%') 
09210:  MOVF   xE6,W
09212:  SUBLW  25
09214:  BZ    9218
....................             { 
....................                escape = TRUE; 
09216:  BSF    xEB.0
....................                debug_mpfs2(debug_putc, "e"); 
....................             } 
....................             debug_mpfs2(debug_putc, " "); 
....................          } 
....................          if (!escape) 
09218:  BTFSC  xEB.0
0921A:  BRA    922E
....................          { 
....................             tcp_http_putc(c); 
0921C:  MOVFF  5E6,5EC
09220:  MOVLB  0
09222:  RCALL  8CBC
....................             max--; 
09224:  MOVLB  5
09226:  MOVF   xE3,W
09228:  BTFSC  FD8.2
0922A:  DECF   xE4,F
0922C:  DECF   xE3,F
....................          } 
0922E:  BRA    9196
....................       } 
....................       HTTP_INTERRUPT_TASKS(); 
09230:  BRA    911A
....................    } 
....................        
....................    *fstream = MPFSGetEnd(); 
09232:  MOVFF  5E1,FE9
09236:  MOVFF  5E2,FEA
0923A:  MOVFF  F9,FEF
0923E:  MOVFF  FA,FEC
09242:  MOVFF  FB,FEC
09246:  MOVFF  FC,FEC
....................     
....................    if (escape) 
0924A:  BTFSS  xEB.0
0924C:  BRA    9296
....................    {   
....................       debug_mpfs2(debug_putc, "f1=%LX ", *fstream); 
....................       *fstream = _MpfsEofLoc; 
0924E:  MOVFF  5E1,FE9
09252:  MOVFF  5E2,FEA
09256:  MOVFF  FD,FEF
0925A:  MOVFF  FE,FEC
0925E:  MOVFF  FF,FEC
09262:  MOVFF  100,FEC
....................       debug_mpfs2(debug_putc, "fe=%LX ", *fstream); 
....................       c = '%'; 
09266:  MOVLW  25
09268:  MOVWF  xE6
....................       readCount++; 
0926A:  INCF   xE9,F
0926C:  BTFSC  FD8.2
0926E:  INCF   xEA,F
....................       myMPFSSeek(fstream, -readCount);  //addy--; 
09270:  COMF   xE9,W
09272:  MOVWF  xEC
09274:  COMF   xEA,W
09276:  MOVWF  xED
09278:  INCF   xEC,F
0927A:  BTFSC  FD8.2
0927C:  INCF   xED,F
0927E:  MOVFF  5E2,5EF
09282:  MOVFF  5E1,5EE
09286:  MOVFF  5ED,5F1
0928A:  MOVFF  5EC,5F0
0928E:  MOVLB  0
09290:  BRA    9038
....................       debug_mpfs2(debug_putc, "r=%LX fr=%LX ", readCount, *fstream); 
....................    } 
09292:  BRA    929A
09294:  MOVLB  5
....................    else 
....................    { 
....................       c = 0; 
09296:  CLRF   xE6
09298:  MOVLB  0
....................    } 
....................  
....................    debug_mpfs2(debug_putc, "c=%X e=%U ", c, escape); 
....................   
....................    return(c); 
0929A:  MOVLB  5
0929C:  MOVFF  5E6,01
092A0:  MOVLB  0
092A2:  GOTO   92F8 (RETURN)
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileConstChunk(*addy) 
.................... // 
.................... // send a chunked response from mmc 
.................... // 
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // returns a response: 
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue 
.................... //                            from this position on next call. 
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character 
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(MPFS *retAddy, int1 isPix) 
.................... { 
....................    char stopC; 
....................    unsigned int16 txLeft; 
....................    TCP_PUT_CONST_EC ec; 
....................    MPFSGetBegin(*retAddy); 
092A6:  MOVLB  5
092A8:  MOVFF  5DA,FE9
092AC:  MOVFF  5DB,FEA
092B0:  MOVFF  FEF,F9
092B4:  MOVFF  FEC,FA
092B8:  MOVFF  FEC,FB
092BC:  MOVFF  FEC,FC
....................    txLeft = tcp_http_tx_left(); 
092C0:  MOVFF  22E,5F1
092C4:  MOVLB  0
092C6:  CALL   8AAC
092CA:  MOVFF  02,5DF
092CE:  MOVFF  01,5DE
....................  
....................    if (!txLeft) 
092D2:  MOVLB  5
092D4:  MOVF   xDE,W
092D6:  IORWF  xDF,W
092D8:  BNZ   92E0
....................    { 
....................       debug_mpfs2(debug_putc, "\r\nTCPPutFileConstChunk() txleft=0 "); 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
092DA:  MOVLW  01
092DC:  MOVWF  01
092DE:  BRA    9348
....................    } 
....................     
....................    stopC=TCPPutFileParseConst(retAddy, txLeft, isPix); 
092E0:  MOVFF  5DB,5E2
092E4:  MOVFF  5DA,5E1
092E8:  MOVFF  5DF,5E4
092EC:  MOVFF  5DE,5E3
092F0:  MOVFF  5DC,5E5
092F4:  MOVLB  0
092F6:  BRA    90EE
092F8:  MOVFF  01,5DD
....................     
....................    if (stopC == '%'&&!isPix) 
092FC:  MOVLB  5
092FE:  MOVF   xDD,W
09300:  SUBLW  25
09302:  BNZ   930E
09304:  MOVF   xDC,F
09306:  BNZ   930E
....................    { 
....................       ec = TCP_PUT_CONST_EC_ESCAPE; 
09308:  MOVLW  02
0930A:  MOVWF  xE0
....................    } 
0930C:  BRA    9312
....................    else 
....................    { 
....................       ec = TCP_PUT_CONST_EC_CONTINUE; 
0930E:  MOVLW  01
09310:  MOVWF  xE0
....................    } 
....................     
....................    if(MPFSIsEOF())//EOF 
09312:  MOVLB  0
09314:  INCFSZ xF9,W
09316:  BRA    932A
09318:  INCFSZ xFA,W
0931A:  BRA    932A
0931C:  INCFSZ xFB,W
0931E:  BRA    932A
09320:  INCFSZ xFC,W
09322:  BRA    932A
....................    { 
....................       ec = TCP_PUT_CONST_EC_FINISH; 
09324:  MOVLB  5
09326:  CLRF   xE0
09328:  MOVLB  0
....................    } 
....................     
....................    debug_mpfs2(debug_putc, "\r\nTCPPutFileConstChunk() stop=%X isPix=%U ec=%X eof=%U ", stopC, isPix, ec, MPFSIsEOF()); 
....................     
....................    *retAddy = MPFSGetEnd(); 
0932A:  MOVLB  5
0932C:  MOVFF  5DA,FE9
09330:  MOVFF  5DB,FEA
09334:  MOVFF  F9,FEF
09338:  MOVFF  FA,FEC
0933C:  MOVFF  FB,FEC
09340:  MOVFF  FC,FEC
....................     
....................    return(ec); 
09344:  MOVFF  5E0,01
09348:  MOVLB  0
0934A:  GOTO   9D00 (RETURN)
.................... } 
....................  
....................  
.................... #if HTTP_USE_TRIPLE_ESCAPE 
.................... unsigned int16 
.................... #else 
.................... unsigned int8 
.................... #endif 
.................... TCPPutFileConstGetEscape(MPFS* fstream) 
.................... { 
.................... #if HTTP_USE_TRIPLE_ESCAPE 
....................    char str[4]; 
....................    uint16_t ret; 
....................    MPFSGetBegin(*fstream); 
....................    str[0]=MPFSGet(); 
....................    str[1]=MPFSGet(); 
....................    str[2]=MPFSGet(); 
....................    str[3] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #elif HTTP_USE_DOUBLE_ESCAPE 
....................    char str[3]; 
....................    unsigned int ret; 
....................    MPFSGetBegin(*fstream); 
*
09780:  MOVLB  5
09782:  MOVFF  5D9,FE9
09786:  MOVFF  5DA,FEA
0978A:  MOVFF  FEF,F9
0978E:  MOVFF  FEC,FA
09792:  MOVFF  FEC,FB
09796:  MOVFF  FEC,FC
....................    str[0]=MPFSGet(); 
0979A:  MOVLB  0
0979C:  CALL   80FA
097A0:  MOVFF  01,5DB
....................    str[1]=MPFSGet(); 
097A4:  CALL   80FA
097A8:  MOVFF  01,5DC
....................    //myfatseek(fstream, -2); 
....................  
....................    str[2] = 0; 
097AC:  MOVLB  5
097AE:  CLRF   xDD
....................    ret = strtol(str, 0, 16); 
097B0:  MOVLW  05
097B2:  MOVWF  xE1
097B4:  MOVLW  DB
097B6:  MOVWF  xE0
097B8:  CLRF   xE3
097BA:  CLRF   xE2
097BC:  CLRF   xE5
097BE:  MOVLW  10
097C0:  MOVWF  xE4
097C2:  MOVLB  0
097C4:  BRA    934E
097C6:  MOVFF  01,5DF
097CA:  MOVFF  00,5DE
.................... #else 
....................    char ret; 
....................    //printf(UserPutc, "\r\nTCPPutFileConstGetEscape() st=%LX ", *fstream); 
....................    MPFSGetBegin(*fstream); 
....................    ret=MPFSGet(); 
....................    //MPFSGetEnd(fstream); 
....................    //myfatseek(fstream, -1);//"replace" that char to the stream 
.................... #endif 
....................    *fstream = MPFSGetEnd(); 
097CE:  MOVLB  5
097D0:  MOVFF  5D9,FE9
097D4:  MOVFF  5DA,FEA
097D8:  MOVFF  F9,FEF
097DC:  MOVFF  FA,FEC
097E0:  MOVFF  FB,FEC
097E4:  MOVFF  FC,FEC
....................    //printf(UserPutc, "ret=%X end=%LX ", ret, *fstream); 
....................    return(ret); 
097E8:  MOVFF  5DE,01
097EC:  MOVLB  0
097EE:  GOTO   9D34 (RETURN)
.................... } 
....................  
.................... int1 tcp_http_put_file(unsigned int16 errorCode, MPFS* MMCfile, char* fname) 
.................... { 
....................    static char str[HTTP_NUM_SOCKETS][HTTP_ESCAPED_STR_SIZE]; 
....................    char ec; 
....................   #if HTTP_USE_TRIPLE_ESCAPE 
....................    unsigned int16 escaped; 
....................   #else 
....................    unsigned int8 escaped; 
....................   #endif 
....................  
....................    MPFS position;    
....................  
....................    static enum 
....................    { 
....................       HTTP_PUT_FILE_INIT = 0, 
....................       HTTP_PUT_FILE_CONTINUE, 
....................       HTTP_PUT_FILE_CHUNK_END, 
....................       HTTP_PUT_FILE_DONE 
....................    } status[HTTP_NUM_SOCKETS]; 
....................     
....................    MPFSGetBegin(*MMCfile);  
*
09900:  MOVLB  5
09902:  MOVFF  5CD,FE9
09906:  MOVFF  5CE,FEA
0990A:  MOVFF  FEF,F9
0990E:  MOVFF  FEC,FA
09912:  MOVFF  FEC,FB
09916:  MOVFF  FEC,FC
....................       
....................    position = MPFSTell()-MPFSFileTell(); 
0991A:  MOVLB  2
0991C:  MOVF   x0A,W
0991E:  MOVLB  0
09920:  SUBWF  xF9,W
09922:  MOVLB  5
09924:  MOVWF  xD3
09926:  MOVLB  2
09928:  MOVF   x0B,W
0992A:  MOVLB  0
0992C:  SUBWFB xFA,W
0992E:  MOVLB  5
09930:  MOVWF  xD4
09932:  MOVLB  2
09934:  MOVF   x0C,W
09936:  MOVLB  0
09938:  SUBWFB xFB,W
0993A:  MOVLB  5
0993C:  MOVWF  xD5
0993E:  MOVLB  2
09940:  MOVF   x0D,W
09942:  MOVLB  0
09944:  SUBWFB xFC,W
09946:  MOVLB  5
09948:  MOVWF  xD6
....................  
....................    debug_html(debug_html_putc, "\r\n** PUT FILE W%U/S%U '%s' EC=%LU MRK=%LX POS=%LX LASTVAR=%LX STATUS=%U ", g_HttpCurrConn, g_HttpCurrSocket, fname, errorCode, *MMCfile, position, lastHTTPPutVarPos[g_HttpCurrConn], status[g_HttpCurrConn]); 
....................    if(position == 0) 
0994A:  MOVF   xD3,F
0994C:  BTFSS  FD8.2
0994E:  BRA    9BD6
09950:  MOVF   xD4,F
09952:  BTFSS  FD8.2
09954:  BRA    9BD6
09956:  MOVF   xD5,F
09958:  BTFSS  FD8.2
0995A:  BRA    9BD6
0995C:  MOVF   xD6,F
0995E:  BTFSS  FD8.2
09960:  BRA    9BD6
....................    { 
....................       lastHTTPPutVarPos[g_HttpCurrConn] = 0; 
09962:  CLRF   03
09964:  MOVLB  2
09966:  MOVFF  22F,02
0996A:  BCF    FD8.0
0996C:  RLCF   02,F
0996E:  RLCF   03,F
09970:  MOVF   02,W
09972:  ADDLW  34
09974:  MOVWF  FE9
09976:  MOVLW  02
09978:  ADDWFC 03,W
0997A:  MOVWF  FEA
0997C:  CLRF   FEC
0997E:  MOVF   FED,F
09980:  CLRF   FEF
....................       lastHTTPPutConstPos[g_HttpCurrConn] = *MMCfile; 
09982:  MOVF   x2F,W
09984:  MULLW  04
09986:  MOVF   FF3,W
09988:  CLRF   03
0998A:  ADDLW  30
0998C:  MOVWF  01
0998E:  MOVLW  02
09990:  ADDWFC 03,F
09992:  MOVFF  01,5D7
09996:  MOVLB  5
09998:  MOVFF  03,5D8
0999C:  MOVFF  5CD,FE9
099A0:  MOVFF  5CE,FEA
099A4:  MOVFF  FEF,00
099A8:  MOVFF  FEC,01
099AC:  MOVFF  FEC,02
099B0:  MOVFF  FEC,03
099B4:  MOVFF  5D8,FEA
099B8:  MOVFF  5D7,FE9
099BC:  MOVFF  00,FEF
099C0:  MOVFF  01,FEC
099C4:  MOVFF  02,FEC
099C8:  MOVFF  03,FEC
....................       status[g_HttpCurrConn] = HTTP_PUT_FILE_CONTINUE; 
099CC:  CLRF   03
099CE:  MOVLB  2
099D0:  MOVF   x2F,W
099D2:  ADDLW  5D
099D4:  MOVWF  FE9
099D6:  MOVLW  05
099D8:  ADDWFC 03,W
099DA:  MOVWF  FEA
099DC:  MOVLW  01
099DE:  MOVWF  FEF
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #else 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
099E0:  MOVLW  3A
099E2:  MOVWF  FF6
099E4:  MOVLW  01
099E6:  MOVWF  FF7
099E8:  MOVLW  09
099EA:  MOVLB  5
099EC:  MOVWF  xD7
099EE:  MOVLB  0
099F0:  GOTO   8CCE
099F4:  MOVLW  10
099F6:  MOVWF  FE9
099F8:  MOVFF  5CC,5D8
099FC:  MOVFF  5CB,5D7
09A00:  GOTO   8CF8
09A04:  MOVLW  20
09A06:  MOVLB  5
09A08:  MOVWF  xEC
09A0A:  MOVLB  0
09A0C:  CALL   8CBC
....................     #endif 
....................  
....................       switch(errorCode) 
09A10:  MOVLB  5
09A12:  MOVF   xCB,W
09A14:  MOVWF  00
09A16:  MOVF   xCC,W
09A18:  MOVWF  03
09A1A:  MOVF   03,W
09A1C:  BNZ   9A28
09A1E:  MOVLW  C8
09A20:  SUBWF  00,W
09A22:  MOVLB  0
09A24:  BZ    9A5A
09A26:  MOVLB  5
09A28:  MOVLW  01
09A2A:  SUBWF  03,W
09A2C:  BNZ   9A38
09A2E:  MOVLW  91
09A30:  SUBWF  00,W
09A32:  MOVLB  0
09A34:  BZ    9A74
09A36:  MOVLB  5
09A38:  MOVLW  01
09A3A:  SUBWF  03,W
09A3C:  BNZ   9A48
09A3E:  MOVLW  94
09A40:  SUBWF  00,W
09A42:  MOVLB  0
09A44:  BZ    9A82
09A46:  MOVLB  5
09A48:  MOVLW  01
09A4A:  SUBWF  03,W
09A4C:  BNZ   9A58
09A4E:  MOVLW  F4
09A50:  SUBWF  00,W
09A52:  MOVLB  0
09A54:  BZ    9A90
09A56:  MOVLB  5
09A58:  BRA    9AA0
....................       { 
....................          case 200: 
....................             printf(tcp_http_putc,"OK"); 
09A5A:  MOVLW  4F
09A5C:  MOVLB  5
09A5E:  MOVWF  xEC
09A60:  MOVLB  0
09A62:  CALL   8CBC
09A66:  MOVLW  4B
09A68:  MOVLB  5
09A6A:  MOVWF  xEC
09A6C:  MOVLB  0
09A6E:  CALL   8CBC
....................             break; 
09A72:  BRA    9AA2
....................         #if HTTP_LAST_MODIFIED_CHECK 
....................          case 304: 
....................             printf(tcp_http_putc, "Not Modified"); 
....................             break; 
....................         #endif 
....................          case 401: 
....................             printf(tcp_http_putc,"Authorization Required"); 
09A74:  MOVLW  48
09A76:  MOVWF  FF6
09A78:  MOVLW  01
09A7A:  MOVWF  FF7
09A7C:  CALL   8DC0
....................             break; 
09A80:  BRA    9AA2
....................          case 404: 
....................             printf(tcp_http_putc,"Not Found"); 
09A82:  MOVLW  60
09A84:  MOVWF  FF6
09A86:  MOVLW  01
09A88:  MOVWF  FF7
09A8A:  CALL   8DC0
....................             break; 
09A8E:  BRA    9AA2
....................          case 500: 
....................             printf(tcp_http_putc,"Server Error"); 
09A90:  MOVLW  6A
09A92:  MOVWF  FF6
09A94:  MOVLW  01
09A96:  MOVWF  FF7
09A98:  CALL   8DC0
....................             break; 
09A9C:  BRA    9AA2
09A9E:  MOVLB  5
....................          default: 
....................             break; 
09AA0:  MOVLB  0
....................       } 
....................       printf(tcp_http_putc, "\r\n"); 
09AA2:  MOVLW  0D
09AA4:  MOVLB  5
09AA6:  MOVWF  xEC
09AA8:  MOVLB  0
09AAA:  CALL   8CBC
09AAE:  MOVLW  0A
09AB0:  MOVLB  5
09AB2:  MOVWF  xEC
09AB4:  MOVLB  0
09AB6:  CALL   8CBC
....................        
....................      #if HTTP_USE_AUTHENTICATION 
....................       if (errorCode==401) 
09ABA:  MOVLB  5
09ABC:  MOVF   xCB,W
09ABE:  SUBLW  91
09AC0:  BNZ   9AD6
09AC2:  DECFSZ xCC,W
09AC4:  BRA    9AD6
....................          printf(tcp_http_putc, "WWW-Authenticate: Basic realm=\"Authorization Required\"\r\n"); 
09AC6:  MOVLW  78
09AC8:  MOVWF  FF6
09ACA:  MOVLW  01
09ACC:  MOVWF  FF7
09ACE:  MOVLB  0
09AD0:  CALL   8DC0
09AD4:  MOVLB  5
....................      #endif 
....................  
....................       printf(tcp_http_putc, "Content-Type: "); 
09AD6:  MOVLW  B2
09AD8:  MOVWF  FF6
09ADA:  MOVLW  01
09ADC:  MOVWF  FF7
09ADE:  MOVLB  0
09AE0:  CALL   8DC0
....................       strcpypgm2ram(&str[g_HttpCurrConn][0], &gc_MimeTypesHeader[g_HTTPMimeType[g_HttpCurrConn]][0]); 
09AE4:  MOVLB  2
09AE6:  MOVF   x2F,W
09AE8:  MULLW  28
09AEA:  MOVF   FF3,W
09AEC:  MOVLB  5
09AEE:  CLRF   xD8
09AF0:  MOVWF  xD7
09AF2:  MOVLW  35
09AF4:  ADDWF  xD7,W
09AF6:  MOVWF  01
09AF8:  MOVLW  05
09AFA:  ADDWFC xD8,W
09AFC:  MOVWF  03
09AFE:  MOVFF  01,5D9
09B02:  MOVWF  xDE
09B04:  CLRF   03
09B06:  MOVLB  2
09B08:  MOVF   x2F,W
09B0A:  ADDLW  36
09B0C:  MOVWF  FE9
09B0E:  MOVLW  02
09B10:  ADDWFC 03,W
09B12:  MOVWF  FEA
09B14:  MOVF   FEF,W
09B16:  MULLW  0D
09B18:  MOVF   FF3,W
09B1A:  MOVLB  5
09B1C:  CLRF   xDC
09B1E:  MOVWF  xDB
09B20:  MOVLW  54
09B22:  ADDWF  xDB,F
09B24:  MOVLW  B6
09B26:  ADDWFC xDC,F
09B28:  MOVFF  01,5DD
09B2C:  MOVFF  5DC,5E0
09B30:  MOVFF  5DB,5DF
09B34:  MOVLB  0
09B36:  CALL   896A
....................       printf(tcp_http_putc, "%s\r\n", str[g_HttpCurrConn]); 
09B3A:  MOVLB  2
09B3C:  MOVF   x2F,W
09B3E:  MULLW  28
09B40:  MOVF   FF3,W
09B42:  CLRF   03
09B44:  ADDLW  35
09B46:  MOVWF  01
09B48:  MOVLW  05
09B4A:  ADDWFC 03,F
09B4C:  MOVFF  01,5D7
09B50:  MOVFF  03,5D8
09B54:  MOVFF  03,FEA
09B58:  MOVFF  01,FE9
09B5C:  MOVLB  0
09B5E:  GOTO   8DE0
09B62:  MOVLW  0D
09B64:  MOVLB  5
09B66:  MOVWF  xEC
09B68:  MOVLB  0
09B6A:  CALL   8CBC
09B6E:  MOVLW  0A
09B70:  MOVLB  5
09B72:  MOVWF  xEC
09B74:  MOVLB  0
09B76:  CALL   8CBC
....................        
....................       debug_html(debug_html_putc, " content='%s'(%u) ", str[g_HttpCurrConn], g_HTTPMimeType[g_HttpCurrConn]); 
....................        
....................       if (IsImage(g_HttpCurrConn)) 
09B7A:  CLRF   03
09B7C:  MOVLB  2
09B7E:  MOVF   x2F,W
09B80:  ADDLW  36
09B82:  MOVWF  FE9
09B84:  MOVLW  02
09B86:  ADDWFC 03,W
09B88:  MOVWF  FEA
09B8A:  MOVF   FEF,W
09B8C:  SUBLW  03
09B8E:  BC    9BA2
....................       { 
....................          printf(tcp_http_putc, "Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\r\n"); 
09B90:  MOVLW  C2
09B92:  MOVWF  FF6
09B94:  MOVLW  01
09B96:  MOVWF  FF7
09B98:  MOVLB  0
09B9A:  CALL   8DC0
....................       } 
09B9E:  BRA    9BB0
09BA0:  MOVLB  2
....................       else 
....................       { 
....................          printf(tcp_http_putc, "Cache-Control: no-cache\r\n"); 
09BA2:  MOVLW  F2
09BA4:  MOVWF  FF6
09BA6:  MOVLW  01
09BA8:  MOVWF  FF7
09BAA:  MOVLB  0
09BAC:  CALL   8DC0
....................       } 
....................  
....................      #if !HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc, "Connection: close\r\n"); 
09BB0:  MOVLW  0C
09BB2:  MOVWF  FF6
09BB4:  MOVLW  02
09BB6:  MOVWF  FF7
09BB8:  CALL   8DC0
....................      #endif 
....................  
....................       printf(tcp_http_putc, "\r\n"); 
09BBC:  MOVLW  0D
09BBE:  MOVLB  5
09BC0:  MOVWF  xEC
09BC2:  MOVLB  0
09BC4:  CALL   8CBC
09BC8:  MOVLW  0A
09BCA:  MOVLB  5
09BCC:  MOVWF  xEC
09BCE:  MOVLB  0
09BD0:  CALL   8CBC
09BD4:  MOVLB  5
....................    } 
....................     
....................   #if HTTP_LAST_MODIFIED_CHECK 
....................    if (errorCode == 304) 
....................    { 
....................       TCPFlush(socket); 
....................       return(TRUE); 
....................    } 
....................   #endif 
....................     
....................    if (errorCode==500) 
09BD6:  MOVF   xCB,W
09BD8:  SUBLW  F4
09BDA:  BNZ   9C24
09BDC:  DECFSZ xCC,W
09BDE:  BRA    9C24
....................    { 
....................       sprintf(fname, "%s", HTTP_500_ERROR_FNAME); 
09BE0:  MOVFF  5D0,55F
09BE4:  MOVFF  5CF,55E
09BE8:  MOVLW  20
09BEA:  MOVWF  FF6
09BEC:  MOVLW  02
09BEE:  MOVWF  FF7
09BF0:  MOVLB  0
09BF2:  CALL   798A
....................       if(!FileExists(fname)) 
09BF6:  MOVFF  5D0,5D8
09BFA:  MOVFF  5CF,5D7
09BFE:  CALL   7C5A
09C02:  MOVF   01,W
09C04:  IORWF  02,W
09C06:  BNZ   9C22
....................       { 
....................          printf(tcp_http_putc, "%s", HTML_500_FILE_CONTENTS); 
09C08:  MOVLW  2E
09C0A:  MOVWF  FF6
09C0C:  MOVLW  02
09C0E:  MOVWF  FF7
09C10:  CALL   8DC0
....................          TCPFlush(g_HttpCurrSocket); 
09C14:  MOVFF  22E,5F1
09C18:  CALL   8B5A
....................          return(TRUE);                                                         
09C1C:  MOVLW  01
09C1E:  MOVWF  01
09C20:  BRA    9EA2
09C22:  MOVLB  5
....................       } 
....................    } 
....................  
....................    debug_mpfs2(debug_putc, "\r\nVAR START ST=%X ", status[g_HttpCurrConn]); 
....................  
....................    if (lastHTTPPutVarPos[g_HttpCurrConn]!=0) 
09C24:  CLRF   03
09C26:  MOVLB  2
09C28:  MOVFF  22F,02
09C2C:  BCF    FD8.0
09C2E:  RLCF   02,F
09C30:  RLCF   03,F
09C32:  MOVF   02,W
09C34:  ADDLW  34
09C36:  MOVWF  FE9
09C38:  MOVLW  02
09C3A:  ADDWFC 03,W
09C3C:  MOVWF  FEA
09C3E:  MOVFF  FEC,5D8
09C42:  MOVF   FED,F
09C44:  MOVFF  FEF,5D7
09C48:  MOVLB  5
09C4A:  MOVF   xD7,F
09C4C:  BNZ   9C52
09C4E:  MOVF   xD8,F
09C50:  BZ    9CA2
....................    { 
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[g_HttpCurrConn]); 
09C52:  CLRF   03
09C54:  MOVLB  2
09C56:  MOVFF  22F,02
09C5A:  BCF    FD8.0
09C5C:  RLCF   02,F
09C5E:  RLCF   03,F
09C60:  MOVF   02,W
09C62:  ADDLW  34
09C64:  MOVWF  01
09C66:  MOVLW  02
09C68:  ADDWFC 03,F
09C6A:  MOVFF  01,5D7
09C6E:  MOVFF  03,5D8
09C72:  MOVFF  03,5DA
09C76:  MOVFF  01,5D9
09C7A:  MOVLB  0
09C7C:  CALL   8E06
....................       lastHTTPPutVarPos[g_HttpCurrConn] = 0; 
09C80:  CLRF   03
09C82:  MOVLB  2
09C84:  MOVFF  22F,02
09C88:  BCF    FD8.0
09C8A:  RLCF   02,F
09C8C:  RLCF   03,F
09C8E:  MOVF   02,W
09C90:  ADDLW  34
09C92:  MOVWF  FE9
09C94:  MOVLW  02
09C96:  ADDWFC 03,W
09C98:  MOVWF  FEA
09C9A:  CLRF   FEC
09C9C:  MOVF   FED,F
09C9E:  CLRF   FEF
09CA0:  MOVLB  5
....................    } 
....................  
....................    debug_mpfs2(debug_putc, "\r\nPUT START ST=%X ", status[g_HttpCurrConn]); 
....................  
....................    if (status[g_HttpCurrConn] == HTTP_PUT_FILE_CONTINUE) 
09CA2:  CLRF   03
09CA4:  MOVLB  2
09CA6:  MOVF   x2F,W
09CA8:  ADDLW  5D
09CAA:  MOVWF  FE9
09CAC:  MOVLW  05
09CAE:  ADDWFC 03,W
09CB0:  MOVWF  FEA
09CB2:  DECFSZ FEF,W
09CB4:  BRA    9E2E
....................    { 
....................       for(;;) 
....................       { 
....................          //printf(UserPutc, "\r\nHTTP Put Const st=%LX ", lastHTTPPutConstPos[g_HttpCurrConn]); 
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[g_HttpCurrConn], IsImage(g_HttpCurrConn)); 
09CB6:  MOVF   x2F,W
09CB8:  MULLW  04
09CBA:  MOVF   FF3,W
09CBC:  CLRF   03
09CBE:  ADDLW  30
09CC0:  MOVWF  01
09CC2:  MOVLW  02
09CC4:  ADDWFC 03,F
09CC6:  MOVFF  01,5D7
09CCA:  MOVLB  5
09CCC:  MOVFF  03,5D8
09CD0:  CLRF   03
09CD2:  MOVLB  2
09CD4:  MOVF   x2F,W
09CD6:  ADDLW  36
09CD8:  MOVWF  FE9
09CDA:  MOVLW  02
09CDC:  ADDWFC 03,W
09CDE:  MOVWF  FEA
09CE0:  MOVF   FEF,W
09CE2:  SUBLW  03
09CE4:  BNC   9CEA
09CE6:  MOVLW  00
09CE8:  BRA    9CEC
09CEA:  MOVLW  01
09CEC:  MOVLB  5
09CEE:  MOVWF  xD9
09CF0:  MOVFF  5D8,5DB
09CF4:  MOVFF  5D7,5DA
09CF8:  MOVWF  xDC
09CFA:  MOVLB  0
09CFC:  GOTO   92A6
09D00:  MOVFF  01,5D1
....................          //printf(UserPutc, "end=%LX\r\n", lastHTTPPutConstPos[g_HttpCurrConn]); 
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE)//&is_image 
09D04:  MOVLB  5
09D06:  MOVF   xD1,W
09D08:  SUBLW  02
09D0A:  BTFSS  FD8.2
09D0C:  BRA    9E08
....................          { 
....................             HTTP_INTERRUPT_TASKS(); 
....................             escaped = TCPPutFileConstGetEscape(&lastHTTPPutConstPos[g_HttpCurrConn]);//// 
09D0E:  MOVLB  2
09D10:  MOVF   x2F,W
09D12:  MULLW  04
09D14:  MOVF   FF3,W
09D16:  CLRF   03
09D18:  ADDLW  30
09D1A:  MOVWF  01
09D1C:  MOVLW  02
09D1E:  ADDWFC 03,F
09D20:  MOVFF  01,5D7
09D24:  MOVFF  03,5D8
09D28:  MOVFF  03,5DA
09D2C:  MOVFF  01,5D9
09D30:  MOVLB  0
09D32:  BRA    9780
09D34:  MOVFF  01,5D2
....................             http_format_char(fname, escaped, &str[g_HttpCurrConn][0], (sizeof(str)/HTTP_NUM_SOCKETS)-1); 
09D38:  MOVLB  2
09D3A:  MOVF   x2F,W
09D3C:  MULLW  28
09D3E:  MOVF   FF3,W
09D40:  MOVLB  5
09D42:  CLRF   xD8
09D44:  MOVWF  xD7
09D46:  MOVLW  35
09D48:  ADDWF  xD7,W
09D4A:  MOVWF  01
09D4C:  MOVLW  05
09D4E:  ADDWFC xD8,W
09D50:  MOVWF  03
09D52:  MOVFF  01,5D9
09D56:  MOVWF  xDA
09D58:  MOVFF  5D0,5DC
09D5C:  MOVFF  5CF,5DB
09D60:  MOVFF  5D2,5DD
09D64:  MOVWF  xDF
09D66:  MOVFF  01,5DE
09D6A:  MOVLW  27
09D6C:  MOVWF  xE0
09D6E:  MOVLB  0
09D70:  BRA    9864
....................             lastHTTPPutVarPos[g_HttpCurrConn] = &str[g_HttpCurrConn][0]; 
09D72:  CLRF   03
09D74:  MOVLB  2
09D76:  MOVFF  22F,02
09D7A:  BCF    FD8.0
09D7C:  RLCF   02,F
09D7E:  RLCF   03,F
09D80:  MOVF   02,W
09D82:  ADDLW  34
09D84:  MOVWF  FE9
09D86:  MOVLW  02
09D88:  ADDWFC 03,W
09D8A:  MOVWF  FEA
09D8C:  MOVF   x2F,W
09D8E:  MULLW  28
09D90:  MOVF   FF3,W
09D92:  MOVLB  5
09D94:  CLRF   xDA
09D96:  MOVWF  xD9
09D98:  MOVLW  35
09D9A:  ADDWF  xD9,W
09D9C:  MOVWF  FEF
09D9E:  MOVLW  05
09DA0:  ADDWFC xDA,W
09DA2:  MOVWF  FEC
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[g_HttpCurrConn]); 
09DA4:  CLRF   03
09DA6:  MOVLB  2
09DA8:  MOVFF  22F,02
09DAC:  BCF    FD8.0
09DAE:  RLCF   02,F
09DB0:  RLCF   03,F
09DB2:  MOVF   02,W
09DB4:  ADDLW  34
09DB6:  MOVWF  01
09DB8:  MOVLW  02
09DBA:  ADDWFC 03,F
09DBC:  MOVFF  01,5D7
09DC0:  MOVFF  03,5D8
09DC4:  MOVFF  03,5DA
09DC8:  MOVFF  01,5D9
09DCC:  MOVLB  0
09DCE:  CALL   8E06
09DD2:  MOVFF  01,5D1
....................             //printf(UserPutc, "\r\n** HTTP PUT VAR ec=%U escape=0x%LX str='%s' start=0x%LX end=0x%LX status=%U", 
....................             debug_html(debug_html_putc, "\r\n** HTTP PUT VAR ec=%U escape=0x%LX str='%s' start=0x%LX end=0x%LX status=%U", 
....................                   ec, 
....................                   escaped, 
....................                   str[g_HttpCurrConn], 
....................                   &str[g_HttpCurrConn][0], 
....................                   lastHTTPPutVarPos[g_HttpCurrConn], 
....................                   status[g_HttpCurrConn] 
....................                ); 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
09DD6:  MOVLB  5
09DD8:  MOVF   xD1,F
09DDA:  BNZ   9E00
....................                lastHTTPPutVarPos[g_HttpCurrConn] = 0; 
09DDC:  CLRF   03
09DDE:  MOVLB  2
09DE0:  MOVFF  22F,02
09DE4:  BCF    FD8.0
09DE6:  RLCF   02,F
09DE8:  RLCF   03,F
09DEA:  MOVF   02,W
09DEC:  ADDLW  34
09DEE:  MOVWF  FE9
09DF0:  MOVLW  02
09DF2:  ADDWFC 03,W
09DF4:  MOVWF  FEA
09DF6:  CLRF   FEC
09DF8:  MOVF   FED,F
09DFA:  CLRF   FEF
09DFC:  BRA    9E04
09DFE:  MOVLB  5
....................             else 
....................                break; 
09E00:  BRA    9E30
09E02:  MOVLB  2
....................          } 
09E04:  BRA    9E26
09E06:  MOVLB  5
....................          else 
....................          { 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
09E08:  MOVF   xD1,F
09E0A:  BNZ   9E22
....................                status[g_HttpCurrConn] = HTTP_PUT_FILE_CHUNK_END; 
09E0C:  CLRF   03
09E0E:  MOVLB  2
09E10:  MOVF   x2F,W
09E12:  ADDLW  5D
09E14:  MOVWF  FE9
09E16:  MOVLW  05
09E18:  ADDWFC 03,W
09E1A:  MOVWF  FEA
09E1C:  MOVLW  02
09E1E:  MOVWF  FEF
09E20:  MOVLB  5
....................             break; 
09E22:  BRA    9E30
09E24:  MOVLB  2
....................          } 
....................          //debug_printf(debug_putc, "\r\nHTTP INTR "); 
....................          HTTP_INTERRUPT_TASKS(); 
....................          //debug_printf(debug_putc "DONE "); 
....................          break; 
09E26:  MOVLB  5
09E28:  BRA    9E30
09E2A:  MOVLB  2
09E2C:  BRA    9CB6
09E2E:  MOVLB  5
....................       } 
....................    } 
....................     
....................    debug_mpfs2(debug_putc, "\r\nPUT END ST=%X ", status[g_HttpCurrConn]); 
....................  
....................    if (status[g_HttpCurrConn] == HTTP_PUT_FILE_CHUNK_END) 
09E30:  CLRF   03
09E32:  MOVLB  2
09E34:  MOVF   x2F,W
09E36:  ADDLW  5D
09E38:  MOVWF  FE9
09E3A:  MOVLW  05
09E3C:  ADDWFC 03,W
09E3E:  MOVWF  FEA
09E40:  MOVF   FEF,W
09E42:  SUBLW  02
09E44:  BNZ   9E58
....................    { 
....................      #if HTTP_USE_CHUNKS 
....................       if (tcp_http_tx_left() > 8) 
....................       { 
....................          TCPPutFileChunkStart(0); 
....................          TCPPutFileChunkStop(); 
....................          status[which] = HTTP_PUT_FILE_DONE; 
....................       } 
....................      #else 
....................       status[g_HttpCurrConn] = HTTP_PUT_FILE_DONE; 
09E46:  CLRF   03
09E48:  MOVF   x2F,W
09E4A:  ADDLW  5D
09E4C:  MOVWF  FE9
09E4E:  MOVLW  05
09E50:  ADDWFC 03,W
09E52:  MOVWF  FEA
09E54:  MOVLW  03
09E56:  MOVWF  FEF
....................      #endif 
....................    } 
....................  
....................    *MMCfile = MPFSGetEnd(); 
09E58:  MOVLB  5
09E5A:  MOVFF  5CD,FE9
09E5E:  MOVFF  5CE,FEA
09E62:  MOVFF  F9,FEF
09E66:  MOVFF  FA,FEC
09E6A:  MOVFF  FB,FEC
09E6E:  MOVFF  FC,FEC
....................    //printf("\r\nFLUSH W%u/S%u/T%u", which,socket,_httpPutcSocket); 
....................    //printf(" RETURN=%U\r\n", ec); 
....................    debug_html(debug_html_putc, "\r\nHTML Flush status=%U ", status[g_HttpCurrConn]); 
....................     
....................    if (status[g_HttpCurrConn] == HTTP_PUT_FILE_DONE) 
09E72:  CLRF   03
09E74:  MOVLB  2
09E76:  MOVF   x2F,W
09E78:  ADDLW  5D
09E7A:  MOVWF  FE9
09E7C:  MOVLW  05
09E7E:  ADDWFC 03,W
09E80:  MOVWF  FEA
09E82:  MOVF   FEF,W
09E84:  SUBLW  03
09E86:  BNZ   9E9C
....................    { 
....................       TCPFlush(g_HttpCurrSocket); 
09E88:  MOVFF  22E,5F1
09E8C:  MOVLB  0
09E8E:  CALL   8B5A
....................       return(TRUE); 
09E92:  MOVLW  01
09E94:  MOVWF  01
09E96:  BRA    9EA2
....................    } 
09E98:  BRA    9EA2
09E9A:  MOVLB  2
....................    else 
....................    { 
....................       return(FALSE); 
09E9C:  MOVLW  00
09E9E:  MOVWF  01
09EA0:  MOVLB  0
....................    } 
09EA2:  GOTO   AD3C (RETURN)
.................... } 
....................  
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack 
.................... void HTTPInit(void) { 
....................    int8 i; 
....................    //fprintf(USER,"\r\nHTTP OPENING"); 
....................    if (HTTP_PORT != 0) 
....................    { 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
*
0147A:  MOVLB  5
0147C:  CLRF   xB5
0147E:  CLRF   03
01480:  MOVF   xB5,W
01482:  MOVWF  00
01484:  BTFSC  FE8.7
01486:  DECF   03,F
01488:  MOVWF  01
0148A:  BTFSC  03.7
0148C:  BRA    1498
0148E:  MOVF   03,F
01490:  BNZ   150C
01492:  MOVF   01,W
01494:  SUBLW  00
01496:  BNC   150C
....................       { 
....................          http_state[i]=HTTP_DISABLED; 
01498:  CLRF   03
0149A:  MOVF   xB5,W
0149C:  ADDLW  11
0149E:  MOVWF  FE9
014A0:  MOVLW  02
014A2:  ADDWFC 03,W
014A4:  MOVWF  FEA
014A6:  SETF   FEF
....................           
....................          http_socket[i]=TCPOpen(0, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
014A8:  CLRF   03
014AA:  MOVF   xB5,W
014AC:  ADDLW  10
014AE:  MOVWF  01
014B0:  MOVLW  02
014B2:  ADDWFC 03,F
014B4:  MOVFF  01,5B6
014B8:  MOVFF  03,5B7
014BC:  CLRF   xBB
014BE:  CLRF   xBA
014C0:  CLRF   xB9
014C2:  CLRF   xB8
014C4:  CLRF   xBC
014C6:  CLRF   xBE
014C8:  MOVLW  50
014CA:  MOVWF  xBD
014CC:  MOVLW  08
014CE:  MOVWF  xBF
014D0:  MOVLB  0
014D2:  BRA    1402
014D4:  MOVFF  5B7,FEA
014D8:  MOVFF  5B6,FE9
014DC:  MOVFF  01,FEF
....................          //fprintf(USER,"\r\nHTTP SOCKET=%X", http_socket[i]); 
....................          if (http_socket[i]!=INVALID_SOCKET) 
014E0:  CLRF   03
014E2:  MOVLB  5
014E4:  MOVF   xB5,W
014E6:  ADDLW  10
014E8:  MOVWF  FE9
014EA:  MOVLW  02
014EC:  ADDWFC 03,W
014EE:  MOVWF  FEA
014F0:  MOVF   FEF,W
014F2:  SUBLW  FE
014F4:  BZ    1508
....................          { 
....................             http_state[i]=HTTP_LISTEN_WAIT; 
014F6:  CLRF   03
014F8:  MOVF   xB5,W
014FA:  ADDLW  11
014FC:  MOVWF  FE9
014FE:  MOVLW  02
01500:  ADDWFC 03,W
01502:  MOVWF  FEA
01504:  MOVLW  01
01506:  MOVWF  FEF
....................          } 
01508:  INCF   xB5,F
0150A:  BRA    147E
....................       } 
....................    } 
....................    else 
....................    { 
....................       //fprintf(USER,"\r\nHTTP DISABLED"); 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
....................       { 
....................             http_state[i]=HTTP_DISABLED; 
....................       } 
....................    } 
0150C:  MOVLB  0
0150E:  GOTO   156C (RETURN)
.................... } 
....................  
.................... #DEFINE HTTP_INDEX_PAGE_EC 0x01 
.................... #DEFINE HTTP_FILE_PAGE_EC    0x02 
.................... #DEFINE HTTP_404_PAGE_EC    0x00 
.................... #DEFINE HTTP_401_PAGE_EC    0xFE 
.................... #DEFINE HTTP_500_PAGE_EC    0xFF 
....................  
.................... void HTTPServer(void) { 
*
09F0A:  MOVLB  5
09F0C:  CLRF   xB5
09F0E:  CLRF   xB6
....................    static char tokens_header[]=" "; 
....................    static char tokens_get[]="?"; 
....................    static char http_get_str[]="GET"; 
....................    static char http_post_str[]="POST"; 
....................    static char http_len_str[]="Content-Length:"; 
....................    unsigned int8 j =0, l=0; 
....................     
....................    char index[]="/"; 
09F10:  MOVLW  2F
09F12:  MOVWF  xB7
09F14:  CLRF   xB8
....................    static char page[HTTP_NUM_SOCKETS][20]; 
....................    MPFS fstream; 
....................    
....................   #if defined(__DO_DEBUG_HTML) 
....................    static unsigned int8 debug; 
....................   #endif 
....................  
....................    //static char http_keepalive_str[]="keep-alive"; 
....................    //static char http_connection_str[]="Connection"; 
....................  
....................  
....................  
....................    static unsigned int8 i[HTTP_NUM_SOCKETS]; 
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]; 
....................     
....................    static unsigned int16 http_error_code[HTTP_NUM_SOCKETS]; 
....................    static unsigned int16 http_post_len[HTTP_NUM_SOCKETS]; 
....................    static TICK http_timer[HTTP_NUM_SOCKETS]; 
....................   
....................  #if HTTP_USE_AUTHENTICATION 
....................    static char http_auth_str[]="Authorization:"; 
....................  #endif 
....................  
....................    int1 doneSend, postContinue; 
....................  
....................    char c, *pKey, *pValue; 
....................    //unsigned int8 hs, currSocket; 
....................  
....................    for (g_HttpCurrConn=0; g_HttpCurrConn<HTTP_NUM_SOCKETS; g_HttpCurrConn++) 
09F16:  MOVLB  2
09F18:  CLRF   x2F
09F1A:  MOVF   x2F,F
09F1C:  BTFSS  FD8.2
09F1E:  GOTO   AF1E
....................    {      
....................       if (http_state[g_HttpCurrConn]==HTTP_DISABLED) 
09F22:  CLRF   03
09F24:  MOVF   x2F,W
09F26:  ADDLW  11
09F28:  MOVWF  FE9
09F2A:  MOVLW  02
09F2C:  ADDWFC 03,W
09F2E:  MOVWF  FEA
09F30:  INCFSZ FEF,W
09F32:  BRA    9F38
....................          return; 
09F34:  GOTO   AF1E
....................  
....................       g_HttpCurrSocket = http_socket[g_HttpCurrConn]; 
09F38:  CLRF   03
09F3A:  MOVF   x2F,W
09F3C:  ADDLW  10
09F3E:  MOVWF  FE9
09F40:  MOVLW  02
09F42:  ADDWFC 03,W
09F44:  MOVWF  FEA
09F46:  MOVFF  FEF,22E
....................  
....................       if (!TCPIsConnected(g_HttpCurrSocket)) 
09F4A:  MOVFF  22E,5C3
09F4E:  MOVLB  0
09F50:  CALL   6E00
09F54:  MOVF   01,F
09F56:  BNZ   9F6E
....................          http_state[g_HttpCurrConn]=HTTP_LISTEN_WAIT; 
09F58:  CLRF   03
09F5A:  MOVLB  2
09F5C:  MOVF   x2F,W
09F5E:  ADDLW  11
09F60:  MOVWF  FE9
09F62:  MOVLW  02
09F64:  ADDWFC 03,W
09F66:  MOVWF  FEA
09F68:  MOVLW  01
09F6A:  MOVWF  FEF
09F6C:  MOVLB  0
....................  
....................       switch(http_state[g_HttpCurrConn]) 
09F6E:  CLRF   03
09F70:  MOVLB  2
09F72:  MOVF   x2F,W
09F74:  ADDLW  11
09F76:  MOVWF  FE9
09F78:  MOVLW  02
09F7A:  ADDWFC 03,W
09F7C:  MOVWF  FEA
09F7E:  MOVF   FEF,W
09F80:  XORLW  01
09F82:  MOVLB  0
09F84:  BZ    9FD2
09F86:  XORLW  03
09F88:  BZ    9FE2
09F8A:  XORLW  01
09F8C:  BTFSC  FD8.2
09F8E:  BRA    A0B0
09F90:  XORLW  07
09F92:  BTFSC  FD8.2
09F94:  BRA    A6F4
09F96:  XORLW  01
09F98:  BTFSC  FD8.2
09F9A:  GOTO   A840
09F9E:  XORLW  03
09FA0:  BTFSC  FD8.2
09FA2:  GOTO   A89E
09FA6:  XORLW  01
09FA8:  BTFSC  FD8.2
09FAA:  GOTO   AB44
09FAE:  XORLW  0F
09FB0:  BTFSC  FD8.2
09FB2:  GOTO   AC8E
09FB6:  XORLW  01
09FB8:  BTFSC  FD8.2
09FBA:  GOTO   ADF6
09FBE:  XORLW  03
09FC0:  BTFSC  FD8.2
09FC2:  GOTO   AE40
09FC6:  XORLW  01
09FC8:  BTFSC  FD8.2
09FCA:  GOTO   AF16
09FCE:  GOTO   AF16
....................       { 
....................          case HTTP_LISTEN_WAIT: 
....................             if (!TCPIsConnected(g_HttpCurrSocket)) 
09FD2:  MOVFF  22E,5C3
09FD6:  CALL   6E00
09FDA:  MOVF   01,F
09FDC:  BNZ   9FE2
....................                break; 
09FDE:  GOTO   AF16
.................... //            fprintf(USER,"HTTP %U CONNECTED\r\n", hs); 
....................  
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header 
....................          case HTTP_CONNECTED: 
.................... //            fprintf(USER,"HTTP %U LISTENING\r\n", hs); 
....................             /* 
....................             printf("\r\nHTTP OPEN %U/%U ", hs, currSocket); 
....................                ui_disp_ip_user(&TCB[currSocket].remote.IPAddr) 
....................                printf(" MAC="); 
....................                ui_disp_mac_user(&TCB[currSocket].remote.MACAddr);; 
....................                printf("\r\n"); 
....................                */ 
....................                 
....................             HTTPbuffer[g_HttpCurrConn][0]=0; 
09FE2:  MOVLB  2
09FE4:  MOVF   x2F,W
09FE6:  MULLW  FE
09FE8:  MOVF   FF3,W
09FEA:  MOVLB  5
09FEC:  CLRF   xC4
09FEE:  MOVWF  xC3
09FF0:  MOVLW  37
09FF2:  ADDWF  xC3,W
09FF4:  MOVWF  FE9
09FF6:  MOVLW  02
09FF8:  ADDWFC xC4,W
09FFA:  MOVWF  FEA
09FFC:  CLRF   FEF
....................             i[g_HttpCurrConn]=0; 
09FFE:  CLRF   03
0A000:  MOVLB  2
0A002:  MOVF   x2F,W
0A004:  ADDLW  91
0A006:  MOVWF  FE9
0A008:  MOVLW  05
0A00A:  ADDWFC 03,W
0A00C:  MOVWF  FEA
0A00E:  CLRF   FEF
....................             http_state[g_HttpCurrConn]=HTTP_GET_HEADERS; 
0A010:  CLRF   03
0A012:  MOVF   x2F,W
0A014:  ADDLW  11
0A016:  MOVWF  FE9
0A018:  MOVLW  02
0A01A:  ADDWFC 03,W
0A01C:  MOVWF  FEA
0A01E:  MOVLW  03
0A020:  MOVWF  FEF
....................             http_timer[g_HttpCurrConn]=TickGet(); 
0A022:  MOVF   x2F,W
0A024:  MULLW  04
0A026:  MOVF   FF3,W
0A028:  CLRF   03
0A02A:  ADDLW  97
0A02C:  MOVWF  01
0A02E:  MOVLW  05
0A030:  ADDWFC 03,F
0A032:  MOVFF  01,5C3
0A036:  MOVFF  03,5C4
0A03A:  MOVLB  0
0A03C:  CALL   23FC
0A040:  MOVFF  5C4,FEA
0A044:  MOVFF  5C3,FE9
0A048:  MOVFF  00,FEF
0A04C:  MOVFF  01,FEC
0A050:  MOVFF  02,FEC
0A054:  MOVFF  03,FEC
....................             http_page_req[g_HttpCurrConn]=0; 
0A058:  MOVLB  2
0A05A:  MOVF   x2F,W
0A05C:  MULLW  04
0A05E:  MOVF   FF3,W
0A060:  CLRF   03
0A062:  ADDLW  35
0A064:  MOVWF  FE9
0A066:  MOVLW  03
0A068:  ADDWFC 03,W
0A06A:  MOVWF  FEA
0A06C:  MOVF   FEE,F
0A06E:  MOVF   FEE,F
0A070:  CLRF   FEC
0A072:  MOVF   FED,F
0A074:  CLRF   FEF
0A076:  MOVF   FED,F
0A078:  CLRF   FEF
0A07A:  MOVF   FED,F
0A07C:  CLRF   FEF
....................             http_post_len[g_HttpCurrConn]=0; 
0A07E:  BCF    FD8.0
0A080:  RLCF   x2F,W
0A082:  CLRF   03
0A084:  ADDLW  95
0A086:  MOVWF  FE9
0A088:  MOVLW  05
0A08A:  ADDWFC 03,W
0A08C:  MOVWF  FEA
0A08E:  CLRF   FEC
0A090:  MOVF   FED,F
0A092:  CLRF   FEF
....................            #if HTTP_USE_AUTHENTICATION 
....................             http_auth_user[g_HttpCurrConn][0]=0; 
0A094:  MOVF   x2F,W
0A096:  MULLW  FE
0A098:  MOVF   FF3,W
0A09A:  MOVLB  5
0A09C:  CLRF   xC4
0A09E:  MOVWF  xC3
0A0A0:  MOVLW  37
0A0A2:  ADDWF  xC3,W
0A0A4:  MOVWF  FE9
0A0A6:  MOVLW  04
0A0A8:  ADDWFC xC4,W
0A0AA:  MOVWF  FEA
0A0AC:  CLRF   FEF
0A0AE:  MOVLB  0
....................            #endif 
....................            #if HTTP_LAST_MODIFIED_CHECK 
....................             g_lastModifiedCheck[g_HttpCurrConn] = FALSE; 
....................            #endif 
....................            debug_html(debug_html_putc, "\r\nHTML Connected %u ", g_HttpCurrConn); 
....................             //http_got_headers[hs]=FALSE; 
....................             //http_isKeepAlive[hs]=FALSE; 
....................  
....................          case HTTP_GET_HEADERS: 
....................             if(mpfsFlags.bits.bNotAvailable) 
0A0B0:  MOVLB  2
0A0B2:  BTFSS  x09.0
0A0B4:  BRA    A0BE
....................                break; 
0A0B6:  MOVLB  0
0A0B8:  GOTO   AF16
0A0BC:  MOVLB  2
....................             postContinue=FALSE; 
0A0BE:  MOVLB  5
0A0C0:  BCF    xBD.1
....................             while (TCPIsGetReady(g_HttpCurrSocket) && TCPGet(g_HttpCurrSocket, &c)) 
0A0C2:  MOVFF  22E,5C8
0A0C6:  MOVLB  0
0A0C8:  CALL   6E2E
0A0CC:  MOVF   01,W
0A0CE:  IORWF  02,W
0A0D0:  BTFSC  FD8.2
0A0D2:  BRA    A61C
0A0D4:  MOVFF  22E,5C3
0A0D8:  MOVLW  05
0A0DA:  MOVLB  5
0A0DC:  MOVWF  xC5
0A0DE:  MOVLW  BE
0A0E0:  MOVWF  xC4
0A0E2:  MOVLB  0
0A0E4:  CALL   6EAE
0A0E8:  MOVF   01,F
0A0EA:  BTFSC  FD8.2
0A0EC:  BRA    A61C
....................             { 
....................                //http_got_headers[hs]=TRUE; 
....................                if ( (c >= 0x20) && (i[g_HttpCurrConn] < HTTP_GET_PARAM_MAX_SIZE - 2) ) 
0A0EE:  CLRF   03
0A0F0:  MOVLB  5
0A0F2:  MOVF   xBE,W
0A0F4:  MOVWF  00
0A0F6:  BTFSC  FE8.7
0A0F8:  DECF   03,F
0A0FA:  MOVWF  01
0A0FC:  BTFSC  03.7
0A0FE:  BRA    A162
0A100:  MOVF   03,F
0A102:  BNZ   A10A
0A104:  MOVF   01,W
0A106:  SUBLW  1F
0A108:  BC    A162
0A10A:  CLRF   03
0A10C:  MOVLB  2
0A10E:  MOVF   x2F,W
0A110:  ADDLW  91
0A112:  MOVWF  FE9
0A114:  MOVLW  05
0A116:  ADDWFC 03,W
0A118:  MOVWF  FEA
0A11A:  MOVF   FEF,W
0A11C:  SUBLW  FB
0A11E:  BTFSC  FD8.0
0A120:  BRA    A126
0A122:  MOVLB  5
0A124:  BRA    A162
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]++]=c; 
0A126:  MOVF   x2F,W
0A128:  MULLW  FE
0A12A:  MOVF   FF3,W
0A12C:  MOVLB  5
0A12E:  CLRF   xC4
0A130:  MOVWF  xC3
0A132:  CLRF   03
0A134:  MOVLB  2
0A136:  MOVF   x2F,W
0A138:  ADDLW  91
0A13A:  MOVWF  FE9
0A13C:  MOVLW  05
0A13E:  ADDWFC 03,W
0A140:  MOVWF  FEA
0A142:  MOVF   FEF,W
0A144:  INCF   FEF,F
0A146:  CLRF   03
0A148:  MOVLB  5
0A14A:  ADDWF  xC3,W
0A14C:  MOVWF  01
0A14E:  MOVF   xC4,W
0A150:  ADDWFC 03,F
0A152:  MOVF   01,W
0A154:  ADDLW  37
0A156:  MOVWF  FE9
0A158:  MOVLW  02
0A15A:  ADDWFC 03,W
0A15C:  MOVWF  FEA
0A15E:  MOVFF  5BE,FEF
....................                } 
....................                if (c=='\n') 
0A162:  MOVF   xBE,W
0A164:  SUBLW  0A
0A166:  BTFSS  FD8.2
0A168:  BRA    A618
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]]=0; 
0A16A:  MOVLB  2
0A16C:  MOVF   x2F,W
0A16E:  MULLW  FE
0A170:  MOVF   FF3,W
0A172:  MOVLB  5
0A174:  CLRF   xC4
0A176:  MOVWF  xC3
0A178:  CLRF   03
0A17A:  MOVLB  2
0A17C:  MOVF   x2F,W
0A17E:  ADDLW  91
0A180:  MOVWF  FE9
0A182:  MOVLW  05
0A184:  ADDWFC 03,W
0A186:  MOVWF  FEA
0A188:  CLRF   03
0A18A:  MOVF   FEF,W
0A18C:  MOVLB  5
0A18E:  ADDWF  xC3,W
0A190:  MOVWF  01
0A192:  MOVF   xC4,W
0A194:  ADDWFC 03,F
0A196:  MOVF   01,W
0A198:  ADDLW  37
0A19A:  MOVWF  FE9
0A19C:  MOVLW  02
0A19E:  ADDWFC 03,W
0A1A0:  MOVWF  FEA
0A1A2:  CLRF   FEF
....................                   if ( 
....................                        ( ( pKey = strtok(&HTTPbuffer[g_HttpCurrConn][0], tokens_header) ) !=0 ) && 
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 ) 
0A1A4:  MOVLB  2
0A1A6:  MOVF   x2F,W
0A1A8:  MULLW  FE
0A1AA:  MOVF   FF3,W
0A1AC:  MOVLB  5
0A1AE:  CLRF   xC4
0A1B0:  MOVWF  xC3
0A1B2:  MOVLW  37
0A1B4:  ADDWF  xC3,W
0A1B6:  MOVWF  01
0A1B8:  MOVLW  02
0A1BA:  ADDWFC xC4,W
0A1BC:  MOVWF  03
0A1BE:  MOVFF  01,5C5
0A1C2:  MOVWF  xC6
0A1C4:  MOVFF  FE8,633
0A1C8:  MOVFF  01,632
0A1CC:  MOVLW  05
0A1CE:  MOVLB  6
0A1D0:  MOVWF  x35
0A1D2:  MOVLW  60
0A1D4:  MOVWF  x34
0A1D6:  MOVLB  0
0A1D8:  CALL   70A4
0A1DC:  MOVFF  02,5C0
0A1E0:  MOVFF  01,5BF
0A1E4:  MOVLB  5
0A1E6:  MOVF   xBF,F
0A1E8:  BNZ   A1F0
0A1EA:  MOVF   xC0,F
0A1EC:  BTFSC  FD8.2
0A1EE:  BRA    A5A0
0A1F0:  MOVLB  6
0A1F2:  CLRF   x33
0A1F4:  CLRF   x32
0A1F6:  MOVLW  05
0A1F8:  MOVWF  x35
0A1FA:  MOVLW  60
0A1FC:  MOVWF  x34
0A1FE:  MOVLB  0
0A200:  CALL   70A4
0A204:  MOVFF  02,5C2
0A208:  MOVFF  01,5C1
0A20C:  MOVLB  5
0A20E:  MOVF   xC1,F
0A210:  BNZ   A218
0A212:  MOVF   xC2,F
0A214:  BTFSC  FD8.2
0A216:  BRA    A5A0
....................                      ) 
....................                   { 
....................                      debug_html(debug_html_putc, "\r\nHTML Key/Pair '%s'/'%s' ", pKey, pValue); 
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) ) 
0A218:  MOVFF  5C0,633
0A21C:  MOVFF  5BF,632
0A220:  MOVLW  05
0A222:  MOVLB  6
0A224:  MOVWF  x35
0A226:  MOVLW  64
0A228:  MOVWF  x34
0A22A:  MOVLB  0
0A22C:  CALL   715C
0A230:  MOVLB  5
0A232:  CLRF   xC4
0A234:  MOVFF  01,5C3
0A238:  BTFSC  01.7
0A23A:  DECF   xC4,F
0A23C:  MOVF   xC3,F
0A23E:  BNZ   A244
0A240:  MOVF   xC4,F
0A242:  BZ    A274
0A244:  MOVFF  5C0,633
0A248:  MOVFF  5BF,632
0A24C:  MOVLW  05
0A24E:  MOVLB  6
0A250:  MOVWF  x35
0A252:  MOVLW  68
0A254:  MOVWF  x34
0A256:  MOVLB  0
0A258:  CALL   715C
0A25C:  MOVLB  5
0A25E:  CLRF   xC4
0A260:  MOVFF  01,5C3
0A264:  BTFSC  01.7
0A266:  DECF   xC4,F
0A268:  MOVF   xC3,F
0A26A:  BTFSS  FD8.2
0A26C:  BRA    A4CA
0A26E:  MOVF   xC4,F
0A270:  BTFSS  FD8.2
0A272:  BRA    A4CA
....................                      { 
....................                         if (strcmp(pKey, http_get_str)==0){ 
0A274:  MOVFF  5C0,633
0A278:  MOVFF  5BF,632
0A27C:  MOVLW  05
0A27E:  MOVLB  6
0A280:  MOVWF  x35
0A282:  MOVLW  64
0A284:  MOVWF  x34
0A286:  MOVLB  0
0A288:  CALL   715C
0A28C:  MOVLB  5
0A28E:  CLRF   xC4
0A290:  MOVFF  01,5C3
0A294:  BTFSC  01.7
0A296:  DECF   xC4,F
0A298:  MOVF   xC3,F
0A29A:  BNZ   A2B8
0A29C:  MOVF   xC4,F
0A29E:  BNZ   A2B8
....................                            http_cmd[g_HttpCurrConn]=HTTP_REQ_GET; 
0A2A0:  CLRF   03
0A2A2:  MOVLB  2
0A2A4:  MOVF   x2F,W
0A2A6:  ADDLW  92
0A2A8:  MOVWF  FE9
0A2AA:  MOVLW  05
0A2AC:  ADDWFC 03,W
0A2AE:  MOVWF  FEA
0A2B0:  MOVLW  01
0A2B2:  MOVWF  FEF
....................                         } 
0A2B4:  BRA    A2CC
0A2B6:  MOVLB  5
....................                         else{ 
....................                            http_cmd[g_HttpCurrConn]=HTTP_REQ_POST; 
0A2B8:  CLRF   03
0A2BA:  MOVLB  2
0A2BC:  MOVF   x2F,W
0A2BE:  ADDLW  92
0A2C0:  MOVWF  FE9
0A2C2:  MOVLW  05
0A2C4:  ADDWFC 03,W
0A2C6:  MOVWF  FEA
0A2C8:  MOVLW  02
0A2CA:  MOVWF  FEF
....................                         } 
....................                                            
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ? 
0A2CC:  MOVFF  5C2,633
0A2D0:  MOVFF  5C1,632
0A2D4:  MOVLW  05
0A2D6:  MOVLB  6
0A2D8:  MOVWF  x35
0A2DA:  MOVLW  62
0A2DC:  MOVWF  x34
0A2DE:  MOVLB  0
0A2E0:  CALL   70A4
0A2E4:  MOVFF  02,5C2
0A2E8:  MOVFF  01,5C1
....................                         http_escape_chars(pValue); 
0A2EC:  MOVFF  5C2,5D5
0A2F0:  MOVFF  5C1,5D4
0A2F4:  CALL   775A
....................  
....................                         if (stricmp(pValue,index)==0) 
0A2F8:  MOVFF  5C2,639
0A2FC:  MOVFF  5C1,638
0A300:  MOVLW  05
0A302:  MOVLB  6
0A304:  MOVWF  x3B
0A306:  MOVLW  B7
0A308:  MOVWF  x3A
0A30A:  MOVLB  0
0A30C:  CALL   7846
0A310:  MOVLB  5
0A312:  CLRF   xC4
0A314:  MOVFF  01,5C3
0A318:  BTFSC  01.7
0A31A:  DECF   xC4,F
0A31C:  MOVF   xC3,F
0A31E:  BNZ   A33E
0A320:  MOVF   xC4,F
0A322:  BNZ   A33E
....................                         { 
....................                            sprintf(pValue, "%s", HTML_INDEX_FNAME); 
0A324:  MOVFF  5C2,55F
0A328:  MOVFF  5C1,55E
0A32C:  MOVLW  7C
0A32E:  MOVWF  FF6
0A330:  MOVLW  02
0A332:  MOVWF  FF7
0A334:  MOVLB  0
0A336:  CALL   798A
....................                            debug_html(debug_html_putc, "index='%s' ", pValue);                            
....................                         } 
0A33A:  BRA    A3A2
0A33C:  MOVLB  5
....................                         else 
....................                         { 
....................                            if (pValue[0] == '/') 
0A33E:  MOVFF  5C1,FE9
0A342:  MOVFF  5C2,FEA
0A346:  MOVF   FEF,W
0A348:  SUBLW  2F
0A34A:  BNZ   A352
....................                                                          pValue++;   //skip leading / 
0A34C:  INCF   xC1,F
0A34E:  BTFSC  FD8.2
0A350:  INCF   xC2,F
....................                            j=strlen(pValue); 
0A352:  MOVFF  5C2,64F
0A356:  MOVFF  5C1,64E
0A35A:  MOVLB  0
0A35C:  CALL   7068
0A360:  MOVFF  01,5B5
....................                            l=j; 
0A364:  MOVFF  5B5,5B6
....................                            while(pValue[--j] == 47&& j!=0){//strip out trailing '/' chars 
0A368:  MOVLB  5
0A36A:  DECF   xB5,F
0A36C:  MOVF   xB5,W
0A36E:  ADDWF  xC1,W
0A370:  MOVWF  FE9
0A372:  MOVLW  00
0A374:  ADDWFC xC2,W
0A376:  MOVWF  FEA
0A378:  CLRF   xC4
0A37A:  MOVFF  FEF,5C3
0A37E:  BTFSC  xC3.7
0A380:  DECF   xC4,F
0A382:  MOVF   xC3,W
0A384:  SUBLW  2F
0A386:  BNZ   A3A0
0A388:  MOVF   xC4,F
0A38A:  BNZ   A3A0
0A38C:  MOVF   xB5,F
0A38E:  BZ    A3A0
....................                               pValue[j] = 0;   //this may have to be changed if 
0A390:  MOVF   xB5,W
0A392:  ADDWF  xC1,W
0A394:  MOVWF  FE9
0A396:  MOVLW  00
0A398:  ADDWFC xC2,W
0A39A:  MOVWF  FEA
0A39C:  CLRF   FEF
0A39E:  BRA    A36A
0A3A0:  MOVLB  0
....................                            }               //we want to process directories 
....................                         } 
....................                          
....................                         debug_html(debug_html_putc, "page='%s' ", pValue); 
....................                          
....................                         //TODO: do i need the following 2 lines? 
....................                         fstream = MPFSGetEnd(); 
0A3A2:  MOVFF  FC,5BC
0A3A6:  MOVFF  FB,5BB
0A3AA:  MOVFF  FA,5BA
0A3AE:  MOVFF  F9,5B9
....................  
....................                         MPFSClose(); 
0A3B2:  CALL   79AA
....................  
....................                         if (FileExists(pValue)) 
0A3B6:  MOVFF  5C2,5D8
0A3BA:  MOVFF  5C1,5D7
0A3BE:  CALL   7C5A
0A3C2:  MOVF   01,W
0A3C4:  IORWF  02,W
0A3C6:  BZ    A420
....................                         { 
....................                            _strncpy(&page[g_HttpCurrConn][0], pValue, sizeof(page)/HTTP_NUM_SOCKETS); 
0A3C8:  MOVLB  2
0A3CA:  MOVF   x2F,W
0A3CC:  MULLW  14
0A3CE:  MOVF   FF3,W
0A3D0:  MOVLB  5
0A3D2:  CLRF   xC4
0A3D4:  MOVWF  xC3
0A3D6:  MOVLW  7D
0A3D8:  ADDWF  xC3,W
0A3DA:  MOVWF  01
0A3DC:  MOVLW  05
0A3DE:  ADDWFC xC4,W
0A3E0:  MOVWF  03
0A3E2:  MOVFF  01,5C5
0A3E6:  MOVWF  xC6
0A3E8:  MOVWF  xC8
0A3EA:  MOVFF  01,5C7
0A3EE:  MOVFF  5C2,5CA
0A3F2:  MOVFF  5C1,5C9
0A3F6:  CLRF   xCC
0A3F8:  MOVLW  14
0A3FA:  MOVWF  xCB
0A3FC:  MOVLB  0
0A3FE:  CALL   7D38
....................                            http_error_code[g_HttpCurrConn]=200; 
0A402:  BCF    FD8.0
0A404:  MOVLB  2
0A406:  RLCF   x2F,W
0A408:  CLRF   03
0A40A:  ADDLW  93
0A40C:  MOVWF  FE9
0A40E:  MOVLW  05
0A410:  ADDWFC 03,W
0A412:  MOVWF  FEA
0A414:  CLRF   FEC
0A416:  MOVF   FED,F
0A418:  MOVLW  C8
0A41A:  MOVWF  FEF
....................                            debug_html(debug_html_putc, "FOUND "); 
....................                         } 
0A41C:  BRA    A470
0A41E:  MOVLB  0
....................                         else 
....................                         { 
....................                            sprintf(&page[g_HttpCurrConn][0], "%s", HTTP_404_ERROR_FNAME); 
0A420:  MOVLB  2
0A422:  MOVF   x2F,W
0A424:  MULLW  14
0A426:  MOVF   FF3,W
0A428:  MOVLB  5
0A42A:  CLRF   xC4
0A42C:  MOVWF  xC3
0A42E:  MOVLW  7D
0A430:  ADDWF  xC3,W
0A432:  MOVWF  01
0A434:  MOVLW  05
0A436:  ADDWFC xC4,W
0A438:  MOVWF  03
0A43A:  MOVFF  01,5C5
0A43E:  MOVWF  xC6
0A440:  MOVWF  x5F
0A442:  MOVFF  01,55E
0A446:  MOVLW  86
0A448:  MOVWF  FF6
0A44A:  MOVLW  02
0A44C:  MOVWF  FF7
0A44E:  MOVLB  0
0A450:  CALL   798A
....................                            http_error_code[g_HttpCurrConn]=404; 
0A454:  BCF    FD8.0
0A456:  MOVLB  2
0A458:  RLCF   x2F,W
0A45A:  CLRF   03
0A45C:  ADDLW  93
0A45E:  MOVWF  FE9
0A460:  MOVLW  05
0A462:  ADDWFC 03,W
0A464:  MOVWF  FEA
0A466:  MOVLW  01
0A468:  MOVWF  FEC
0A46A:  MOVF   FED,F
0A46C:  MOVLW  94
0A46E:  MOVWF  FEF
....................                            debug_html(debug_html_putc, "MISSING "); 
....................                         } 
....................  
.................... //                      fprintf(USER,"HTTP %U PVALUE: %s FILE OPENED: %s, handle:%LX\r\n", hs, pValue, page, fstream); 
....................                         pValue=strtok(0, tokens_get); 
0A470:  MOVLB  6
0A472:  CLRF   x33
0A474:  CLRF   x32
0A476:  MOVLW  05
0A478:  MOVWF  x35
0A47A:  MOVLW  62
0A47C:  MOVWF  x34
0A47E:  MOVLB  0
0A480:  CALL   70A4
0A484:  MOVFF  02,5C2
0A488:  MOVFF  01,5C1
....................                        #if HTTP_USE_AUTHENTICATION 
....................                        //we cant execute this until we authorize 
....................                         _strncpy(&http_get_cache[g_HttpCurrConn][0],pValue,(sizeof(http_get_cache)/HTTP_NUM_SOCKETS)); 
0A48C:  MOVLB  2
0A48E:  MOVF   x2F,W
0A490:  MULLW  FE
0A492:  MOVF   FF3,W
0A494:  MOVLB  5
0A496:  CLRF   xC4
0A498:  MOVWF  xC3
0A49A:  MOVLW  39
0A49C:  ADDWF  xC3,W
0A49E:  MOVWF  01
0A4A0:  MOVLW  03
0A4A2:  ADDWFC xC4,W
0A4A4:  MOVWF  03
0A4A6:  MOVFF  01,5C5
0A4AA:  MOVWF  xC6
0A4AC:  MOVWF  xC8
0A4AE:  MOVFF  01,5C7
0A4B2:  MOVFF  5C2,5CA
0A4B6:  MOVFF  5C1,5C9
0A4BA:  CLRF   xCC
0A4BC:  MOVLW  FE
0A4BE:  MOVWF  xCB
0A4C0:  MOVLB  0
0A4C2:  CALL   7D38
....................                        #else 
....................                         if (pValue && (http_error_code[g_HttpCurrConn]==200)) 
....................                         { 
....................                            http_parse_cgi_string(&page[g_HttpCurrConn][0], pValue); 
....................                         } 
....................                        #endif 
....................                      } 
0A4C6:  BRA    A598
0A4C8:  MOVLB  5
....................                      else if (http_cmd[g_HttpCurrConn] != HTTP_REQ_UNKOWN)   //we processed a GET or POST 
0A4CA:  CLRF   03
0A4CC:  MOVLB  2
0A4CE:  MOVF   x2F,W
0A4D0:  ADDLW  92
0A4D2:  MOVWF  FE9
0A4D4:  MOVLW  05
0A4D6:  ADDWFC 03,W
0A4D8:  MOVWF  FEA
0A4DA:  MOVF   FEF,F
0A4DC:  BZ    A59C
....................                      { 
....................                         //if you want to parse HTTP headers, do it here. 
....................                         //pKey and pVal hold the individual headers. 
....................  
....................                         //parse the Content-Length header. 
....................                         if (strcmp(pKey, http_len_str)==0) 
0A4DE:  MOVFF  5C0,633
0A4E2:  MOVFF  5BF,632
0A4E6:  MOVLW  05
0A4E8:  MOVLB  6
0A4EA:  MOVWF  x35
0A4EC:  MOVLW  6D
0A4EE:  MOVWF  x34
0A4F0:  MOVLB  0
0A4F2:  CALL   715C
0A4F6:  MOVLB  5
0A4F8:  CLRF   xC4
0A4FA:  MOVFF  01,5C3
0A4FE:  BTFSC  01.7
0A500:  DECF   xC4,F
0A502:  MOVF   xC3,F
0A504:  BNZ   A544
0A506:  MOVF   xC4,F
0A508:  BNZ   A544
....................                            http_post_len[g_HttpCurrConn]=atol(pValue); 
0A50A:  BCF    FD8.0
0A50C:  MOVLB  2
0A50E:  RLCF   x2F,W
0A510:  CLRF   03
0A512:  ADDLW  95
0A514:  MOVWF  01
0A516:  MOVLW  05
0A518:  ADDWFC 03,F
0A51A:  MOVFF  01,5C3
0A51E:  MOVFF  03,5C4
0A522:  MOVFF  5C2,5C6
0A526:  MOVFF  5C1,5C5
0A52A:  MOVLB  0
0A52C:  GOTO   7D80
0A530:  MOVFF  5C4,FEA
0A534:  MOVFF  5C3,FE9
0A538:  MOVFF  01,FEC
0A53C:  MOVF   FED,F
0A53E:  MOVFF  00,FEF
0A542:  MOVLB  5
....................                       #if HTTP_LAST_MODIFIED_CHECK 
....................                         if (strstr(pKey, "If-Modified-Since") != 0) 
....................                            g_lastModifiedCheck[g_HttpCurrConn] = TRUE; 
....................                       #endif 
....................                       #if HTTP_USE_AUTHENTICATION                         
....................                         //parse the Authorization header. 
....................                         if (strcmp(pKey, http_auth_str)==0) 
0A544:  MOVFF  5C0,633
0A548:  MOVFF  5BF,632
0A54C:  MOVLW  05
0A54E:  MOVLB  6
0A550:  MOVWF  x35
0A552:  MOVLW  9B
0A554:  MOVWF  x34
0A556:  MOVLB  0
0A558:  CALL   715C
0A55C:  MOVLB  5
0A55E:  CLRF   xC4
0A560:  MOVFF  01,5C3
0A564:  BTFSC  01.7
0A566:  DECF   xC4,F
0A568:  MOVF   xC3,F
0A56A:  BNZ   A59A
0A56C:  MOVF   xC4,F
0A56E:  BNZ   A59A
....................                         { 
....................                            _strncpy(http_auth_user, pValue+6,(sizeof(http_auth_user)/HTTP_NUM_SOCKETS)); 
0A570:  MOVLW  06
0A572:  ADDWF  xC1,W
0A574:  MOVWF  xC3
0A576:  MOVLW  00
0A578:  ADDWFC xC2,W
0A57A:  MOVWF  xC4
0A57C:  MOVLW  04
0A57E:  MOVWF  xC8
0A580:  MOVLW  37
0A582:  MOVWF  xC7
0A584:  MOVFF  5C4,5CA
0A588:  MOVFF  5C3,5C9
0A58C:  CLRF   xCC
0A58E:  MOVLW  FE
0A590:  MOVWF  xCB
0A592:  MOVLB  0
0A594:  CALL   7D38
0A598:  MOVLB  5
0A59A:  MOVLB  2
....................                            //printf("\r\nAuth Attempt '%s'->'%s'\r\n", pValue, &http_auth_user[hs][0]); 
....................                         } 
....................                       #endif 
....................                      } 
....................                   } 
0A59C:  BRA    A606
0A59E:  MOVLB  5
....................                   else if (i[g_HttpCurrConn] == 0) 
0A5A0:  CLRF   03
0A5A2:  MOVLB  2
0A5A4:  MOVF   x2F,W
0A5A6:  ADDLW  91
0A5A8:  MOVWF  FE9
0A5AA:  MOVLW  05
0A5AC:  ADDWFC 03,W
0A5AE:  MOVWF  FEA
0A5B0:  MOVF   FEF,F
0A5B2:  BNZ   A606
....................                   { 
....................                      //got a double \r\n 
....................                      //fprintf(USER,"HTTP %U GET HEADER DONE\r\n", hs); 
....................                      if (http_cmd[g_HttpCurrConn] == HTTP_REQ_POST) 
0A5B4:  CLRF   03
0A5B6:  MOVF   x2F,W
0A5B8:  ADDLW  92
0A5BA:  MOVWF  FE9
0A5BC:  MOVLW  05
0A5BE:  ADDWFC 03,W
0A5C0:  MOVWF  FEA
0A5C2:  MOVF   FEF,W
0A5C4:  SUBLW  02
0A5C6:  BNZ   A5E2
....................                      { 
....................                       #if HTTP_USE_AUTHENTICATION 
....................                         http_state[g_HttpCurrConn]=HTTP_CHECK_AUTHENTICATION; 
0A5C8:  CLRF   03
0A5CA:  MOVF   x2F,W
0A5CC:  ADDLW  11
0A5CE:  MOVWF  FE9
0A5D0:  MOVLW  02
0A5D2:  ADDWFC 03,W
0A5D4:  MOVWF  FEA
0A5D6:  MOVLW  04
0A5D8:  MOVWF  FEF
....................                       #else 
....................                         http_state[g_HttpCurrConn]=HTTP_GET_POST; 
....................                       #endif 
....................                         postContinue=TRUE; 
0A5DA:  MOVLB  5
0A5DC:  BSF    xBD.1
....................                      } 
0A5DE:  BRA    A600
0A5E0:  MOVLB  2
....................                      else 
....................                      { 
....................                       #if HTTP_USE_AUTHENTICATION 
....................                         http_state[g_HttpCurrConn]=HTTP_CHECK_AUTHENTICATION; 
0A5E2:  CLRF   03
0A5E4:  MOVF   x2F,W
0A5E6:  ADDLW  11
0A5E8:  MOVWF  FE9
0A5EA:  MOVLW  02
0A5EC:  ADDWFC 03,W
0A5EE:  MOVWF  FEA
0A5F0:  MOVLW  04
0A5F2:  MOVWF  FEF
....................                       #else 
....................                         http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
....................                       #endif 
....................                         TCPDiscard(g_HttpCurrSocket); 
0A5F4:  MOVFF  22E,5C3
0A5F8:  MOVLB  0
0A5FA:  CALL   80CA
0A5FE:  MOVLB  5
....................                      } 
....................                      break;   //break out of read from ethernet loop 
0A600:  MOVLB  0
0A602:  BRA    A61C
0A604:  MOVLB  2
....................                   } 
....................                   i[g_HttpCurrConn]=0; 
0A606:  CLRF   03
0A608:  MOVF   x2F,W
0A60A:  ADDLW  91
0A60C:  MOVWF  FE9
0A60E:  MOVLW  05
0A610:  ADDWFC 03,W
0A612:  MOVWF  FEA
0A614:  CLRF   FEF
0A616:  MOVLB  5
....................                } 
0A618:  BRA    A0C2
0A61A:  MOVLB  0
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[g_HttpCurrConn]) > TICKS_PER_SECOND*20) 
0A61C:  CALL   23FC
0A620:  MOVFF  03,5C6
0A624:  MOVFF  02,5C5
0A628:  MOVFF  01,5C4
0A62C:  MOVFF  00,5C3
0A630:  MOVLB  2
0A632:  MOVF   x2F,W
0A634:  MULLW  04
0A636:  MOVF   FF3,W
0A638:  CLRF   03
0A63A:  ADDLW  97
0A63C:  MOVWF  FE9
0A63E:  MOVLW  05
0A640:  ADDWFC 03,W
0A642:  MOVWF  FEA
0A644:  MOVFF  FEF,00
0A648:  MOVFF  FEC,01
0A64C:  MOVFF  FEC,02
0A650:  MOVFF  FEC,03
0A654:  MOVF   00,W
0A656:  MOVLB  5
0A658:  SUBWF  xC3,F
0A65A:  MOVF   01,W
0A65C:  SUBWFB xC4,F
0A65E:  MOVF   02,W
0A660:  SUBWFB xC5,F
0A662:  MOVF   03,W
0A664:  SUBWFB xC6,F
0A666:  BNZ   A682
0A668:  MOVF   xC5,W
0A66A:  SUBLW  08
0A66C:  BC    A6E6
0A66E:  XORLW  FF
0A670:  BNZ   A682
0A672:  MOVF   xC4,W
0A674:  SUBLW  88
0A676:  BC    A6E6
0A678:  XORLW  FF
0A67A:  BNZ   A682
0A67C:  MOVF   xC3,W
0A67E:  SUBLW  68
0A680:  BC    A6E6
....................             { 
....................                   debug_html(debug_html_putc, "\r\nHTTP %U GET HEADER TIMEOUT ", g_HttpCurrConn); 
....................                   sprintf(&page[g_HttpCurrConn][0], "%s", HTTP_500_ERROR_FNAME); 
0A682:  MOVLB  2
0A684:  MOVF   x2F,W
0A686:  MULLW  14
0A688:  MOVF   FF3,W
0A68A:  MOVLB  5
0A68C:  CLRF   xC4
0A68E:  MOVWF  xC3
0A690:  MOVLW  7D
0A692:  ADDWF  xC3,W
0A694:  MOVWF  01
0A696:  MOVLW  05
0A698:  ADDWFC xC4,W
0A69A:  MOVWF  03
0A69C:  MOVFF  01,5C5
0A6A0:  MOVWF  xC6
0A6A2:  MOVWF  x5F
0A6A4:  MOVFF  01,55E
0A6A8:  MOVLW  94
0A6AA:  MOVWF  FF6
0A6AC:  MOVLW  02
0A6AE:  MOVWF  FF7
0A6B0:  MOVLB  0
0A6B2:  CALL   798A
....................                   http_error_code[g_HttpCurrConn]=500; 
0A6B6:  BCF    FD8.0
0A6B8:  MOVLB  2
0A6BA:  RLCF   x2F,W
0A6BC:  CLRF   03
0A6BE:  ADDLW  93
0A6C0:  MOVWF  FE9
0A6C2:  MOVLW  05
0A6C4:  ADDWFC 03,W
0A6C6:  MOVWF  FEA
0A6C8:  MOVLW  01
0A6CA:  MOVWF  FEC
0A6CC:  MOVF   FED,F
0A6CE:  MOVLW  F4
0A6D0:  MOVWF  FEF
....................                   http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
0A6D2:  CLRF   03
0A6D4:  MOVF   x2F,W
0A6D6:  ADDLW  11
0A6D8:  MOVWF  FE9
0A6DA:  MOVLW  02
0A6DC:  ADDWFC 03,W
0A6DE:  MOVWF  FEA
0A6E0:  MOVLW  07
0A6E2:  MOVWF  FEF
0A6E4:  MOVLB  5
....................             } 
....................             if (!postContinue) 
0A6E6:  BTFSC  xBD.1
0A6E8:  BRA    A6F2
....................                break; 
0A6EA:  MOVLB  0
0A6EC:  GOTO   AF16
0A6F0:  MOVLB  5
0A6F2:  MOVLB  0
....................  
....................       #if HTTP_USE_AUTHENTICATION 
....................          case HTTP_CHECK_AUTHENTICATION: 
....................             http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
0A6F4:  CLRF   03
0A6F6:  MOVLB  2
0A6F8:  MOVF   x2F,W
0A6FA:  ADDLW  11
0A6FC:  MOVWF  FE9
0A6FE:  MOVLW  02
0A700:  ADDWFC 03,W
0A702:  MOVWF  FEA
0A704:  MOVLW  07
0A706:  MOVWF  FEF
....................             postContinue=FALSE; 
0A708:  MOVLB  5
0A70A:  BCF    xBD.1
....................             if (HTTPRequiresAuthentication(&page[g_HttpCurrConn][0], &http_auth_user[g_HttpCurrConn][0])) 
0A70C:  MOVLB  2
0A70E:  MOVF   x2F,W
0A710:  MULLW  14
0A712:  MOVF   FF3,W
0A714:  MOVLB  5
0A716:  CLRF   xC4
0A718:  MOVWF  xC3
0A71A:  MOVLW  7D
0A71C:  ADDWF  xC3,W
0A71E:  MOVWF  01
0A720:  MOVLW  05
0A722:  ADDWFC xC4,W
0A724:  MOVWF  03
0A726:  MOVFF  01,5CB
0A72A:  MOVWF  xCC
0A72C:  MOVLB  2
0A72E:  MOVF   x2F,W
0A730:  MULLW  FE
0A732:  MOVF   FF3,W
0A734:  MOVLB  5
0A736:  CLRF   xC8
0A738:  MOVWF  xC7
0A73A:  MOVLW  37
0A73C:  ADDWF  xC7,W
0A73E:  MOVWF  01
0A740:  MOVLW  04
0A742:  ADDWFC xC8,W
0A744:  MOVWF  03
0A746:  MOVFF  01,5C9
0A74A:  MOVWF  xCA
0A74C:  MOVWF  xCE
0A74E:  MOVFF  01,5CD
0A752:  MOVLB  0
0A754:  GOTO   8462
0A758:  MOVF   01,F
0A75A:  BZ    A7B6
....................             { 
....................                //printf("\r\nAUTH REQUIRED\r\n"); 
....................                _strncpy(&page[g_HttpCurrConn][0], http_401_error, sizeof(page)/HTTP_NUM_SOCKETS); 
0A75C:  MOVLB  2
0A75E:  MOVF   x2F,W
0A760:  MULLW  14
0A762:  MOVF   FF3,W
0A764:  MOVLB  5
0A766:  CLRF   xC4
0A768:  MOVWF  xC3
0A76A:  MOVLW  7D
0A76C:  ADDWF  xC3,W
0A76E:  MOVWF  01
0A770:  MOVLW  05
0A772:  ADDWFC xC4,W
0A774:  MOVWF  03
0A776:  MOVFF  01,5C5
0A77A:  MOVWF  xC6
0A77C:  MOVWF  xC8
0A77E:  MOVFF  01,5C7
0A782:  MOVLW  02
0A784:  MOVWF  xCA
0A786:  MOVLW  12
0A788:  MOVWF  xC9
0A78A:  CLRF   xCC
0A78C:  MOVLW  14
0A78E:  MOVWF  xCB
0A790:  MOVLB  0
0A792:  CALL   7D38
....................                http_error_code[g_HttpCurrConn]=401; 
0A796:  BCF    FD8.0
0A798:  MOVLB  2
0A79A:  RLCF   x2F,W
0A79C:  CLRF   03
0A79E:  ADDLW  93
0A7A0:  MOVWF  FE9
0A7A2:  MOVLW  05
0A7A4:  ADDWFC 03,W
0A7A6:  MOVWF  FEA
0A7A8:  MOVLW  01
0A7AA:  MOVWF  FEC
0A7AC:  MOVF   FED,F
0A7AE:  MOVLW  91
0A7B0:  MOVWF  FEF
....................             } 
0A7B2:  BRA    A832
0A7B4:  MOVLB  0
....................             else if (http_cmd[g_HttpCurrConn] == HTTP_REQ_POST) 
0A7B6:  CLRF   03
0A7B8:  MOVLB  2
0A7BA:  MOVF   x2F,W
0A7BC:  ADDLW  92
0A7BE:  MOVWF  FE9
0A7C0:  MOVLW  05
0A7C2:  ADDWFC 03,W
0A7C4:  MOVWF  FEA
0A7C6:  MOVF   FEF,W
0A7C8:  SUBLW  02
0A7CA:  BNZ   A7E6
....................             { 
....................                http_state[g_HttpCurrConn]=HTTP_GET_POST; 
0A7CC:  CLRF   03
0A7CE:  MOVF   x2F,W
0A7D0:  ADDLW  11
0A7D2:  MOVWF  FE9
0A7D4:  MOVLW  02
0A7D6:  ADDWFC 03,W
0A7D8:  MOVWF  FEA
0A7DA:  MOVLW  05
0A7DC:  MOVWF  FEF
....................                postContinue=TRUE; 
0A7DE:  MOVLB  5
0A7E0:  BSF    xBD.1
....................             } 
0A7E2:  BRA    A830
0A7E4:  MOVLB  2
....................             else 
....................             { 
....................                debug_html(debug_html_putc, "\r\n!! AUTH OK !!\r\n"); 
....................                http_parse_cgi_string(&page[g_HttpCurrConn][0], &http_get_cache[g_HttpCurrConn][0]); 
0A7E6:  MOVF   x2F,W
0A7E8:  MULLW  14
0A7EA:  MOVF   FF3,W
0A7EC:  MOVLB  5
0A7EE:  CLRF   xC4
0A7F0:  MOVWF  xC3
0A7F2:  MOVLW  7D
0A7F4:  ADDWF  xC3,W
0A7F6:  MOVWF  01
0A7F8:  MOVLW  05
0A7FA:  ADDWFC xC4,W
0A7FC:  MOVWF  03
0A7FE:  MOVFF  01,5CB
0A802:  MOVWF  xCC
0A804:  MOVLB  2
0A806:  MOVF   x2F,W
0A808:  MULLW  FE
0A80A:  MOVF   FF3,W
0A80C:  MOVLB  5
0A80E:  CLRF   xC8
0A810:  MOVWF  xC7
0A812:  MOVLW  39
0A814:  ADDWF  xC7,W
0A816:  MOVWF  01
0A818:  MOVLW  03
0A81A:  ADDWFC xC8,W
0A81C:  MOVWF  03
0A81E:  MOVFF  01,5C9
0A822:  MOVWF  xCA
0A824:  MOVWF  xCE
0A826:  MOVFF  01,5CD
0A82A:  MOVLB  0
0A82C:  CALL   886E
0A830:  MOVLB  2
....................             } 
....................             if (!postContinue) 
0A832:  MOVLB  5
0A834:  BTFSC  xBD.1
0A836:  BRA    A83E
....................                break; 
0A838:  MOVLB  0
0A83A:  BRA    AF16
0A83C:  MOVLB  5
0A83E:  MOVLB  0
....................       #endif 
....................  
....................          case HTTP_GET_POST: 
.................... //            fprintf(USER,"HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]); 
....................             http_state[g_HttpCurrConn]=HTTP_GET_POST_CONTINUE; 
0A840:  CLRF   03
0A842:  MOVLB  2
0A844:  MOVF   x2F,W
0A846:  ADDLW  11
0A848:  MOVWF  FE9
0A84A:  MOVLW  02
0A84C:  ADDWFC 03,W
0A84E:  MOVWF  FEA
0A850:  MOVLW  06
0A852:  MOVWF  FEF
....................             http_timer[g_HttpCurrConn]=TickGet(); 
0A854:  MOVF   x2F,W
0A856:  MULLW  04
0A858:  MOVF   FF3,W
0A85A:  CLRF   03
0A85C:  ADDLW  97
0A85E:  MOVWF  01
0A860:  MOVLW  05
0A862:  ADDWFC 03,F
0A864:  MOVFF  01,5C3
0A868:  MOVFF  03,5C4
0A86C:  MOVLB  0
0A86E:  CALL   23FC
0A872:  MOVFF  5C4,FEA
0A876:  MOVFF  5C3,FE9
0A87A:  MOVFF  00,FEF
0A87E:  MOVFF  01,FEC
0A882:  MOVFF  02,FEC
0A886:  MOVFF  03,FEC
....................             i[g_HttpCurrConn]=0; 
0A88A:  CLRF   03
0A88C:  MOVLB  2
0A88E:  MOVF   x2F,W
0A890:  ADDLW  91
0A892:  MOVWF  FE9
0A894:  MOVLW  05
0A896:  ADDWFC 03,W
0A898:  MOVWF  FEA
0A89A:  CLRF   FEF
0A89C:  MOVLB  0
....................  
....................          case HTTP_GET_POST_CONTINUE: 
....................             while ( 
....................                      TCPIsGetReady(g_HttpCurrSocket) && 
....................                      TCPGet(g_HttpCurrSocket, &c) && 
....................                      (http_post_len[g_HttpCurrConn] != 0) 
....................                   ) 
0A89E:  MOVFF  22E,5C8
0A8A2:  CALL   6E2E
0A8A6:  MOVF   01,W
0A8A8:  IORWF  02,W
0A8AA:  BTFSC  FD8.2
0A8AC:  BRA    AA76
0A8AE:  MOVFF  22E,5C3
0A8B2:  MOVLW  05
0A8B4:  MOVLB  5
0A8B6:  MOVWF  xC5
0A8B8:  MOVLW  BE
0A8BA:  MOVWF  xC4
0A8BC:  MOVLB  0
0A8BE:  CALL   6EAE
0A8C2:  MOVF   01,F
0A8C4:  BTFSC  FD8.2
0A8C6:  BRA    AA76
0A8C8:  BCF    FD8.0
0A8CA:  MOVLB  2
0A8CC:  RLCF   x2F,W
0A8CE:  CLRF   03
0A8D0:  ADDLW  95
0A8D2:  MOVWF  FE9
0A8D4:  MOVLW  05
0A8D6:  ADDWFC 03,W
0A8D8:  MOVWF  FEA
0A8DA:  MOVFF  FEC,5C4
0A8DE:  MOVF   FED,F
0A8E0:  MOVFF  FEF,5C3
0A8E4:  MOVLB  5
0A8E6:  MOVF   xC3,F
0A8E8:  BNZ   A8F4
0A8EA:  MOVF   xC4,F
0A8EC:  BTFSS  FD8.2
0A8EE:  BRA    A8F4
0A8F0:  MOVLB  0
0A8F2:  BRA    AA76
....................             { 
....................                http_post_len[g_HttpCurrConn] -= 1; 
0A8F4:  BCF    FD8.0
0A8F6:  MOVLB  2
0A8F8:  RLCF   x2F,W
0A8FA:  CLRF   03
0A8FC:  ADDLW  95
0A8FE:  MOVWF  FE9
0A900:  MOVLW  05
0A902:  ADDWFC 03,W
0A904:  MOVWF  FEA
0A906:  MOVLW  01
0A908:  SUBWF  FEF,W
0A90A:  MOVWF  00
0A90C:  MOVLW  00
0A90E:  SUBWFB FEC,W
0A910:  MOVWF  03
0A912:  MOVF   00,W
0A914:  MOVF   FED,F
0A916:  MOVWF  FEF
0A918:  MOVFF  03,FEC
....................  
....................                if (c!='&') 
0A91C:  MOVLB  5
0A91E:  MOVF   xBE,W
0A920:  SUBLW  26
0A922:  BZ    A962
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]++]=c; 
0A924:  MOVLB  2
0A926:  MOVF   x2F,W
0A928:  MULLW  FE
0A92A:  MOVF   FF3,W
0A92C:  MOVLB  5
0A92E:  CLRF   xC4
0A930:  MOVWF  xC3
0A932:  CLRF   03
0A934:  MOVLB  2
0A936:  MOVF   x2F,W
0A938:  ADDLW  91
0A93A:  MOVWF  FE9
0A93C:  MOVLW  05
0A93E:  ADDWFC 03,W
0A940:  MOVWF  FEA
0A942:  MOVF   FEF,W
0A944:  INCF   FEF,F
0A946:  CLRF   03
0A948:  MOVLB  5
0A94A:  ADDWF  xC3,W
0A94C:  MOVWF  01
0A94E:  MOVF   xC4,W
0A950:  ADDWFC 03,F
0A952:  MOVF   01,W
0A954:  ADDLW  37
0A956:  MOVWF  FE9
0A958:  MOVLW  02
0A95A:  ADDWFC 03,W
0A95C:  MOVWF  FEA
0A95E:  MOVFF  5BE,FEF
....................                } 
....................  
....................                if ( (c=='&') || (http_post_len[g_HttpCurrConn] == 0) ) 
0A962:  MOVF   xBE,W
0A964:  SUBLW  26
0A966:  BZ    A98E
0A968:  BCF    FD8.0
0A96A:  MOVLB  2
0A96C:  RLCF   x2F,W
0A96E:  CLRF   03
0A970:  ADDLW  95
0A972:  MOVWF  FE9
0A974:  MOVLW  05
0A976:  ADDWFC 03,W
0A978:  MOVWF  FEA
0A97A:  MOVFF  FEC,5C4
0A97E:  MOVF   FED,F
0A980:  MOVFF  FEF,5C3
0A984:  MOVLB  5
0A986:  MOVF   xC3,F
0A988:  BNZ   AA72
0A98A:  MOVF   xC4,F
0A98C:  BNZ   AA72
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]]=0; 
0A98E:  MOVLB  2
0A990:  MOVF   x2F,W
0A992:  MULLW  FE
0A994:  MOVF   FF3,W
0A996:  MOVLB  5
0A998:  CLRF   xC4
0A99A:  MOVWF  xC3
0A99C:  CLRF   03
0A99E:  MOVLB  2
0A9A0:  MOVF   x2F,W
0A9A2:  ADDLW  91
0A9A4:  MOVWF  FE9
0A9A6:  MOVLW  05
0A9A8:  ADDWFC 03,W
0A9AA:  MOVWF  FEA
0A9AC:  CLRF   03
0A9AE:  MOVF   FEF,W
0A9B0:  MOVLB  5
0A9B2:  ADDWF  xC3,W
0A9B4:  MOVWF  01
0A9B6:  MOVF   xC4,W
0A9B8:  ADDWFC 03,F
0A9BA:  MOVF   01,W
0A9BC:  ADDLW  37
0A9BE:  MOVWF  FE9
0A9C0:  MOVLW  02
0A9C2:  ADDWFC 03,W
0A9C4:  MOVWF  FEA
0A9C6:  CLRF   FEF
....................  
....................                   //fprintf(USER,"%lu - %s\r\n", http_post_len[hs], &HTTPbuffer[hs][0]); 
....................  
....................                   http_parse_cgi_string(&page[g_HttpCurrConn][0], &HTTPbuffer[g_HttpCurrConn][0]); 
0A9C8:  MOVLB  2
0A9CA:  MOVF   x2F,W
0A9CC:  MULLW  14
0A9CE:  MOVF   FF3,W
0A9D0:  MOVLB  5
0A9D2:  CLRF   xC4
0A9D4:  MOVWF  xC3
0A9D6:  MOVLW  7D
0A9D8:  ADDWF  xC3,W
0A9DA:  MOVWF  01
0A9DC:  MOVLW  05
0A9DE:  ADDWFC xC4,W
0A9E0:  MOVWF  03
0A9E2:  MOVFF  01,5CB
0A9E6:  MOVWF  xCC
0A9E8:  MOVLB  2
0A9EA:  MOVF   x2F,W
0A9EC:  MULLW  FE
0A9EE:  MOVF   FF3,W
0A9F0:  MOVLB  5
0A9F2:  CLRF   xC8
0A9F4:  MOVWF  xC7
0A9F6:  MOVLW  37
0A9F8:  ADDWF  xC7,W
0A9FA:  MOVWF  01
0A9FC:  MOVLW  02
0A9FE:  ADDWFC xC8,W
0AA00:  MOVWF  03
0AA02:  MOVFF  01,5C9
0AA06:  MOVWF  xCA
0AA08:  MOVWF  xCE
0AA0A:  MOVFF  01,5CD
0AA0E:  MOVLB  0
0AA10:  CALL   886E
....................                   if (http_post_len[g_HttpCurrConn] == 0) 
0AA14:  BCF    FD8.0
0AA16:  MOVLB  2
0AA18:  RLCF   x2F,W
0AA1A:  CLRF   03
0AA1C:  ADDLW  95
0AA1E:  MOVWF  FE9
0AA20:  MOVLW  05
0AA22:  ADDWFC 03,W
0AA24:  MOVWF  FEA
0AA26:  MOVFF  FEC,5C4
0AA2A:  MOVF   FED,F
0AA2C:  MOVFF  FEF,5C3
0AA30:  MOVLB  5
0AA32:  MOVF   xC3,F
0AA34:  BNZ   AA5E
0AA36:  MOVF   xC4,F
0AA38:  BNZ   AA5E
....................                   { 
....................                      http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
0AA3A:  CLRF   03
0AA3C:  MOVLB  2
0AA3E:  MOVF   x2F,W
0AA40:  ADDLW  11
0AA42:  MOVWF  FE9
0AA44:  MOVLW  02
0AA46:  ADDWFC 03,W
0AA48:  MOVWF  FEA
0AA4A:  MOVLW  07
0AA4C:  MOVWF  FEF
....................                      TCPDiscard(g_HttpCurrSocket); 
0AA4E:  MOVFF  22E,5C3
0AA52:  MOVLB  0
0AA54:  CALL   80CA
....................                      break; 
0AA58:  BRA    AA76
....................                   } 
0AA5A:  BRA    AA72
0AA5C:  MOVLB  5
....................                   else 
....................                      i[g_HttpCurrConn]=0; 
0AA5E:  CLRF   03
0AA60:  MOVLB  2
0AA62:  MOVF   x2F,W
0AA64:  ADDLW  91
0AA66:  MOVWF  FE9
0AA68:  MOVLW  05
0AA6A:  ADDWFC 03,W
0AA6C:  MOVWF  FEA
0AA6E:  CLRF   FEF
0AA70:  MOVLB  0
....................                } 
0AA72:  MOVLB  0
0AA74:  BRA    A89E
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[g_HttpCurrConn]) > TICKS_PER_SECOND*20) 
0AA76:  CALL   23FC
0AA7A:  MOVFF  03,5C6
0AA7E:  MOVFF  02,5C5
0AA82:  MOVFF  01,5C4
0AA86:  MOVFF  00,5C3
0AA8A:  MOVLB  2
0AA8C:  MOVF   x2F,W
0AA8E:  MULLW  04
0AA90:  MOVF   FF3,W
0AA92:  CLRF   03
0AA94:  ADDLW  97
0AA96:  MOVWF  FE9
0AA98:  MOVLW  05
0AA9A:  ADDWFC 03,W
0AA9C:  MOVWF  FEA
0AA9E:  MOVFF  FEF,00
0AAA2:  MOVFF  FEC,01
0AAA6:  MOVFF  FEC,02
0AAAA:  MOVFF  FEC,03
0AAAE:  MOVF   00,W
0AAB0:  MOVLB  5
0AAB2:  SUBWF  xC3,F
0AAB4:  MOVF   01,W
0AAB6:  SUBWFB xC4,F
0AAB8:  MOVF   02,W
0AABA:  SUBWFB xC5,F
0AABC:  MOVF   03,W
0AABE:  SUBWFB xC6,F
0AAC0:  BNZ   AADC
0AAC2:  MOVF   xC5,W
0AAC4:  SUBLW  08
0AAC6:  BC    AB40
0AAC8:  XORLW  FF
0AACA:  BNZ   AADC
0AACC:  MOVF   xC4,W
0AACE:  SUBLW  88
0AAD0:  BC    AB40
0AAD2:  XORLW  FF
0AAD4:  BNZ   AADC
0AAD6:  MOVF   xC3,W
0AAD8:  SUBLW  68
0AADA:  BC    AB40
....................             { 
....................                debug_html(debug_html_putc, "\r\nHTTP %U GET POST TIMEOUT ", g_HttpCurrConn); 
....................                sprintf(&page[g_HttpCurrConn][0], HTTP_500_ERROR_FNAME); 
0AADC:  MOVLB  2
0AADE:  MOVF   x2F,W
0AAE0:  MULLW  14
0AAE2:  MOVF   FF3,W
0AAE4:  MOVLB  5
0AAE6:  CLRF   xC4
0AAE8:  MOVWF  xC3
0AAEA:  MOVLW  7D
0AAEC:  ADDWF  xC3,W
0AAEE:  MOVWF  01
0AAF0:  MOVLW  05
0AAF2:  ADDWFC xC4,W
0AAF4:  MOVWF  03
0AAF6:  MOVFF  01,5C5
0AAFA:  MOVWF  xC6
0AAFC:  MOVWF  x5F
0AAFE:  MOVFF  01,55E
0AB02:  MOVLW  A2
0AB04:  MOVWF  FF6
0AB06:  MOVLW  02
0AB08:  MOVWF  FF7
0AB0A:  MOVLB  0
0AB0C:  CALL   798A
....................                http_error_code[g_HttpCurrConn]=500; 
0AB10:  BCF    FD8.0
0AB12:  MOVLB  2
0AB14:  RLCF   x2F,W
0AB16:  CLRF   03
0AB18:  ADDLW  93
0AB1A:  MOVWF  FE9
0AB1C:  MOVLW  05
0AB1E:  ADDWFC 03,W
0AB20:  MOVWF  FEA
0AB22:  MOVLW  01
0AB24:  MOVWF  FEC
0AB26:  MOVF   FED,F
0AB28:  MOVLW  F4
0AB2A:  MOVWF  FEF
....................                http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
0AB2C:  CLRF   03
0AB2E:  MOVF   x2F,W
0AB30:  ADDLW  11
0AB32:  MOVWF  FE9
0AB34:  MOVLW  02
0AB36:  ADDWFC 03,W
0AB38:  MOVWF  FEA
0AB3A:  MOVLW  07
0AB3C:  MOVWF  FEF
0AB3E:  MOVLB  5
....................             } 
....................             break; 
0AB40:  MOVLB  0
0AB42:  BRA    AF16
....................  
....................          case HTTP_SEND_RESPONSE: 
....................             //putc('.'); 
....................             if(mpfsFlags.bits.bNotAvailable) 
0AB44:  MOVLB  2
0AB46:  BTFSS  x09.0
0AB48:  BRA    AB50
....................                break; 
0AB4A:  MOVLB  0
0AB4C:  BRA    AF16
0AB4E:  MOVLB  2
.................... //            fprintf(USER,"HTTP %U SEND RESPONSE\r\n", hs); 
....................             //putc('*'); 
....................             g_HTTPMimeType[g_HttpCurrConn] = HTTPFindMimeType(&page[g_HttpCurrConn][0]); 
0AB50:  CLRF   03
0AB52:  MOVF   x2F,W
0AB54:  ADDLW  36
0AB56:  MOVWF  01
0AB58:  MOVLW  02
0AB5A:  ADDWFC 03,F
0AB5C:  MOVFF  01,5C3
0AB60:  MOVFF  03,5C4
0AB64:  MOVLB  2
0AB66:  MOVF   x2F,W
0AB68:  MULLW  14
0AB6A:  MOVF   FF3,W
0AB6C:  MOVLB  5
0AB6E:  CLRF   xC6
0AB70:  MOVWF  xC5
0AB72:  MOVLW  7D
0AB74:  ADDWF  xC5,W
0AB76:  MOVWF  01
0AB78:  MOVLW  05
0AB7A:  ADDWFC xC6,W
0AB7C:  MOVWF  03
0AB7E:  MOVFF  01,5C7
0AB82:  MOVWF  xC8
0AB84:  MOVWF  xCA
0AB86:  MOVFF  01,5C9
0AB8A:  MOVLB  0
0AB8C:  GOTO   89BC
0AB90:  MOVFF  5C4,FEA
0AB94:  MOVFF  5C3,FE9
0AB98:  MOVFF  01,FEF
....................            #if HTTP_LAST_MODIFIED_CHECK 
....................             if (IsImage(g_HttpCurrConn) && g_lastModifiedCheck[g_HttpCurrConn]) 
....................             { 
....................                http_error_code[g_HttpCurrConn] = 304; 
....................             } 
....................            #endif 
....................             fstream = MPFSOpen(page); 
0AB9C:  MOVLW  05
0AB9E:  MOVLB  6
0ABA0:  MOVWF  x33
0ABA2:  MOVLW  7D
0ABA4:  MOVWF  x32
0ABA6:  MOVLB  0
0ABA8:  CALL   7AE8
0ABAC:  MOVFF  03,5BC
0ABB0:  MOVFF  02,5BB
0ABB4:  MOVFF  01,5BA
0ABB8:  MOVFF  00,5B9
....................             if (fstream == MPFS_INVALID) 
0ABBC:  MOVLB  5
0ABBE:  INCFSZ xB9,W
0ABC0:  BRA    AC22
0ABC2:  INCFSZ xBA,W
0ABC4:  BRA    AC22
0ABC6:  INCFSZ xBB,W
0ABC8:  BRA    AC22
0ABCA:  INCFSZ xBC,W
0ABCC:  BRA    AC22
....................             { 
....................                sprintf(page, HTTP_500_ERROR_FNAME); 
0ABCE:  MOVLW  05
0ABD0:  MOVWF  x5F
0ABD2:  MOVLW  7D
0ABD4:  MOVWF  x5E
0ABD6:  MOVLW  B0
0ABD8:  MOVWF  FF6
0ABDA:  MOVLW  02
0ABDC:  MOVWF  FF7
0ABDE:  MOVLB  0
0ABE0:  CALL   798A
....................                http_error_code[g_HttpCurrConn]=500; 
0ABE4:  BCF    FD8.0
0ABE6:  MOVLB  2
0ABE8:  RLCF   x2F,W
0ABEA:  CLRF   03
0ABEC:  ADDLW  93
0ABEE:  MOVWF  FE9
0ABF0:  MOVLW  05
0ABF2:  ADDWFC 03,W
0ABF4:  MOVWF  FEA
0ABF6:  MOVLW  01
0ABF8:  MOVWF  FEC
0ABFA:  MOVF   FED,F
0ABFC:  MOVLW  F4
0ABFE:  MOVWF  FEF
....................                fstream = MPFSOpen(page); 
0AC00:  MOVLW  05
0AC02:  MOVLB  6
0AC04:  MOVWF  x33
0AC06:  MOVLW  7D
0AC08:  MOVWF  x32
0AC0A:  MOVLB  0
0AC0C:  CALL   7AE8
0AC10:  MOVFF  03,5BC
0AC14:  MOVFF  02,5BB
0AC18:  MOVFF  01,5BA
0AC1C:  MOVFF  00,5B9
0AC20:  MOVLB  5
....................             } 
....................             MPFSGetBegin(fstream); 
0AC22:  MOVFF  5BC,FC
0AC26:  MOVFF  5BB,FB
0AC2A:  MOVFF  5BA,FA
0AC2E:  MOVFF  5B9,F9
....................             http_page_req[g_HttpCurrConn]=fstream; 
0AC32:  MOVLB  2
0AC34:  MOVF   x2F,W
0AC36:  MULLW  04
0AC38:  MOVF   FF3,W
0AC3A:  CLRF   03
0AC3C:  ADDLW  35
0AC3E:  MOVWF  FE9
0AC40:  MOVLW  03
0AC42:  ADDWFC 03,W
0AC44:  MOVWF  FEA
0AC46:  MOVFF  5B9,FEF
0AC4A:  MOVFF  5BA,FEC
0AC4E:  MOVFF  5BB,FEC
0AC52:  MOVFF  5BC,FEC
....................             lastHTTPPutConstPos[g_HttpCurrConn]=0; 
0AC56:  MOVF   x2F,W
0AC58:  MULLW  04
0AC5A:  MOVF   FF3,W
0AC5C:  CLRF   03
0AC5E:  ADDLW  30
0AC60:  MOVWF  FE9
0AC62:  MOVLW  02
0AC64:  ADDWFC 03,W
0AC66:  MOVWF  FEA
0AC68:  MOVF   FEE,F
0AC6A:  MOVF   FEE,F
0AC6C:  CLRF   FEC
0AC6E:  MOVF   FED,F
0AC70:  CLRF   FEF
0AC72:  MOVF   FED,F
0AC74:  CLRF   FEF
0AC76:  MOVF   FED,F
0AC78:  CLRF   FEF
....................             http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE_CONTINUE; 
0AC7A:  CLRF   03
0AC7C:  MOVF   x2F,W
0AC7E:  ADDLW  11
0AC80:  MOVWF  FE9
0AC82:  MOVLW  02
0AC84:  ADDWFC 03,W
0AC86:  MOVWF  FEA
0AC88:  MOVLW  08
0AC8A:  MOVWF  FEF
0AC8C:  MOVLB  0
....................  
....................          case HTTP_SEND_RESPONSE_CONTINUE: 
....................             TCPDiscard(g_HttpCurrSocket); 
0AC8E:  MOVFF  22E,5C3
0AC92:  CALL   80CA
....................             //putc('@'); 
....................              if (TCPIsPutReady(g_HttpCurrSocket)) 
0AC96:  MOVFF  22E,5F1
0AC9A:  CALL   8AAC
0AC9E:  MOVF   01,W
0ACA0:  IORWF  02,W
0ACA2:  BZ    AD72
....................             { 
....................                //printf("\r\nPut Page Segment %U/%U EC=%LU '%s' %LX ", hs, currSocket, http_error_code[hs], page, http_page_req[hs]); 
....................                /* 
....................                ui_disp_mac_user(&TCB[currSocket].remote.MACAddr); 
....................                printf(" MAC="); 
....................                ui_disp_ip_user(&TCB[currSocket].remote.IPAddr); 
....................                printf("\r\n"); 
....................                */ 
....................                http_timer[g_HttpCurrConn]=TickGet(); 
0ACA4:  MOVLB  2
0ACA6:  MOVF   x2F,W
0ACA8:  MULLW  04
0ACAA:  MOVF   FF3,W
0ACAC:  CLRF   03
0ACAE:  ADDLW  97
0ACB0:  MOVWF  01
0ACB2:  MOVLW  05
0ACB4:  ADDWFC 03,F
0ACB6:  MOVFF  01,5C3
0ACBA:  MOVFF  03,5C4
0ACBE:  MOVLB  0
0ACC0:  CALL   23FC
0ACC4:  MOVFF  5C4,FEA
0ACC8:  MOVFF  5C3,FE9
0ACCC:  MOVFF  00,FEF
0ACD0:  MOVFF  01,FEC
0ACD4:  MOVFF  02,FEC
0ACD8:  MOVFF  03,FEC
....................                 
.................... //               fprintf(USER,"\r\nPUTTING HTTP SEG\r\n"); 
....................                doneSend=tcp_http_put_file(http_error_code[g_HttpCurrConn], &http_page_req[g_HttpCurrConn], &page[g_HttpCurrConn][0]); 
0ACDC:  BCF    FD8.0
0ACDE:  MOVLB  2
0ACE0:  RLCF   x2F,W
0ACE2:  CLRF   03
0ACE4:  ADDLW  93
0ACE6:  MOVWF  FE9
0ACE8:  MOVLW  05
0ACEA:  ADDWFC 03,W
0ACEC:  MOVWF  FEA
0ACEE:  MOVFF  FEC,5CC
0ACF2:  MOVF   FED,F
0ACF4:  MOVFF  FEF,5CB
0ACF8:  MOVF   x2F,W
0ACFA:  MULLW  04
0ACFC:  MOVF   FF3,W
0ACFE:  CLRF   03
0AD00:  ADDLW  35
0AD02:  MOVWF  01
0AD04:  MOVLW  03
0AD06:  ADDWFC 03,F
0AD08:  MOVFF  01,5CD
0AD0C:  MOVFF  03,5CE
0AD10:  MOVLB  2
0AD12:  MOVF   x2F,W
0AD14:  MULLW  14
0AD16:  MOVF   FF3,W
0AD18:  MOVLB  5
0AD1A:  CLRF   xC8
0AD1C:  MOVWF  xC7
0AD1E:  MOVLW  7D
0AD20:  ADDWF  xC7,W
0AD22:  MOVWF  01
0AD24:  MOVLW  05
0AD26:  ADDWFC xC8,W
0AD28:  MOVWF  03
0AD2A:  MOVFF  01,5C9
0AD2E:  MOVWF  xCA
0AD30:  MOVWF  xD0
0AD32:  MOVFF  01,5CF
0AD36:  MOVLB  0
0AD38:  GOTO   9900
0AD3C:  MOVLB  5
0AD3E:  BCF    xBD.0
0AD40:  BTFSC  01.0
0AD42:  BSF    xBD.0
....................                if (doneSend!=0) 
0AD44:  BTFSS  xBD.0
0AD46:  BRA    AD74
....................                { 
....................                   debug_html(debug_html_putc, "\r\nHTML Done sending page "); 
....................                   //if (http_isKeepAlive[hs]) 
....................                   //   http_state[hs]=HTTP_CONNECTED; 
....................                   //else 
....................                   //   http_state[hs]=HTTP_CLOSE; 
....................                   http_state[g_HttpCurrConn] = HTTP_CLOSE; 
0AD48:  CLRF   03
0AD4A:  MOVLB  2
0AD4C:  MOVF   x2F,W
0AD4E:  ADDLW  11
0AD50:  MOVWF  FE9
0AD52:  MOVLW  02
0AD54:  ADDWFC 03,W
0AD56:  MOVWF  FEA
0AD58:  MOVLW  09
0AD5A:  MOVWF  FEF
....................                    
....................                   fstream = MPFSGetEnd();  
0AD5C:  MOVFF  FC,5BC
0AD60:  MOVFF  FB,5BB
0AD64:  MOVFF  FA,5BA
0AD68:  MOVFF  F9,5B9
....................                   MPFSClose(); 
0AD6C:  MOVLB  0
0AD6E:  CALL   79AA
0AD72:  MOVLB  5
.................... //                  fprintf(USER,"HTTP %U RESPONSE SENT\r\n", hs); 
....................                } 
....................             } 
....................             if ((TickGet() - http_timer[g_HttpCurrConn]) >= (TICK)15*TICKS_PER_SECOND) 
0AD74:  MOVLB  0
0AD76:  CALL   23FC
0AD7A:  MOVFF  03,5C6
0AD7E:  MOVFF  02,5C5
0AD82:  MOVFF  01,5C4
0AD86:  MOVFF  00,5C3
0AD8A:  MOVLB  2
0AD8C:  MOVF   x2F,W
0AD8E:  MULLW  04
0AD90:  MOVF   FF3,W
0AD92:  CLRF   03
0AD94:  ADDLW  97
0AD96:  MOVWF  FE9
0AD98:  MOVLW  05
0AD9A:  ADDWFC 03,W
0AD9C:  MOVWF  FEA
0AD9E:  MOVFF  FEF,00
0ADA2:  MOVFF  FEC,01
0ADA6:  MOVFF  FEC,02
0ADAA:  MOVFF  FEC,03
0ADAE:  MOVF   00,W
0ADB0:  MOVLB  5
0ADB2:  SUBWF  xC3,F
0ADB4:  MOVF   01,W
0ADB6:  SUBWFB xC4,F
0ADB8:  MOVF   02,W
0ADBA:  SUBWFB xC5,F
0ADBC:  MOVF   03,W
0ADBE:  SUBWFB xC6,F
0ADC0:  BNZ   ADDC
0ADC2:  MOVF   xC5,W
0ADC4:  SUBLW  06
0ADC6:  BC    ADF2
0ADC8:  XORLW  FF
0ADCA:  BNZ   ADDC
0ADCC:  MOVF   xC4,W
0ADCE:  SUBLW  26
0ADD0:  BC    ADF2
0ADD2:  XORLW  FF
0ADD4:  BNZ   ADDC
0ADD6:  MOVF   xC3,W
0ADD8:  SUBLW  0D
0ADDA:  BC    ADF2
....................             { 
....................                http_state[g_HttpCurrConn] = HTTP_CLOSE; 
0ADDC:  CLRF   03
0ADDE:  MOVLB  2
0ADE0:  MOVF   x2F,W
0ADE2:  ADDLW  11
0ADE4:  MOVWF  FE9
0ADE6:  MOVLW  02
0ADE8:  ADDWFC 03,W
0ADEA:  MOVWF  FEA
0ADEC:  MOVLW  09
0ADEE:  MOVWF  FEF
0ADF0:  MOVLB  5
....................             } 
....................             break; 
0ADF2:  MOVLB  0
0ADF4:  BRA    AF16
....................  
....................          case HTTP_CLOSE: 
....................             //since we set connection: close in the header, the client 
....................             //should automatically close.  but after so many seconds we 
....................             //shall kill the connection 
....................             /* 
....................             printf("\r\nClosing HTTP %U/%U.... ", hs, currSocket); 
....................                ui_disp_mac_user(&TCB[currSocket].remote.MACAddr); 
....................                printf(" MAC="); 
....................                ui_disp_ip_user(&TCB[currSocket].remote.IPAddr); 
....................                printf("\r\n"); 
....................                */ 
....................              
....................             http_state[g_HttpCurrConn]=HTTP_CLOSE_WAITING; 
0ADF6:  CLRF   03
0ADF8:  MOVLB  2
0ADFA:  MOVF   x2F,W
0ADFC:  ADDLW  11
0ADFE:  MOVWF  FE9
0AE00:  MOVLW  02
0AE02:  ADDWFC 03,W
0AE04:  MOVWF  FEA
0AE06:  MOVLW  0A
0AE08:  MOVWF  FEF
....................             http_timer[g_HttpCurrConn]=TickGet(); 
0AE0A:  MOVF   x2F,W
0AE0C:  MULLW  04
0AE0E:  MOVF   FF3,W
0AE10:  CLRF   03
0AE12:  ADDLW  97
0AE14:  MOVWF  01
0AE16:  MOVLW  05
0AE18:  ADDWFC 03,F
0AE1A:  MOVFF  01,5C3
0AE1E:  MOVFF  03,5C4
0AE22:  MOVLB  0
0AE24:  CALL   23FC
0AE28:  MOVFF  5C4,FEA
0AE2C:  MOVFF  5C3,FE9
0AE30:  MOVFF  00,FEF
0AE34:  MOVFF  01,FEC
0AE38:  MOVFF  02,FEC
0AE3C:  MOVFF  03,FEC
....................              
....................          case HTTP_CLOSE_WAITING: 
....................             TCPDiscard(g_HttpCurrSocket); 
0AE40:  MOVFF  22E,5C3
0AE44:  CALL   80CA
....................             if (   
....................                   (TCPGetTxFIFOFull(g_HttpCurrSocket) == 0) || 
....................                   (TickGetDiff(TickGet(),http_timer[g_HttpCurrConn]) > (TICKS_PER_SECOND*8)) 
0AE48:  MOVFF  22E,5C3
0AE4C:  CALL   9EA6
0AE50:  MOVFF  02,5C4
0AE54:  MOVFF  01,5C3
0AE58:  MOVLB  5
0AE5A:  MOVF   xC3,F
0AE5C:  BNZ   AE62
0AE5E:  MOVF   xC4,F
0AE60:  BZ    AECA
0AE62:  MOVLB  0
0AE64:  CALL   23FC
0AE68:  MOVFF  03,5C6
0AE6C:  MOVFF  02,5C5
0AE70:  MOVFF  01,5C4
0AE74:  MOVFF  00,5C3
0AE78:  MOVLB  2
0AE7A:  MOVF   x2F,W
0AE7C:  MULLW  04
0AE7E:  MOVF   FF3,W
0AE80:  CLRF   03
0AE82:  ADDLW  97
0AE84:  MOVWF  FE9
0AE86:  MOVLW  05
0AE88:  ADDWFC 03,W
0AE8A:  MOVWF  FEA
0AE8C:  MOVFF  FEF,00
0AE90:  MOVFF  FEC,01
0AE94:  MOVFF  FEC,02
0AE98:  MOVFF  FEC,03
0AE9C:  MOVF   00,W
0AE9E:  MOVLB  5
0AEA0:  SUBWF  xC3,F
0AEA2:  MOVF   01,W
0AEA4:  SUBWFB xC4,F
0AEA6:  MOVF   02,W
0AEA8:  SUBWFB xC5,F
0AEAA:  MOVF   03,W
0AEAC:  SUBWFB xC6,F
0AEAE:  BNZ   AECA
0AEB0:  MOVF   xC5,W
0AEB2:  SUBLW  02
0AEB4:  BC    AF12
0AEB6:  XORLW  FF
0AEB8:  BNZ   AECA
0AEBA:  MOVF   xC4,W
0AEBC:  SUBLW  CF
0AEBE:  BC    AF12
0AEC0:  XORLW  FF
0AEC2:  BNZ   AECA
0AEC4:  MOVF   xC3,W
0AEC6:  SUBLW  90
0AEC8:  BC    AF12
....................                ) 
....................             { 
....................                if (TCPGetTxFIFOFull(g_HttpCurrSocket) != 0) 
0AECA:  MOVFF  22E,5C3
0AECE:  MOVLB  0
0AED0:  CALL   9EA6
0AED4:  MOVFF  02,5C4
0AED8:  MOVFF  01,5C3
0AEDC:  MOVLB  5
0AEDE:  MOVF   xC3,F
0AEE0:  BNZ   AEE6
0AEE2:  MOVF   xC4,F
0AEE4:  BZ    AEF2
....................                { 
....................                   //socket is messed up.  just kill it by calling TCPDisconnect() twice. 
....................                   TCPDisconnect(g_HttpCurrSocket); 
0AEE6:  MOVFF  22E,5C3
0AEEA:  MOVLB  0
0AEEC:  CALL   3C20
0AEF0:  MOVLB  5
....................                } 
....................                TCPDisconnect(g_HttpCurrSocket); 
0AEF2:  MOVFF  22E,5C3
0AEF6:  MOVLB  0
0AEF8:  CALL   3C20
....................                http_state[g_HttpCurrConn]=HTTP_CLOSED; 
0AEFC:  CLRF   03
0AEFE:  MOVLB  2
0AF00:  MOVF   x2F,W
0AF02:  ADDLW  11
0AF04:  MOVWF  FE9
0AF06:  MOVLW  02
0AF08:  ADDWFC 03,W
0AF0A:  MOVWF  FEA
0AF0C:  MOVLW  0B
0AF0E:  MOVWF  FEF
0AF10:  MOVLB  5
....................             } 
....................             break; 
0AF12:  MOVLB  0
0AF14:  BRA    AF16
....................  
....................          case HTTP_CLOSED: //do nothing until socket actually closes 
....................          default: 
....................             break; 
....................       } 
....................        
....................      #if defined(__DO_DEBUG_HTML) 
0AF16:  MOVLB  2
0AF18:  INCF   x2F,F
0AF1A:  GOTO   9F1A
....................       //HTTP_NUM_SOCKETS 
....................       if (debug != http_state[g_HttpCurrConn]) 
....................       { 
....................          debug_html(debug_html_putc, "\r\nHTML %U %X->%X ", g_HttpCurrConn, debug, http_state[g_HttpCurrConn]); 
....................          debug = http_state[g_HttpCurrConn]; 
....................       } 
....................      #endif 
....................    } 
0AF1E:  MOVLB  0
0AF20:  GOTO   AF28 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
....................    #include "smtp.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TWITTER) 
....................    #include "ccs_twitter.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_EMAIL_ALERTS) 
....................    #include "ccs_email_alert.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) && !defined(__ANNOUNCE_C) 
....................    #include "Announce.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_ANNOUNCE) && !defined(__CCS_ANNOUNCE_C) 
....................    #include "ccs_announce.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP_CLIENT) 
....................    #include "ccs_http_client.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_FTP_SERVER) 
....................    #include "ccs_ftp_mdd.c" 
.................... #endif 
....................  
.................... #if defined(__18CXX) 
....................    #include "p18cxxx.c" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_C__ 
.................... #define __P18CXXXX_C__ 
....................  
.................... #include "p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
....................  
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
....................  
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F97J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................  #include "PIC18F4620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1) 
....................  
.................... #define __CCS__ 
....................  
.................... signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... rom char *strchrpgm(rom char* s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, rom char * s2); 
.................... __ADDRESS__ strlenpgm(rom char *s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, rom char *s); 
.................... signed int8 strcmppgm2ram(char *s1, rom char *s2); 
.................... #endif 
....................  
....................  
.................... signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n) 
.................... { 
....................    char *su1; 
....................    rom char *su2; 
....................     
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................          return ((*su1<*su2)?-1:+1); 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... __ADDRESS__ strlenpgm(rom char *s) 
.................... { 
....................    rom char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... #if 0 //this is in string.h and helpers.c 
.................... char* strupr(char *s) 
.................... { 
....................    char *p; 
....................     
....................    p=s; 
....................     
....................    while(*p) 
....................    { 
....................       *p = toupper(*p++); 
....................    } 
....................    return(s); 
.................... } 
.................... #endif 
....................  
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n) 
.................... { 
.................... //debug_printf(debug_putc, " ROM_0x%LX-to-0x%LX\r\n", s, d); 
....................   //#if (getenv("PROGRAM_MEMORY") > 0x10000) 
....................   #if 0 
....................    #warning temporary ccs bug fix 
....................    s |= 0x10000; 
....................   #endif 
....................    read_program_memory(s, d, n); 
*
07A42:  MOVFF  652,FF8
07A46:  MOVFF  651,FF7
07A4A:  MOVFF  650,FF6
07A4E:  MOVFF  64F,FEA
07A52:  MOVFF  64E,FE9
07A56:  MOVFF  655,657
07A5A:  MOVFF  654,656
07A5E:  RCALL  7A24
07A60:  RETURN 0
.................... } 
....................  
.................... void strcpypgm2ram(char *d, rom char *s) 
.................... { 
....................    char c; 
....................     
....................    do 
....................    { 
....................       c = *s; 
*
0896A:  CLRF   FF8
0896C:  MOVFF  5E0,FF7
08970:  MOVFF  5DF,FF6
08974:  MOVLW  05
08976:  MOVWF  FEA
08978:  MOVLW  E2
0897A:  MOVWF  FE9
0897C:  MOVLB  6
0897E:  CLRF   x57
08980:  MOVLW  01
08982:  MOVWF  x56
08984:  MOVLB  0
08986:  CALL   7A24
0898A:  MOVFF  5E2,5E1
....................       *d = c; 
0898E:  MOVLB  5
08990:  MOVFF  5DD,FE9
08994:  MOVFF  5DE,FEA
08998:  MOVFF  5E1,FEF
....................       d++; 
0899C:  INCF   xDD,F
0899E:  BTFSC  FD8.2
089A0:  INCF   xDE,F
....................       s++; 
089A2:  MOVFF  5E0,03
089A6:  MOVF   xDF,W
089A8:  INCF   xDF,F
089AA:  BTFSC  FD8.2
089AC:  INCF   xE0,F
....................    } while(c); 
089AE:  MOVF   xE1,F
089B0:  BTFSC  FD8.2
089B2:  BRA    89B8
089B4:  MOVLB  0
089B6:  BRA    896A
089B8:  MOVLB  0
089BA:  RETURN 0
.................... } 
....................  
.................... signed int8 strcmppgm2ram(char *s1, rom char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... rom char *strchrpgm(rom char* s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
....................  
.................... char *strstrrampgm(char *s1, rom char * s2) 
.................... { 
....................    char *s; 
....................    rom char *t; 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       while(*s1 != '\0' && *s1 != *s2) 
....................          ++s1; 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    #include "SNMP.c" 
....................     
....................    #if defined(STACK_USE_SNMPV3_SERVER) 
....................       #include "SNMPv3.c" 
....................    #endif 
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void) 
.................... { 
....................   #if defined(STACK_USE_DHCP_CLIENT) 
....................    return(!DHCPIsEnabled(0) || DHCPIsBound(0)); 
....................   #else 
....................    return(TRUE); 
....................   #endif 
.................... } 
....................  
.................... int1 IsLinked(void) 
.................... { 
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       return(MACIsLinked() && g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................     
....................    return(MACIsLinked() && DHCPBoundOrDisabled()); 
.................... } 
....................  
.................... #if defined(STACK_USE_MPFS) 
.................... MPFS _MpfsEofLoc; 
....................  
.................... unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n) 
*
08EBA:  MOVLB  5
08EBC:  CLRF   xF1
08EBE:  CLRF   xF0
08EC0:  BCF    xF6.0
.................... { 
....................    unsigned int16 ret = 0; 
....................    unsigned int16 i; 
....................    unsigned int8 *p; 
....................    int1 escaped = FALSE; 
....................     
....................    p = pDest; 
08EC2:  MOVFF  5ED,5F5
08EC6:  MOVFF  5EC,5F4
....................     
....................    debug_mpfs(debug_putc, "\r\nMPFSGetBytes() START %LX ", _currentHandle); 
....................     
....................    while(n) 
08ECA:  MOVF   xEE,W
08ECC:  IORWF  xEF,W
08ECE:  BTFSC  FD8.2
08ED0:  BRA    9004
....................    { 
....................      #if defined(HTTP_INTERRUPT_TASKS) 
....................       HTTP_INTERRUPT_TASKS(); 
....................      #endif 
....................        
....................       debug_mpfs(debug_putc, "n=%LX ", n); 
....................        
....................       //_MpfsEofLoc = _currentHandle; 
....................      #if defined(MPFS_USE_SPI_FLASH) 
....................       SPIFlashReadArray(_currentHandle, pDest, n); 
....................      #else 
....................       memcpypgm2ram(pDest, _currentHandle, n); //__ccs__ change because MPFS isn't rom pointer 
08ED2:  MOVFF  5ED,64F
08ED6:  MOVFF  5EC,64E
08EDA:  MOVFF  FC,653
08EDE:  MOVFF  FB,652
08EE2:  MOVFF  FA,651
08EE6:  MOVFF  F9,650
08EEA:  MOVFF  5EF,655
08EEE:  MOVFF  5EE,654
08EF2:  MOVLB  0
08EF4:  CALL   7A42
....................      #endif 
....................  
....................       //_currentHandle += n;  //removed when removing _MpfsEofLoc 
....................  
....................       //debug_array("START", pDest, n); 
....................  
....................       i = n; 
08EF8:  MOVFF  5EF,5F3
08EFC:  MOVFF  5EE,5F2
....................       n = 0; 
08F00:  MOVLB  5
08F02:  CLRF   xEF
08F04:  CLRF   xEE
....................        
....................       while(i--) 
08F06:  MOVFF  5F3,03
08F0A:  MOVF   xF2,W
08F0C:  BTFSC  FD8.2
08F0E:  DECF   xF3,F
08F10:  DECF   xF2,F
08F12:  IORWF  03,W
08F14:  BTFSC  FD8.2
08F16:  BRA    9002
....................       { 
....................          _currentHandle++; //_MpfsEofLoc++; 
08F18:  MOVLW  01
08F1A:  MOVLB  0
08F1C:  ADDWF  xF9,F
08F1E:  BTFSC  FD8.0
08F20:  INCF   xFA,F
08F22:  BTFSC  FD8.2
08F24:  INCF   xFB,F
08F26:  BTFSC  FD8.2
08F28:  INCF   xFC,F
....................          if (escaped || (*pDest == MPFS_DLE)) 
08F2A:  MOVLB  5
08F2C:  BTFSC  xF6.0
08F2E:  BRA    8F42
08F30:  MOVFF  5ED,03
08F34:  MOVFF  5EC,FE9
08F38:  MOVFF  5ED,FEA
08F3C:  MOVF   FEF,W
08F3E:  SUBLW  03
08F40:  BNZ   8FB2
....................          { 
....................             if (!escaped) 
08F42:  BTFSC  xF6.0
08F44:  BRA    8F4C
....................             { 
....................                n++; 
08F46:  INCF   xEE,F
08F48:  BTFSC  FD8.2
08F4A:  INCF   xEF,F
....................             } 
....................              
....................             if (escaped || i) 
08F4C:  BTFSC  xF6.0
08F4E:  BRA    8F56
08F50:  MOVF   xF2,W
08F52:  IORWF  xF3,W
08F54:  BZ    8FA6
....................             { 
....................                if (!escaped) 
08F56:  BTFSC  xF6.0
08F58:  BRA    8F9C
....................                { 
....................                   debug_mpfs(debug_putc, "! "); 
....................                   memmove(pDest, pDest+1, i); 
08F5A:  MOVLW  01
08F5C:  ADDWF  xEC,W
08F5E:  MOVWF  xF7
08F60:  MOVLW  00
08F62:  ADDWFC xED,W
08F64:  MOVWF  xF8
08F66:  MOVFF  5ED,5FA
08F6A:  MOVFF  5EC,5F9
08F6E:  MOVWF  xFC
08F70:  MOVFF  5F7,5FB
08F74:  MOVFF  5F3,5FE
08F78:  MOVFF  5F2,5FD
08F7C:  MOVLB  0
08F7E:  CALL   7636
....................                   _currentHandle++;   //_MpfsEofLoc++; 
08F82:  MOVLW  01
08F84:  ADDWF  xF9,F
08F86:  BTFSC  FD8.0
08F88:  INCF   xFA,F
08F8A:  BTFSC  FD8.2
08F8C:  INCF   xFB,F
08F8E:  BTFSC  FD8.2
08F90:  INCF   xFC,F
....................                   i--; 
08F92:  MOVLB  5
08F94:  MOVF   xF2,W
08F96:  BTFSC  FD8.2
08F98:  DECF   xF3,F
08F9A:  DECF   xF2,F
....................                } 
....................                ret++; 
08F9C:  INCF   xF0,F
08F9E:  BTFSC  FD8.2
08FA0:  INCF   xF1,F
....................                escaped = FALSE; 
08FA2:  BCF    xF6.0
....................             } 
08FA4:  BRA    8FB0
....................             else 
....................             { 
....................                escaped = TRUE; 
08FA6:  BSF    xF6.0
....................                pDest--; //counter pDest++ below, since we need to start saving new bytes here 
08FA8:  MOVF   xEC,W
08FAA:  BTFSC  FD8.2
08FAC:  DECF   xED,F
08FAE:  DECF   xEC,F
....................             } 
....................          } 
08FB0:  BRA    8FFA
....................          else if(*pDest == MPFS_ETX) 
08FB2:  MOVFF  5ED,03
08FB6:  MOVFF  5EC,FE9
08FBA:  MOVFF  5ED,FEA
08FBE:  MOVF   FEF,W
08FC0:  SUBLW  04
08FC2:  BNZ   8FF4
....................          { 
....................             _MpfsEofLoc = _currentHandle - 1;   //_MpfsEofLoc--; 
08FC4:  MOVLW  01
08FC6:  MOVLB  0
08FC8:  SUBWF  xF9,W
08FCA:  MOVWF  xFD
08FCC:  MOVLW  00
08FCE:  SUBWFB xFA,W
08FD0:  MOVWF  xFE
08FD2:  MOVLW  00
08FD4:  SUBWFB xFB,W
08FD6:  MOVWF  xFF
08FD8:  MOVLW  00
08FDA:  SUBWFB xFC,W
08FDC:  MOVLB  1
08FDE:  MOVWF  x00
....................             debug_mpfs(debug_putc, "EOF %LX ", _currentHandle);  //debug_mpfs2(debug_putc, "EOF %LX ", _MpfsEofLoc); 
....................             _currentHandle = MPFS_INVALID; 
08FE0:  MOVLB  0
08FE2:  SETF   xFC
08FE4:  SETF   xFB
08FE6:  SETF   xFA
08FE8:  SETF   xF9
....................             n = 0; 
08FEA:  MOVLB  5
08FEC:  CLRF   xEF
08FEE:  CLRF   xEE
....................             break; 
08FF0:  BRA    9002
....................          } 
08FF2:  BRA    8FFA
....................          else 
....................          { 
....................             ret++; 
08FF4:  INCF   xF0,F
08FF6:  BTFSC  FD8.2
08FF8:  INCF   xF1,F
....................          } 
....................          pDest++; 
08FFA:  INCF   xEC,F
08FFC:  BTFSC  FD8.2
08FFE:  INCF   xED,F
09000:  BRA    8F06
....................       } 
09002:  BRA    8ECA
....................    } 
....................     
....................    if (_currentHandle != MPFS_INVALID) 
09004:  MOVLB  0
09006:  INCFSZ xF9,W
09008:  BRA    9018
0900A:  INCFSZ xFA,W
0900C:  BRA    9018
0900E:  INCFSZ xFB,W
09010:  BRA    9018
09012:  INCFSZ xFC,W
09014:  BRA    9018
09016:  BRA    9028
....................       _MpfsEofLoc = _currentHandle; 
09018:  MOVFF  FC,100
0901C:  MOVFF  FB,FF
09020:  MOVFF  FA,FE
09024:  MOVFF  F9,FD
....................    
....................    //debug_array("STOP", p, ret);    
....................  
....................    return(ret); 
09028:  MOVLB  5
0902A:  MOVFF  5F0,01
0902E:  MOVFF  5F1,02
09032:  MOVLB  0
09034:  GOTO   918C (RETURN)
.................... } 
.................... #ENDIF 
....................  
.................... #if STACK_USE_WIFI 
....................  
.................... //extern int1 g_WifiTempDisFlag; 
.................... //extern TICK g_WifiTempDisTick; 
.................... //extern int1 g_wifiConnected; 
.................... extern int1 g_WifiConnectFail; 
....................  
.................... // see StackTsk2.h for documentation 
.................... #if 0 
.................... int1 MyWFisConnected(void) 
.................... { 
....................    int1 ret = FALSE; 
....................  
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................       return(g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................  
....................    if (g_wifiConnected) 
....................    { 
....................       ret = TRUE; 
....................    } 
....................    else if (!g_WifiConnectFail) 
....................    { 
....................       if (g_WifiTempDisFlag) 
....................       { 
....................          if ((TickGet() - g_WifiTempDisTick) < ((TICK)5*TICKS_PER_SECOND)) 
....................          { 
....................             ret = TRUE; 
....................          } 
....................          else 
....................          { 
....................             g_WifiTempDisFlag = FALSE; 
....................          } 
....................       } 
....................    } 
....................  
....................    return(ret); 
.................... } 
.................... #endif 
....................  
.................... unsigned int8 g_connectionProfileID = 0xFF;  //used to communicate with the connection profile on the WiFi module 
....................  
.................... unsigned int8 WIFI_channelList[16]; 
.................... unsigned int8 WIFI_numChannelsInList; 
.................... unsigned int8 WIFI_region; 
....................  
.................... // this option will force the connection profile to be closed and reopened 
.................... // if we do not get a connection within this time.  might fix an errata that 
.................... // says WPA/WPA2 will lockup instead of sending an event. 
.................... #define WIFI_FORCE_RECONNECT_TICK   (TICK)(TICKS_PER_SECOND * 120)  //might be too short for WPA/WPA2 phrase 
....................  
.................... #if defined(WIFI_GET_VERSION_INFO) 
.................... extern tWFDeviceInfo WIFI_GET_VERSION_INFO; 
.................... #endif 
....................  
.................... int1 g_WIFIConnectStart; 
....................  
.................... void WIFIConnectInitStates(void) 
.................... { 
....................    wf_debug_printf(wf_debug_putc, "\r\nWIFIConnectInitStates"); 
....................     
....................    g_connectionProfileID = 0xFF; 
....................     
....................    g_WIFIConnectStart = TRUE; 
....................     
....................    g_WifiConnectFail = FALSE;    
....................     
....................   #if defined(STACK_USE_CCS_SCAN_TASK) 
....................    WIFIScanInit(); 
....................   #endif 
....................  
....................         #if defined(WIFI_GET_VERSION_INFO) 
....................          WF_GetDeviceInfo(&WIFI_GET_VERSION_INFO); 
....................         #endif  
....................  
....................          WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);   // was WF_ACTIVE_SCAN 
....................  
....................          WF_CASetChannelList(WIFI_channelList, WIFI_numChannelsInList); //was AppConfig.channelList, AppConfig.numChannelsInList 
....................  
....................          WF_SetRegionalDomain(WIFI_region);  //was AppConfig.region 
....................           
....................          WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);  // was WF_RETRY_FOREVER 
....................           
....................          WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST); // was WF_NOTIFY_ALL_EVENTS 
....................           
....................          WF_CASetBeaconTimeout(MY_DEFAULT_BEACON_TIMEOUT); 
....................  
....................          WF_CASetBeaconTimeoutAction(WF_ATTEMPT_TO_RECONNECT); 
....................           
....................          WF_CASetDeauthAction(WF_ATTEMPT_TO_RECONNECT); 
....................  
....................        #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................            if (AppConfig.SecurityMode == WF_SECURITY_WPA_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA2_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) { 
....................                WF_ConvPassphrase2Key(AppConfig.SecurityKeyLength, AppConfig.SecurityKey, 
....................                    AppConfig.SsidLength, AppConfig.MySSID); 
....................                AppConfig.SecurityMode--; 
....................                AppConfig.SecurityKeyLength = 32; 
....................            } 
....................        #if defined (MRF24WG) 
....................            else if (AppConfig.SecurityMode == WF_SECURITY_WPS_PUSH_BUTTON 
....................                        || AppConfig.SecurityMode == WF_SECURITY_WPS_PIN) { 
....................                WF_YieldPassphrase2Host();     
....................            } 
....................        #endif    // defined (MRF24WG) 
....................        #endif    // defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................  
....................      #ifndef WF_FORCE_NO_PS_POLL 
....................       #if MY_DEFAULT_PS_POLL == WF_ENABLED 
....................            WF_PsPollEnable(TRUE); 
....................        #if !defined(MRF24WG)  
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableDeferredPowerSave(); 
....................        #endif    // !defined(MRF24WG) 
....................       #else     // MY_DEFAULT_PS_POLL != WF_ENABLED 
....................            WF_PsPollDisable(); 
....................       #endif    // MY_DEFAULT_PS_POLL == WF_ENABLED 
....................     
....................       #ifdef WF_AGGRESSIVE_PS 
....................        #if !defined(MRF24WG) 
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableAggressivePowerSave(); 
....................        #endif 
....................       #endif 
....................      #endif  
.................... } 
....................  
.................... void WIFIConnectStop(void) 
.................... { 
....................    if (!MACIsLinked() || (g_connectionProfileID == 0xFF)) 
....................    { 
....................       wf_debug_printf(wf_debug_putc, "\r\n\n*** Reset of MAC because WIFIConnectStop()\r\n"); 
....................       MACInit(); 
....................    } 
....................   #if defined(WF_DEBUG) 
....................    else 
....................    { 
....................       wf_debug_printf(wf_debug_putc, "\r\nWIFIConnectStop"); 
....................    } 
....................   #endif 
....................     
....................    g_WIFIConnectStart = FALSE; 
.................... } 
....................  
.................... void WIFIConnectStart(void) 
.................... { 
....................    wf_debug_printf(wf_debug_putc, "\r\nWIFIConnectStart"); 
....................     
....................    g_WIFIConnectStart = TRUE; 
.................... } 
....................  
.................... // this was based off of WF_Connect() in Microchip's demo application. 
.................... void WIFIConnectTask(void) 
.................... { 
....................    #if !defined(APP_GENERIC_SCRATCH) 
....................       char WIFIConnectTask_Scratch[6]; 
....................    #else 
....................       #define WIFIConnectTask_Scratch  APP_GENERIC_SCRATCH 
....................    #endif 
....................     
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    static TICK fTick; 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) || defined(LED_ACTIVITY_ON) 
....................    static TICK l; 
....................    // if you have both LED_CONNECTION_ON and LED_ACTIVITY_ON (2 WIFI LEDs),  
....................    //    then one LED is used for flickering on traffic and another is used to  
....................    //    show connection state. 
....................    // if you only have LED_CONNECTION_ON (only 1 WIFI LED), then WIFI  
....................    //    connection status and wifi traffic flickering is shared on the same 
....................    //    LED. 
....................    // this routine below handles the traffic led flickering.  the LED was 
....................    //    turned off in the TCP/IP stack, this routine turns it back on every 
....................    //    200ms. 
....................    if ((TickGet() - l) >= TICKS_PER_SECOND/5) 
....................    { 
....................       l = TickGet(); 
....................        
....................      #if defined(LED_ACTIVITY_ON) 
....................       LED_ACTIVITY_OFF(); 
....................      #else 
....................       if (IsLinked()) 
....................       { 
....................          LED_CONNECTION_ON(); 
....................       } 
....................       else 
....................       { 
....................          LED_CONNECTION_OFF(); 
....................       } 
....................      #endif 
....................    } 
....................   #endif 
....................  
....................   #if defined(STACK_USE_CCS_SCAN_TASK) 
....................    WIFIScanTask(); 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) && defined(LED_ACTIVITY_ON) 
....................    // handle the connection status LED if you have 2 WIFI LEDs. 
....................    if (IsLinked()) 
....................    { 
....................       LED_CONNECTION_ON(); 
....................    } 
....................    else 
....................    { 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................   #endif 
....................  
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................    } 
....................   #endif 
....................  
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    if ( 
....................          (AppConfig.networkType != WF_ADHOC) && 
....................          (g_connectionProfileID != 0xFF) 
....................       ) 
....................    { 
....................       if (IsLinked()) 
....................       { 
....................          fTick = TickGet(); 
....................       } 
....................       else if ((TickGet() - fTick) > WIFI_FORCE_RECONNECT_TICK) 
....................       { 
....................         #if defined(STACK_IS_CCS_EXAMPLE) 
....................          fprintf(STREAM_UI, "\r\nLong WIFI connection timeout, reseting module"); 
....................         #endif 
....................          MACInit(); 
....................         #if defined(WIFI_EXTRA_LINK_STATUS) 
....................          g_LastWifiEvent = 20; 
....................         #endif 
....................       } 
....................    } 
....................   #endif 
....................  
....................    if ((g_connectionProfileID == 0xFF) && g_WIFIConnectStart) 
....................    { 
....................       g_WifiConnectFail = FALSE; 
....................        
....................       WF_CPCreate(&g_connectionProfileID); 
....................        
....................       wf_debug_printf(wf_debug_putc, "\r\nCreating connect profile... "); 
....................        
....................       if (g_connectionProfileID != 0xFF) 
....................       { 
....................          /* 
....................         #if defined(WIFI_GET_VERSION_INFO) 
....................          WF_GetDeviceInfo(&WIFI_GET_VERSION_INFO); 
....................         #endif 
....................         */ 
....................          wf_debug_printf(wf_debug_putc, "%U ", g_connectionProfileID); 
....................  
....................          g_WifiConnectFail = TRUE; 
....................  
....................          WF_CPSetSsid(g_connectionProfileID,  
....................                     AppConfig.MySSID,  
....................                     AppConfig.SsidLength); 
....................           
....................          memset(WIFIConnectTask_Scratch, 0xFF, 6); 
....................          WF_CPSetBssid(g_connectionProfileID, WIFIConnectTask_Scratch); 
....................  
....................          WF_CPSetNetworkType(g_connectionProfileID, AppConfig.networkType); 
....................           
....................          if(AppConfig.networkType == WF_ADHOC) 
....................          { 
....................             WF_CPSetAdHocBehavior(g_connectionProfileID, AppConfig.adhocBehavior); 
....................          } 
....................  
....................          /* 
....................          WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);   // was WF_ACTIVE_SCAN 
....................  
....................          WF_CASetChannelList(WIFI_channelList, WIFI_numChannelsInList); //was AppConfig.channelList, AppConfig.numChannelsInList 
....................  
....................          WF_SetRegionalDomain(WIFI_region);  //was AppConfig.region 
....................           
....................          WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);  // was WF_RETRY_FOREVER 
....................           
....................          WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST); // was WF_NOTIFY_ALL_EVENTS 
....................           
....................          WF_CASetBeaconTimeout(MY_DEFAULT_BEACON_TIMEOUT); 
....................  
....................          WF_CASetBeaconTimeoutAction(WF_ATTEMPT_TO_RECONNECT); 
....................           
....................          WF_CASetDeauthAction(WF_ATTEMPT_TO_RECONNECT); 
....................  
....................        #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................            if (AppConfig.SecurityMode == WF_SECURITY_WPA_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA2_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) { 
....................                WF_ConvPassphrase2Key(AppConfig.SecurityKeyLength, AppConfig.SecurityKey, 
....................                    AppConfig.SsidLength, AppConfig.MySSID); 
....................                AppConfig.SecurityMode--; 
....................                AppConfig.SecurityKeyLength = 32; 
....................            } 
....................        #if defined (MRF24WG) 
....................            else if (AppConfig.SecurityMode == WF_SECURITY_WPS_PUSH_BUTTON 
....................                        || AppConfig.SecurityMode == WF_SECURITY_WPS_PIN) { 
....................                WF_YieldPassphrase2Host();     
....................            } 
....................        #endif    // defined (MRF24WG) 
....................        #endif    // defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................        */ 
....................  
....................          WF_CPSetSecurity(g_connectionProfileID, 
....................                         AppConfig.SecurityMode, 
....................                         0, //AppConfig.WepKeyIndex, //AppConfig.WepKeyIndex,   /* only used if WEP enabled */ 
....................                         AppConfig.SecurityKey, 
....................                         AppConfig.SecurityKeyLength);       
....................   
....................       #if (MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE!=WF_SECURITY_WEP_SHAREDKEY) 
....................         #if !defined(MRF24WG) 
....................          if (gRFModuleVer1209orLater) 
....................         #endif 
....................          { 
....................             // If WEP security is used, set WEP Key Type.  The default WEP Key Type is Shared Key. 
....................             if ((AppConfig.SecurityMode == WF_SECURITY_WEP_40) || (AppConfig.SecurityMode == WF_SECURITY_WEP_104)) 
....................             { 
....................                 WF_CPSetWepKeyType(g_connectionProfileID, MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE); 
....................             } 
....................          } 
....................      #endif 
....................  
....................          /* 
....................        #ifndef WF_FORCE_NO_PS_POLL 
....................        #if MY_DEFAULT_PS_POLL == WF_ENABLED 
....................            WF_PsPollEnable(TRUE); 
....................        #if !defined(MRF24WG)  
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableDeferredPowerSave(); 
....................        #endif    // !defined(MRF24WG) 
....................        #else     // MY_DEFAULT_PS_POLL != WF_ENABLED 
....................            WF_PsPollDisable(); 
....................        #endif    // MY_DEFAULT_PS_POLL == WF_ENABLED 
....................     
....................        #ifdef WF_AGGRESSIVE_PS 
....................        #if !defined(MRF24WG) 
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableAggressivePowerSave(); 
....................        #endif 
....................        #endif 
....................        #endif 
....................          */ 
....................       } 
....................    } 
....................  
....................    if(g_WifiConnectFail && g_WIFIConnectStart) 
....................    { 
....................       wf_debug_printf(wf_debug_putc, "\r\nStart WiFi Connect PROF=%u ", g_connectionProfileID); 
....................       
....................      #if defined(STACK_IS_CCS_EXAMPLE) 
....................       fprintf(STREAM_UI, "\r\nStart WiFi Connect"); 
....................      #endif 
....................       
....................      #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................       fTick = TickGet(); 
....................      #endif 
....................       
....................      #if defined(STACK_USE_CCS_SCAN_TASK) 
....................       WIFIScanIgnoreResults(); 
....................      #endif     
....................  
....................      #if defined(WF_FORCE_NO_PS_POLL) 
....................       WF_CCS_PsPollDisable(); 
....................      #endif 
....................     
....................       WF_CMConnect(g_connectionProfileID); 
....................    } 
....................     
....................    g_WifiConnectFail = 0; 
.................... } 
....................  
.................... void LinkTraffic(int1 isTx) 
.................... { 
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (!isTx && (AppConfig.networkType == WF_ADHOC)) 
....................    { 
....................       g_WifiAdhocIsConn = TRUE; 
....................       g_WifiAdhocTickConn = TickGet(); 
....................    } 
....................   #endif 
....................  
....................    // these LEDs are desribed in WIFIConnectTask() 
....................   #if defined(LED_ACTIVITY_ON) 
....................    LED_ACTIVITY_ON(); 
....................   #elif defined(LED_CONNECTION_ON) 
....................    LED_CONNECTION_OFF(); 
....................   #endif 
.................... } 
....................  
....................  
.................... #if defined(WF_FORCE_NO_PS_POLL) 
.................... #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................    #error dont use both at the same time 
.................... #endif 
.................... typedef struct pwrModeRequestStruct 
.................... { 
....................     UINT8 mode; 
....................     UINT8 wake; 
....................     UINT8 rcvDtims; 
....................     UINT8 reserved;            /* pad byte */ 
.................... } tWFPwrModeReq; 
....................  
.................... static void SendPowerModeMsg(tWFPwrModeReq *p_powerMode) 
.................... { 
....................     UINT8 hdr[2]; 
....................      
....................     hdr[0] = WF_MGMT_REQUEST_TYPE; 
....................     hdr[1] = WF_SET_POWER_MODE_SUBTYPE; 
....................  
....................     SendMgmtMsg(hdr, 
....................                 sizeof(hdr), 
....................                (UINT8 *)p_powerMode, 
....................                sizeof(tWFPwrModeReq)); 
....................  
....................     /* wait for mgmt response, free buffer after it comes in (no data to read) */ 
....................    WaitForMgmtResponse(WF_SET_POWER_MODE_SUBTYPE, FREE_MGMT_BUFFER); 
....................      
.................... }  
....................  
.................... void WF_CCS_PsPollDisable(void) 
.................... { 
....................    tWFPwrModeReq   pwrModeReq; 
....................      
....................     pwrModeReq.mode     = 1;  //PS_POLL_DISABLED; 
....................     pwrModeReq.wake     = 1; 
....................     pwrModeReq.rcvDtims = 1; 
....................     SendPowerModeMsg(&pwrModeReq); 
....................  
....................     //SetPowerSaveState(WF_PS_OFF); //not really needed, sets a global for their statemachine 
....................  
....................     WFConfigureLowPowerMode(WF_LOW_POWER_MODE_OFF);  
.................... } 
.................... #endif   //WF_FORCE_NO_PS_POLL 
....................  
.................... #endif //STACK_USE_WIFI 
....................  
.................... #if defined(__DO_DEBUG_MPFS) 
.................... void debug_array(char *str, char *p, unsigned int16 n) 
.................... { 
....................    char c; 
....................    debug_mpfs(debug_putc, "\r\n%s %LX ", str, n); 
....................    while(n--) 
....................    { 
....................       c = *p++; 
....................       if ((c >= ' ') && (c <= '}')) 
....................       { 
....................          debug_mpfs(debug_putc, "%c", c); 
....................       } 
....................       else 
....................       { 
....................          debug_mpfs(debug_putc, "+%X", c); 
....................       } 
....................    } 
....................    debug_mpfs(debug_putc, " "); 
.................... } 
.................... #else 
.................... #define debug_array(str, p, n) 
.................... #endif 
....................  
.................... // if you call TickGet() from an ISR, this may be a lock-up condition. 
.................... // this is a morph of GetTickCopy() and TickUpdate() that works from an ISR. 
.................... // only works on PIC18. 
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void) 
.................... { 
....................    BYTE myTickReading[6]; 
....................    do 
....................    { 
....................       if(INTCONbits.TMR0IF) 
....................       { 
....................          dwInternalTicks++; 
....................          INTCONbits.TMR0IF = 0; 
....................       } 
....................       myTickReading[0] = TMR0L; 
....................       myTickReading[1] = TMR0H; 
....................       *((DWORD*)&myTickReading[2]) = dwInternalTicks; 
....................    } while(INTCONbits.TMR0IF); 
....................     
....................    return *((DWORD*)&myTickReading[0]); 
.................... } 
.................... #endif 
....................  
.................... // this used to be called GenerateRandomBYTE() in an older CCS port of Helpers.c 
.................... BYTE GenerateRandomByteFromTimers(void) 
.................... { 
....................    BYTE rand; 
....................     
....................   #if getenv("TIMER0") && !defined(__PCD__) 
....................    rand+=get_timer0(); 
....................   #endif 
....................    
....................   #if getenv("TIMER1") 
....................    rand+=get_timer1(); 
....................   #endif 
....................    
....................   #if getenv("TIMER2") 
....................    rand+=get_timer2(); 
....................   #endif 
....................    
....................   #if getenv("TIMER3") 
....................    rand+=get_timer3(); 
....................   #endif 
....................    
....................   #if getenv("TIMER4") 
....................    rand+=get_timer4(); 
....................   #endif 
....................    
....................   #if getenv("TIMER5") 
....................    rand+=get_timer5(); 
....................   #endif 
....................    
....................    return(rand); 
.................... } 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... //SNMP CALLBACK VARIABLES 
.................... BYTE gSendTrapFlag = FALSE; 
.................... BYTE gGenericTrapNotification = ENTERPRISE_SPECIFIC; 
.................... BYTE gSpecificTrapNotification = VENDOR_TRAP_DEFAULT; 
.................... BYTE gOIDCorrespondingSnmpMibID = 0; 
....................  
.................... BYTE SNMPValidateCommunity(BYTE * community) 
.................... { 
....................    BYTE i; 
....................    BYTE *ptr; 
....................     
....................    /* 
....................    If the community name is encrypted in the request from the Manager, 
....................    agent required to decrypt it to match with the community it is 
....................    configured for. The response from the agent should contain encrypted community  
....................    name using the same encryption algorithm which Manager used while 
....................    making the request. 
....................    */        
....................  
....................    // Validate that community string is a legal size 
....................    if(strlen((char*)community) <= SNMP_COMMUNITY_MAX_LEN) 
....................    { 
....................       // Search to see if this is a write community.  This is done before  
....................       // searching read communities so that full read/write access is  
....................       // granted if a read and write community name happen to be the same. 
....................       for(i = 0; i < SNMP_MAX_COMMUNITY_SUPPORT; i++) 
....................       { 
....................          ptr = AppConfig.writeCommunity[i]; 
....................          if(ptr == NULL) 
....................             continue; 
....................          if(*ptr == 0x00u) 
....................             continue; 
....................          if(strncmp((char*)community, (char*)ptr, SNMP_COMMUNITY_MAX_LEN) == 0) 
....................          { 
....................             debug_snmp(debug_putc, "SNMPValidateCommunity('%s') WRITE\r\n", community); 
....................             return WRITE_COMMUNITY; 
....................          } 
....................       } 
....................        
....................       // Did not find in write communities, search read communities 
....................       for(i = 0; i < SNMP_MAX_COMMUNITY_SUPPORT; i++) 
....................       { 
....................          ptr = AppConfig.readCommunity[i]; 
....................          if(ptr == NULL) 
....................             continue; 
....................          if(*ptr == 0x00u) 
....................             continue; 
....................          if(strncmp((char*)community, (char*)ptr, SNMP_COMMUNITY_MAX_LEN) == 0) 
....................          { 
....................             debug_snmp(debug_putc, "SNMPValidateCommunity('%s') READ\r\n", community); 
....................             return READ_COMMUNITY; 
....................          } 
....................       } 
....................    } 
....................     
....................    debug_snmp(debug_putc, "SNMPValidateCommunity('%s') INVALID\r\n", community); 
....................     
....................    // Could not find any matching community, set up to send a trap 
....................    gSpecificTrapNotification=VENDOR_TRAP_DEFAULT; 
....................    gGenericTrapNotification=AUTH_FAILURE; 
....................    gSendTrapFlag=TRUE; 
....................    return INVALID_COMMUNITY;   
.................... } 
.................... #endif   //if defined(STACK_USE_SNMP_SERVER) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* TODO: Web server enabled. Server files are added to the /pages 
.................... directory. You can modify the contents of the dynamic display fields 
.................... at the end of the index.htm file. By default, headings are in the left 
.................... column and the dynamic display elements are in the right. The text on 
.................... the input buttons can be set by changing the 'value' strings in the 
.................... form section. Dynamic display elements can be added or removed from 
.................... index.htm and index.xml */ 
.................... /* TODO: Server files must be built into an MPFS image prior to  
.................... compiling and runing the web server. Running makempfsimg.bat in the 
.................... /mpfs directory will create an MPFS image of the files in /pages. 
.................... A new MPFS image has to be compiled and re-loaded if a file in 
.................... /pages needs to be changed. */ 
....................  
.................... unsigned int8 http_format_char(char* file, char id, char *str, unsigned int8 max_ret) 
*
09864:  MOVLB  5
09866:  CLRF   xF5
.................... { 
....................   /**************************  FUNCIN FORMAT CHAR  *****************************/ 
.................... /* Con  la funcin http_format_char  interconectamos las variables virtuales de  
.................... la pgina web con las variables del programa del PIC. Se encarga de enviar los  
.................... cambios producidos en la aplicacin del PIC y reflejarlos en la aplicacin web.  
.................... Muestra,por tanto, las lectura obtenidas por el PIC y las representa en la  
.................... aplicacin de la pgina web                
....................                                           
.................... %0 es la variable virtual para representar el valor de la lectura del canal  
.................... analgico 
.................... %1 es la variable virtual para representar el valor de la lectura del bit 0 del  
.................... puerto E. 
.................... */ 
....................    char new_str[20];                                               
....................    int8 len=0; 
....................    int8 AD0; 
....................     
....................                                                    
....................     if (id == 0) 
09868:  CLRF   03
0986A:  MOVF   xDD,W
0986C:  MOVWF  00
0986E:  BTFSC  FE8.7
09870:  DECF   03,F
09872:  XORLW  00
09874:  BNZ   98FA
09876:  MOVF   03,F
09878:  BNZ   98FA
....................    { 
....................          //TODO: Handle dyn0 field and save result to str 
....................           set_adc_channel(0);                              
0987A:  MOVLW  00
0987C:  MOVWF  01
0987E:  MOVF   FC2,W
09880:  ANDLW  C3
09882:  IORWF  01,W
09884:  MOVWF  FC2
....................          delay_us(100); 
09886:  MOVLW  64
09888:  MOVWF  xF7
0988A:  MOVLB  0
0988C:  BRA    97F2
....................          AD0=read_adc(); 
0988E:  BSF    FC2.1
09890:  BTFSC  FC2.1
09892:  BRA    9890
09894:  MOVFF  FC4,5F6
09898:  MOVLB  5
....................          sprintf(new_str,"0x%X",AD0); 
0989A:  MOVLW  05
0989C:  MOVWF  x5F
0989E:  MOVLW  E1
098A0:  MOVWF  x5E
098A2:  MOVLW  30
098A4:  MOVWF  xF9
098A6:  MOVLB  0
098A8:  CALL   796A
098AC:  MOVLW  78
098AE:  MOVLB  5
098B0:  MOVWF  xF9
098B2:  MOVLB  0
098B4:  CALL   796A
098B8:  MOVFF  5F6,5F7
098BC:  MOVLW  37
098BE:  MOVLB  5
098C0:  MOVWF  xF8
098C2:  MOVLB  0
098C4:  BRA    9818
....................          len=strlen(new_str); 
098C6:  MOVLW  05
098C8:  MOVLB  6
098CA:  MOVWF  x4F
098CC:  MOVLW  E1
098CE:  MOVWF  x4E
098D0:  MOVLB  0
098D2:  CALL   7068
098D6:  MOVFF  01,5F5
....................          strncpy(str, new_str, max_ret); 
098DA:  MOVFF  5DF,5F8
098DE:  MOVFF  5DE,5F7
098E2:  MOVLW  05
098E4:  MOVLB  5
098E6:  MOVWF  xFA
098E8:  MOVLW  E1
098EA:  MOVWF  xF9
098EC:  CLRF   xFC
098EE:  MOVFF  5E0,5FB
098F2:  MOVLB  0
098F4:  CALL   7CA8
098F8:  MOVLB  5
....................    }            
098FA:  MOVLB  0
098FC:  GOTO   9D72 (RETURN)
.................... } 
....................  
.................... void http_exec_cgi(char* file, char *key, char *val)          
.................... { 
.................... /* Con la funcin http_exec_cgi interconectamos las variables virtuales de la  
.................... pgina web con las variables del programa del PIC. Se encarga de recibir  
.................... los cambios producidos en la aplicacin web y reflejarlos en el hardware del PIC.  
.................... Ejecuta, por tanto, la accin elegida segn el valor de la variable virtual recibida  
.................... de la pgina web 
....................  
.................... key es la variable virtual que viene de la pagina web 
.................... val es el valor de una variable virtual de la pgina web 
.................... file es la direccin de la pgina web devuelta por http_get_page () 
....................                                  
.................... */                            
....................     if (strcmp(key, "button00") == 0)                                
*
08722:  MOVLW  05
08724:  MOVWF  FEA
08726:  MOVLW  DA
08728:  MOVWF  FE9
0872A:  MOVLW  09
0872C:  MOVWF  01
0872E:  CLRF   FF7
08730:  MOVLW  00
08732:  CALL   00AE
08736:  TBLRD*-
08738:  TBLRD*+
0873A:  MOVFF  FF5,FEE
0873E:  DECFSZ 01,F
08740:  BRA    8738
08742:  MOVFF  5D7,633
08746:  MOVFF  5D6,632
0874A:  MOVLW  05
0874C:  MOVLB  6
0874E:  MOVWF  x35
08750:  MOVLW  DA
08752:  MOVWF  x34
08754:  MOVLB  0
08756:  CALL   715C
0875A:  MOVLB  5
0875C:  CLRF   xE4
0875E:  MOVFF  01,5E3
08762:  BTFSC  01.7
08764:  DECF   xE4,F
08766:  MOVF   xE3,F
08768:  BNZ   8772
0876A:  MOVF   xE4,F
0876C:  BNZ   8772
....................    { 
....................          //TODO: Handle button00 
....................          output_toggle(PIN_D4); 
0876E:  BCF    F95.4
08770:  BTG    F8C.4
....................    }                                                           
....................    if (strcmp(key, "button01") == 0) 
08772:  MOVLW  05
08774:  MOVWF  FEA
08776:  MOVLW  DA
08778:  MOVWF  FE9
0877A:  MOVLW  09
0877C:  MOVWF  01
0877E:  CLRF   FF7
08780:  MOVLW  00
08782:  MOVLB  0
08784:  CALL   00C8
08788:  TBLRD*-
0878A:  TBLRD*+
0878C:  MOVFF  FF5,FEE
08790:  DECFSZ 01,F
08792:  BRA    878A
08794:  MOVFF  5D7,633
08798:  MOVFF  5D6,632
0879C:  MOVLW  05
0879E:  MOVLB  6
087A0:  MOVWF  x35
087A2:  MOVLW  DA
087A4:  MOVWF  x34
087A6:  MOVLB  0
087A8:  CALL   715C
087AC:  MOVLB  5
087AE:  CLRF   xE4
087B0:  MOVFF  01,5E3
087B4:  BTFSC  01.7
087B6:  DECF   xE4,F
087B8:  MOVF   xE3,F
087BA:  BNZ   87C4
087BC:  MOVF   xE4,F
087BE:  BNZ   87C4
....................    {                                               
....................          //TODO: Handle button01  
....................           output_toggle(PIN_D5); 
087C0:  BCF    F95.5
087C2:  BTG    F8C.5
....................    }  
....................    if (strcmp(key, "button02") == 0)                                
087C4:  MOVLW  05
087C6:  MOVWF  FEA
087C8:  MOVLW  DA
087CA:  MOVWF  FE9
087CC:  MOVLW  09
087CE:  MOVWF  01
087D0:  CLRF   FF7
087D2:  MOVLW  00
087D4:  MOVLB  0
087D6:  CALL   00E2
087DA:  TBLRD*-
087DC:  TBLRD*+
087DE:  MOVFF  FF5,FEE
087E2:  DECFSZ 01,F
087E4:  BRA    87DC
087E6:  MOVFF  5D7,633
087EA:  MOVFF  5D6,632
087EE:  MOVLW  05
087F0:  MOVLB  6
087F2:  MOVWF  x35
087F4:  MOVLW  DA
087F6:  MOVWF  x34
087F8:  MOVLB  0
087FA:  CALL   715C
087FE:  MOVLB  5
08800:  CLRF   xE4
08802:  MOVFF  01,5E3
08806:  BTFSC  01.7
08808:  DECF   xE4,F
0880A:  MOVF   xE3,F
0880C:  BNZ   8816
0880E:  MOVF   xE4,F
08810:  BNZ   8816
....................    { 
....................          //TODO: Handle button00                    
....................          output_toggle(PIN_D6);                       
08812:  BCF    F95.6
08814:  BTG    F8C.6
....................    }                                                          
....................    if (strcmp(key, "button03") == 0) 
08816:  MOVLW  05
08818:  MOVWF  FEA
0881A:  MOVLW  DA
0881C:  MOVWF  FE9
0881E:  MOVLW  09
08820:  MOVWF  01
08822:  CLRF   FF7
08824:  MOVLW  00
08826:  MOVLB  0
08828:  CALL   00FC
0882C:  TBLRD*-
0882E:  TBLRD*+
08830:  MOVFF  FF5,FEE
08834:  DECFSZ 01,F
08836:  BRA    882E
08838:  MOVFF  5D7,633
0883C:  MOVFF  5D6,632
08840:  MOVLW  05
08842:  MOVLB  6
08844:  MOVWF  x35
08846:  MOVLW  DA
08848:  MOVWF  x34
0884A:  MOVLB  0
0884C:  CALL   715C
08850:  MOVLB  5
08852:  CLRF   xE4
08854:  MOVFF  01,5E3
08858:  BTFSC  01.7
0885A:  DECF   xE4,F
0885C:  MOVF   xE3,F
0885E:  BNZ   8868
08860:  MOVF   xE4,F
08862:  BNZ   8868
....................    {                                                         
....................          //TODO: Handle button01          
....................           output_toggle(PIN_D7); 
08864:  BCF    F95.7
08866:  BTG    F8C.7
....................    } 
08868:  MOVLB  0
0886A:  GOTO   88DA (RETURN)
....................  
.................... }  
....................  
.................... #if HTTP_USE_AUTHENTICATION  
.................... //This is a callback to the HTTP stack.  
.................... //fileName is a file that has been requested over HTTP and is password  
.................... //protected, user and pwd contains the authentication login the user had  
.................... //attempted.  This function returns TRUE if the user/pwd is valid for this  
.................... //fileName.  
.................... int1 http_check_authentication(char *fileName, char *user, char *pwd)  
.................... {  
....................    static char goodUser[]="admin";  
....................    static char goodPwd[]="1234";  
....................      
....................    return((stricmp(goodUser,user)==0) && (stricmp(goodPwd,pwd)==0));  
*
083FE:  MOVLW  05
08400:  MOVLB  6
08402:  MOVWF  x39
08404:  MOVLW  AA
08406:  MOVWF  x38
08408:  MOVFF  635,63B
0840C:  MOVFF  634,63A
08410:  MOVLB  0
08412:  CALL   7846
08416:  MOVLB  6
08418:  CLRF   x39
0841A:  MOVFF  01,638
0841E:  BTFSC  01.7
08420:  DECF   x39,F
08422:  MOVF   x38,F
08424:  BNZ   8454
08426:  MOVF   x39,F
08428:  BNZ   8454
0842A:  MOVLW  05
0842C:  MOVWF  x39
0842E:  MOVLW  B0
08430:  MOVWF  x38
08432:  MOVFF  637,63B
08436:  MOVFF  636,63A
0843A:  MOVLB  0
0843C:  CALL   7846
08440:  MOVLB  6
08442:  CLRF   x39
08444:  MOVFF  01,638
08448:  BTFSC  01.7
0844A:  DECF   x39,F
0844C:  MOVF   x38,F
0844E:  BNZ   8454
08450:  MOVF   x39,F
08452:  BZ    8458
08454:  MOVLW  00
08456:  BRA    845A
08458:  MOVLW  01
0845A:  MOVWF  01
0845C:  MOVLB  0
0845E:  GOTO   86E4 (RETURN)
.................... }  
.................... #endif  
....................                                               
.................... void IPAddressInit(void) 
.................... { 
....................    //MAC address of this unit 
....................    MY_MAC_BYTE1=MY_DEFAULT_MAC_BYTE1; 
*
002BE:  CLRF   4C
....................    MY_MAC_BYTE2=MY_DEFAULT_MAC_BYTE2; 
002C0:  MOVLW  08
002C2:  MOVWF  4D
....................    MY_MAC_BYTE3=MY_DEFAULT_MAC_BYTE3; 
002C4:  MOVLW  DC
002C6:  MOVWF  4E
....................    MY_MAC_BYTE4=MY_DEFAULT_MAC_BYTE4; 
002C8:  MOVLW  18
002CA:  MOVWF  4F
....................    MY_MAC_BYTE5=MY_DEFAULT_MAC_BYTE5; 
002CC:  MOVLW  7C
002CE:  MOVWF  50
....................    MY_MAC_BYTE6=MY_DEFAULT_MAC_BYTE6; 
002D0:  MOVLW  06
002D2:  MOVWF  51
....................  
....................    //IP address of this unit 
....................    MY_IP_BYTE1=MY_DEFAULT_IP_ADDR_BYTE1; 
002D4:  MOVLW  0A
002D6:  MOVWF  1F
....................    MY_IP_BYTE2=MY_DEFAULT_IP_ADDR_BYTE2; 
002D8:  MOVLW  02
002DA:  MOVWF  20
....................    MY_IP_BYTE3=MY_DEFAULT_IP_ADDR_BYTE3; 
002DC:  MOVLW  0A
002DE:  MOVWF  21
....................    MY_IP_BYTE4=MY_DEFAULT_IP_ADDR_BYTE4; 
002E0:  MOVLW  C8
002E2:  MOVWF  22
....................  
....................    //network gateway 
....................    MY_GATE_BYTE1=MY_DEFAULT_GATE_BYTE1; 
002E4:  MOVLW  0A
002E6:  MOVWF  27
....................    MY_GATE_BYTE2=MY_DEFAULT_GATE_BYTE2; 
002E8:  MOVLW  02
002EA:  MOVWF  28
....................    MY_GATE_BYTE3=MY_DEFAULT_GATE_BYTE3; 
002EC:  MOVLW  0A
002EE:  MOVWF  29
....................    MY_GATE_BYTE4=MY_DEFAULT_GATE_BYTE4; 
002F0:  MOVLW  01
002F2:  MOVWF  2A
....................  
....................    //subnet mask 
....................    MY_MASK_BYTE1=MY_DEFAULT_MASK_BYTE1; 
002F4:  SETF   23
....................    MY_MASK_BYTE2=MY_DEFAULT_MASK_BYTE2; 
002F6:  SETF   24
....................    MY_MASK_BYTE3=MY_DEFAULT_MASK_BYTE3; 
002F8:  SETF   25
....................    MY_MASK_BYTE4=MY_DEFAULT_MASK_BYTE4; 
002FA:  CLRF   26
002FC:  GOTO   B06C (RETURN)
.................... } 
....................  
.................... void main() 
*
0AF2C:  CLRF   FF8
0AF2E:  BCF    FD0.7
0AF30:  BSF    07.7
0AF32:  MOVLW  7E
0AF34:  MOVWF  00
0AF36:  MOVLW  10
0AF38:  MOVWF  01
0AF3A:  MOVLW  02
0AF3C:  MOVWF  FE9
0AF3E:  MOVLW  00
0AF40:  MOVWF  FEA
0AF42:  CLRF   FEE
0AF44:  DECFSZ 00,F
0AF46:  BRA    AF42
0AF48:  DECFSZ 01,F
0AF4A:  BRA    AF42
0AF4C:  MOVLW  70
0AF4E:  MOVWF  FD3
0AF50:  MOVLW  40
0AF52:  MOVWF  F9B
0AF54:  MOVF   FD3,W
0AF56:  BSF    FB8.3
0AF58:  MOVLW  40
0AF5A:  MOVWF  FAF
0AF5C:  MOVLW  03
0AF5E:  MOVWF  FB0
0AF60:  MOVLW  A6
0AF62:  MOVWF  FAC
0AF64:  MOVLW  90
0AF66:  MOVWF  FAB
0AF68:  MOVLB  1
0AF6A:  BCF    x12.0
0AF6C:  BCF    x12.1
0AF6E:  MOVLW  41
0AF70:  MOVWF  x16
0AF72:  MOVLW  FE
0AF74:  MOVWF  x15
0AF76:  MOVLW  9F
0AF78:  MOVWF  x14
0AF7A:  MOVLW  9E
0AF7C:  MOVWF  x13
0AF7E:  CLRF   x1E
0AF80:  CLRF   x1D
0AF82:  CLRF   x1C
0AF84:  CLRF   x1B
0AF86:  CLRF   x2B
0AF88:  CLRF   x2A
0AF8A:  BCF    x12.3
0AF8C:  SETF   x37
0AF8E:  SETF   x3D
0AF90:  BCF    x12.4
0AF92:  MOVLW  FE
0AF94:  MOVWF  xA3
0AF96:  MOVLW  FE
0AF98:  MOVWF  xFC
0AF9A:  MOVLB  5
0AF9C:  CLRF   x5F
0AF9E:  CLRF   x5E
0AFA0:  MOVF   FC1,W
0AFA2:  ANDLW  C0
0AFA4:  IORLW  0F
0AFA6:  MOVWF  FC1
0AFA8:  MOVLW  07
0AFAA:  MOVWF  FB4
0AFAC:  BRA    B014
0AFAE:  DATA 06,01
0AFB0:  DATA 01,08
0AFB2:  DATA 00,DC
0AFB4:  DATA 05,F4
0AFB6:  DATA 01,1C
0AFB8:  DATA 02,12
0AFBA:  DATA 65,72
0AFBC:  DATA 72,6F
0AFBE:  DATA 72,34
0AFC0:  DATA 30,31
0AFC2:  DATA 2E,68
0AFC4:  DATA 74,6D
0AFC6:  DATA 00,68
0AFC8:  DATA 74,61
0AFCA:  DATA 63,63
0AFCC:  DATA 65,73
0AFCE:  DATA 73,2E
0AFD0:  DATA 74,78
0AFD2:  DATA 74,00
0AFD4:  DATA 3A,00
0AFD6:  DATA 1D,05
0AFD8:  DATA 60,20
0AFDA:  DATA 00,3F
0AFDC:  DATA 00,47
0AFDE:  DATA 45,54
0AFE0:  DATA 00,50
0AFE2:  DATA 4F,53
0AFE4:  DATA 54,00
0AFE6:  DATA 43,6F
0AFE8:  DATA 6E,74
0AFEA:  DATA 65,6E
0AFEC:  DATA 74,2D
0AFEE:  DATA 4C,65
0AFF0:  DATA 6E,67
0AFF2:  DATA 74,68
0AFF4:  DATA 3A,00
0AFF6:  DATA 1A,05
0AFF8:  DATA 9B,41
0AFFA:  DATA 75,74
0AFFC:  DATA 68,6F
0AFFE:  DATA 72,69
0B000:  DATA 7A,61
0B002:  DATA 74,69
0B004:  DATA 6F,6E
0B006:  DATA 3A,00
0B008:  DATA 61,64
0B00A:  DATA 6D,69
0B00C:  DATA 6E,00
0B00E:  DATA 31,32
0B010:  DATA 33,34
0B012:  DATA 00,00
0B014:  MOVLW  00
0B016:  MOVWF  FF8
0B018:  MOVLW  AF
0B01A:  MOVWF  FF7
0B01C:  MOVLW  AE
0B01E:  MOVWF  FF6
0B020:  TBLRD*+
0B022:  MOVF   FF5,W
0B024:  MOVWF  00
0B026:  XORLW  00
0B028:  BZ    B050
0B02A:  TBLRD*+
0B02C:  MOVF   FF5,W
0B02E:  MOVWF  01
0B030:  BTFSC  FE8.7
0B032:  BRA    B03E
0B034:  ANDLW  0F
0B036:  MOVWF  FEA
0B038:  TBLRD*+
0B03A:  MOVFF  FF5,FE9
0B03E:  BTFSC  01.6
0B040:  TBLRD*+
0B042:  BTFSS  01.6
0B044:  TBLRD*+
0B046:  MOVFF  FF5,FEE
0B04A:  DCFSNZ 00,F
0B04C:  BRA    B020
0B04E:  BRA    B042
0B050:  CLRF   FF8
.................... { 
....................    setup_adc_ports(AN0); 
0B052:  MOVF   FC1,W
0B054:  ANDLW  C0
0B056:  IORLW  0E
0B058:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
0B05A:  MOVF   FC0,W
0B05C:  ANDLW  C0
0B05E:  IORLW  07
0B060:  MOVWF  FC0
0B062:  BCF    FC0.7
0B064:  BSF    FC2.0
....................  
....................    IPAddressInit(); 
0B066:  MOVLB  0
0B068:  GOTO   02BE
....................    TickInit(); 
0B06C:  GOTO   0300
....................    enable_interrupts(GLOBAL); 
0B070:  MOVLW  C0
0B072:  IORWF  FF2,F
....................    StackInit(); 
0B074:  GOTO   1512
....................  
....................  
....................    while(TRUE) 
....................    { 
....................  
....................       // TCP/IP code 
....................       StackTask(); 
0B078:  GOTO   6C14
....................  
....................       //StackPrintfChanges(); 
....................  
....................       StackApplications(); 
0B07C:  BRA    AF24
0B07E:  BRA    B078
....................  
....................  
....................  
....................       //TODO: User Code 
....................    } 
....................  
.................... } 
....................  
0B080:  SLEEP 
....................  
....................  

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 1F1E   PUT BROWNOUT BORV21 WDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
00B654: 74 65 78 74 2F 68 74 6D 6C 00 00 00 00 74 65 78 
00B664: 74 2F 68 74 6D 6C 00 00 00 00 74 65 78 74 2F 70 
00B674: 6C 61 69 6E 00 00 00 74 65 78 74 2F 78 6D 6C 00 
00B684: 00 00 00 00 69 6D 61 67 65 2F 67 69 66 00 00 00 
00B694: 00 69 6D 61 67 65 2F 6A 70 65 67 00 00 00 69 6D 
00B6A4: 61 67 65 2F 70 6E 67 00 00 00 00 69 6D 61 67 65 
00B6B4: 2F 78 2D 69 63 6F 6E 00 

00B6BC: 68 74 6D 00 00 68 74 6D 6C 00 74 78 74 00 00 78 
00B6CC: 6D 6C 00 00 67 69 66 00 00 6A 70 67 00 00 70 6E 
00B6DC: 67 00 00 69 63 6F 00 00 

00B6E4: 00 66 00 00 00 48 54 41 43 43 45 53 53 2E 54 58 
00B6F4: 54 00 80 00 00 00 49 4E 44 45 58 2E 48 54 4D 20 
00B704: 20 20 00 5A 04 00 00 49 4E 44 45 58 2E 58 4D 4C 
00B714: 20 20 20 00 8B 04 00 00 49 4E 49 43 49 4F 2E 48 
00B724: 54 4D 20 20 00 7F 1C 00 00 4C 4F 47 4F 2E 4A 50 
00B734: 47 20 20 20 20 04 FF FF FF FF 45 4E 44 20 4F 46 
00B744: 20 46 41 54 20 20 63 68 61 72 6C 69 65 7C 31 32 
00B754: 33 34 7C 69 6E 69 63 69 6F 2E 68 74 6D 04 FF FF 
00B764: 3C 21 44 4F 43 54 59 50 45 20 48 54 4D 4C 20 50 
00B774: 55 42 4C 49 43 20 22 2D 2F 2F 57 33 43 2F 2F 44 
00B784: 54 44 20 48 54 4D 4C 20 33 2E 32 2F 2F 45 4E 22 
00B794: 3E 0D 0A 3C 68 74 6D 6C 3E 0D 0A 3C 68 65 61 64 
00B7A4: 3E 0D 0A 09 3C 74 69 74 6C 65 3E 3C 2F 74 69 74 
00B7B4: 6C 65 3E 0D 0A 3C 2F 68 65 61 64 3E 0D 0A 3C 62 
00B7C4: 6F 64 79 3E 26 6E 62 73 70 3B 0D 0A 3C 70 3E 26 
00B7D4: 6E 62 73 70 3B 3C 2F 70 3E 0D 0A 0D 0A 3C 68 31 
00B7E4: 3E 53 69 6D 70 6C 65 20 4C 6F 67 69 6E 20 50 61 
00B7F4: 67 65 3C 2F 68 31 3E 0D 0A 0D 0A 3C 70 3E 26 6E 
00B804: 62 73 70 3B 3C 2F 70 3E 0D 0A 0D 0A 3C 66 6F 72 
00B814: 6D 20 6E 61 6D 65 3D 22 6C 6F 67 69 6E 22 3E 55 
00B824: 73 65 72 6E 61 6D 65 3C 69 6E 70 75 74 20 6E 61 
00B834: 6D 65 3D 22 75 73 65 72 69 64 22 20 74 79 70 65 
00B844: 3D 22 74 65 78 74 22 20 2F 3E 20 50 61 73 73 77 
00B854: 6F 72 64 3C 69 6E 70 75 74 20 6E 61 6D 65 3D 22 
00B864: 70 73 77 72 64 22 20 74 79 70 65 3D 22 70 61 73 
00B874: 73 77 6F 72 64 22 20 2F 3E 20 3C 69 6E 70 75 74 
00B884: 20 6F 6E 63 6C 69 63 6B 3D 22 63 68 65 63 6B 28 
00B894: 74 68 69 73 2E 66 6F 72 6D 29 22 20 74 79 70 65 
00B8A4: 3D 22 62 75 74 74 6F 6E 22 20 76 61 6C 75 65 3D 
00B8B4: 22 4C 6F 67 69 6E 22 20 2F 3E 20 3C 69 6E 70 75 
00B8C4: 74 20 74 79 70 65 3D 22 72 65 73 65 74 22 20 76 
00B8D4: 61 6C 75 65 3D 22 43 61 6E 63 65 6C 22 20 2F 3E 
00B8E4: 26 6E 62 73 70 3B 3C 2F 66 6F 72 6D 3E 0D 0A 3C 
00B8F4: 73 63 72 69 70 74 20 6C 61 6E 67 75 61 67 65 3D 
00B904: 22 6A 61 76 61 73 63 72 69 70 74 22 3E 0D 0A 20 
00B914: 20 20 20 20 20 20 20 20 20 20 20 66 75 6E 63 74 
00B924: 69 6F 6E 20 63 68 65 63 6B 28 66 6F 72 6D 29 20 
00B934: 7B 20 2F 2A 66 75 6E 63 74 69 6F 6E 20 74 6F 20 
00B944: 63 68 65 63 6B 20 75 73 65 72 69 64 20 26 20 70 
00B954: 61 73 73 77 6F 72 64 2A 2F 0D 0A 20 20 20 20 20 
00B964: 20 20 20 20 20 20 20 20 20 20 20 2F 2A 74 68 65 
00B974: 20 66 6F 6C 6C 6F 77 69 6E 67 20 63 6F 64 65 20 
00B984: 63 68 65 63 6B 65 73 20 77 68 65 74 68 65 72 20 
00B994: 74 68 65 20 65 6E 74 65 72 65 64 20 75 73 65 72 
00B9A4: 69 64 20 61 6E 64 20 70 61 73 73 77 6F 72 64 20 
00B9B4: 61 72 65 20 6D 61 74 63 68 69 6E 67 2A 2F 0D 0A 
00B9C4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B9D4: 69 66 28 66 6F 72 6D 2E 75 73 65 72 69 64 2E 76 
00B9E4: 61 6C 75 65 20 3D 3D 20 27 75 73 65 72 27 20 26 
00B9F4: 26 20 66 6F 72 6D 2E 70 73 77 72 64 2E 76 61 6C 
00BA04: 75 65 20 3D 3D 20 27 70 77 64 27 29 20 7B 0D 0A 
00BA14: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BA24: 20 20 20 20 77 69 6E 64 6F 77 2E 6F 70 65 6E 28 
00BA34: 27 69 6E 69 63 69 6F 2E 68 74 6D 27 29 2F 2A 6F 
00BA44: 70 65 6E 73 20 74 68 65 20 74 61 72 67 65 74 20 
00BA54: 70 61 67 65 20 77 68 69 6C 65 20 49 64 20 26 20 
00BA64: 70 61 73 73 77 6F 72 64 20 6D 61 74 63 68 65 73 
00BA74: 2A 2F 0D 0A 20 20 20 20 20 20 20 20 20 20 20 20 
00BA84: 20 20 20 20 7D 0D 0A 20 20 20 20 20 20 20 20 20 
00BA94: 20 20 20 20 20 20 20 65 6C 73 65 20 7B 0D 0A 20 
00BAA4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BAB4: 20 20 20 61 6C 65 72 74 28 22 45 72 72 6F 72 20 
00BAC4: 50 61 73 73 77 6F 72 64 20 6F 72 20 55 73 65 72 
00BAD4: 6E 61 6D 65 22 29 2F 2A 64 69 73 70 6C 61 79 73 
00BAE4: 20 65 72 72 6F 72 20 6D 65 73 73 61 67 65 2A 2F 
00BAF4: 0D 0A 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BB04: 20 20 7D 0D 0A 20 20 20 20 20 20 20 20 20 20 20 
00BB14: 20 7D 0D 0A 20 20 20 20 20 20 20 20 3C 2F 73 63 
00BB24: 72 69 70 74 3E 3C 2F 62 6F 64 79 3E 0D 0A 3C 2F 
00BB34: 68 74 6D 6C 3E 0D 0A 04 FF FF 3C 50 49 43 54 43 
00BB44: 50 49 50 3E 0D 0A 20 20 20 3C 64 79 6E 30 3E 25 
00BB54: 30 30 3C 2F 64 79 6E 30 3E 0D 0A 3C 2F 50 49 43 
00BB64: 54 43 50 49 50 3E 0D 0A 04 FF FF 48 54 54 50 2F 
00BB74: 31 2E 31 20 34 30 31 20 41 75 74 68 6F 72 69 7A 
00BB84: 61 74 69 6F 6E 20 52 65 71 75 69 72 65 64 0D 0A 
00BB94: 53 65 72 76 65 72 3A 20 48 54 54 50 64 2F 31 2E 
00BBA4: 30 0D 0A 44 61 74 65 3A 20 53 61 74 2C 20 32 37 
00BBB4: 20 4E 6F 76 20 32 30 30 34 20 31 30 3A 31 38 3A 
00BBC4: 31 35 20 47 4D 54 0D 0A 57 57 57 2D 41 75 74 68 
00BBD4: 65 6E 74 69 63 61 74 65 3A 20 42 61 73 69 63 20 
00BBE4: 72 65 61 6C 6D 3D 22 53 65 63 75 72 65 20 41 72 
00BBF4: 65 61 22 0D 0A 43 6F 6E 74 65 6E 74 2D 54 79 70 
00BC04: 65 3A 20 74 65 78 74 2F 68 74 6D 6C 0D 0A 43 6F 
00BC14: 6E 74 65 6E 74 2D 4C 65 6E 67 74 68 3A 20 33 31 
00BC24: 31 0D 0A 3C 21 44 4F 43 54 59 50 45 20 48 54 4D 
00BC34: 4C 20 50 55 42 4C 49 43 20 22 2D 2F 2F 57 33 43 
00BC44: 2F 2F 44 54 44 20 48 54 4D 4C 20 34 2E 30 31 20 
00BC54: 54 72 61 6E 73 69 74 69 6F 6E 61 6C 2F 2F 45 4E 
00BC64: 22 3E 0D 0A 3C 68 74 6D 6C 3E 0D 0A 3C 68 65 61 
00BC74: 64 3E 0D 0A 09 3C 74 69 74 6C 65 3E 4D 79 20 57 
00BC84: 65 62 70 61 67 65 3C 2F 74 69 74 6C 65 3E 0D 0A 
00BC94: 09 3C 73 63 72 69 70 74 20 74 79 70 65 3D 22 74 
00BCA4: 65 78 74 2F 6A 61 76 61 73 63 72 69 70 74 22 3E 
00BCB4: 0D 0A 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00BCC4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00BCD4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00BCE4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00BCF4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 0D 0A 2F 2F 2F 
00BD04: 2F 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BD14: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BD24: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BD34: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BD44: 20 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 20 41 4A 
00BD54: 41 58 20 72 6F 75 74 69 6E 65 73 20 66 6F 72 20 
00BD64: 72 78 2F 74 78 20 6F 66 20 64 61 74 61 20 77 69 
00BD74: 74 68 6F 75 74 20 68 61 76 69 6E 67 20 74 6F 20 
00BD84: 72 65 6C 6F 61 64 20 70 61 67 65 2E 20 2F 2F 2F 
00BD94: 2F 0D 0A 2F 2F 2F 2F 20 20 20 20 20 20 20 20 20 
00BDA4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BDB4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BDC4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BDD4: 20 20 20 20 20 20 20 20 2F 2F 2F 2F 0D 0A 2F 2F 
00BDE4: 2F 2F 20 20 57 72 69 74 74 65 6E 20 62 79 20 43 
00BDF4: 43 53 2C 20 49 6E 63 2E 20 20 20 20 20 20 20 20 
00BE04: 20 20 20 20 20 20 20 20 20 20 20 20 68 74 74 70 
00BE14: 3A 2F 2F 77 77 77 2E 63 63 73 69 6E 66 6F 2E 63 
00BE24: 6F 6D 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 20 20 
00BE34: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BE44: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BE54: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BE64: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 2F 2F 
00BE74: 2F 2F 0D 0A 2F 2F 2F 2F 20 20 20 20 20 20 20 20 
00BE84: 28 43 29 20 43 6F 70 79 72 69 67 68 74 20 31 39 
00BE94: 39 36 2C 32 30 31 33 20 43 75 73 74 6F 6D 20 43 
00BEA4: 6F 6D 70 75 74 65 72 20 53 65 72 76 69 63 65 73 
00BEB4: 20 20 20 20 20 20 20 20 20 2F 2F 2F 2F 0D 0A 2F 
00BEC4: 2F 2F 2F 20 54 68 69 73 20 73 6F 75 72 63 65 20 
00BED4: 63 6F 64 65 20 6D 61 79 20 6F 6E 6C 79 20 62 65 
00BEE4: 20 75 73 65 64 20 62 79 20 6C 69 63 65 6E 73 65 
00BEF4: 64 20 75 73 65 72 73 20 6F 66 20 74 68 65 20 43 
00BF04: 43 53 20 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 43 
00BF14: 20 63 6F 6D 70 69 6C 65 72 2E 20 20 54 68 69 73 
00BF24: 20 73 6F 75 72 63 65 20 63 6F 64 65 20 6D 61 79 
00BF34: 20 6F 6E 6C 79 20 62 65 20 64 69 73 74 72 69 62 
00BF44: 75 74 65 64 20 74 6F 20 6F 74 68 65 72 20 20 2F 
00BF54: 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 6C 69 63 65 6E 73 
00BF64: 65 64 20 75 73 65 72 73 20 6F 66 20 74 68 65 20 
00BF74: 43 43 53 20 43 20 63 6F 6D 70 69 6C 65 72 2E 20 
00BF84: 20 4E 6F 20 6F 74 68 65 72 20 75 73 65 2C 20 20 
00BF94: 20 20 20 20 20 20 20 20 20 20 2F 2F 2F 2F 0D 0A 
00BFA4: 2F 2F 2F 2F 20 72 65 70 72 6F 64 75 63 74 69 6F 
00BFB4: 6E 20 6F 72 20 64 69 73 74 72 69 62 75 74 69 6F 
00BFC4: 6E 20 69 73 20 70 65 72 6D 69 74 74 65 64 20 77 
00BFD4: 69 74 68 6F 75 74 20 77 72 69 74 74 65 6E 20 20 
00BFE4: 20 20 20 20 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 
00BFF4: 70 65 72 6D 69 73 73 69 6F 6E 2E 20 20 20 20 20 
00C004: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00C014: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00C024: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00C034: 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00C044: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00C054: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00C064: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00C074: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 0D 
00C084: 0A 76 61 72 20 61 6A 61 78 47 65 74 3B 0D 0A 76 
00C094: 61 72 20 74 3B 0D 0A 76 61 72 20 77 61 69 74 69 
00C0A4: 6E 67 20 3D 20 30 3B 0D 0A 76 61 72 20 74 56 61 
00C0B4: 6C 69 64 20 3D 20 30 3B 0D 0A 76 61 72 20 6E 65 
00C0C4: 78 74 43 67 69 20 3D 20 22 22 3B 0D 0A 76 61 72 
00C0D4: 20 6C 61 73 74 43 67 69 20 3D 20 22 22 3B 0D 0A 
00C0E4: 76 61 72 20 69 6F 73 36 77 6F 72 6B 61 72 6F 75 
00C0F4: 6E 64 20 3D 20 30 3B 0D 0A 0D 0A 66 75 6E 63 74 
00C104: 69 6F 6E 20 73 65 74 53 74 61 72 74 54 69 6D 65 
00C114: 28 29 0D 0A 7B 0D 0A 20 20 20 74 56 61 6C 69 64 
00C124: 20 3D 20 31 3B 0D 0A 20 20 20 74 20 3D 20 73 65 
00C134: 74 54 69 6D 65 6F 75 74 28 27 61 6A 61 78 28 29 
00C144: 27 2C 20 35 30 30 29 3B 0D 0A 7D 0D 0A 0D 0A 66 
00C154: 75 6E 63 74 69 6F 6E 20 61 6A 61 78 28 29 0D 0A 
00C164: 7B 0D 0A 20 20 20 69 66 20 28 77 61 69 74 69 6E 
00C174: 67 29 0D 0A 20 20 20 7B 0D 0A 20 20 20 20 20 20 
00C184: 77 61 69 74 69 6E 67 2D 2D 3B 0D 0A 20 20 20 20 
00C194: 20 20 69 66 20 28 77 61 69 74 69 6E 67 20 3D 3D 
00C1A4: 20 30 29 0D 0A 20 20 20 20 20 20 7B 0D 0A 20 20 
00C1B4: 20 20 20 20 20 20 20 69 66 20 28 6C 61 73 74 43 
00C1C4: 67 69 20 21 3D 20 22 22 29 0D 0A 20 20 20 20 20 
00C1D4: 20 20 20 20 7B 0D 0A 20 20 20 20 20 20 20 20 20 
00C1E4: 20 20 20 69 66 20 28 6E 65 78 74 43 67 69 20 3D 
00C1F4: 3D 20 22 22 29 0D 0A 20 20 20 20 20 20 20 20 20 
00C204: 20 20 20 20 20 20 6E 65 78 74 43 67 69 20 3D 20 
00C214: 6C 61 73 74 43 67 69 3B 0D 0A 20 20 20 20 20 20 
00C224: 20 20 20 20 20 20 65 6C 73 65 0D 0A 20 20 20 20 
00C234: 20 20 20 20 20 20 20 20 20 20 20 6E 65 78 74 43 
00C244: 67 69 20 3D 20 6C 61 73 74 43 67 69 20 2B 20 22 
00C254: 26 22 20 2B 20 6E 65 78 74 43 67 69 3B 0D 0A 20 
00C264: 20 20 20 20 20 20 20 20 7D 0D 0A 20 20 20 20 20 
00C274: 20 7D 0D 0A 20 20 20 7D 0D 0A 0D 0A 20 20 20 69 
00C284: 66 20 28 21 77 61 69 74 69 6E 67 29 0D 0A 20 20 
00C294: 20 7B 0D 0A 20 20 20 20 20 20 61 6A 61 78 47 65 
00C2A4: 74 3D 47 65 74 58 6D 6C 48 74 74 70 4F 62 6A 65 
00C2B4: 63 74 28 29 3B 0D 0A 0D 0A 20 20 20 20 20 20 69 
00C2C4: 66 20 28 61 6A 61 78 47 65 74 3D 3D 6E 75 6C 6C 
00C2D4: 29 0D 0A 20 20 20 20 20 20 7B 0D 0A 20 20 20 20 
00C2E4: 20 20 20 20 20 61 6C 65 72 74 20 28 22 59 6F 75 
00C2F4: 72 20 62 72 6F 77 73 65 72 20 64 6F 65 73 20 6E 
00C304: 6F 74 20 73 75 70 70 6F 72 74 20 41 4A 41 58 21 
00C314: 22 29 3B 0D 0A 20 20 20 20 20 20 20 20 20 72 65 
00C324: 74 75 72 6E 3B 0D 0A 20 20 20 20 20 20 7D 0D 0A 
00C334: 0D 0A 20 20 20 20 20 20 77 61 69 74 69 6E 67 20 
00C344: 3D 20 35 3B 20 20 2F 2F 77 61 69 74 20 32 2E 35 
00C354: 20 73 65 63 6F 6E 64 73 20 66 6F 72 20 61 20 72 
00C364: 65 73 70 6F 6E 73 65 0D 0A 0D 0A 20 20 20 20 20 
00C374: 20 61 6A 61 78 47 65 74 2E 6F 70 65 6E 28 22 50 
00C384: 4F 53 54 22 2C 20 22 69 6E 64 65 78 2E 78 6D 6C 
00C394: 22 2C 20 74 72 75 65 29 3B 0D 0A 0D 0A 20 20 20 
00C3A4: 20 20 20 61 6A 61 78 47 65 74 2E 6F 6E 72 65 61 
00C3B4: 64 79 73 74 61 74 65 63 68 61 6E 67 65 20 3D 20 
00C3C4: 73 74 61 74 65 43 68 61 6E 67 65 64 3B 0D 0A 0D 
00C3D4: 0A 20 20 20 20 20 20 69 66 20 28 6E 65 78 74 43 
00C3E4: 67 69 20 21 3D 20 22 22 29 0D 0A 20 20 20 20 20 
00C3F4: 20 7B 0D 0A 20 20 20 20 20 20 20 20 20 61 6A 61 
00C404: 78 47 65 74 2E 73 65 6E 64 28 6E 65 78 74 43 67 
00C414: 69 29 3B 0D 0A 20 20 20 20 20 20 20 20 20 6C 61 
00C424: 73 74 43 67 69 20 3D 20 6E 65 78 74 43 67 69 3B 
00C434: 0D 0A 20 20 20 20 20 20 20 20 20 6E 65 78 74 43 
00C444: 67 69 20 3D 20 22 22 3B 0D 0A 20 20 20 20 20 20 
00C454: 7D 0D 0A 20 20 20 20 20 20 65 6C 73 65 0D 0A 20 
00C464: 20 20 20 20 20 7B 0D 0A 20 20 20 20 20 20 20 20 
00C474: 20 61 6A 61 78 47 65 74 2E 73 65 6E 64 28 22 49 
00C484: 47 4E 4F 52 45 44 54 41 47 3D 22 2B 69 6F 73 36 
00C494: 77 6F 72 6B 61 72 6F 75 6E 64 29 3B 0D 0A 0D 0A 
00C4A4: 20 20 20 20 20 20 20 20 20 69 66 20 28 2B 2B 69 
00C4B4: 6F 73 36 77 6F 72 6B 61 72 6F 75 6E 64 20 3E 20 
00C4C4: 32 35 35 29 0D 0A 20 20 20 20 20 20 20 20 20 20 
00C4D4: 20 20 69 6F 73 36 77 6F 72 6B 61 72 6F 75 6E 64 
00C4E4: 20 3D 20 30 3B 0D 0A 20 20 20 20 20 20 7D 0D 0A 
00C4F4: 20 20 20 7D 0D 0A 0D 0A 20 20 20 73 65 74 53 74 
00C504: 61 72 74 54 69 6D 65 28 29 3B 0D 0A 7D 0D 0A 0D 
00C514: 0A 66 75 6E 63 74 69 6F 6E 20 73 65 6E 64 43 67 
00C524: 69 28 63 6D 64 2C 20 76 61 6C 75 65 29 0D 0A 7B 
00C534: 0D 0A 20 20 20 69 66 20 28 6E 65 78 74 43 67 69 
00C544: 20 21 3D 20 22 22 29 0D 0A 20 20 20 20 20 20 6E 
00C554: 65 78 74 43 67 69 20 2B 3D 20 22 26 22 3B 0D 0A 
00C564: 0D 0A 20 20 20 6E 65 78 74 43 67 69 20 2B 3D 20 
00C574: 63 6D 64 20 2B 20 22 3D 22 20 2B 20 76 61 6C 75 
00C584: 65 3B 0D 0A 7D 0D 0A 0D 0A 66 75 6E 63 74 69 6F 
00C594: 6E 20 47 65 74 45 6C 65 6D 65 6E 74 4E 6F 64 65 
00C5A4: 56 61 6C 75 65 28 78 6D 6C 44 6F 63 2C 20 69 64 
00C5B4: 29 0D 0A 7B 0D 0A 20 20 20 72 65 74 75 72 6E 20 
00C5C4: 78 6D 6C 44 6F 63 2E 67 65 74 45 6C 65 6D 65 6E 
00C5D4: 74 73 42 79 54 61 67 4E 61 6D 65 28 69 64 29 5B 
00C5E4: 30 5D 2E 63 68 69 6C 64 4E 6F 64 65 73 5B 30 5D 
00C5F4: 2E 6E 6F 64 65 56 61 6C 75 65 3B 0D 0A 7D 0D 0A 
00C604: 0D 0A 66 75 6E 63 74 69 6F 6E 20 47 65 74 45 6C 
00C614: 65 6D 65 6E 74 41 74 74 72 69 62 75 74 65 56 61 
00C624: 6C 75 65 28 78 6D 6C 44 6F 63 2C 20 65 6C 65 6D 
00C634: 65 6E 74 2C 20 61 74 74 72 69 62 75 74 65 29 0D 
00C644: 0A 7B 0D 0A 20 20 20 76 61 72 20 6E 3B 0D 0A 20 
00C654: 20 20 76 61 72 20 69 3B 0D 0A 0D 0A 20 20 20 6E 
00C664: 20 3D 20 78 6D 6C 44 6F 63 2E 67 65 74 45 6C 65 
00C674: 6D 65 6E 74 73 42 79 54 61 67 4E 61 6D 65 28 65 
00C684: 6C 65 6D 65 6E 74 29 5B 30 5D 2E 61 74 74 72 69 
00C694: 62 75 74 65 73 2E 6C 65 6E 67 74 68 3B 0D 0A 0D 
00C6A4: 0A 20 20 20 66 6F 72 20 28 69 3D 30 3B 20 69 3C 
00C6B4: 6E 3B 20 69 2B 2B 29 0D 0A 20 20 20 7B 0D 0A 20 
00C6C4: 20 20 20 20 20 69 66 20 28 78 6D 6C 44 6F 63 2E 
00C6D4: 67 65 74 45 6C 65 6D 65 6E 74 73 42 79 54 61 67 

00C6E4: 4E 61 6D 65 28 65 6C 65 6D 65 6E 74 29 5B 30 5D 
00C6F4: 2E 61 74 74 72 69 62 75 74 65 73 5B 69 5D 2E 6E 
00C704: 61 6D 65 20 3D 3D 20 61 74 74 72 69 62 75 74 65 
00C714: 29 0D 0A 20 20 20 20 20 20 7B 0D 0A 20 20 20 20 
00C724: 20 20 20 20 20 72 65 74 75 72 6E 20 78 6D 6C 44 
00C734: 6F 63 2E 67 65 74 45 6C 65 6D 65 6E 74 73 42 79 
00C744: 54 61 67 4E 61 6D 65 28 65 6C 65 6D 65 6E 74 29 
00C754: 5B 30 5D 2E 61 74 74 72 69 62 75 74 65 73 5B 69 
00C764: 5D 2E 76 61 6C 75 65 3B 0D 0A 20 20 20 20 20 20 
00C774: 7D 0D 0A 20 20 20 7D 0D 0A 0D 0A 20 20 20 72 65 
00C784: 74 75 72 6E 20 22 22 3B 0D 0A 7D 0D 0A 0D 0A 66 
00C794: 75 6E 63 74 69 6F 6E 20 55 70 64 61 74 65 45 78 
00C7A4: 69 73 74 69 6E 67 54 61 62 6C 65 28 78 6D 6C 44 
00C7B4: 6F 63 29 0D 0A 7B 0D 0A 20 20 20 76 61 72 20 69 
00C7C4: 20 3D 20 30 3B 0D 0A 0D 0A 20 20 20 66 6F 72 28 
00C7D4: 3B 3B 29 0D 0A 20 20 20 7B 0D 0A 20 20 20 20 20 
00C7E4: 20 76 61 72 20 69 64 20 3D 20 22 64 79 6E 22 2B 
00C7F4: 69 3B 0D 0A 20 20 20 20 20 20 69 2B 2B 3B 0D 0A 
00C804: 20 20 20 20 20 20 69 66 20 28 64 6F 63 75 6D 65 
00C814: 6E 74 2E 67 65 74 45 6C 65 6D 65 6E 74 42 79 49 
00C824: 64 28 69 64 29 29 0D 0A 20 20 20 20 20 20 7B 0D 
00C834: 0A 20 20 20 20 20 20 20 20 20 64 6F 63 75 6D 65 
00C844: 6E 74 2E 67 65 74 45 6C 65 6D 65 6E 74 42 79 49 
00C854: 64 28 69 64 29 2E 69 6E 6E 65 72 48 54 4D 4C 20 
00C864: 3D 20 47 65 74 45 6C 65 6D 65 6E 74 4E 6F 64 65 
00C874: 56 61 6C 75 65 28 78 6D 6C 44 6F 63 2C 20 69 64 
00C884: 29 3B 0D 0A 20 20 20 20 20 20 7D 0D 0A 20 20 20 
00C894: 20 20 20 65 6C 73 65 0D 0A 20 20 20 20 20 20 20 
00C8A4: 20 20 62 72 65 61 6B 3B 0D 0A 20 20 20 7D 0D 0A 
00C8B4: 7D 0D 0A 0D 0A 66 75 6E 63 74 69 6F 6E 20 73 74 
00C8C4: 61 74 65 43 68 61 6E 67 65 64 28 29 0D 0A 7B 0D 
00C8D4: 0A 20 20 20 69 66 20 28 61 6A 61 78 47 65 74 2E 
00C8E4: 72 65 61 64 79 53 74 61 74 65 3D 3D 34 29 0D 0A 
00C8F4: 20 20 20 7B 0D 0A 20 20 20 20 20 20 55 70 64 61 
00C904: 74 65 45 78 69 73 74 69 6E 67 54 61 62 6C 65 28 
00C914: 61 6A 61 78 47 65 74 2E 72 65 73 70 6F 6E 73 65 
00C924: 58 4D 4C 2E 64 6F 63 75 6D 65 6E 74 45 6C 65 6D 
00C934: 65 6E 74 29 3B 0D 0A 0D 0A 20 20 20 20 20 20 77 
00C944: 61 69 74 69 6E 67 20 3D 20 30 3B 0D 0A 20 20 7D 
00C954: 0D 0A 7D 0D 0A 0D 0A 66 75 6E 63 74 69 6F 6E 20 
00C964: 47 65 74 58 6D 6C 48 74 74 70 4F 62 6A 65 63 74 
00C974: 28 29 0D 0A 7B 0D 0A 20 20 20 69 66 20 28 77 69 
00C984: 6E 64 6F 77 2E 58 4D 4C 48 74 74 70 52 65 71 75 
00C994: 65 73 74 29 0D 0A 20 20 20 7B 0D 0A 20 20 20 20 
00C9A4: 20 20 2F 2F 20 63 6F 64 65 20 66 6F 72 20 49 45 
00C9B4: 37 2B 2C 20 46 69 72 65 66 6F 78 2C 20 43 68 72 
00C9C4: 6F 6D 65 2C 20 4F 70 65 72 61 2C 20 53 61 66 61 
00C9D4: 72 69 0D 0A 20 20 20 20 20 20 72 65 74 75 72 6E 
00C9E4: 20 6E 65 77 20 58 4D 4C 48 74 74 70 52 65 71 75 
00C9F4: 65 73 74 28 29 3B 0D 0A 20 20 20 7D 0D 0A 20 20 
00CA04: 20 69 66 20 28 77 69 6E 64 6F 77 2E 41 63 74 69 
00CA14: 76 65 58 4F 62 6A 65 63 74 29 0D 0A 20 20 20 7B 
00CA24: 0D 0A 20 20 20 20 20 20 2F 2F 20 63 6F 64 65 20 
00CA34: 66 6F 72 20 49 45 36 2C 20 49 45 35 0D 0A 20 20 
00CA44: 20 20 20 20 72 65 74 75 72 6E 20 6E 65 77 20 41 
00CA54: 63 74 69 76 65 58 4F 62 6A 65 63 74 28 22 4D 69 
00CA64: 63 72 6F 73 6F 66 74 2E 58 4D 4C 48 54 54 50 22 
00CA74: 29 3B 0D 0A 20 20 20 7D 0D 0A 20 20 20 72 65 74 
00CA84: 75 72 6E 20 6E 75 6C 6C 3B 0D 0A 7D 0D 0A 0D 0A 
00CA94: 3C 2F 73 63 72 69 70 74 3E 0D 0A 3C 2F 68 65 61 
00CAA4: 64 3E 0D 0A 3C 62 6F 64 79 20 6F 6E 6C 6F 61 64 
00CAB4: 3D 22 73 65 74 53 74 61 72 74 54 69 6D 65 28 27 
00CAC4: 27 29 3B 22 20 42 47 43 4F 4C 4F 52 3D 23 46 46 
00CAD4: 46 46 46 46 20 53 54 59 4C 45 3D 22 62 61 63 6B 
00CAE4: 67 72 6F 75 6E 64 2D 63 6F 6C 6F 72 3A 20 23 46 
00CAF4: 46 46 46 46 46 3B 22 20 41 4C 49 4E 4B 3D 23 46 
00CB04: 46 30 30 30 30 3E 0D 0A 3C 68 31 3E 26 6E 62 73 
00CB14: 70 3B 3C 69 6D 67 20 62 6F 72 64 65 72 3D 22 30 
00CB24: 22 20 68 65 69 67 68 74 3D 22 31 32 31 22 20 73 
00CB34: 72 63 3D 22 6C 6F 67 6F 2E 6A 70 67 22 20 73 74 
00CB44: 79 6C 65 3D 22 68 65 69 67 68 74 3A 20 39 38 70 
00CB54: 78 3B 20 77 69 64 74 68 3A 20 31 39 32 70 78 22 
00CB64: 20 77 69 64 74 68 3D 22 32 38 33 22 20 2F 3E 3C 
00CB74: 2F 68 31 3E 0D 0A 0D 0A 3C 70 3E 50 44 55 20 2D 
00CB84: 20 3C 73 70 61 6E 20 73 74 79 6C 65 3D 22 77 68 
00CB94: 69 74 65 2D 73 70 61 63 65 3A 20 6E 6F 72 6D 61 
00CBA4: 6C 3B 20 77 6F 72 64 2D 73 70 61 63 69 6E 67 3A 
00CBB4: 20 30 70 78 3B 20 74 65 78 74 2D 74 72 61 6E 73 
00CBC4: 66 6F 72 6D 3A 20 6E 6F 6E 65 3B 20 66 6C 6F 61 
00CBD4: 74 3A 20 6E 6F 6E 65 3B 20 63 6F 6C 6F 72 3A 20 
00CBE4: 72 67 62 28 33 34 2C 33 34 2C 33 34 29 3B 20 74 
00CBF4: 65 78 74 2D 61 6C 69 67 6E 3A 20 6A 75 73 74 69 
00CC04: 66 79 3B 20 66 6F 6E 74 3A 20 31 33 70 78 20 61 
00CC14: 72 69 61 6C 3B 20 77 69 64 6F 77 73 3A 20 31 3B 
00CC24: 20 64 69 73 70 6C 61 79 3A 20 69 6E 6C 69 6E 65 
00CC34: 20 21 69 6D 70 6F 72 74 61 6E 74 3B 20 6C 65 74 
00CC44: 74 65 72 2D 73 70 61 63 69 6E 67 3A 20 6E 6F 72 
00CC54: 6D 61 6C 3B 20 62 61 63 6B 67 72 6F 75 6E 64 2D 
00CC64: 63 6F 6C 6F 72 3A 20 72 67 62 28 32 35 35 2C 32 
00CC74: 35 35 2C 32 35 35 29 3B 20 74 65 78 74 2D 69 6E 
00CC84: 64 65 6E 74 3A 20 30 70 78 3B 20 2D 77 65 62 6B 
00CC94: 69 74 2D 74 65 78 74 2D 73 74 72 6F 6B 65 2D 77 
00CCA4: 69 64 74 68 3A 20 30 70 78 22 3E 50 6F 77 65 72 
00CCB4: 20 44 69 73 74 72 69 62 75 74 69 6F 6E 20 55 6E 
00CCC4: 69 74 3C 2F 73 70 61 6E 3E 3C 2F 70 3E 0D 0A 0D 
00CCD4: 0A 3C 70 3E 3C 73 70 61 6E 20 73 74 79 6C 65 3D 
00CCE4: 22 77 68 69 74 65 2D 73 70 61 63 65 3A 20 6E 6F 
00CCF4: 72 6D 61 6C 3B 20 77 6F 72 64 2D 73 70 61 63 69 
00CD04: 6E 67 3A 20 30 70 78 3B 20 74 65 78 74 2D 74 72 
00CD14: 61 6E 73 66 6F 72 6D 3A 20 6E 6F 6E 65 3B 20 66 
00CD24: 6C 6F 61 74 3A 20 6E 6F 6E 65 3B 20 63 6F 6C 6F 
00CD34: 72 3A 20 72 67 62 28 33 37 2C 33 37 2C 33 37 29 
00CD44: 3B 20 66 6F 6E 74 3A 20 31 34 70 78 2F 32 32 70 
00CD54: 78 20 73 61 6E 73 2D 73 65 72 69 66 3B 20 77 69 
00CD64: 64 6F 77 73 3A 20 31 3B 20 64 69 73 70 6C 61 79 
00CD74: 3A 20 69 6E 6C 69 6E 65 20 21 69 6D 70 6F 72 74 
00CD84: 61 6E 74 3B 20 6C 65 74 74 65 72 2D 73 70 61 63 
00CD94: 69 6E 67 3A 20 6E 6F 72 6D 61 6C 3B 20 62 61 63 
00CDA4: 6B 67 72 6F 75 6E 64 2D 63 6F 6C 6F 72 3A 20 72 
00CDB4: 67 62 28 32 35 35 2C 32 35 35 2C 32 35 35 29 3B 
00CDC4: 20 74 65 78 74 2D 69 6E 64 65 6E 74 3A 20 30 70 
00CDD4: 78 3B 20 2D 77 65 62 6B 69 74 2D 74 65 78 74 2D 
00CDE4: 73 74 72 6F 6B 65 2D 77 69 64 74 68 3A 20 30 70 
00CDF4: 78 22 3E 52 65 6D 6F 74 65 20 6D 6F 6E 69 74 6F 
00CE04: 72 69 6E 67 20 61 6E 64 20 63 6F 6E 74 72 6F 6C 
00CE14: 20 62 79 3C 73 70 61 6E 20 63 6C 61 73 73 3D 22 
00CE24: 41 70 70 6C 65 2D 63 6F 6E 76 65 72 74 65 64 2D 
00CE34: 73 70 61 63 65 22 3E 26 6E 62 73 70 3B 3C 2F 73 
00CE44: 70 61 6E 3E 3C 2F 73 70 61 6E 3E 3C 61 20 63 6C 
00CE54: 61 73 73 3D 22 6D 77 2D 72 65 64 69 72 65 63 74 
00CE64: 22 20 68 72 65 66 3D 22 68 74 74 70 73 3A 2F 2F 
00CE74: 65 6E 2E 77 69 6B 69 70 65 64 69 61 2E 6F 72 67 
00CE84: 2F 77 69 6B 69 2F 4C 41 4E 22 20 73 74 79 6C 65 
00CE94: 3D 22 74 65 78 74 2D 64 65 63 6F 72 61 74 69 6F 
00CEA4: 6E 3A 20 6E 6F 6E 65 3B 20 62 61 63 6B 67 72 6F 
00CEB4: 75 6E 64 3A 20 72 67 62 28 32 35 35 2C 32 35 35 
00CEC4: 2C 32 35 35 29 3B 20 77 68 69 74 65 2D 73 70 61 
00CED4: 63 65 3A 20 6E 6F 72 6D 61 6C 3B 20 77 6F 72 64 
00CEE4: 2D 73 70 61 63 69 6E 67 3A 20 30 70 78 3B 20 74 
00CEF4: 65 78 74 2D 74 72 61 6E 73 66 6F 72 6D 3A 20 6E 
00CF04: 6F 6E 65 3B 20 63 6F 6C 6F 72 3A 20 72 67 62 28 
00CF14: 31 31 2C 30 2C 31 32 38 29 3B 20 66 6F 6E 74 3A 
00CF24: 20 31 34 70 78 2F 32 32 70 78 20 73 61 6E 73 2D 
00CF34: 73 65 72 69 66 3B 20 77 69 64 6F 77 73 3A 20 31 
00CF44: 3B 20 6C 65 74 74 65 72 2D 73 70 61 63 69 6E 67 
00CF54: 3A 20 6E 6F 72 6D 61 6C 3B 20 74 65 78 74 2D 69 
00CF64: 6E 64 65 6E 74 3A 20 30 70 78 3B 20 2D 77 65 62 
00CF74: 6B 69 74 2D 74 65 78 74 2D 73 74 72 6F 6B 65 2D 
00CF84: 77 69 64 74 68 3A 20 30 70 78 22 20 74 69 74 6C 
00CF94: 65 3D 22 4C 41 4E 22 3E 4C 41 4E 3C 2F 61 3E 2E 
00CFA4: 3C 2F 70 3E 0D 0A 0D 0A 3C 70 3E 45 71 75 69 70 
00CFB4: 6F 20 64 65 20 49 6E 76 65 73 74 69 67 61 63 69 
00CFC4: 6F 6E 20 79 20 44 65 73 61 72 72 6F 6C 6C 6F 20 
00CFD4: 64 65 20 41 6C 74 65 63 20 53 2E 45 2E 3C 2F 70 
00CFE4: 3E 0D 0A 0D 0A 3C 70 3E 43 61 72 6C 6F 73 2C 20 
00CFF4: 47 61 62 72 69 65 6C 20 79 20 57 61 6C 64 6F 3C 
00D004: 2F 70 3E 0D 0A 0D 0A 3C 74 61 62 6C 65 20 62 6F 
00D014: 72 64 65 72 3D 22 31 22 20 73 74 79 6C 65 3D 22 
00D024: 68 65 69 67 68 74 3A 20 32 39 70 78 3B 20 77 69 
00D034: 64 74 68 3A 20 31 36 35 70 78 22 3E 0D 0A 09 3C 
00D044: 74 62 6F 64 79 3E 0D 0A 09 09 3C 74 72 3E 0D 0A 
00D054: 09 09 09 3C 74 68 3E 53 65 6E 73 6F 72 20 43 6F 
00D064: 72 72 69 65 6E 74 65 3C 2F 74 68 3E 0D 0A 09 09 
00D074: 09 3C 74 64 20 69 64 3D 22 64 79 6E 30 22 3E 26 
00D084: 6E 62 73 70 3B 3C 2F 74 64 3E 0D 0A 09 09 3C 2F 
00D094: 74 72 3E 0D 0A 09 3C 2F 74 62 6F 64 79 3E 0D 0A 
00D0A4: 3C 2F 74 61 62 6C 65 3E 0D 0A 0D 0A 3C 66 6F 72 
00D0B4: 6D 20 6D 65 74 68 6F 64 3D 22 67 65 74 22 20 74 
00D0C4: 61 72 67 65 74 3D 22 5F 74 6F 70 22 3E 0D 0A 3C 
00D0D4: 70 3E 26 6E 62 73 70 3B 3C 69 6E 70 75 74 20 6E 
00D0E4: 61 6D 65 3D 22 62 75 74 74 6F 6E 30 30 22 20 6F 
00D0F4: 6E 63 6C 69 63 6B 3D 22 73 65 6E 64 43 67 69 28 
00D104: 27 62 75 74 74 6F 6E 30 30 27 2C 27 31 27 29 22 
00D114: 20 73 69 7A 65 3D 22 31 34 22 20 73 74 79 6C 65 
00D124: 3D 22 68 65 69 67 68 74 3A 20 32 32 70 78 3B 20 
00D134: 77 69 64 74 68 3A 20 31 31 30 70 78 22 20 74 79 
00D144: 70 65 3D 22 62 75 74 74 6F 6E 22 20 76 61 6C 75 
00D154: 65 3D 22 53 61 6C 69 64 61 20 31 20 22 20 2F 3E 
00D164: 3C 2F 70 3E 0D 0A 0D 0A 3C 70 3E 26 6E 62 73 70 
00D174: 3B 3C 69 6E 70 75 74 20 6E 61 6D 65 3D 22 62 75 
00D184: 74 74 6F 6E 30 31 22 20 6F 6E 63 6C 69 63 6B 3D 
00D194: 22 73 65 6E 64 43 67 69 28 27 62 75 74 74 6F 6E 
00D1A4: 30 31 27 2C 27 31 27 29 22 20 73 69 7A 65 3D 22 
00D1B4: 31 34 22 20 73 74 79 6C 65 3D 22 68 65 69 67 68 
00D1C4: 74 3A 20 32 32 70 78 3B 20 77 69 64 74 68 3A 20 
00D1D4: 31 31 30 70 78 22 20 74 79 70 65 3D 22 62 75 74 
00D1E4: 74 6F 6E 22 20 76 61 6C 75 65 3D 22 53 61 6C 69 
00D1F4: 64 61 20 32 20 22 20 2F 3E 3C 2F 70 3E 0D 0A 0D 
00D204: 0A 3C 70 3E 26 6E 62 73 70 3B 3C 69 6E 70 75 74 
00D214: 20 6E 61 6D 65 3D 22 62 75 74 74 6F 6E 30 32 22 
00D224: 20 6F 6E 63 6C 69 63 6B 3D 22 73 65 6E 64 43 67 
00D234: 69 28 27 62 75 74 74 6F 6E 30 32 27 2C 27 31 27 
00D244: 29 22 20 73 69 7A 65 3D 22 31 34 22 20 73 74 79 
00D254: 6C 65 3D 22 68 65 69 67 68 74 3A 20 32 32 70 78 
00D264: 3B 20 77 69 64 74 68 3A 20 31 31 30 70 78 22 20 
00D274: 74 79 70 65 3D 22 62 75 74 74 6F 6E 22 20 76 61 
00D284: 6C 75 65 3D 22 53 61 6C 69 64 61 20 33 22 20 2F 
00D294: 3E 3C 2F 70 3E 0D 0A 0D 0A 3C 70 3E 26 6E 62 73 
00D2A4: 70 3B 3C 69 6E 70 75 74 20 6E 61 6D 65 3D 22 62 
00D2B4: 75 74 74 6F 6E 30 33 22 20 6F 6E 63 6C 69 63 6B 
00D2C4: 3D 22 73 65 6E 64 43 67 69 28 27 62 75 74 74 6F 
00D2D4: 6E 30 33 27 2C 27 31 27 29 22 20 73 69 7A 65 3D 
00D2E4: 22 31 34 22 20 73 74 79 6C 65 3D 22 68 65 69 67 
00D2F4: 68 74 3A 20 32 32 70 78 3B 20 77 69 64 74 68 3A 
00D304: 20 31 31 30 70 78 22 20 74 79 70 65 3D 22 62 75 
00D314: 74 74 6F 6E 22 20 76 61 6C 75 65 3D 22 53 61 6C 
00D324: 69 64 61 20 34 20 22 20 2F 3E 3C 2F 70 3E 0D 0A 
00D334: 3C 2F 66 6F 72 6D 3E 0D 0A 0D 0A 3C 70 3E 26 6E 
00D344: 62 73 70 3B 3C 2F 70 3E 0D 0A 3C 2F 62 6F 64 79 
00D354: 3E 0D 0A 3C 2F 68 74 6D 6C 3E 0D 0A 04 FF FF FF 
00D364: D8 FF E0 00 10 4A 46 49 46 00 01 01 01 00 60 00 
00D374: 60 00 00 FF E1 00 2E 45 78 69 66 00 00 4D 4D 00 
00D384: 2A 00 00 00 08 00 02 51 00 00 03 04 00 00 00 01 
00D394: 00 00 00 00 51 01 00 03 03 00 00 00 01 00 01 00 
00D3A4: 00 00 00 00 00 FF DB 00 43 00 02 01 01 02 01 01 
00D3B4: 02 02 02 02 02 02 02 02 03 03 05 03 03 03 03 03 
00D3C4: 03 03 03 03 03 06 03 04 03 04 03 03 05 07 06 07 
00D3D4: 07 07 06 07 07 08 09 0B 09 08 08 0A 08 07 07 0A 
00D3E4: 0D 0A 0A 0B 0C 0C 0C 0C 07 09 0E 0F 0D 0C 0E 0B 
00D3F4: 0C 0C 0C FF DB 00 43 01 02 02 02 03 03 03 03 03 
00D404: 03 06 03 03 03 03 06 0C 08 07 08 0C 0C 0C 0C 0C 
00D414: 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 
00D424: 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 
00D434: 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C 0C FF C0 00 
00D444: 11 08 00 79 01 1B 03 03 01 22 00 02 11 01 03 03 
00D454: 11 01 FF C4 00 1F 00 00 01 05 01 01 01 01 01 01 
00D464: 00 00 00 00 00 00 00 00 01 02 03 03 03 04 05 06 
00D474: 07 08 09 0A 0B FF C4 00 B5 10 00 02 01 03 03 03 
00D484: 03 02 03 04 03 03 05 05 03 04 03 04 00 00 01 7D 
00D494: 01 02 03 03 00 03 04 11 05 12 21 31 41 06 13 51 
00D4A4: 61 07 22 71 14 32 81 91 A1 08 23 42 B1 C1 15 52 
00D4B4: D1 F0 24 33 62 72 82 09 0A 16 17 18 19 1A 25 26 
00D4C4: 27 28 29 2A 34 35 36 37 38 39 3A 43 44 45 46 47 
00D4D4: 48 49 4A 53 54 55 56 57 58 59 5A 63 64 65 66 67 
00D4E4: 68 69 6A 73 74 75 76 77 78 79 7A 83 84 85 86 87 
00D4F4: 88 89 8A 92 93 94 95 96 97 98 99 9A A2 A3 A4 A5 
00D504: A6 A7 A8 A9 AA B2 B3 B4 B5 B6 B7 B8 B9 BA C2 C3 
00D514: C4 C5 C6 C7 C8 C9 CA D2 D3 D4 D5 D6 D7 D8 D9 DA 
00D524: E1 E2 E3 E4 E5 E6 E7 E8 E9 EA F1 F2 F3 F4 F5 F6 
00D534: F7 F8 F9 FA FF C4 00 1F 01 00 03 03 01 01 01 01 
00D544: 01 01 01 01 01 00 00 00 00 00 00 01 02 03 03 03 
00D554: 04 05 06 07 08 09 0A 0B FF C4 00 B5 11 00 02 01 
00D564: 02 03 04 03 04 03 03 03 04 07 05 03 04 03 04 00 
00D574: 01 02 77 00 01 02 03 03 11 03 04 05 21 31 06 12 
00D584: 41 51 07 61 71 13 22 32 81 08 14 42 91 A1 B1 C1 
00D594: 09 23 33 52 F0 15 62 72 D1 0A 16 24 34 E1 25 F1 
00D5A4: 17 18 19 1A 26 27 28 29 2A 35 36 37 38 39 3A 43 
00D5B4: 44 45 46 47 48 49 4A 53 54 55 56 57 58 59 5A 63 
00D5C4: 64 65 66 67 68 69 6A 73 74 75 76 77 78 79 7A 82 
00D5D4: 83 84 85 86 87 88 89 8A 92 93 94 95 96 97 98 99 
00D5E4: 9A A2 A3 A4 A5 A6 A7 A8 A9 AA B2 B3 B4 B5 B6 B7 
00D5F4: B8 B9 BA C2 C3 C4 C5 C6 C7 C8 C9 CA D2 D3 D4 D5 
00D604: D6 D7 D8 D9 DA E2 E3 E4 E5 E6 E7 E8 E9 EA F2 F3 
00D614: F4 F5 F6 F7 F8 F9 FA FF DA 00 0C 03 03 01 00 02 
00D624: 11 03 03 11 00 3F 00 FD FC A2 8A 28 00 A2 8A 28 
00D634: 00 A2 8A 28 00 A2 80 D9 A3 75 00 14 51 9A 33 40 
00D644: 05 14 66 80 73 40 05 14 13 46 68 00 A2 8A 28 00 
00D654: A2 93 75 2E 79 A0 02 8A 28 A0 02 8A 09 C5 19 A0 
00D664: 02 8A 4D E2 94 1C D0 01 45 19 A3 34 00 51 45 14 
00D674: 00 51 45 14 00 51 45 14 00 51 45 14 00 51 45 14 
00D684: 00 51 45 14 00 51 45 14 00 51 41 38 A6 89 01 A0 
00D694: 00 91 42 F5 AE 3F E3 9F C6 EF 0D FE CE 7F 0A F5 
00D6A4: AF 19 F8 BB 52 87 4B F0 FE 87 01 9E E6 77 3F 31 
00D6B4: EC A8 8B D5 DD D8 AA AA 8E 59 98 01 5F 3E 7F C1 
00D6C4: 29 3F E0 A2 93 7F C1 43 FC 23 F1 13 58 BC B1 83 
00D6D4: 48 7D 03 03 C4 86 DF 4F B0 8C 96 92 DF 4D 92 08 

00D6E4: CD B9 95 B3 F3 4A CE 93 96 23 03 03 3C 0E 05 6D 
00D6F4: 1C 3D 47 49 D6 4B DD 4E D7 31 75 A0 AA 7B 27 BB 
00D704: 3E B5 07 22 90 B0 14 0E 2B E1 9F F8 2C CF FC 15 
00D714: 0B C5 7F F0 4E B8 BC 03 03 6F E0 DD 27 C3 1A BE 
00D724: A3 E2 C6 BE 92 E9 75 88 67 99 60 8A 0F 20 29 51 
00D734: 14 B1 9C B3 4A DD 49 FB 9D 28 C3 E1 E7 5E A2 A5 
00D744: 4F 71 D6 AD 1A 50 73 9E C7 DC B9 DC 7B D2 86 C7 
00D754: 7A FC 33 FF 00 88 9B BE 38 FF 00 D0 9F F0 AF FF 
00D764: 00 00 2F F3 FF 00 A5 75 FA A3 FF 00 03 04 D6 FD 
00D774: A4 7C 59 FB 5D FE C7 7E 17 F8 89 E3 2D 3F 45 D2 
00D784: F5 6F 12 3D D3 AD B6 97 14 B1 5B A4 31 DC CB 0A 
00D794: 1D B2 3B B6 58 47 BB 3B 88 20 8E 95 D9 8C CA 71 
00D7A4: 38 58 A9 D6 49 27 A6 E7 36 1F 30 A5 5E 5C B4 CF 
00D7B4: 7A F5 E6 80 B9 AF 85 FF 00 E0 B2 FF 00 F0 54 6F 
00D7C4: 16 FF 00 C1 39 C7 80 2D 7C 1F A4 F8 67 58 D4 3C 
00D7D4: 55 F6 E9 AE D7 58 82 79 16 08 A0 F2 02 6C 11 4B 
00D7E4: 19 05 9A 56 CE 49 FB 9D AB E1 DF F8 89 BB E3 90 
00D7F4: FF 00 99 3F E1 57 FE 00 5F FF 00 F2 65 69 85 C9 
00D804: 71 75 E9 AA B4 D6 8F CC 9A F9 A5 0A 53 E4 9B D4 
00D814: FD CC A2 BF 0C FF 00 E2 27 0F 8E 3F F4 27 7C 2A 
00D824: FF 00 C0 0B FF 00 FE 4C A3 FE 22 70 F8 E5 FF 00 
00D834: 42 77 C2 AF FC 00 BF FF 00 E4 CA DB FD 5B C7 7F 
00D844: 2A FB D1 8F F6 D6 17 BF E0 7E E5 1F 97 F3 A0 9C 
00D854: F7 AF CE 7F F8 24 07 FC 15 A3 E2 97 FC 14 37 E3 
00D864: DF 88 BC 3F E2 AF 0E F8 27 4B D0 34 1D 09 B5 07 
00D874: B8 D2 2D 6E A3 B8 37 06 78 A3 89 09 96 79 17 69 
00D884: 56 94 F4 CF C8 3D EB C2 FF 00 6A CF F8 38 9B E2 
00D894: A7 C2 0F DA 5F C7 BE 12 F0 CF 85 FE 1D DE 68 3E 
00D8A4: 17 D7 6F 34 7B 49 EF AD 2F 24 B8 9D 6D E6 68 8B 
00D8B4: BB 25 CA A9 C9 42 46 14 70 47 5A E7 8E 4B 89 95 
00D8C4: 67 45 2F 79 2B BD 7B 9B 4B 32 A2 A9 AA B7 D1 9F 
00D8D4: B1 C3 A5 15 F8 67 FF 00 11 37 FC 72 FF 00 A1 3B 
00D8E4: E1 57 FE 00 5F FF 00 F2 65 1F F1 13 87 C7 2F FA 
00D8F4: 13 BE 15 7F E0 05 FF 00 FF 00 26 57 47 FA B7 8E 
00D904: FE 55 F7 A3 3F ED 8C 37 77 F7 1F B9 40 FC D4 A1 
00D914: B2 6B F0 CC FF 00 C1 CD 9F 1C 37 7F C8 9D F0 AF 
00D924: 9F FA 70 BF FF 00 E4 CA FD B0 F8 6B AA EA 9A CF 
00D934: C3 AD 02 F3 5D 86 DE D7 5B BA D3 AD E5 D4 22 81 
00D944: 59 61 8A E1 A2 53 22 A0 62 C4 28 72 C0 02 C4 E3 
00D954: 19 27 AD 70 E3 32 DA D8 54 9D 65 6B F9 DC E9 C3 
00D964: 63 69 D7 6D 53 E8 6D F7 EF 41 38 AC FF 00 14 F8 
00D974: B7 4A F0 27 87 AF 35 7D 6B 52 B1 D2 34 9D 3E 23 
00D984: 35 D5 E5 ED C2 DB DB DB 20 EA CE EE 42 A8 F7 26 
00D994: BF 3E 7F 6A BF F8 38 EF E1 57 C2 1B DB 8D 33 E1 
00D9A4: EE 93 A8 7C 4C D4 E1 25 4D D2 48 74 FD 2D 4F 4E 
00D9B4: 25 74 69 24 C1 FE EC 7B 48 E8 E4 1C D6 38 6C 0D 
00D9C4: 6C 44 B9 69 46 E5 D7 C5 52 A2 AF 51 D8 FD 16 F3 
00D9D4: 31 FD 28 24 62 BF 03 03 FE 29 FF 00 C1 C6 5F B4 
00D9E4: 17 8E 2E 25 FE C1 FF 00 84 43 C1 76 E7 22 31 63 
00D9F4: A5 0B A9 94 7F B4 D7 2D 2A B1 F7 08 A3 DA BD 5B 
00DA04: FE 09 1F FF 00 05 38 FD A3 3F 6B 7F DB BB C2 BE 
00DA14: 11 F1 57 C4 19 35 7F 0A C9 05 E5 E6 AD 6A 34 3D 
00DA24: 36 0D F1 45 6D 21 41 BE 38 15 D7 F7 C6 1C 95 20 
00DA34: E1 BD 2B D5 AD C3 B8 9A 54 9D 6A 8D 25 15 7D DD 
00DA44: FF 00 2B 1C 30 CE 28 CE A2 A7 03 04 EE FF 00 AE 
00DA54: E7 EC E0 E9 45 22 F0 B4 92 4C B1 23 33 32 AA A8 
00DA64: CB 13 D0 0F 5A F0 8F 58 75 15 97 FF 00 09 C6 8B 
00DA74: FF 00 41 8D 2F FF 00 02 A3 FF 00 1A 3F E1 38 D1 
00DA84: 7F E8 31 A5 FF 00 E0 54 7F E3 40 1A 94 56 5F FC 
00DA94: 27 1A 2F FD 06 34 BF FC 0A 8F FC 68 FF 00 84 E3 
00DAA4: 45 FF 00 A0 C6 97 FF 00 81 51 FF 00 8D 00 6A 51 
00DAB4: 59 7F F0 9C 68 BF F4 18 D2 FF 00 F0 2A 3F F1 AB 
00DAC4: 9A 76 AB 6B AB C2 D2 5A 5C 41 75 1A B6 D2 F1 48 
00DAD4: 1D 41 EB 8C 8F A8 A0 0B 14 51 45 00 14 51 45 00 
00DAE4: 14 51 9E 28 CD 00 21 EB 59 BE 29 F1 36 9F E0 9F 
00DAF4: 0E EA 1A C6 B1 7D 6B A6 E9 3A 5D BB DD 5E 5D DC 
00DB04: CA 22 86 DA 24 05 9D DD 8F 0A AA A0 92 49 C5 68 
00DB14: B4 8A AB B9 8E 00 EE 7B 57 E4 17 FC 14 C7 F6 A8 
00DB24: F8 9D FF 00 05 48 F8 97 7D F0 4F F6 78 D0 F5 6F 
00DB34: 11 78 0F 43 BA F2 F5 DD 66 C4 F9 76 3A C5 D2 10 
00DB44: DB 5E E5 8A C4 96 D1 B0 F9 72 FF 00 BD 71 B8 06 
00DB54: 0A 84 F6 60 70 6E BD 4E 4B DA 3D 5B E8 8E 6C 56 
00DB64: 21 52 8F 35 AE FA 2F 33 E5 CF F8 2B CF FC 15 12 
00DB74: FF 00 F6 FB F8 AA BA 46 83 35 CD 9F C2 FF 00 0C 
00DB84: CE DF D8 F6 8C 0C 6D AA 4B CA B5 F4 C8 79 DC 41 
00DB94: 21 14 8C A2 31 E0 33 38 3E C1 FF 00 06 CC FC 5E 
00DBA4: 6F 0A 7E D5 FE 32 F0 64 92 08 ED 7C 5D E1 F1 76 
00DBB4: 89 8F F5 97 16 73 02 83 FE FD DC 4E 7D 38 FA 57 
00DBC4: A0 7E CF 1F F0 6D 03 04 5A 7E 97 1E B1 F1 9B E2 
00DBD4: 24 3A 7C 28 03 04 97 1A 5F 87 B6 AA C4 BE 8F 77 
00DBE4: 30 C0 3D 88 11 11 9E 8D DE BE 8A F8 45 E1 3F D8 
00DBF4: D7 FE 09 EF E2 08 75 4F 07 5A 59 EA 1E 2D B1 47 
00DC04: 58 F5 1B 69 A7 D5 AF 0E E4 68 DF 6C A5 8C 31 EE 
00DC14: 52 54 84 28 0E 4F 1C 9A F6 F3 7E 22 C9 F0 78 27 
00DC24: 85 53 49 5B 7D 12 BF 7D 77 3E 72 31 A9 4E B2 C4 
00DC34: E2 E6 A1 EA D7 DC 7D EA 0E DA FC 28 FF 00 83 94 
00DC44: FE 24 7F C2 55 FB 73 E8 7A 03 04 72 6E 87 C2 FE 
00DC54: 17 B7 8A 44 07 94 9E 79 A6 95 8F E3 19 82 BF 58 
00DC64: 7F 65 FF 00 DB B3 44 FD AB 7C 75 AB 69 3A 0E 8B 
00DC74: AB D9 DB 69 56 82 E9 EE 6F 8C 48 CC 4B 85 0A 11 
00DC84: 19 8F 3C 9C E7 B5 7E 0E FF 00 C1 5D 3E 25 7F C2 
00DC94: D7 FF 00 82 90 7C 5C D4 96 4F 31 6D 75 B6 D2 53 
00DCA4: 1D 00 B2 8D 2D 38 FC 60 3F 5C 93 5C 7C 17 5A 96 
00DCB4: 32 BF D6 28 4B 9A 29 3D 57 DC 75 66 98 DA 55 B0 
00DCC4: AA 74 5F 32 6F F2 3E 72 03 03 8F D3 02 BF A8 AF 
00DCD4: D8 23 E1 C7 FC 2A 5F D8 AB E1 4F 87 9A 2F 26 6D 
00DCE4: 3B C2 BA 78 B9 5F 49 DA DD 1E 6F FC 88 CE 6B F9 
00DCF4: 9F F8 15 F0 F1 BE 2E FC 6F F0 6F 85 23 DD BB C4 
00DD04: DA ED 96 92 31 D7 F7 F7 09 17 FE CF 5F D5 C5 AC 
00DD14: 0B 6B 03 04 71 C6 AA 91 C6 A1 55 54 60 28 03 03 
00DD24: 00 0A F6 B8 BA B7 F0 E9 F7 BB FD 08 E1 FA 7F 14 
00DD34: FE 47 E1 57 FC 1C 8F E3 E9 FC 65 FB 76 E9 5A 1C 
00DD44: 1E 74 96 DE 14 F0 C5 B4 12 22 A9 60 93 CD 2C B3 
00DD54: B9 F6 26 37 87 3E CA 2B F3 DA 7B 59 2D 80 F3 23 
00DD64: 78 F3 D3 72 95 CD 7F 5C 0C 99 39 23 DB 3E 95 F8 
00DD74: BF FF 00 07 41 FC 45 5D 47 E3 A7 C2 FF 00 09 AC 
00DD84: 9C E8 BA 1D CE AE CA 3B 1B B9 C4 40 FF 00 E4 9F 
00DD94: E1 F8 F3 59 0E 70 E6 E1 83 50 D1 27 AD FF 00 E0 
00DDA4: 13 9A E5 FC AA 58 87 2F 95 BF E0 9F 97 75 24 76 
00DDB4: 73 4C 9B 92 29 19 73 8C 85 24 7E 7F 8D 46 6B FA 
00DDC4: 3A FF 00 82 2A 7C 32 FF 00 85 67 FF 00 03 04 CE 
00DDD4: F8 63 03 04 91 EC B8 D5 AC E7 D6 25 6C 63 CC FB 
00DDE4: 4D CC B3 46 7F EF D3 46 32 3A E3 35 ED 66 D9 9F 
00DDF4: D4 69 C6 7C BC D7 F9 7F 99 E6 65 F8 27 88 A8 E0 
00DE04: 9D AC 7C 83 FF 00 06 D6 78 5E 3F 86 BF 03 04 7E 
00DE14: 36 7C 48 D5 21 9A 1B 38 A6 B6 B4 32 32 E3 62 59 
00DE24: DB CD 71 36 3F 09 D0 9F A0 AF C9 3F 17 78 9A E7 
00DE34: C6 9E 2B D5 35 8B C3 BA F3 56 BB 96 F2 72 3B C9 
00DE44: 23 97 6F D4 9A FE 94 3F E0 AB 3F 11 7F E1 53 FF 
00DE54: 00 C1 3A 7E 2F EA 9B 8C 6D 37 87 E6 D2 D1 83 60 
00DE64: AB DE 15 B4 5C 7E 33 83 C7 3E 9C D7 F3 3F FE 7A 
00DE74: 57 07 0F D6 FA CD 4A B8 A9 2B 73 34 BD 2C 8E CC 
00DE84: D6 9F B1 84 28 2D 6C 3A 18 1E E0 FE ED 19 F1 C9 
00DE94: DA 33 8A 93 FB 36 E3 FE 7D E7 FF 00 BF 66 BF 4A 
00DEA4: 7F E0 D8 CF 87 0D AD 7E D4 9F 10 3C 54 D1 EE 8B 
00DEB4: 40 F0 D2 E9 E1 88 E1 24 BA B9 8D D4 E7 B1 DB 6D 
00DEC4: 26 3B 10 5A BE E5 F1 C7 FC 16 0F 4B F0 67 8E 35 
00DED4: 9D 22 3F 03 04 DE 5E C7 A5 DF 4D 66 B7 0B A9 2A 
00DEE4: 09 C4 72 14 0E 07 96 70 1B 19 C6 4F 5E A6 BC DE 
00DEF4: 24 E3 8C 26 4D 55 43 13 65 7E B7 7A BB 6D 64 99 
00DF04: C3 EC 70 F4 A8 C6 B6 26 A7 22 93 B2 D2 E7 E1 87 
00DF14: EC A5 F0 A2 6F 8B BF B4 EF C3 CF 0B BD AC CF 0F 
00DF24: 88 3C 49 A7 D8 4C 0C 6C 55 63 92 E6 35 72 78 FB 
00DF34: A1 0B 13 EC 0D 7F 49 BF B5 E7 ED 75 E0 EF D8 9B 
00DF44: E0 A6 A1 E3 6F 19 5E 34 16 56 BF BA B4 B4 87 0D 
00DF54: 73 A9 DC 10 4A 41 0A E4 65 DB 03 04 E4 E1 54 02 
00DF64: CC 40 03 04 D6 47 EC 9F FB 58 DD FE D3 DE 1D D4 
00DF74: 75 C9 7C 25 37 86 3C 3F 63 95 8E FE EA F8 48 B7 
00DF84: 6E 32 5F 60 D8 BF 2A 01 CB E7 19 E3 9C 36 3F 08 
00DF94: FF 00 E0 AC 1F B7 BD F7 ED DF FB 50 6A 1A 85 B5 
00DFA4: D4 CD E0 7F 0C C9 26 9D E1 8B 5E 55 03 04 01 80 
00DFB4: 7B 92 BF DF 99 94 39 38 03 04 28 8D 79 DB 5C B8 
00DFC4: 3C 64 78 8E A4 2B C1 5A 9A 5E 7A FD E9 6E 7A B4 
00DFD4: 6B 52 C2 61 BD AD 29 73 73 6D A5 BF 0E C6 3F ED 
00DFE4: F1 FF 00 05 2C F8 8D FB 7F 78 D2 49 FC 45 7C DA 
00DFF4: 5F 85 6D 66 2F A5 F8 6E CE 56 16 36 6A 32 15 DC 
00E004: 71 E7 4C 01 E6 47 19 E5 82 84 53 B6 BE 78 FB A1 
00E014: 8F E2 4D 49 61 63 36 A7 7B 0D AD AC 32 DC 5C 5C 
00E024: 3A C7 14 51 21 67 91 89 C0 55 51 C9 24 F1 81 5F 
00E034: B2 5F F0 4D 6F F8 37 CB C3 FE 1D F0 D6 9B E3 2F 
00E044: 8E D6 6D AC EB D7 4A 97 16 FE 15 12 94 B3 D3 87 
00E054: 0C A2 E8 A1 CC D2 74 CC 60 88 D7 90 44 99 E3 EB 
00E064: 31 58 CC 2E 5D 45 47 6E C9 6F FD 79 9E 65 1A 15 
00E074: F1 75 5B 4E EF AB EC 7E 3E F8 5F C1 3A D7 8E 2F 
00E084: DA D7 45 D2 35 4D 62 E9 46 E3 0D 95 AB DC 48 07 
00E094: FB A8 09 AF D4 0F F8 36 FB F6 60 F1 57 82 FF 00 
00E0A4: 69 6F 1C F8 B3 C4 DE 17 D7 B4 28 F4 FF 00 0D A6 
00E0B4: 9F 68 DA 9E 9D 2D A0 95 AE 6E 11 F7 27 98 A3 76 
00E0C4: 16 D8 8C 8E 81 BD EB F5 EB C0 FF 00 0E F4 1F 86 
00E0D4: 5E 1B 83 47 F0 DE 89 A4 E8 3A 4D A8 C4 36 5A 75 
00E0E4: A4 76 B6 F1 7F BA 91 80 A3 F0 15 AD E5 ED AF 93 
00E0F4: C7 F1 2C B1 14 65 46 30 B2 7E 7F F0 0F 7F 0B 93 
00E104: AA 55 15 47 2B B4 48 BF 76 BC A7 F6 DB F1 97 FC 
00E114: 20 9F B2 97 8E AF BC CF 2D A4 D2 E4 B3 43 9C 61 
00E124: A7 22 01 8F FB F9 9F C2 BD 59 46 16 BE 51 FF 00 
00E134: 82 BD 78 C4 E8 9F B3 7E 9F A4 A3 AA C9 AE 6B 31 
00E144: 46 EA 4F DE 8A 34 77 27 1E CE 23 FC EB E6 4F 6C 
00E154: FC D4 03 04 F4 CF B7 5A F4 0F 01 7E CB 3F 10 FE 
00E164: 27 78 77 FB 5B 42 F0 AE A9 A8 69 EC 8D 2C 72 AE 
00E174: D4 F3 D5 4E 09 8C 31 06 40 0F 1F 20 3C F1 D6 B8 
00E184: 00 D9 1F DE EF CF D7 3C D7 D2 7F B1 B7 C3 7D 73 
00E194: C7 5F 15 74 BF 19 8F 12 E9 1A B7 88 3C 3B 1A DE 
00E1A4: 69 FE 1E 4D 5D 13 53 D4 96 24 C2 5B A9 3F 24 51 
00E1B4: 03 04 18 65 C9 2A 9C 6C EE 00 3E 74 3A 4D E0 D5 
00E1C4: 7E C3 F6 6B 8F B7 79 BF 67 FB 3E C6 F3 7C CC ED 
00E1D4: D9 B7 19 DD 9E 31 8C E6 BA AF 11 7E CF 9E 33 F0 
00E1E4: A6 89 7B A8 5F 68 77 11 DB E9 6E A9 7E 12 68 E5 
00E1F4: 97 4E 66 38 51 71 1A 31 78 72 78 1E 62 AE 4F 1D 
00E204: 6B DD 3E 0F DD 5E 59 58 7C 6E F8 DF AD 69 E9 61 
00E214: E2 4D 1E 69 2D 34 D8 0A 15 FE CE D4 EE E6 28 EE 
00E224: AA 79 0F 0F 98 A0 06 07 EF 36 7A 03 03 59 3F F0 
00E234: 4F 1B 7F ED 7D 6F E2 BD E6 A8 ED 36 93 FF 00 08 
00E244: 36 A3 FD A2 65 3B D5 CB 34 6D 96 CF 53 B5 64 39 
00E254: 3E FE A4 90 0F 9B C1 27 FF 00 D7 5F AA FF 00 F0 
00E264: 4C 4F 05 7F C2 1D FB 20 68 32 B2 6C 9B 5B 9E E3 
00E274: 52 94 63 AE E9 0A 29 FC 63 8D 0D 7E 54 1C E3 BF 
00E284: 3D 0F E3 5F B5 FF 00 03 03 BC 1D FF 00 0A F7 E0 
00E294: CF 85 34 36 4F 2D F4 9D 22 D6 D5 C7 FB 69 12 86 
00E2A4: 27 DC B0 26 80 3A 9A 28 A2 80 0A 28 CF 34 50 03 
00E2B4: 03 4F 14 D2 D8 6C 73 4E CF CD F8 D7 87 7E D7 DF 
00E2C4: B6 F7 87 7F 65 7D 13 C9 90 C7 AC 78 9E E9 03 03 
00E2D4: DA E9 51 CB B5 B6 13 8F 32 56 C1 F2 D3 AE 32 32 
00E2E4: C4 10 01 C3 11 CB 8C C6 52 C2 D2 75 AB CB 96 2B 
00E2F4: 76 73 E2 B1 54 F0 F4 DD 5A B2 E5 48 EB FF 00 69 
00E304: 8B 5F 0A 6A 9F 09 75 0B 5F 1C 6B 8D A2 F8 4E E0 
00E314: 79 7A A0 5B AF B3 7F 68 42 73 BA D5 9D 7F 79 B2 
00E324: 41 F2 95 88 AB B8 CA 83 82 41 F8 DB E2 47 FC 15 
00E334: 13 44 F8 61 E1 BB 7F 09 FC 17 F0 8E 95 A2 E8 7A 
00E344: 6A 18 6D A7 96 CC 5B 5B C4 BF F4 C6 DA 3D B8 CF 
00E354: 5C BF 24 F5 5E F5 F2 E7 C7 3F DA 0B C5 7F B4 47 
00E364: 8A 9B 56 F1 56 A4 F7 72 21 22 0B 75 1B 2D AC 90 
00E374: 9C ED 8E 3E 80 74 E4 FC CD 81 92 DD 6B 3F C0 3F 
00E384: 07 3C 59 F1 4E 6F 2F C3 9E 1B D6 B5 9F 9B 61 7B 
00E394: 4B 47 92 38 CF FB 4E 06 D5 FC 48 AF CA 33 6E 39 
00E3A4: C6 E2 DF D5 F2 B4 E3 1E E9 5E 4F E5 D3 E5 A9 F9 
00E3B4: 9E 67 C5 98 9C 55 4F 65 80 8D 97 7B 5D BF F2 26 
00E3C4: F8 9D F1 CB C6 1F 19 2F E4 BA F1 37 88 B5 6D 62 
00E3D4: 46 6F 30 47 34 A7 C9 89 BB 6D 89 48 44 EA 7E E8 
00E3E4: 1D FB 1A E5 7E 52 38 2A 57 A7 5E 2B 6B F6 B2 F8 
00E3F4: 65 E2 6F D8 9B C1 9A 2E BD F1 03 03 41 BF D2 EC 
00E404: F5 EB A7 B5 B3 58 5E 2B 89 1D D5 77 1C ED 7D A9 
00E414: 85 3C 06 20 9C 1C 03 03 83 8F 9F F5 2F DB 77 C3 
00E424: 70 DA 06 B3 D3 35 C9 EE 3F B9 3A 47 12 74 3F C6 
00E434: 1D CF A7 F0 F7 3E 83 3E 36 1B 83 78 8B 31 FD F4 
00E444: 68 4A 57 EA F4 FC D9 F3 35 B2 FC 7D 49 DE AC 5D 
00E454: FC F4 7F 89 FA BF FF 00 03 04 7B D1 AD 7C 23 F0 
00E464: B7 E2 17 8C AF 64 58 6D 16 74 B6 92 46 E9 12 5B 
00E474: 42 D3 39 CF D2 61 9F F7 45 7E 0C 78 F7 C5 D7 1F 
00E484: 10 3C 75 AD EB D7 9C DE 6B 97 F3 EA 13 9C 75 79 
00E494: 64 69 1B F5 63 5F B1 3F B3 17 ED 4F A5 CF FF 00 
00E4A4: 03 04 23 F8 C5 E2 ED 36 D6 4D 2E F6 CF FB 57 45 
00E4B4: BA 0F 28 6D B7 97 11 41 03 04 4E AC 00 FE 0B AB 
00E4C4: 7E 3D 46 2B F1 80 74 AF E9 AF 0D 72 5A 99 7E 5F 
00E4D4: EC 31 11 E5 9C 74 6A F7 D7 77 B1 F7 9E CF D9 60 
00E4E4: 68 50 7D 15 DF AD CF A9 BF E0 8B 5F 0D 7F E1 68 
00E4F4: 7F C1 4B FE 18 DB 48 8C D6 FA 55 E4 FA C4 C4 2E 
00E504: 76 7D 96 DA 49 A3 27 D0 79 AB 1A E7 D5 87 7A FE 
00E514: 90 14 63 15 F8 7F FF 00 06 CA 7C 35 6F 10 7E D7 
00E524: 1E 36 F1 43 C7 BA 1F 0D F8 60 DA A3 63 88 A6 BA 
00E534: B8 8F 69 CF AF 97 03 04 C3 1E E7 D2 BF 70 32 38 
00E544: AB E2 8A BC D8 CE 4F E5 4B F1 D4 FA 6C 92 9F 2E 
00E554: 1F 9B BB 06 3C 7E B5 FC EE 7F C1 78 3E 23 B7 C4 
00E564: 3F F8 29 AF 8E A2 59 03 04 D6 DE 1D 86 C7 47 84 
00E574: EE DD 80 96 B1 BC 83 DB 12 CB 20 C7 B6 7A D7 F4 
00E584: 44 CD 83 5F CA E7 ED 67 F1 2B FE 17 1F ED 47 F1 
00E594: 17 C5 8B 20 92 3F 10 F8 93 50 BF 84 83 90 23 92 
00E5A4: E1 DA 30 0F 70 10 A8 1E C2 B6 E1 3A 5C D8 89 4D 
00E5B4: F4 5F 99 96 7D 53 F7 51 87 77 F9 1C 05 B4 0F 79 
00E5C4: 71 1C 71 A9 92 49 99 51 54 75 62 4F 4F D6 BF AB 
00E5D4: BF 82 3F 0F A3 F8 4D F0 67 C2 3E 17 8C 2F 97 E1 
00E5E4: AD 1A CF 4B 4C 74 02 08 12 21 8F C1 6B F9 9E FD 
00E5F4: 81 7E 1B 7F C2 DD FD B6 7E 15 78 75 A3 13 5B EA 
00E604: 1E 29 B0 FB 4A ED C8 30 24 E9 24 BF F9 0D 1B F1 
00E614: F6 AF EA 24 0F 96 BA 38 B6 B7 BD 0A 7E AC CB 87 
00E624: E9 FB B3 A9 E7 63 F3 E7 FE 0E 48 F8 92 DE 10 FD 
00E634: 81 EC 34 38 E4 2B 2F 8B 7C 4F 69 6A E8 0F 58 61 
00E644: 49 6E 09 F7 C4 91 43 C7 A9 1E 95 F8 3E 38 AF D5 
00E654: FF 00 F8 3A 33 E2 47 DA 7C 67 F0 97 C1 F1 C8 C0 
00E664: D8 D9 DF EB 13 C7 9E 1F CE 78 A1 88 91 ED E4 CD 
00E674: 8F A9 AF CA 0A F6 78 6E 97 26 09 4B BB 6C F3 F3 
00E684: 8A 9C D8 96 BB 58 FD 96 FF 00 83 74 3C 39 1F C3 
00E694: 4F D8 87 E2 E7 C4 29 55 23 6B AD 5D E2 DC E0 80 
00E6A4: D1 58 D9 AC A0 93 DD 77 5C C8 38 F4 22 B9 DF D8 
00E6B4: B3 F6 42 D5 3F 6B 4F 88 A6 4B AF B4 5B F8 5E C2 
00E6C4: 5F 33 55 BF DB B5 A4 27 9F 26 33 8C 19 1B 3C FF 
00E6D4: 00 74 1D C7 A8 56 FA 2F FE 09 8B FB 39 6A 17 5F 

00E6E4: F0 46 CF 0B F8 57 4F 9E 1D 37 52 F1 CD A5 C5 DD 
00E6F4: D5 CC A9 B9 52 1B CB B6 25 F6 F1 B8 FD 90 AE 06 
00E704: 46 48 1C 8C E4 7D 7B F0 7B E0 F6 8B F0 37 C0 16 
00E714: 3E 1B F0 FD B0 B7 D3 EC 53 19 63 BA 49 DC F2 D2 
00E724: 48 DF C4 CC 79 27 F0 00 00 05 7E 3B C5 B9 3F F6 
00E734: AE 70 AA 56 FE 1C 1B 6D 77 7D 17 A6 9A 9B 54 C8 
00E744: FE B7 2A 1E D7 F8 70 57 6B BB EC 7C F7 FF 00 05 
00E754: 5E F1 ED BF EC A1 FF 00 03 04 C4 F8 81 FF 00 08 
00E764: DC 31 69 3B F4 C8 BC 3D A7 43 6E 3C BF 29 6E E5 
00E774: 4B 77 D8 7B 30 8A 49 18 1E B9 5C E7 3C D7 F3 8F 
00E784: D2 BF A1 0F F8 38 07 C2 B7 9E 26 FF 00 82 67 F8 
00E794: AE E2 D5 0B 8D 17 51 D3 AF E6 50 32 DE 58 B9 48 
00E7A4: C9 18 F4 F3 43 13 D8 29 3D 2B F9 EF FE 9D 40 ED 
00E7B4: 5F AB 70 8D 3A 71 C2 B5 15 D7 6F CA C4 E7 7A 56 
00E7C4: 50 4A C9 2D 11 F7 9F FC 1B C7 FB 3A 69 7F 1A FF 
00E7D4: 00 6E 39 75 FD 66 18 EE AD 7E 1E 69 6D AC 5A C2 
00E7E4: FF 00 32 B5 EB 4A 91 40 C5 7F D8 DC F2 03 03 D9 
00E7F4: D1 0F BD 7E F9 27 45 F6 AF E7 67 FE 08 A3 FB 6B 
00E804: E8 FF 00 B1 67 ED 89 1D D7 8A 2E 16 CF C2 7E 30 
00E814: B2 6D 13 52 BB 6E 53 4E 66 75 78 6E 1F 9F B8 AE 
00E824: BB 58 F4 54 91 DB F8 71 5F D1 06 9B AA 5B 6B 1A 
00E834: 75 BD E5 A5 C4 37 56 B7 51 AC D0 CD 0B 87 8E 58 
00E844: D8 65 59 58 70 41 03 04 10 47 03 04 57 87 C5 11 
00E854: A9 F5 BE 69 7C 36 56 3D 4C 8E 50 F6 16 5B DF 52 
00E864: CD 14 85 C0 34 B9 AF 9D 3D A0 AF CF BF F8 2C DF 
00E874: 8C BE D3 E3 CF 05 F8 7C 37 CB 63 61 3E A0 EB EB 
00E884: E7 48 23 07 F0 F2 1B F3 AF D0 4C D7 E5 1F FC 14 
00E894: C7 C6 63 C5 FF 00 B6 0F 89 11 1B 74 3A 3C 76 FA 
00E8A4: 7C 64 1C E0 A4 41 9C 7B 7C EE E3 1F 8F 5A 00 F2 
00E8B4: AF 84 7F 0F AD 7E 28 78 DE 1D 1A F3 C4 3A 3F 86 
00E8C4: 56 E2 39 0C 77 BA 9B 98 ED 8C A1 49 44 67 1F 77 
00E8D4: 73 00 37 13 80 39 E7 EE 9F 49 F8 33 A2 5B 7E CA 
00E8E4: FF 00 19 74 EF 15 78 A3 5C D0 AE 07 87 5D E7 82 
00E8F4: C3 45 D5 21 D4 AE 75 19 36 B2 A2 03 03 11 74 89 
00E904: 0B 30 2C D2 15 20 13 85 62 40 AE 1F E1 9F C1 79 
00E914: BC 75 2E 8A D7 57 53 58 59 F8 8B 55 1A 2E 9E 60 
00E924: B6 FB 44 F7 77 07 60 62 A8 5D 06 C4 F3 63 DC C5 
00E934: C6 3C C5 00 37 CD 8E FB E1 47 EC F5 69 71 26 87 
00E944: 24 97 9E 1C D6 2C 7C 59 E2 19 FC 3F 6C 6F ED 6E 
00E954: 8B 46 62 68 C0 95 16 39 63 2D BB CD 0E DC ED 55 
00E964: 8C E5 F9 2A C0 1B 9E 0E F8 C5 1F C7 4F 80 5F 16 
00E974: BC 33 7D 7B A5 E9 BE 29 F1 46 BD 1F 89 EC E0 B9 
00E984: B9 4B 58 6F 59 A4 56 9A 14 96 42 AA 19 55 41 55 
00E994: 62 0B 03 03 C6 4F 4C 48 BC 71 63 FB 39 7E CC FA 
00E9A4: F7 84 EC 75 1D 37 52 F1 B7 C4 29 23 5D 59 F4 FB 
00E9B4: 84 BA 87 49 D3 E3 CE 20 F3 A3 26 36 96 46 67 0C 
00E9C4: AA C4 05 6C 1C 10 2B 92 F0 7F EC F0 DE 24 D4 B4 
00E9D4: 9B 19 B5 88 6C EF BC 49 6B 77 79 A3 29 B7 DE 97 
00E9E4: 11 5B F9 D8 92 66 DC 0C 29 23 40 EA A4 07 3F 29 
00E9F4: 25 42 E0 B6 1F 8F 3E 14 B7 C3 FF 00 0A E8 77 B7 
00EA04: 77 57 12 5E 6B B6 D1 DF 5B C6 2D 7F D1 A5 82 44 
00EA14: DC 1A 39 C3 1D EE 9C 24 89 B5 4A 38 23 E6 C6 68 
00EA24: 00 F8 03 03 E0 CF F8 58 5F 1C 7C 23 A1 BA EE 8F 
00EA34: 54 D6 2D AD E5 03 04 7F CB 36 95 77 FE 49 9A FD 
00EA44: AA AF CA DF F8 25 CF 83 07 8A FF 00 6B DD 1A E1 
00EA54: 97 CC 8B 42 B3 B9 D4 58 7F 08 FD DF 92 A7 F0 69 
00EA64: 57 F4 AF D5 2A 00 28 A2 8A 00 42 71 48 5B 14 A4 
00EA74: D6 67 8A B5 79 34 0F 0F DE 5E 47 6D 35 EC B6 F1 
00EA84: B3 A5 BC 23 F7 93 B6 3E 54 5C F1 96 38 19 38 03 
00EA94: 03 39 24 0C 9A 99 3B 26 D8 A4 EC AE 78 BF ED CD 
00EAA4: FB 66 58 7E CA DE 08 58 AC FE CF 7D E2 ED 5D 48 
00EAB4: D3 AC DC E5 61 5E 86 E2 50 3F 81 4F 00 64 17 6E 
00EAC4: 06 00 62 BF 16 FC 1E FD 83 BE 28 7E D7 9E 22 93 
00EAD4: C5 9E 24 9A 6D 1E CB 58 97 ED 33 EA BA B2 B1 B8 
00EAE4: BB CE 06 E8 A0 C8 66 1B 71 B7 25 13 68 01 4E 00 
00EAF4: 15 F6 87 C2 5F D8 BE D9 FE 23 5E 7C 44 F8 8A D6 
00EB04: BE 26 F1 AE A5 30 9A 28 59 7C CB 1D 11 47 FA B8 
00EB14: A0 56 1F 31 41 80 24 60 0E 46 40 03 04 96 6F 78 
00EB24: 48 F1 D8 0E 3A 0A F9 1C 46 43 3C D2 BF B6 CC 1B 
00EB34: F6 6B E1 82 FC E5 E6 FC BE F3 E6 71 19 3D 4C C2 
00EB44: AF B4 C6 BB 41 6D 05 F9 B7 DD F6 FC 4F 9F FE 09 
00EB54: FF 00 C1 34 7E 18 FC 1E 10 DC CD A6 37 89 F5 38 
00EB64: F0 7E D5 AB E2 65 0D 8E 4A C4 00 8C 7B 12 A5 87 
00EB74: F7 AB DF 2C 34 CB 7D 2E D2 38 6D E1 8A DE 08 54 
00EB84: 22 47 1A 05 44 03 03 80 00 1D 00 15 61 46 28 1D 
00EB94: 6B E8 B0 79 7E 1B 0B 0E 5C 3C 14 57 92 3D CC 2E 
00EBA4: 07 0F 86 8F 25 08 28 AF 24 7C 3F FF 00 07 09 7C 
00EBB4: 28 FF 00 85 91 FF 00 03 04 DB D6 F5 25 66 F3 BC 
00EBC4: 15 AC 58 6B 68 8A BB 9A 40 64 FB 23 8F 60 12 E9 
00EBD4: D8 FB 25 7F 3F 38 C5 7F 55 5F B5 1F C2 73 F1 E3 
00EBE4: F6 6D F1 F7 82 D1 63 33 78 A7 C3 F7 DA 5C 06 40 
00EBF4: 0A C7 2C B0 3A 46 FC F1 95 72 AC 0F 62 05 7F 38 
00EC04: 5F F0 ED 8F DA 08 FF 00 CD 17 F8 97 FF 00 84 FD 
00EC14: CF FF 00 11 5F A3 70 BE 36 9C 28 CA 9D 49 25 67 
00EC24: A5 DF 73 C2 CE B0 F2 95 55 38 2B E9 D0 9F E1 67 
00EC34: ED 43 FF 00 08 37 EC 13 F1 6B E1 74 97 17 1B BC 
00EC44: 6B AE E8 97 96 B0 81 F2 03 04 80 CF 2D C3 12 7A 
00EC54: 12 D1 59 01 EB B4 7A 57 85 9E 2B DC 2D FF 00 E0 
00EC64: 9A 1F B4 25 DC CB 1A FC 19 F8 8E 19 BA 6F D0 67 
00EC74: 55 FC 4B 28 02 AF 7F C3 AC 7F 68 A2 7F E4 8E 78 
00EC84: EB FF 00 05 CD 5F 41 4F 11 84 A6 DB 8C D7 BC EF 
00EC94: BA 3C 99 51 AF 2B 27 17 A2 B6 C7 B0 7F C1 3C 3F 
00ECA4: 6F FD 37 FE 09 D5 FB 1A FC 48 D6 34 5F B2 DF FC 
00ECB4: 52 F8 85 AB C3 A5 68 D6 72 0D EB 61 05 AC 05 8D 
00ECC4: EC CB FF 00 3C C3 DD B0 45 FF 00 96 8E 08 E4 23 
00ECD4: 91 C0 0F F8 2C FF 00 ED 3D 8E 3E 2D 6B 38 FF 00 
00ECE4: AF 2B 3F FE 33 5C F7 FC 3A C7 F6 8A FF 00 A2 39 
00ECF4: E3 BF FC 17 37 F9 3F CB F9 51 FF 00 0E B0 FD A2 
00ED04: FF 00 E8 8D F8 EB FF 00 05 CD 5C D1 A7 97 73 CA 
00ED14: A5 47 19 39 3B EB 67 E9 B9 BF 3E 2D 45 46 09 A4 
00ED24: BD 4F D5 2F F8 26 AF ED 75 F1 23 C6 5F F0 4A 9F 
00ED34: 8B 5F 16 BE 24 78 A2 F3 C4 5A A6 93 FD B1 36 95 
00ED44: 35 C2 45 01 48 6D 6C 11 91 57 CB 45 19 6B 83 20 
00ED54: 07 03 04 F4 E4 F4 AF C2 FC E6 BF 70 B5 7F D9 7F 
00ED64: E2 17 C2 CF F8 37 EA DF E1 9E 89 E1 2D 6A F3 E2 
00ED74: 06 B5 67 1A DD 69 56 D6 E5 AE E2 6B 9D 4F ED 13 
00ED84: 07 5E C5 60 2C A7 D3 15 F9 77 FF 00 0E B0 FD A2 
00ED94: F3 FF 00 24 6F C7 5F F8 2D 6A E0 C9 AB E1 E1 3A 
00EDA4: D3 6D 45 39 69 AA D9 1D 39 85 3A D2 8D 38 59 B6 
00EDB4: 96 BE A7 B1 FF 00 C1 BD 3F 0C FF 00 E1 3D FF 00 
00EDC4: 82 91 68 DA 93 47 E6 47 E1 0D 1B 50 D5 CE 7A 29 
00EDD4: 68 C5 A2 93 F8 DD 8C 7B FD 2B FA 05 DD C0 FA D7 
00EDE4: E5 9F FC 1B C7 FB 10 78 FB F6 73 F1 CF C4 CF 12 
00EDF4: 7C 40 F0 76 B1 E1 3B AB 9B 0B 2D 37 4C 1A 95 B7 
00EE04: 94 F7 28 D2 4B 2C FB 3B E0 18 E0 CF A9 23 D2 BF 
00EE14: 52 4B 71 FA F1 5F 37 C4 58 88 D6 C6 37 07 74 92 
00EE24: 5A 1E D6 4F 45 D3 C3 AE 65 66 D9 FC FD FF 00 C1 
00EE34: C2 7F 12 FF 00 E1 3C FF 00 82 94 6B 9A 7A B8 64 
00EE44: F0 8E 8D A7 E9 0A 46 78 26 23 74 C3 D3 83 74 7F 
00EE54: 10 6B E2 1D 9B 87 BE 32 00 F4 FF 00 22 BE D1 FD 
00EE64: B9 BF 60 CF DA 13 E3 BF ED 8D F1 33 C5 F6 7F 08 
00EE74: FC 71 79 A7 EB 7E 23 BD 9A C2 65 D3 D8 AC B6 A2 
00EE84: 56 48 1B F1 89 63 AF 2B 1F F0 4B 1F DA 28 7F CD 
00EE94: 1B F1 D7 6F F9 87 37 6F F3 F8 57 DA E5 F8 8C 3D 
00EEA4: 3C 2C 29 FB 45 A2 4B 74 7C DE 2A 8D 69 D6 94 B9 
00EEB4: 5E AF B1 F4 DF ED 8F FF 00 05 98 F1 37 C2 9F 0C 
00EEC4: F8 1B E1 27 C0 5F 11 36 8B A0 FC 35 D1 AC F4 8B 
00EED4: EF 10 5B C1 0C CD AC DC 5B DB A4 2C 21 2E AE BF 
00EEE4: 67 5D A7 E6 03 03 32 31 2C 0E D0 A5 FC 14 7F C1 
00EEF4: 67 BF 69 EF FA 2B 5A CF A7 FC 79 D9 FF 00 F1 9A 
00EF04: E7 87 FC 12 BF F6 8A 51 FF 00 24 6F C7 5F F8 2D 
00EF14: 6A 07 FC 12 BB F6 8B 91 F6 FF 00 C2 9C F1 C6 5B 
00EF24: 8F 9B 4F 65 1F E7 9A CA 95 2C B2 9C 2C F9 5F 5B 
00EF34: E8 DB 2A 55 31 92 96 BC CB B5 AE 7E E6 FE C6 BE 
00EF44: 17 D5 FF 00 6B 2F F8 25 FF 00 86 74 FF 00 8B 1A 
00EF54: 85 D7 89 6F FE 23 F8 6E 73 AB 5D CA A9 14 D3 C1 
00EF64: 78 65 78 88 D8 A1 54 A4 32 46 14 85 C8 DA 0F 5E 
00EF74: 6B F0 23 F6 C7 FD 92 7C 55 FB 14 FC 77 D5 FC 0F 
00EF84: E2 AB 69 16 4B 19 1A 4B 0B E0 84 41 AA DA 92 7C 
00EF94: AB 98 8F 4C 30 1C 8C 9D AD 95 38 20 8A FE 9B 3E 
00EFA4: 0C 7C 3E 8F E1 37 C1 FF 00 09 F8 56 DF 02 0F 0D 
00EFB4: 68 D6 9A 4C 78 EC B0 42 91 0F D1 6B 87 FD B1 BF 
00EFC4: 61 FF 00 87 BF B7 37 C3 7F F8 46 FC 79 A4 7D A7 
00EFD4: EC FB 9F 4F D4 AD 98 45 7F A5 C8 C3 05 E0 97 03 
00EFE4: 04 AE 70 32 A4 15 6C 0C A9 C0 C7 C9 E5 B9 C7 D5 
00EFF4: 2B CE EB DC 93 DB B7 6B 1E F6 33 2E F6 F4 62 AF 
00F004: EF 25 B9 FC BB 8E 9E 8A B8 E7 FA FF 00 4C 9F D3 
00F014: BF BD 7E CC 1F F0 53 4F 8D BF B1 FE 9D 16 9D E0 
00F024: 9F 1C 6A 16 FA 1C 3B 8A E9 17 D1 A5 ED 82 67 92 
00F034: 12 39 43 79 59 39 27 CB 2B 93 C9 EA 45 7D 0B FB 
00F044: 57 7F C1 BB FF 00 19 BE 0C EA 97 57 9E 03 03 36 
00F054: 3F 13 3C 3E A5 9A 36 B5 91 2D 35 48 53 1F F2 D2 
00F064: 09 18 2B 11 D0 79 4E E5 BA ED 5E 95 F1 E7 8D 7F 
00F074: 65 AF 89 9F 0D EF 1E DF C4 1F 0E FC 71 A2 4D 1F 
00F084: 55 BE D0 EE 60 E3 D4 6E 4E 47 B8 24 7B D7 DC 47 
00F094: 15 82 C6 46 DC CA 4B B3 E9 F2 67 CD BA 38 9A 13 
00F0A4: BE A9 FF 00 5D 51 F7 DF EC 9D FF 00 05 C9 FD A1 
00F0B4: BF 69 5F DA 87 E1 BF 81 66 9B C2 16 76 7E 22 F1 
00F0C4: 0D 95 95 FC B6 9A 3E 26 6B 56 99 3C F2 0B BB 00 
00F0D4: DE 50 90 E4 01 8E D5 FB 5F D8 7D 2B F0 1F FE 08 
00F0E4: 1F FB 3B EB BE 20 FF 00 82 89 78 6F 5C D4 74 1D 
00F0F4: 5A DB 4C F0 AE 9F 7F A9 19 EE 6C A4 8E 13 21 84 
00F104: DB A0 DC C0 0D C1 AE 32 00 39 F9 6B F7 E1 79 AF 
00F114: 85 E2 2A 74 29 E2 15 3A 09 24 97 4E A7 D3 64 F2 
00F124: AB 2A 4E 55 77 B8 64 20 EB C7 5A FC 4D F8 C5 E3 
00F134: 23 F1 13 E2 CF 89 B5 ED D9 1A C6 A9 73 7A 98 EC 
00F144: 1E 56 65 1F 91 02 BF 6B AF 2C A3 BE B5 92 19 14 
00F154: B4 53 21 47 01 8A E4 1E 08 C8 E4 75 EA 39 AF 15 
00F164: FF 00 87 70 FC 17 3F F3 24 C1 FF 00 83 1B BF FE 
00F174: 3B 5E 09 EB 1F 9C 3F 0F FF 00 69 FD 6B E1 C6 95 
00F184: E1 8B 7B 1D 37 45 92 6F 09 5C DC DC D9 5C CB 1C 
00F194: 9E 71 13 6D 2F 1B 10 E0 6C 2C AA 49 50 AE 40 DB 
00F1A4: BB 6E 54 D3 D0 3F 68 7D 5B C3 DA F7 86 EF A1 D3 
00F1B4: F4 76 5F 0A C1 77 0D A5 B9 8A 45 85 8D CB 4E ED 
00F1C4: 23 00 E0 EF 53 3F CB B4 A8 02 28 F8 E0 EE FD 2A 
00F1D4: FF 00 87 70 7C 16 FF 00 A1 26 1F FC 18 DE 7F F1 
00F1E4: DA 3F E1 DC 1F 05 BF E8 49 87 FF 00 06 37 9F FC 
00F1F4: 76 80 3F 34 6E FF 00 68 1D 5A E7 49 D3 E3 5B 3D 
00F204: 2A DF 52 D3 74 A9 34 48 75 48 62 74 B8 5B 49 0C 
00F214: 85 90 28 7F 29 49 59 A5 8F 72 A0 60 8D 81 D3 35 
00F224: 9F E3 DF 8A D7 5E 39 D2 6D 74 D8 EC 34 FD 17 48 
00F234: B4 BA 9A FA 2D 3E C3 CD FB 3C 53 CC B1 AC 8E A2 
00F244: 59 1C AE EF 29 7E 55 21 57 9C 01 9A FD 3E FF 00 
00F254: 87 70 7C 16 FF 00 A1 26 1F FC 18 DE 7F F1 DA 3F 
00F264: E1 DC 1F 05 BF E8 49 87 FF 00 06 37 9F FC 76 80 
00F274: 3E 75 FF 00 82 32 78 3B CE F1 1F 8E 3C 40 CA A0 
00F284: DB DB 5B D8 44 C7 AF EF 19 DD F9 F4 FD D4 64 FD 
00F294: 45 7D F4 2B 90 F8 41 F0 27 C2 BF 01 74 6B AD 3F 
00F2A4: C2 5A 4C 7A 3D 9D EC FF 00 68 9A 35 9A 49 B7 C9 
00F2B4: B4 2E 73 23 31 E8 00 C6 71 5D 78 E9 40 05 14 51 
00F2C4: 40 0D 63 C5 71 7F 19 BF 68 8F 02 FE CE DA 3D AE 
00F2D4: A1 E3 AF 16 68 7E 13 B2 BE 98 DB DB 4F A9 DD A5 
00F2E4: BA 4D 20 5D C5 54 B1 E4 85 19 C7 A0 AE D4 8C D7 
00F2F4: CC 5F F0 57 32 DA BF EC 65 7F E1 68 70 75 0F 88 
00F304: 5A F6 8B E1 5B 41 8C EE 6B BD 4A DD 1D 47 23 AC 
00F314: 42 41 D4 56 94 61 19 CD 46 46 75 24 E3 1B A3 DE 
00F324: 3E 14 7C 61 F0 AF C7 3F 08 47 E2 0F 07 EB DA 67 
00F334: 89 34 49 A4 78 63 BE D3 E6 13 40 EE 87 0C 03 03 
00F344: 8E 09 07 83 4D F8 5D F1 83 C3 BF 1A 34 3B CD 53 
00F354: C3 7A 87 F6 8D 8E 9F A9 5D E9 33 4D E4 49 12 8B 
00F364: 9B 59 9A 19 90 6F 55 2C 16 44 61 B9 72 A7 19 03 
00F374: 04 8E 6B E1 DF 07 FC 5B F8 85 F1 6B F6 B8 F1 76 
00F384: BD 0F 8D 2D FC 2D E1 3F 85 FE 37 BD D2 E6 D2 BF 
00F394: E1 20 58 63 BA D2 34 EB 27 33 DB 26 96 23 CC D3 
00F3A4: CF 26 66 37 12 BE 12 30 36 0C 2D 78 9F C1 0F 19 
00F3B4: 7C 4E F1 AF C3 5F 87 5F 0C FC 1D E3 0B 6F 07 99 
00F3C4: 7E 1F A7 8C BF B4 5B C4 EB A2 03 03 AA EB 1A A5 
00F3D4: DC DF 6B 93 11 BC 97 91 41 82 9F 67 50 15 A4 94 
00F3E4: 87 3C 2E 3B FF 00 B3 6F 7B 3F 3D F6 47 1C 71 BB 
00F3F4: 5D 1F AE 79 14 A7 15 F9 C1 F1 27 F6 A4 F1 75 9F 
00F404: C3 DF DA 03 03 E2 44 3F 13 2F A3 F1 A7 C3 DF 12 
00F414: CF E0 8D 0B C3 8B 7D 15 BE 97 A4 DA AD CD A6 9A 
00F424: DA AD C5 96 3F 78 DE 6D CB DC F9 92 96 45 C4 6A 
00F434: 08 50 45 67 41 F1 57 C7 C9 F1 5B 56 F8 79 E0 5F 
00F444: 8B 1E 2F F1 07 86 F5 0F 89 FE 1D F0 D6 97 E2 6B 
00F454: AB E4 D4 AE E3 2B A5 DC 5F 6B 6B 1C FB 4A 48 88 
00F464: 23 84 79 67 72 23 96 52 A1 72 0E 4B 2F 6F ED 2F 
00F474: C7 CB FC CD 3E BB 1E CC FD 2C 71 DB D4 D3 8E D2 
00F484: 2B F2 D7 E1 BF ED 01 F1 17 C0 36 5E 0B F1 94 DF 
00F494: 12 7C 65 AF E8 F7 16 FF 00 11 B5 48 74 EB FB C1 
00F4A4: 71 14 9A 16 91 1D CA DA 34 E7 68 69 AE 3E D2 D0 
00F4B4: B0 99 8E 76 05 45 C2 82 1A 1F 14 FE D9 3E 3C BD 
00F4C4: F8 50 F6 7E 15 F8 85 AA EA DA E6 81 F0 8F C3 3A 
00F4D4: 7D DD DC 37 A6 64 9B C4 FA E6 A5 6B 1F 9A D2 2E 
00F4E4: 43 4B 14 3B F0 72 70 1D C7 2C BC 53 CB 67 D1 A6 
00F4F4: 4A C7 47 AA 3F 4C 3E 2A 7C 56 F0 FF 00 C1 4F 03 
00F504: 03 DD 78 93 C5 1A 94 7A 4E 87 63 24 31 4D 74 D1 
00F514: 3C 82 36 9A 64 86 21 B5 03 03 31 DD 24 88 BC 0E 
00F524: AD D8 57 43 8E 6B F3 82 E7 C7 DF 10 34 8F 8A BA 
00F534: 87 86 EC FE 23 F8 EB 5A B1 83 E3 A6 87 E1 CB 69 
00F544: A6 BC 53 71 71 14 5A 42 DF 6B 30 B6 C5 50 20 7C 
00F554: 3E 22 5C 24 64 AE 00 19 15 4F C2 FF 00 B4 D6 B9 
00F564: E3 0F D9 AF E1 FF 00 8E 26 F8 C1 A9 D8 F8 8B E3 
00F574: B7 8C 2D 74 5F 10 C9 16 B5 0F F6 7F 81 34 E9 1E 
00F584: F2 E0 C3 69 0B 0D 96 97 1F 67 B4 F2 03 04 B2 02 
00F594: FB 8B B9 24 8C 87 FD 9D 2D 2D 20 8E 39 3E 87 E9 
00F5A4: 56 E5 61 5C F7 87 3E 2C F8 77 C5 BF 10 3C 49 E1 
00F5B4: 5D 3B 53 8E EB 5F F0 88 B5 6D 5E D1 63 70 D6 42 
00F5C4: E5 1A 48 32 C5 42 9D E8 AC 70 A4 E3 1C E3 22 BF 
00F5D4: 39 BF 67 5F 8E 7A F7 C5 CF 11 78 3F C0 FA 87 C5 
00F5E4: EF 1B 68 BF 0F FC 67 E2 0F 16 EA D6 1A FD DE B4 
00F5F4: 2D F5 8D 4F 4F B0 BA 82 C6 C2 C2 2B D9 17 78 CB 
00F604: F9 B3 38 1F 3B 7D DC E3 20 DF 4F 8F 7E 24 BE F8 
00F614: D7 79 E0 AD 5B E2 8F 89 7C 37 E0 3F 13 7C 53 F1 
00F624: 3D 8D CE BB 3E B1 F6 7B CD 3F 4E D1 2C 20 73 65 
00F634: 6F 74 E3 F7 4B 2D E4 92 E4 AE 1B CB 85 80 6C E6 
00F644: 97 F6 7C 93 B3 7E 7F D6 9F 80 7D 75 5A E9 1F A5 
00F654: 64 28 6E DD 3B D2 F0 07 5A FC 98 4F DA 53 E2 C7 
00F664: 8C BF 67 79 AF F5 6F 89 1E 32 D1 6D 7C 17 F0 63 
00F674: 50 F1 6D C5 D5 B4 C2 DE FB 54 BA B9 D5 2E E3 D0 
00F684: CC F2 6C C8 66 B6 B7 B7 77 60 03 03 38 62 0E 44 
00F694: 8F 9F 54 F8 7D F1 37 E3 07 C7 8F DA B6 7B 3B CF 
00F6A4: 1D 43 E1 48 7E 1B 78 87 45 D3 AF ED EE 3C 48 96 
00F6B4: 11 DC 5B C1 63 05 CE A4 1F 4E 54 26 ED EE DA 49 
00F6C4: 42 C9 23 2A 44 88 0A 61 95 B2 7F 66 CE DC DC CA 
00F6D4: C8 3E BB 1B DA CC FD 12 E3 1F D3 DA 8C 64 FE 95 

00F6E4: F2 9F FC 13 2F C7 FA C7 8B 6F BE 2A 69 BE 2C F1 
00F6F4: 2E B9 E2 8F 19 78 67 5F FB 26 AB 7E 75 61 7F A0 
00F704: DC C7 28 92 E6 D6 4D 39 53 09 02 FD 9E 68 D5 E2 
00F714: 03 03 2A 63 5D DC E6 B8 4F F8 26 0F C6 1F 1F 7E 
00F724: D1 1E 38 B7 4D 73 C4 9A DD F6 95 F0 9F 4D D4 F4 
00F734: 4D 77 ED 13 92 DA B6 BB 36 AF 74 A8 26 3D 24 FB 
00F744: 35 8D B4 24 03 03 D0 DE 21 1D 33 58 CB 07 2F 79 
00F754: DF E1 B5 FE 66 B1 C4 26 A3 A6 E7 D5 FA 97 ED 2F 
00F764: F0 FF 00 48 F8 C7 6B F0 EE 7F 17 68 6B E3 8B D4 
00F774: DF 16 8A 2E 43 5E 11 E5 B4 A3 72 0C 95 26 34 67 
00F784: 01 B0 59 54 91 91 5A BF 09 BE 2F 78 6F E3 A7 C3 
00F794: DD 3F C5 5E 13 D5 60 D6 BC 3D AB 09 0D A5 EC 48 
00F7A4: CB 1C E2 39 1A 27 C0 70 0F 0E 8C 39 1D BD 2B E1 
00F7B4: AF 89 3F 16 E1 FD 97 FF 00 6A 3F 8D 56 BE 17 F1 
00F7C4: 56 9B E2 8D 03 03 E2 8F 83 B5 BF 1B 6A 32 69 57 
00F7D4: A8 DA BF 82 AF B4 CB 25 84 B3 4A 85 80 86 52 15 
00F7E4: 22 0C 03 03 24 AA 40 FB A4 BF 3D A1 7C 61 F1 87 
00F7F4: C3 EF 16 78 52 1F 1E 78 FB C6 3A B4 7A 87 C1 C7 
00F804: D6 34 F1 A2 F8 84 47 26 9D AA 5A 69 32 5C 6A 6D 
00F814: A9 5B AF CC EE DE 7C 6F 0C CF 95 46 48 D4 2E 6B 
00F824: A1 60 39 B5 8B E9 D4 C9 E2 DA 7A A3 F4 77 42 F1 
00F834: 16 9F E2 7D 3D 6F 34 DB EB 3D 42 CD 9D E2 59 ED 
00F844: A6 59 A2 2E 8E 63 75 DC A4 8C AB AB 29 1D 43 29 
00F854: 07 90 6A DB AF 3F 5F C2 BF 25 BE 1A DD 78 EF 4A 
00F864: F8 71 F0 A7 E1 07 81 FE 20 5D E9 0B 7F F0 B6 2F 
00F874: 1C CB AA DD 78 CF FB 2A 38 35 6D 4A 73 08 63 36 
00F884: D7 92 6B 6B 59 12 56 36 B1 80 1E 59 BE 73 DA BD 
00F894: 03 03 E2 57 8F FE 2D 78 C7 E3 0E A0 FA 57 C5 6F 
00F8A4: 15 E9 A7 FE 17 06 8D F0 E3 48 86 C3 CB 5B 5C C5 
00F8B4: A5 44 FA BD D4 90 15 2B 22 9D 92 C8 B1 9F DD A3 
00F8C4: 86 E0 92 08 3F B3 9D F4 92 05 8D 5F CA CF D2 B0 
00F8D4: FB 87 D2 80 FC FE 95 F9 65 65 FB 53 F8 8A 0F 0C 
00F8E4: DB F8 5F C4 1F 14 FC 61 A2 F8 26 DE E7 C7 3E 23 
00F8F4: 8B 59 6D 5B C9 D7 B5 BB 1D 37 51 FB 1E 9D A7 C7 
00F904: 78 EA 64 DE D2 99 0E 10 6F 70 AA 83 00 60 FA 0F 
00F914: EC BF F1 67 C6 D2 7C 70 FD 9B 74 FF 00 1F 78 DB 
00F924: C4 9E 20 B6 F1 DF 81 2D EE 6D 20 D3 B5 D1 14 96 
00F934: FA CA 5B 49 A8 CE 75 5B 65 C3 CD 1C 96 92 44 11 
00F944: 98 B2 A9 8B 05 7E 6D F5 32 CB 65 15 CC DA 08 E3 
00F954: 13 76 B1 F6 8F C6 3F DA 77 E1 FF 00 EC FF 00 7D 
00F964: A5 5A F8 D3 C5 DA 1F 87 6E F5 C7 F2 EC 2D EF 2E 
00F974: 42 4D 76 72 14 EC 41 96 20 16 50 5B 18 05 80 27 
00F984: 91 56 3E 33 7E D0 FE 06 FD 9D F4 9B 3D 43 C7 5E 
00F994: 2A D0 FC 27 63 7F 37 D9 AD A7 D5 2E 92 DE 39 A4 
00F9A4: C1 3B 14 B7 56 C0 27 15 F3 2F ED 89 E3 2B 7F 81 
00F9B4: 1F B7 AF C3 2F 88 DE 1E F1 07 87 75 8D 73 5C 96 
00F9C4: CF E1 8F 88 3C 25 2C E8 DA 87 D8 6E EE 7E D2 97 
00F9D4: 76 E0 12 F1 3C 45 84 92 06 01 1E 20 A4 95 C2 9A 
00F9E4: E7 BF 6C 0F 8D 36 7F 17 FF 00 6D 1F 80 77 5E 03 
00F9F4: 03 F8 95 F0 FB 43 B6 D0 BC 3F AF 78 AE DB 5E D6 
00FA04: 36 5F 69 17 02 6F 23 4E 40 BB 6E 21 DE D8 7B 95 
00FA14: 18 90 11 86 38 3B 4E 15 3C 24 64 A1 7B D9 A6 DF 
00FA24: CB E5 FE 65 4F 10 D5 ED DC FB 67 C1 3E 33 D2 7E 
00FA34: 23 F8 53 4F D7 B4 2B FB 3D 5B 47 D5 A0 5B 9B 3B 
00FA44: DB 57 12 43 73 13 0C AB A3 74 2A 46 08 23 AD 6B 
00FA54: 29 FC 6B 0F C2 1E 3C D1 7C 6E FA 95 BE 97 AC E9 
00FA64: 7A C5 D6 81 76 74 CD 51 6C E6 59 3E C5 76 8A AE 
00FA74: F0 C8 01 3B 1C 07 52 50 F2 37 0A DC 1F 77 FF 00 
00FA84: AF 5C 12 56 D8 EA 8F 90 EA 28 1D 28 A0 A0 A2 8A 
00FA94: 28 00 A2 8A 28 00 A2 8A 28 00 A2 8A 28 00 AC ED 
00FAA4: 77 C2 7A 6F 8A 3E C9 FD A5 A7 D8 EA 02 C2 E5 2F 
00FAB4: 6D 45 CC 0B 2F D9 A7 4E 63 95 37 03 03 B6 45 CF 
00FAC4: 0C 30 47 62 2B 46 8A 36 0D CE 4C FC 0B F0 63 78 
00FAD4: EA E7 C5 0D E1 1F 0B B7 89 EF 22 30 4F AB 9D 2E 
00FAE4: 03 03 7F 34 65 36 14 69 F6 79 8C A5 09 5C 13 8D 
00FAF4: BC 74 AA AD FB 37 7C 3E 91 74 6D DE 03 03 F0 5B 
00FB04: 0F 0E A9 5D 24 1D 16 DB 1A 58 2C 5F 10 7C 9F BA 
00FB14: 1B 8E EF 93 1C F3 D6 BB 6A 2A B9 A5 DC 9F 67 1E 
00FB24: C7 2F 73 F0 57 C2 17 7A CE B1 A8 CB E1 5F 0D C9 
00FB34: A8 78 86 DF EC 9A AD CB E9 B0 99 B5 28 78 1E 54 
00FB44: EF B7 74 A9 80 06 D7 24 70 38 A9 7C 3B F0 8F C2 
00FB54: DE 11 D3 B4 8B 3D 27 C3 3E 1E D2 ED 3C 3E EF 26 
00FB64: 99 05 A6 9F 14 31 E9 AC EA C8 E6 15 55 02 32 CA 
00FB74: CC A4 AE 32 18 83 D4 D7 47 45 1C D2 EE 1C B1 EC 
00FB84: 73 B6 1F 09 FC 33 A5 C1 6F 0D B7 87 74 1B 78 6C 
00FB94: ED A5 B2 B7 48 AC 22 55 82 DE 52 1A 58 50 05 01 
00FBA4: 63 72 01 65 1C 31 00 9C 9A AB A3 7C 0B F0 67 87 
00FBB4: 34 E8 6C F4 FF 00 08 F8 5E C6 D6 DC C0 D1 43 6F 
00FBC4: A5 C1 14 71 98 24 79 61 2A AA 80 03 03 1C 92 3B 
00FBD4: A6 07 CA CE C4 60 93 5D 65 14 73 4B B8 F9 57 63 
00FBE4: 06 1F 86 3E 1D B6 D4 52 F2 3D 07 45 8E F2 3B C9 
00FBF4: 35 24 9D 6C A3 59 16 EA 44 F2 E4 9C 36 DC 89 59 
00FC04: 3E 52 F9 DC 57 82 48 AC 93 FB 39 FC 3F 6D 33 50 
00FC14: B2 3E 05 F0 71 B3 D5 AE D6 FE FA DF FB 1A DF CB 
00FC24: BC B8 52 59 66 91 76 61 E4 03 04 92 1D 81 60 49 
00FC34: E6 BB 4A 28 E6 97 71 72 C7 B1 CA EA DF 03 03 FC 
00FC44: 1B E2 0B 5D 36 0D 43 C2 7E 19 BE 87 47 BA 6B DD 
00FC54: 3E 39 F4 B8 24 4B 1B 86 7D EF 2C 41 94 F9 72 33 
00FC64: 92 C5 97 03 04 B1 CE 73 4C F1 17 C0 7F 03 04 F8 
00FC74: BF 40 FE CA D5 BC 1F E1 5D 53 4C FB 6B 6A 42 CE 
00FC84: EF 49 82 7B 71 74 CC 59 A7 D8 C8 57 CD 2C CC 4B 
00FC94: E3 71 2C 4E 72 6B AD A2 8E 69 77 0E 55 D8 E7 F5 
00FCA4: 4F 85 9E 1B D6 D6 F8 5E 78 7F 43 BC FE D3 82 2B 
00FCB4: 6B C1 35 8C 52 7D B2 28 89 68 A3 93 2A 77 2A 31 
00FCC4: 25 41 C8 52 49 03 03 35 53 52 F8 19 E0 CD 63 C6 
00FCD4: 8D E2 4B CF 08 F8 66 EF C4 4D 19 85 B5 49 B4 B8 
00FCE4: 1E F4 A1 43 1E C3 31 42 FB 4A 12 B8 CE 36 92 3A 
00FCF4: 71 5D 5D 14 73 CB B8 72 47 B1 C7 C5 F0 8A CF C1 
00FD04: 1F 0C B5 0F 0F FC 3F B6 D0 7C 07 2D C4 72 1B 39 
00FD14: 6C 34 78 BE CB 67 3B 8C 79 C6 DD 76 23 91 C1 C1 
00FD24: 23 38 E4 D6 67 EC D3 FB 3A 69 7F B3 37 C2 C8 7C 
00FD34: 37 A6 DC DC 6A 57 13 DD 4F A9 EA BA 9D D0 51 73 
00FD44: AC 6A 17 0E 64 B8 BB 97 68 C6 F9 1D 89 C0 E1 54 
00FD54: 2A 8E 14 57 A1 D1 47 B4 95 AD 70 F6 71 BD CE 3F 
00FD64: 44 FD 9F FC 0B E1 CB 6D 6A 0D 3F C1 7E 12 B0 83 
00FD74: C4 6A 53 55 8E DB 48 B7 89 35 45 39 C8 9C 2A 01 
00FD84: 2E 77 37 DF CF 53 EA 6A CE 9F F0 5F C2 3A 46 BF 
00FD94: A9 EA D6 9E 15 F0 DD AE A9 AD 41 F6 6D 42 F2 1D 
00FDA4: 36 14 9E FA 2C 05 D9 2B 85 DD 22 E0 01 86 24 60 
00FDB4: 0A E9 E8 A3 9A 5D C3 92 3D 8E 1E F7 F6 67 F8 77 
00FDC4: A9 59 E8 B6 F7 1E 02 F0 5D C5 BF 86 CB 1D 22 29 
00FDD4: 74 4B 67 4D 2B 73 6E 6F B3 A9 4C 45 93 C9 D9 8C 
00FDE4: 9E 7A D6 DC 3F 0C FC 3D 6D 73 1C D1 68 3A 2C 73 
00FDF4: 47 7D 26 A6 8E B6 51 86 4B B9 01 59 2E 01 DB FE 
00FE04: B5 D5 98 33 FD E6 0C 41 3C D6 ED 14 73 4B B8 72 
00FE14: C7 B1 C9 DD FC 0B F0 6D F5 B6 9B 0C DE 13 F0 C4 
00FE24: D0 E8 AF 34 9A 7C 72 69 70 32 D8 B4 D9 32 B4 43 
00FE34: 66 23 2E 49 DC 57 1B B2 73 9C D4 9A 0F C1 5F 07 
00FE44: F8 57 C5 D3 78 83 4B F0 AF 86 F4 ED 7A E6 DD 2D 
00FE54: 26 D4 AD 74 C8 61 BC 96 14 55 44 89 A5 55 0E 51 
00FE64: 55 11 42 93 80 14 01 8C 0A EA 28 A3 99 DA D7 05 
00FE74: 4E 2B 54 8E 66 2F 83 9E 14 87 C7 F2 78 B1 3C 33 
00FE84: E1 E4 F1 44 C9 E5 C9 AC 2E 9D 08 D4 1D 76 84 DA 
00FE94: 67 DB E6 11 B4 05 C6 71 80 06 31 59 DA A7 EC D9 
00FEA4: F0 F7 5C 8A C2 3B DF 01 F8 2E EE 3D 26 21 6F 62 
00FEB4: 93 68 B6 D2 2D 9C 5B 8B 6C 8C 14 F9 17 73 31 DA 
00FEC4: B8 19 24 F7 35 DB D1 47 34 BB 87 24 7B 19 FA 37 
00FED4: 85 F4 FF 00 0E BD E3 E9 FA 7D 8D 8C 9A 95 C3 5D 
00FEE4: DE 35 BC 0B 11 BA 98 85 53 24 9B 40 DE E5 55 41 
00FEF4: 63 C9 0A 07 41 5A 00 62 8A 2A 4A 0A 28 A2 80 0A 
00FF04: 28 A2 80 0A 28 A2 80 0A 28 A2 80 0A 28 A2 80 0A 
00FF14: 28 A2 80 0A 28 A2 80 0A 28 A2 80 0A 28 A2 80 0A 
00FF24: 28 A2 80 0A 28 A2 80 0A 28 A2 80 0A 28 A2 80 0A 
00FF34: 28 A2 80 0A 28 A2 80 0A 28 A2 80 0A 28 A2 80 0A 
00FF44: 28 A2 80 0A 28 A2 80 0A 28 A2 80 0A 28 A2 80 0A 
00FF54: 28 A2 80 0A 28 A2 80 3F FF D9 04 FF FF 2F 2A 2A 
00FF64: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00FF74: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00FF84: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00FF94: 0D 0A 20 2A 20 45 6E 64 20 6F 66 20 4D 50 46 53 
00FFA4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00FFB4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00FFC4: 20 20 20 20 0D 0A 20 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00FFD4: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00FFE4: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00FFF4: 2A 2A 2A 2A 2A 2A 2A 2A 2F 0D 0A 00 
