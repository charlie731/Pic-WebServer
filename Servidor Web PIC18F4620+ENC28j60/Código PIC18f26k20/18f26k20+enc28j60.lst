CCS PCH C Compiler, Version 5.051, 43599               02-dic.-15 15:02

               Filename:   C:\Users\Charlie\Desktop\Servidor Web PIC18F4620+ENC28j60\Código PIC18f26k20\18f26k20+enc28j60.lst

               ROM used:   52126 bytes (80%)
                           Largest free fragment is 13408
               RAM used:   850 (22%) at main() level
                           1035 (26%) worst case
               Stack used: 11 locations (10 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   C8F4
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   00AE
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVFF  15,FF5
0009A:  MOVFF  16,FF6
0009E:  MOVFF  17,FF7
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
.................... #include <18f26k20+enc28j60.h> 
.................... #include <18F26K20.h> 
.................... //////////// Standard Header file for the PIC18F26K20 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F26K20 
*
000CE:  DATA 3C,48
000D0:  DATA 54,4D
000D2:  DATA 4C,3E
000D4:  DATA 3C,42
000D6:  DATA 4F,44
000D8:  DATA 59,3E
000DA:  DATA 3C,48
000DC:  DATA 31,3E
000DE:  DATA 45,72
000E0:  DATA 72,6F
000E2:  DATA 72,20
000E4:  DATA 50,61
000E6:  DATA 73,73
000E8:  DATA 77,6F
000EA:  DATA 72,64
000EC:  DATA 20,6F
000EE:  DATA 72,20
000F0:  DATA 55,73
000F2:  DATA 65,72
000F4:  DATA 6E,61
000F6:  DATA 6D,65
000F8:  DATA 2F,34
000FA:  DATA 30,34
000FC:  DATA 20,45
000FE:  DATA 72,72
00100:  DATA 6F,72
00102:  DATA 3C,2F
00104:  DATA 48,31
00106:  DATA 3E,3C
00108:  DATA 48,52
0010A:  DATA 3E,3C
0010C:  DATA 50,3E
0010E:  DATA 4C,6F
00110:  DATA 67,69
00112:  DATA 6E,2F
00114:  DATA 66,69
00116:  DATA 6C,65
00118:  DATA 20,4E
0011A:  DATA 6F,74
0011C:  DATA 20,66
0011E:  DATA 6F,75
00120:  DATA 6E,64
00122:  DATA 2E,3C
00124:  DATA 2F,42
00126:  DATA 4F,44
00128:  DATA 59,3E
0012A:  DATA 3C,2F
0012C:  DATA 48,54
0012E:  DATA 4D,4C
00130:  DATA 3E,20
00132:  DATA 0A,3C
00134:  DATA 50,3E
00136:  DATA 3C,41
00138:  DATA 20,48
0013A:  DATA 52,45
0013C:  DATA 46,3D
0013E:  DATA 22,2F
00140:  DATA 22,3E
00142:  DATA 49,4E
00144:  DATA 49,43
00146:  DATA 49,4F
00148:  DATA 3C,2F
0014A:  DATA 41,3E
0014C:  DATA 20,20
0014E:  DATA 00,00
00150:  DATA 3C,48
00152:  DATA 54,4D
00154:  DATA 4C,3E
00156:  DATA 3C,42
00158:  DATA 4F,44
0015A:  DATA 59,3E
0015C:  DATA 3C,48
0015E:  DATA 31,3E
00160:  DATA 35,30
00162:  DATA 30,20
00164:  DATA 45,72
00166:  DATA 72,6F
00168:  DATA 72,3C
0016A:  DATA 2F,48
0016C:  DATA 31,3E
0016E:  DATA 3C,48
00170:  DATA 52,3E
00172:  DATA 3C,50
00174:  DATA 3E,49
00176:  DATA 6E,74
00178:  DATA 65,72
0017A:  DATA 6E,61
0017C:  DATA 6C,20
0017E:  DATA 53,65
00180:  DATA 72,76
00182:  DATA 65,72
00184:  DATA 20,45
00186:  DATA 72,72
00188:  DATA 6F,72
0018A:  DATA 3C,2F
0018C:  DATA 42,4F
0018E:  DATA 44,59
00190:  DATA 3E,3C
00192:  DATA 2F,48
00194:  DATA 54,4D
00196:  DATA 4C,3E
00198:  DATA 00,00
0019A:  DATA 48,54
0019C:  DATA 54,50
0019E:  DATA 2F,31
001A0:  DATA 2E,30
001A2:  DATA 20,25
001A4:  DATA 4C,55
001A6:  DATA 20,00
001A8:  DATA 4E,6F
001AA:  DATA 74,20
001AC:  DATA 66,6F
001AE:  DATA 75,6E
001B0:  DATA 64,00
001B2:  DATA 53,65
001B4:  DATA 72,76
001B6:  DATA 65,72
001B8:  DATA 20,45
001BA:  DATA 72,72
001BC:  DATA 6F,72
001BE:  DATA 00,00
001C0:  DATA 0D,0A
001C2:  DATA 43,6F
001C4:  DATA 6E,74
001C6:  DATA 65,6E
001C8:  DATA 74,2D
001CA:  DATA 54,79
001CC:  DATA 70,65
001CE:  DATA 3A,20
001D0:  DATA 00,00
001D2:  DATA 74,65
001D4:  DATA 78,74
001D6:  DATA 2F,68
001D8:  DATA 74,6D
001DA:  DATA 6C,00
001DC:  DATA 0D,0A
001DE:  DATA 0D,0A
001E0:  DATA 00,00
001E2:  DATA 20,0A
001E4:  DATA 3C,21
001E6:  DATA 44,4F
001E8:  DATA 43,54
001EA:  DATA 59,50
001EC:  DATA 45,20
001EE:  DATA 68,74
001F0:  DATA 6D,6C
001F2:  DATA 3E,20
001F4:  DATA 0A,3C
001F6:  DATA 68,74
001F8:  DATA 6D,6C
001FA:  DATA 20,6C
001FC:  DATA 61,6E
001FE:  DATA 67,3D
00200:  DATA 22,65
00202:  DATA 73,22
00204:  DATA 3E,20
00206:  DATA 0A,3C
00208:  DATA 6D,65
0020A:  DATA 74,61
0020C:  DATA 20,63
0020E:  DATA 68,61
00210:  DATA 72,73
00212:  DATA 65,74
00214:  DATA 3D,22
00216:  DATA 55,54
00218:  DATA 46,2D
0021A:  DATA 38,22
0021C:  DATA 3E,20
0021E:  DATA 0A,3C
00220:  DATA 6D,65
00222:  DATA 74,61
00224:  DATA 20,6E
00226:  DATA 61,6D
00228:  DATA 65,3D
0022A:  DATA 22,4D
0022C:  DATA 6F,62
0022E:  DATA 69,6C
00230:  DATA 65,4F
00232:  DATA 70,74
00234:  DATA 69,6D
00236:  DATA 69,7A
00238:  DATA 65,64
0023A:  DATA 22,20
0023C:  DATA 63,6F
0023E:  DATA 6E,74
00240:  DATA 65,6E
00242:  DATA 74,3D
00244:  DATA 22,77
00246:  DATA 69,64
00248:  DATA 74,68
0024A:  DATA 22,20
0024C:  DATA 2F,3E
0024E:  DATA 20,0A
00250:  DATA 3C,6D
00252:  DATA 65,74
00254:  DATA 61,20
00256:  DATA 6E,61
00258:  DATA 6D,65
0025A:  DATA 3D,22
0025C:  DATA 48,61
0025E:  DATA 6E,64
00260:  DATA 68,65
00262:  DATA 6C,64
00264:  DATA 46,72
00266:  DATA 69,65
00268:  DATA 6E,64
0026A:  DATA 6C,79
0026C:  DATA 22,20
0026E:  DATA 63,6F
00270:  DATA 6E,74
00272:  DATA 65,6E
00274:  DATA 74,3D
00276:  DATA 22,74
00278:  DATA 72,75
0027A:  DATA 65,22
0027C:  DATA 20,2F
0027E:  DATA 3E,20
00280:  DATA 0A,3C
00282:  DATA 6D,65
00284:  DATA 74,61
00286:  DATA 20,6E
00288:  DATA 61,6D
0028A:  DATA 65,3D
0028C:  DATA 22,76
0028E:  DATA 69,65
00290:  DATA 77,70
00292:  DATA 6F,72
00294:  DATA 74,22
00296:  DATA 20,63
00298:  DATA 6F,6E
0029A:  DATA 74,65
0029C:  DATA 6E,74
0029E:  DATA 3D,22
002A0:  DATA 77,69
002A2:  DATA 64,74
002A4:  DATA 68,3D
002A6:  DATA 64,65
002A8:  DATA 76,69
002AA:  DATA 63,65
002AC:  DATA 2D,77
002AE:  DATA 69,64
002B0:  DATA 74,68
002B2:  DATA 2C,20
002B4:  DATA 69,6E
002B6:  DATA 69,74
002B8:  DATA 69,61
002BA:  DATA 6C,2D
002BC:  DATA 73,63
002BE:  DATA 61,6C
002C0:  DATA 65,3D
002C2:  DATA 31,22
002C4:  DATA 3E,20
002C6:  DATA 0A,3C
002C8:  DATA 74,69
002CA:  DATA 74,6C
002CC:  DATA 65,3E
002CE:  DATA 45,6D
002D0:  DATA 62,65
002D2:  DATA 64,64
002D4:  DATA 65,64
002D6:  DATA 20,53
002D8:  DATA 65,72
002DA:  DATA 76,65
002DC:  DATA 72,20
002DE:  DATA 41,6C
002E0:  DATA 74,65
002E2:  DATA 63,3C
002E4:  DATA 2F,74
002E6:  DATA 69,74
002E8:  DATA 6C,65
002EA:  DATA 3E,20
002EC:  DATA 20,0A
002EE:  DATA 3C,64
002F0:  DATA 69,76
002F2:  DATA 20,73
002F4:  DATA 74,79
002F6:  DATA 6C,65
002F8:  DATA 3D,22
002FA:  DATA 74,65
002FC:  DATA 78,74
002FE:  DATA 2D,61
00300:  DATA 6C,69
00302:  DATA 67,6E
00304:  DATA 3A,20
00306:  DATA 63,65
00308:  DATA 6E,74
0030A:  DATA 65,72
0030C:  DATA 3B,22
0030E:  DATA 3E,20
00310:  DATA 0A,3C
00312:  DATA 64,69
00314:  DATA 76,20
00316:  DATA 73,74
00318:  DATA 79,6C
0031A:  DATA 65,3D
0031C:  DATA 22,62
0031E:  DATA 6F,78
00320:  DATA 2D,73
00322:  DATA 69,7A
00324:  DATA 69,6E
00326:  DATA 67,3A
00328:  DATA 20,62
0032A:  DATA 6F,72
0032C:  DATA 64,65
0032E:  DATA 72,2D
00330:  DATA 62,6F
00332:  DATA 78,3B
00334:  DATA 20,64
00336:  DATA 69,73
00338:  DATA 70,6C
0033A:  DATA 61,79
0033C:  DATA 3A,20
0033E:  DATA 69,6E
00340:  DATA 6C,69
00342:  DATA 6E,65
00344:  DATA 2D,62
00346:  DATA 6C,6F
00348:  DATA 63,6B
0034A:  DATA 3B,20
0034C:  DATA 77,69
0034E:  DATA 64,74
00350:  DATA 68,3A
00352:  DATA 20,61
00354:  DATA 75,74
00356:  DATA 6F,3B
00358:  DATA 20,6D
0035A:  DATA 61,78
0035C:  DATA 2D,77
0035E:  DATA 69,64
00360:  DATA 74,68
00362:  DATA 3A,20
00364:  DATA 34,38
00366:  DATA 30,70
00368:  DATA 78,3B
0036A:  DATA 20,62
0036C:  DATA 61,63
0036E:  DATA 6B,67
00370:  DATA 72,6F
00372:  DATA 75,6E
00374:  DATA 64,2D
00376:  DATA 63,6F
00378:  DATA 6C,6F
0037A:  DATA 72,3A
0037C:  DATA 20,23
0037E:  DATA 46,46
00380:  DATA 46,46
00382:  DATA 46,46
00384:  DATA 3B,20
00386:  DATA 62,6F
00388:  DATA 72,64
0038A:  DATA 65,72
0038C:  DATA 3A,20
0038E:  DATA 32,70
00390:  DATA 78,20
00392:  DATA 73,6F
00394:  DATA 6C,69
00396:  DATA 64,20
00398:  DATA 23,30
0039A:  DATA 33,36
0039C:  DATA 31,41
0039E:  DATA 38,3B
003A0:  DATA 20,62
003A2:  DATA 6F,72
003A4:  DATA 64,65
003A6:  DATA 72,2D
003A8:  DATA 72,61
003AA:  DATA 64,69
003AC:  DATA 75,73
003AE:  DATA 3A,20
003B0:  DATA 35,70
003B2:  DATA 78,3B
003B4:  DATA 20,62
003B6:  DATA 6F,78
003B8:  DATA 2D,73
003BA:  DATA 68,61
003BC:  DATA 64,6F
003BE:  DATA 77,3A
003C0:  DATA 20,30
003C2:  DATA 70,78
003C4:  DATA 20,30
003C6:  DATA 70,78
003C8:  DATA 20,38
003CA:  DATA 70,78
003CC:  DATA 20,23
003CE:  DATA 30,33
003D0:  DATA 36,31
003D2:  DATA 41,38
003D4:  DATA 3B,20
003D6:  DATA 6D,61
003D8:  DATA 72,67
003DA:  DATA 69,6E
003DC:  DATA 3A,20
003DE:  DATA 35,30
003E0:  DATA 70,78
003E2:  DATA 20,61
003E4:  DATA 75,74
003E6:  DATA 6F,20
003E8:  DATA 61,75
003EA:  DATA 74,6F
003EC:  DATA 3B,22
003EE:  DATA 3E,20
003F0:  DATA 0A,3C
003F2:  DATA 64,69
003F4:  DATA 76,20
003F6:  DATA 73,74
003F8:  DATA 79,6C
003FA:  DATA 65,3D
003FC:  DATA 22,62
003FE:  DATA 61,63
00400:  DATA 6B,67
00402:  DATA 72,6F
00404:  DATA 75,6E
00406:  DATA 64,3A
00408:  DATA 20,23
0040A:  DATA 30,33
0040C:  DATA 36,31
0040E:  DATA 41,38
00410:  DATA 3B,20
00412:  DATA 62,6F
00414:  DATA 72,64
00416:  DATA 65,72
00418:  DATA 2D,72
0041A:  DATA 61,64
0041C:  DATA 69,75
0041E:  DATA 73,3A
00420:  DATA 20,35
00422:  DATA 70,78
00424:  DATA 20,35
00426:  DATA 70,78
00428:  DATA 20,30
0042A:  DATA 70,78
0042C:  DATA 20,30
0042E:  DATA 70,78
00430:  DATA 3B,20
00432:  DATA 70,61
00434:  DATA 64,64
00436:  DATA 69,6E
00438:  DATA 67,3A
0043A:  DATA 20,31
0043C:  DATA 35,70
0043E:  DATA 78,3B
00440:  DATA 22,3E
00442:  DATA 3C,73
00444:  DATA 70,61
00446:  DATA 6E,20
00448:  DATA 73,74
0044A:  DATA 79,6C
0044C:  DATA 65,3D
0044E:  DATA 22,66
00450:  DATA 6F,6E
00452:  DATA 74,2D
00454:  DATA 66,61
00456:  DATA 6D,69
00458:  DATA 6C,79
0045A:  DATA 3A,20
0045C:  DATA 76,65
0045E:  DATA 72,64
00460:  DATA 61,6E
00462:  DATA 61,2C
00464:  DATA 61,72
00466:  DATA 69,61
00468:  DATA 6C,3B
0046A:  DATA 20,63
0046C:  DATA 6F,6C
0046E:  DATA 6F,72
00470:  DATA 3A,20
00472:  DATA 23,44
00474:  DATA 34,44
00476:  DATA 34,44
00478:  DATA 34,3B
0047A:  DATA 20,66
0047C:  DATA 6F,6E
0047E:  DATA 74,2D
00480:  DATA 73,69
00482:  DATA 7A,65
00484:  DATA 3A,20
00486:  DATA 31,2E
00488:  DATA 30,30
0048A:  DATA 65,6D
0048C:  DATA 3B,20
0048E:  DATA 66,6F
00490:  DATA 6E,74
00492:  DATA 2D,77
00494:  DATA 65,69
00496:  DATA 67,68
00498:  DATA 74,3A
0049A:  DATA 62,6F
0049C:  DATA 6C,64
0049E:  DATA 3B,22
004A0:  DATA 3E,45
004A2:  DATA 6D,62
004A4:  DATA 65,64
004A6:  DATA 20,53
004A8:  DATA 65,72
004AA:  DATA 76,65
004AC:  DATA 72,20
004AE:  DATA 41,6C
004B0:  DATA 74,65
004B2:  DATA 63,3C
004B4:  DATA 2F,73
004B6:  DATA 70,61
004B8:  DATA 6E,3E
004BA:  DATA 3C,2F
004BC:  DATA 64,69
004BE:  DATA 76,3E
004C0:  DATA 20,20
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 20,20
004C8:  DATA 20,20
004CA:  DATA 0A,3C
004CC:  DATA 64,69
004CE:  DATA 76,20
004D0:  DATA 73,74
004D2:  DATA 79,6C
004D4:  DATA 65,3D
004D6:  DATA 22,62
004D8:  DATA 61,63
004DA:  DATA 6B,67
004DC:  DATA 72,6F
004DE:  DATA 75,6E
004E0:  DATA 64,3A
004E2:  DATA 20,3B
004E4:  DATA 20,70
004E6:  DATA 61,64
004E8:  DATA 64,69
004EA:  DATA 6E,67
004EC:  DATA 3A,20
004EE:  DATA 31,35
004F0:  DATA 70,78
004F2:  DATA 22,20
004F4:  DATA 69,64
004F6:  DATA 3D,22
004F8:  DATA 61,70
004FA:  DATA 5F,73
004FC:  DATA 74,79
004FE:  DATA 6C,65
00500:  DATA 22,3E
00502:  DATA 20,20
00504:  DATA 20,20
00506:  DATA 20,20
00508:  DATA 20,20
0050A:  DATA 20,20
0050C:  DATA 20,20
0050E:  DATA 20,20
00510:  DATA 20,20
00512:  DATA 20,20
00514:  DATA 20,20
00516:  DATA 20,20
00518:  DATA 20,20
0051A:  DATA 20,20
0051C:  DATA 20,20
0051E:  DATA 20,20
00520:  DATA 20,20
00522:  DATA 20,20
00524:  DATA 20,20
00526:  DATA 20,20
00528:  DATA 20,20
0052A:  DATA 20,20
0052C:  DATA 20,20
0052E:  DATA 20,20
00530:  DATA 20,20
00532:  DATA 20,20
00534:  DATA 20,20
00536:  DATA 20,20
00538:  DATA 20,20
0053A:  DATA 20,20
0053C:  DATA 20,20
0053E:  DATA 20,20
00540:  DATA 20,20
00542:  DATA 20,20
00544:  DATA 20,20
00546:  DATA 20,20
00548:  DATA 20,20
0054A:  DATA 20,20
0054C:  DATA 20,20
0054E:  DATA 20,20
00550:  DATA 20,20
00552:  DATA 20,20
00554:  DATA 20,20
00556:  DATA 20,20
00558:  DATA 20,20
0055A:  DATA 20,20
0055C:  DATA 20,20
0055E:  DATA 20,20
00560:  DATA 20,20
00562:  DATA 20,20
00564:  DATA 20,20
00566:  DATA 20,20
00568:  DATA 20,20
0056A:  DATA 20,20
0056C:  DATA 20,20
0056E:  DATA 20,20
00570:  DATA 20,20
00572:  DATA 20,20
00574:  DATA 20,20
00576:  DATA 20,20
00578:  DATA 20,20
0057A:  DATA 20,20
0057C:  DATA 20,20
0057E:  DATA 20,20
00580:  DATA 20,20
00582:  DATA 20,20
00584:  DATA 20,20
00586:  DATA 20,20
00588:  DATA 20,20
0058A:  DATA 20,20
0058C:  DATA 20,20
0058E:  DATA 20,20
00590:  DATA 20,20
00592:  DATA 20,20
00594:  DATA 20,20
00596:  DATA 20,20
00598:  DATA 20,20
0059A:  DATA 20,20
0059C:  DATA 20,20
0059E:  DATA 20,20
005A0:  DATA 20,20
005A2:  DATA 20,20
005A4:  DATA 20,20
005A6:  DATA 20,20
005A8:  DATA 20,20
005AA:  DATA 20,20
005AC:  DATA 20,20
005AE:  DATA 20,20
005B0:  DATA 20,20
005B2:  DATA 20,20
005B4:  DATA 20,20
005B6:  DATA 20,20
005B8:  DATA 20,0A
005BA:  DATA 3C,73
005BC:  DATA 74,79
005BE:  DATA 6C,65
005C0:  DATA 20,74
005C2:  DATA 79,70
005C4:  DATA 65,3D
005C6:  DATA 22,74
005C8:  DATA 65,78
005CA:  DATA 74,2F
005CC:  DATA 63,73
005CE:  DATA 73,22
005D0:  DATA 20,73
005D2:  DATA 63,6F
005D4:  DATA 70,65
005D6:  DATA 64,3E
005D8:  DATA 20,20
005DA:  DATA 20,20
005DC:  DATA 20,20
005DE:  DATA 20,20
005E0:  DATA 20,20
005E2:  DATA 20,20
005E4:  DATA 20,20
005E6:  DATA 20,20
005E8:  DATA 20,20
005EA:  DATA 20,20
005EC:  DATA 20,20
005EE:  DATA 20,20
005F0:  DATA 20,20
005F2:  DATA 20,0A
005F4:  DATA 23,61
005F6:  DATA 70,5F
005F8:  DATA 73,74
005FA:  DATA 79,6C
005FC:  DATA 65,20
005FE:  DATA 74,64
00600:  DATA 20,7B
00602:  DATA 20,74
00604:  DATA 65,78
00606:  DATA 74,2D
00608:  DATA 61,6C
0060A:  DATA 69,67
0060C:  DATA 6E,3A
0060E:  DATA 6C,65
00610:  DATA 66,74
00612:  DATA 3B,20
00614:  DATA 66,6F
00616:  DATA 6E,74
00618:  DATA 2D,66
0061A:  DATA 61,6D
0061C:  DATA 69,6C
0061E:  DATA 79,3A
00620:  DATA 20,76
00622:  DATA 65,72
00624:  DATA 64,61
00626:  DATA 6E,61
00628:  DATA 2C,61
0062A:  DATA 72,69
0062C:  DATA 61,6C
0062E:  DATA 3B,20
00630:  DATA 63,6F
00632:  DATA 6C,6F
00634:  DATA 72,3A
00636:  DATA 20,23
00638:  DATA 30,36
0063A:  DATA 34,30
0063C:  DATA 37,33
0063E:  DATA 3B,20
00640:  DATA 66,6F
00642:  DATA 6E,74
00644:  DATA 2D,73
00646:  DATA 69,7A
00648:  DATA 65,3A
0064A:  DATA 20,31
0064C:  DATA 2E,30
0064E:  DATA 30,65
00650:  DATA 6D,3B
00652:  DATA 20,7D
00654:  DATA 20,0A
00656:  DATA 23,61
00658:  DATA 70,5F
0065A:  DATA 73,74
0065C:  DATA 79,6C
0065E:  DATA 65,20
00660:  DATA 69,6E
00662:  DATA 70,75
00664:  DATA 74,20
00666:  DATA 7B,20
00668:  DATA 62,6F
0066A:  DATA 72,64
0066C:  DATA 65,72
0066E:  DATA 3A,20
00670:  DATA 31,70
00672:  DATA 78,20
00674:  DATA 73,6F
00676:  DATA 6C,69
00678:  DATA 64,20
0067A:  DATA 23,43
0067C:  DATA 43,43
0067E:  DATA 43,43
00680:  DATA 43,3B
00682:  DATA 20,62
00684:  DATA 6F,72
00686:  DATA 64,65
00688:  DATA 72,2D
0068A:  DATA 72,61
0068C:  DATA 64,69
0068E:  DATA 75,73
00690:  DATA 3A,20
00692:  DATA 35,70
00694:  DATA 78,3B
00696:  DATA 20,63
00698:  DATA 6F,6C
0069A:  DATA 6F,72
0069C:  DATA 3A,20
0069E:  DATA 23,36
006A0:  DATA 36,36
006A2:  DATA 36,36
006A4:  DATA 36,3B
006A6:  DATA 20,64
006A8:  DATA 69,73
006AA:  DATA 70,6C
006AC:  DATA 61,79
006AE:  DATA 3A,20
006B0:  DATA 69,6E
006B2:  DATA 6C,69
006B4:  DATA 6E,65
006B6:  DATA 2D,62
006B8:  DATA 6C,6F
006BA:  DATA 63,6B
006BC:  DATA 3B,20
006BE:  DATA 66,6F
006C0:  DATA 6E,74
006C2:  DATA 2D,73
006C4:  DATA 69,7A
006C6:  DATA 65,3A
006C8:  DATA 20,31
006CA:  DATA 2E,30
006CC:  DATA 30,65
006CE:  DATA 6D,3B
006D0:  DATA 20,20
006D2:  DATA 70,61
006D4:  DATA 64,64
006D6:  DATA 69,6E
006D8:  DATA 67,3A
006DA:  DATA 20,35
006DC:  DATA 70,78
006DE:  DATA 3B,20
006E0:  DATA 7D,20
006E2:  DATA 0A,23
006E4:  DATA 61,70
006E6:  DATA 5F,73
006E8:  DATA 74,79
006EA:  DATA 6C,65
006EC:  DATA 20,69
006EE:  DATA 6E,70
006F0:  DATA 75,74
006F2:  DATA 5B,74
006F4:  DATA 79,70
006F6:  DATA 65,3D
006F8:  DATA 22,74
006FA:  DATA 65,78
006FC:  DATA 74,22
006FE:  DATA 5D,2C
00700:  DATA 20,69
00702:  DATA 6E,70
00704:  DATA 75,74
00706:  DATA 5B,74
00708:  DATA 79,70
0070A:  DATA 65,3D
0070C:  DATA 22,70
0070E:  DATA 61,73
00710:  DATA 73,77
00712:  DATA 6F,72
00714:  DATA 64,22
00716:  DATA 5D,20
00718:  DATA 7B,20
0071A:  DATA 77,69
0071C:  DATA 64,74
0071E:  DATA 68,3A
00720:  DATA 20,31
00722:  DATA 30,30
00724:  DATA 25,3B
00726:  DATA 20,7D
00728:  DATA 20,20
0072A:  DATA 20,20
0072C:  DATA 20,20
0072E:  DATA 20,20
00730:  DATA 20,20
00732:  DATA 20,20
00734:  DATA 20,20
00736:  DATA 20,20
00738:  DATA 20,20
0073A:  DATA 20,20
0073C:  DATA 20,20
0073E:  DATA 20,20
00740:  DATA 20,20
00742:  DATA 20,20
00744:  DATA 20,20
00746:  DATA 20,20
00748:  DATA 20,20
0074A:  DATA 20,20
0074C:  DATA 20,20
0074E:  DATA 20,20
00750:  DATA 20,20
00752:  DATA 20,20
00754:  DATA 20,20
00756:  DATA 20,20
00758:  DATA 20,20
0075A:  DATA 20,20
0075C:  DATA 20,20
0075E:  DATA 20,20
00760:  DATA 20,20
00762:  DATA 20,20
00764:  DATA 20,20
00766:  DATA 20,20
00768:  DATA 20,20
0076A:  DATA 20,20
0076C:  DATA 20,20
0076E:  DATA 20,20
00770:  DATA 20,20
00772:  DATA 20,20
00774:  DATA 20,20
00776:  DATA 20,20
00778:  DATA 20,20
0077A:  DATA 20,20
0077C:  DATA 20,20
0077E:  DATA 20,20
00780:  DATA 20,20
00782:  DATA 20,20
00784:  DATA 20,20
00786:  DATA 20,20
00788:  DATA 20,20
0078A:  DATA 20,20
0078C:  DATA 20,20
0078E:  DATA 20,20
00790:  DATA 20,20
00792:  DATA 20,20
00794:  DATA 20,20
00796:  DATA 20,20
00798:  DATA 20,20
0079A:  DATA 20,20
0079C:  DATA 20,20
0079E:  DATA 20,20
007A0:  DATA 0A,23
007A2:  DATA 61,70
007A4:  DATA 5F,73
007A6:  DATA 74,79
007A8:  DATA 6C,65
007AA:  DATA 20,69
007AC:  DATA 6E,70
007AE:  DATA 75,74
007B0:  DATA 5B,74
007B2:  DATA 79,70
007B4:  DATA 65,3D
007B6:  DATA 22,62
007B8:  DATA 75,74
007BA:  DATA 74,6F
007BC:  DATA 6E,22
007BE:  DATA 5D,2C
007C0:  DATA 20,0A
007C2:  DATA 23,61
007C4:  DATA 70,5F
007C6:  DATA 73,74
007C8:  DATA 79,6C
007CA:  DATA 65,20
007CC:  DATA 69,6E
007CE:  DATA 70,75
007D0:  DATA 74,5B
007D2:  DATA 74,79
007D4:  DATA 70,65
007D6:  DATA 3D,22
007D8:  DATA 72,65
007DA:  DATA 73,65
007DC:  DATA 74,22
007DE:  DATA 5D,2C
007E0:  DATA 20,0A
007E2:  DATA 23,61
007E4:  DATA 70,5F
007E6:  DATA 73,74
007E8:  DATA 79,6C
007EA:  DATA 65,20
007EC:  DATA 69,6E
007EE:  DATA 70,75
007F0:  DATA 74,5B
007F2:  DATA 74,79
007F4:  DATA 70,65
007F6:  DATA 3D,22
007F8:  DATA 73,75
007FA:  DATA 62,6D
007FC:  DATA 69,74
007FE:  DATA 22,5D
00800:  DATA 20,7B
00802:  DATA 20,68
00804:  DATA 65,69
00806:  DATA 67,68
00808:  DATA 74,3A
0080A:  DATA 20,61
0080C:  DATA 75,74
0080E:  DATA 6F,3B
00810:  DATA 20,77
00812:  DATA 69,64
00814:  DATA 74,68
00816:  DATA 3A,20
00818:  DATA 61,75
0081A:  DATA 74,6F
0081C:  DATA 3B,20
0081E:  DATA 63,75
00820:  DATA 72,73
00822:  DATA 6F,72
00824:  DATA 3A,20
00826:  DATA 70,6F
00828:  DATA 69,6E
0082A:  DATA 74,65
0082C:  DATA 72,3B
0082E:  DATA 20,62
00830:  DATA 6F,78
00832:  DATA 2D,73
00834:  DATA 68,61
00836:  DATA 64,6F
00838:  DATA 77,3A
0083A:  DATA 20,30
0083C:  DATA 70,78
0083E:  DATA 20,30
00840:  DATA 70,78
00842:  DATA 20,35
00844:  DATA 70,78
00846:  DATA 20,23
00848:  DATA 30,33
0084A:  DATA 36,31
0084C:  DATA 41,38
0084E:  DATA 3B,20
00850:  DATA 66,6C
00852:  DATA 6F,61
00854:  DATA 74,3A
00856:  DATA 20,72
00858:  DATA 69,67
0085A:  DATA 68,74
0085C:  DATA 3B,20
0085E:  DATA 74,65
00860:  DATA 78,74
00862:  DATA 2D,61
00864:  DATA 6C,69
00866:  DATA 67,6E
00868:  DATA 3A,72
0086A:  DATA 69,67
0086C:  DATA 68,74
0086E:  DATA 3B,20
00870:  DATA 6D,61
00872:  DATA 72,67
00874:  DATA 69,6E
00876:  DATA 2D,74
00878:  DATA 6F,70
0087A:  DATA 3A,20
0087C:  DATA 31,30
0087E:  DATA 70,78
00880:  DATA 3B,20
00882:  DATA 6D,61
00884:  DATA 72,67
00886:  DATA 69,6E
00888:  DATA 2D,6C
0088A:  DATA 65,66
0088C:  DATA 74,3A
0088E:  DATA 37,70
00890:  DATA 78,3B
00892:  DATA 7D,20
00894:  DATA 0A,23
00896:  DATA 61,70
00898:  DATA 5F,73
0089A:  DATA 74,79
0089C:  DATA 6C,65
0089E:  DATA 20,74
008A0:  DATA 61,62
008A2:  DATA 6C,65
008A4:  DATA 2E,63
008A6:  DATA 65,6E
008A8:  DATA 74,65
008AA:  DATA 72,20
008AC:  DATA 7B,20
008AE:  DATA 6D,61
008B0:  DATA 72,67
008B2:  DATA 69,6E
008B4:  DATA 2D,6C
008B6:  DATA 65,66
008B8:  DATA 74,3A
008BA:  DATA 61,75
008BC:  DATA 74,6F
008BE:  DATA 3B,20
008C0:  DATA 6D,61
008C2:  DATA 72,67
008C4:  DATA 69,6E
008C6:  DATA 2D,72
008C8:  DATA 69,67
008CA:  DATA 68,74
008CC:  DATA 3A,61
008CE:  DATA 75,74
008D0:  DATA 6F,3B
008D2:  DATA 20,7D
008D4:  DATA 20,0A
008D6:  DATA 23,61
008D8:  DATA 70,5F
008DA:  DATA 73,74
008DC:  DATA 79,6C
008DE:  DATA 65,20
008E0:  DATA 2E,65
008E2:  DATA 72,72
008E4:  DATA 6F,72
008E6:  DATA 20,7B
008E8:  DATA 20,66
008EA:  DATA 6F,6E
008EC:  DATA 74,2D
008EE:  DATA 66,61
008F0:  DATA 6D,69
008F2:  DATA 6C,79
008F4:  DATA 3A,20
008F6:  DATA 76,65
008F8:  DATA 72,64
008FA:  DATA 61,6E
008FC:  DATA 61,2C
008FE:  DATA 61,72
00900:  DATA 69,61
00902:  DATA 6C,3B
00904:  DATA 20,63
00906:  DATA 6F,6C
00908:  DATA 6F,72
0090A:  DATA 3A,20
0090C:  DATA 23,44
0090E:  DATA 34,31
00910:  DATA 33,31
00912:  DATA 33,3B
00914:  DATA 20,66
00916:  DATA 6F,6E
00918:  DATA 74,2D
0091A:  DATA 73,69
0091C:  DATA 7A,65
0091E:  DATA 3A,20
00920:  DATA 31,2E
00922:  DATA 30,30
00924:  DATA 65,6D
00926:  DATA 3B,20
00928:  DATA 7D,20
0092A:  DATA 0A,3C
0092C:  DATA 2F,73
0092E:  DATA 74,79
00930:  DATA 6C,65
00932:  DATA 3E,20
00934:  DATA 0A,3C
00936:  DATA 70,3E
00938:  DATA 3C,69
0093A:  DATA 6D,67
0093C:  DATA 20,73
0093E:  DATA 72,63
00940:  DATA 3D,22
00942:  DATA 64,61
00944:  DATA 74,61
00946:  DATA 3A,69
00948:  DATA 6D,61
0094A:  DATA 67,65
0094C:  DATA 2F,67
0094E:  DATA 69,66
00950:  DATA 3B,62
00952:  DATA 61,73
00954:  DATA 65,36
00956:  DATA 34,2C
00958:  DATA 2F,39
0095A:  DATA 6A,2F
0095C:  DATA 34,41
0095E:  DATA 41,51
00960:  DATA 53,6B
00962:  DATA 5A,4A
00964:  DATA 52,67
00966:  DATA 41,42
00968:  DATA 41,51
0096A:  DATA 45,41
0096C:  DATA 59,41
0096E:  DATA 42,67
00970:  DATA 41,41
00972:  DATA 44,2F
00974:  DATA 34,51
00976:  DATA 41,75
00978:  DATA 52,58
0097A:  DATA 68,70
0097C:  DATA 5A,67
0097E:  DATA 41,41
00980:  DATA 54,55
00982:  DATA 30,41
00984:  DATA 4B,67
00986:  DATA 41,41
00988:  DATA 41,41
0098A:  DATA 67,41
0098C:  DATA 41,6C
0098E:  DATA 45,41
00990:  DATA 41,41
00992:  DATA 51,41
00994:  DATA 41,41
00996:  DATA 41,42
00998:  DATA 41,41
0099A:  DATA 41,41
0099C:  DATA 41,46
0099E:  DATA 45,42
009A0:  DATA 41,41
009A2:  DATA 4D,41
009A4:  DATA 20,0A
009A6:  DATA 41,41
009A8:  DATA 41,42
009AA:  DATA 41,41
009AC:  DATA 45,41
009AE:  DATA 41,41
009B0:  DATA 41,41
009B2:  DATA 41,41
009B4:  DATA 44,2F
009B6:  DATA 32,77
009B8:  DATA 42,44
009BA:  DATA 41,41
009BC:  DATA 49,42
009BE:  DATA 41,51
009C0:  DATA 49,42
009C2:  DATA 41,51
009C4:  DATA 49,43
009C6:  DATA 41,67
009C8:  DATA 49,43
009CA:  DATA 41,67
009CC:  DATA 49,43
009CE:  DATA 41,77
009D0:  DATA 55,44
009D2:  DATA 41,77
009D4:  DATA 4D,44
009D6:  DATA 41,77
009D8:  DATA 59,45
009DA:  DATA 42,41
009DC:  DATA 4D,46
009DE:  DATA 42,77
009E0:  DATA 59,48
009E2:  DATA 42,77
009E4:  DATA 63,47
009E6:  DATA 42,77
009E8:  DATA 63,49
009EA:  DATA 43,51
009EC:  DATA 73,4A
009EE:  DATA 43,41
009F0:  DATA 67,4B
009F2:  DATA 20,0A
009F4:  DATA 43,41
009F6:  DATA 63,48
009F8:  DATA 43,67
009FA:  DATA 30,4B
009FC:  DATA 43,67
009FE:  DATA 73,4D
00A00:  DATA 44,41
00A02:  DATA 77,4D
00A04:  DATA 42,77
00A06:  DATA 6B,4F
00A08:  DATA 44,77
00A0A:  DATA 30,4D
00A0C:  DATA 44,67
00A0E:  DATA 73,4D
00A10:  DATA 44,41
00A12:  DATA 7A,2F
00A14:  DATA 32,77
00A16:  DATA 42,44
00A18:  DATA 41,51
00A1A:  DATA 49,43
00A1C:  DATA 41,67
00A1E:  DATA 4D,44
00A20:  DATA 41,77
00A22:  DATA 59,44
00A24:  DATA 41,77
00A26:  DATA 59,4D
00A28:  DATA 43,41
00A2A:  DATA 63,49
00A2C:  DATA 44,41
00A2E:  DATA 77,4D
00A30:  DATA 44,41
00A32:  DATA 77,4D
00A34:  DATA 44,41
00A36:  DATA 77,4D
00A38:  DATA 44,41
00A3A:  DATA 77,4D
00A3C:  DATA 44,41
00A3E:  DATA 77,4D
00A40:  DATA 20,0A
00A42:  DATA 44,41
00A44:  DATA 77,4D
00A46:  DATA 44,41
00A48:  DATA 77,4D
00A4A:  DATA 44,41
00A4C:  DATA 77,4D
00A4E:  DATA 44,41
00A50:  DATA 77,4D
00A52:  DATA 44,41
00A54:  DATA 77,4D
00A56:  DATA 44,41
00A58:  DATA 77,4D
00A5A:  DATA 44,41
00A5C:  DATA 77,4D
00A5E:  DATA 44,41
00A60:  DATA 77,4D
00A62:  DATA 44,41
00A64:  DATA 77,4D
00A66:  DATA 44,41
00A68:  DATA 77,4D
00A6A:  DATA 44,41
00A6C:  DATA 77,4D
00A6E:  DATA 44,41
00A70:  DATA 7A,2F
00A72:  DATA 77,41
00A74:  DATA 41,52
00A76:  DATA 43,41
00A78:  DATA 42,35
00A7A:  DATA 41,52
00A7C:  DATA 73,44
00A7E:  DATA 41,53
00A80:  DATA 49,41
00A82:  DATA 41,68
00A84:  DATA 45,42
00A86:  DATA 41,78
00A88:  DATA 45,42
00A8A:  DATA 2F,38
00A8C:  DATA 51,41
00A8E:  DATA 20,0A
00A90:  DATA 48,77
00A92:  DATA 41,41
00A94:  DATA 41,51
00A96:  DATA 55,42
00A98:  DATA 41,51
00A9A:  DATA 45,42
00A9C:  DATA 41,51
00A9E:  DATA 45,41
00AA0:  DATA 41,41
00AA2:  DATA 41,41
00AA4:  DATA 41,41
00AA6:  DATA 41,41
00AA8:  DATA 41,41
00AAA:  DATA 45,43
00AAC:  DATA 41,77
00AAE:  DATA 51,46
00AB0:  DATA 42,67
00AB2:  DATA 63,49
00AB4:  DATA 43,51
00AB6:  DATA 6F,4C
00AB8:  DATA 2F,38
00ABA:  DATA 51,41
00ABC:  DATA 74,52
00ABE:  DATA 41,41
00AC0:  DATA 41,67
00AC2:  DATA 45,44
00AC4:  DATA 41,77
00AC6:  DATA 49,45
00AC8:  DATA 41,77
00ACA:  DATA 55,46
00ACC:  DATA 42,41
00ACE:  DATA 51,41
00AD0:  DATA 41,41
00AD2:  DATA 46,39
00AD4:  DATA 41,51
00AD6:  DATA 49,44
00AD8:  DATA 41,41
00ADA:  DATA 51,52
00ADC:  DATA 20,0A
00ADE:  DATA 42,52
00AE0:  DATA 49,68
00AE2:  DATA 4D,55
00AE4:  DATA 45,47
00AE6:  DATA 45,31
00AE8:  DATA 46,68
00AEA:  DATA 42,79
00AEC:  DATA 4A,78
00AEE:  DATA 46,44
00AF0:  DATA 4B,42
00AF2:  DATA 6B,61
00AF4:  DATA 45,49
00AF6:  DATA 49,30
00AF8:  DATA 4B,78
00AFA:  DATA 77,52
00AFC:  DATA 56,53
00AFE:  DATA 30,66
00B00:  DATA 41,6B
00B02:  DATA 4D,32
00B04:  DATA 4A,79
00B06:  DATA 67,67
00B08:  DATA 6B,4B
00B0A:  DATA 46,68
00B0C:  DATA 63,59
00B0E:  DATA 47,52
00B10:  DATA 6F,6C
00B12:  DATA 4A,69
00B14:  DATA 63,6F
00B16:  DATA 4B,53
00B18:  DATA 6F,30
00B1A:  DATA 4E,54
00B1C:  DATA 59,33
00B1E:  DATA 4F,44
00B20:  DATA 6B,36
00B22:  DATA 51,30
00B24:  DATA 52,46
00B26:  DATA 52,6B
00B28:  DATA 64,49
00B2A:  DATA 20,0A
00B2C:  DATA 53,55
00B2E:  DATA 70,54
00B30:  DATA 56,46
00B32:  DATA 56,57
00B34:  DATA 56,31
00B36:  DATA 68,5A
00B38:  DATA 57,6D
00B3A:  DATA 4E,6B
00B3C:  DATA 5A,57
00B3E:  DATA 5A,6E
00B40:  DATA 61,47
00B42:  DATA 6C,71
00B44:  DATA 63,33
00B46:  DATA 52,31
00B48:  DATA 64,6E
00B4A:  DATA 64,34
00B4C:  DATA 65,58
00B4E:  DATA 71,44
00B50:  DATA 68,49
00B52:  DATA 57,47
00B54:  DATA 68,34
00B56:  DATA 69,4A
00B58:  DATA 69,70
00B5A:  DATA 4B,54
00B5C:  DATA 6C,4A
00B5E:  DATA 57,57
00B60:  DATA 6C,35
00B62:  DATA 69,5A
00B64:  DATA 6D,71
00B66:  DATA 4B,6A
00B68:  DATA 70,4B
00B6A:  DATA 57,6D
00B6C:  DATA 70,36
00B6E:  DATA 69,70
00B70:  DATA 71,72
00B72:  DATA 4B,7A
00B74:  DATA 74,4C
00B76:  DATA 57,32
00B78:  DATA 20,0A
00B7A:  DATA 74,37
00B7C:  DATA 69,35
00B7E:  DATA 75,73
00B80:  DATA 4C,44
00B82:  DATA 78,4D
00B84:  DATA 58,47
00B86:  DATA 78,38
00B88:  DATA 6A,4A
00B8A:  DATA 79,74
00B8C:  DATA 4C,54
00B8E:  DATA 31,4E
00B90:  DATA 58,57
00B92:  DATA 31,39
00B94:  DATA 6A,5A
00B96:  DATA 32,75
00B98:  DATA 48,69
00B9A:  DATA 34,2B
00B9C:  DATA 54,6C
00B9E:  DATA 35,75
00BA0:  DATA 66,6F
00BA2:  DATA 36,65
00BA4:  DATA 72,78
00BA6:  DATA 38,76
00BA8:  DATA 50,30
00BAA:  DATA 39,66
00BAC:  DATA 62,33
00BAE:  DATA 2B,50
00BB0:  DATA 6E,36
00BB2:  DATA 2F,38
00BB4:  DATA 51,41
00BB6:  DATA 48,77
00BB8:  DATA 45,41
00BBA:  DATA 41,77
00BBC:  DATA 45,42
00BBE:  DATA 41,51
00BC0:  DATA 45,42
00BC2:  DATA 41,51
00BC4:  DATA 45,42
00BC6:  DATA 20,0A
00BC8:  DATA 41,51
00BCA:  DATA 41,41
00BCC:  DATA 41,41
00BCE:  DATA 41,41
00BD0:  DATA 41,41
00BD2:  DATA 45,43
00BD4:  DATA 41,77
00BD6:  DATA 51,46
00BD8:  DATA 42,67
00BDA:  DATA 63,49
00BDC:  DATA 43,51
00BDE:  DATA 6F,4C
00BE0:  DATA 2F,38
00BE2:  DATA 51,41
00BE4:  DATA 74,52
00BE6:  DATA 45,41
00BE8:  DATA 41,67
00BEA:  DATA 45,43
00BEC:  DATA 42,41
00BEE:  DATA 51,44
00BF0:  DATA 42,41
00BF2:  DATA 63,46
00BF4:  DATA 42,41
00BF6:  DATA 51,41
00BF8:  DATA 41,51
00BFA:  DATA 4A,33
00BFC:  DATA 41,41
00BFE:  DATA 45,43
00C00:  DATA 41,78
00C02:  DATA 45,45
00C04:  DATA 42,53
00C06:  DATA 45,78
00C08:  DATA 42,68
00C0A:  DATA 4A,42
00C0C:  DATA 55,51
00C0E:  DATA 64,68
00C10:  DATA 63,52
00C12:  DATA 4D,69
00C14:  DATA 20,0A
00C16:  DATA 4D,6F
00C18:  DATA 45,49
00C1A:  DATA 46,45
00C1C:  DATA 4B,52
00C1E:  DATA 6F,62
00C20:  DATA 48,42
00C22:  DATA 43,53
00C24:  DATA 4D,7A
00C26:  DATA 55,76
00C28:  DATA 41,56
00C2A:  DATA 59,6E
00C2C:  DATA 4C,52
00C2E:  DATA 43,68
00C30:  DATA 59,6B
00C32:  DATA 4E,4F
00C34:  DATA 45,6C
00C36:  DATA 38,52
00C38:  DATA 63,59
00C3A:  DATA 47,52
00C3C:  DATA 6F,6D
00C3E:  DATA 4A,79
00C40:  DATA 67,70
00C42:  DATA 4B,6A
00C44:  DATA 55,32
00C46:  DATA 4E,7A
00C48:  DATA 67,35
00C4A:  DATA 4F,6B
00C4C:  DATA 4E,45
00C4E:  DATA 52,55
00C50:  DATA 5A,48
00C52:  DATA 53,45
00C54:  DATA 6C,4B
00C56:  DATA 55,31
00C58:  DATA 52,56
00C5A:  DATA 56,6C
00C5C:  DATA 64,59
00C5E:  DATA 57,56
00C60:  DATA 70,6A
00C62:  DATA 20,0A
00C64:  DATA 5A,47
00C66:  DATA 56,6D
00C68:  DATA 5A,32
00C6A:  DATA 68,70
00C6C:  DATA 61,6E
00C6E:  DATA 4E,30
00C70:  DATA 64,58
00C72:  DATA 5A,33
00C74:  DATA 65,48
00C76:  DATA 6C,36
00C78:  DATA 67,6F
00C7A:  DATA 4F,45
00C7C:  DATA 68,59
00C7E:  DATA 61,48
00C80:  DATA 69,49
00C82:  DATA 6D,4B
00C84:  DATA 6B,70
00C86:  DATA 4F,55
00C88:  DATA 6C,5A
00C8A:  DATA 61,58
00C8C:  DATA 6D,4A
00C8E:  DATA 6D,61
00C90:  DATA 6F,71
00C92:  DATA 4F,6B
00C94:  DATA 70,61
00C96:  DATA 61,6E
00C98:  DATA 71,4B
00C9A:  DATA 6D,71
00C9C:  DATA 73,72
00C9E:  DATA 4F,30
00CA0:  DATA 74,62
00CA2:  DATA 61,33
00CA4:  DATA 75,4C
00CA6:  DATA 6D,36
00CA8:  DATA 77,73
00CAA:  DATA 50,45
00CAC:  DATA 78,63
00CAE:  DATA 62,48
00CB0:  DATA 20,0A
00CB2:  DATA 79,4D
00CB4:  DATA 6E,4B
00CB6:  DATA 30,74
00CB8:  DATA 50,55
00CBA:  DATA 31,64
00CBC:  DATA 62,58
00CBE:  DATA 32,4E
00CC0:  DATA 6E,61
00CC2:  DATA 34,75
00CC4:  DATA 50,6B
00CC6:  DATA 35,65
00CC8:  DATA 62,6E
00CCA:  DATA 36,4F
00CCC:  DATA 6E,71
00CCE:  DATA 38,76
00CD0:  DATA 50,30
00CD2:  DATA 39,66
00CD4:  DATA 62,33
00CD6:  DATA 2B,50
00CD8:  DATA 6E,36
00CDA:  DATA 2F,39
00CDC:  DATA 6F,41
00CDE:  DATA 44,41
00CE0:  DATA 4D,42
00CE2:  DATA 41,41
00CE4:  DATA 49,52
00CE6:  DATA 41,78
00CE8:  DATA 45,41
00CEA:  DATA 50,77
00CEC:  DATA 44,39
00CEE:  DATA 2F,4B
00CF0:  DATA 4B,4B
00CF2:  DATA 4B,41
00CF4:  DATA 43,69
00CF6:  DATA 69,69
00CF8:  DATA 67,41
00CFA:  DATA 6F,6F
00CFC:  DATA 6F,6F
00CFE:  DATA 20,0A
00D00:  DATA 41,4B
00D02:  DATA 4B,41
00D04:  DATA 32,61
00D06:  DATA 4E,31
00D08:  DATA 41,42
00D0A:  DATA 52,52
00D0C:  DATA 6D,6A
00D0E:  DATA 4E,41
00D10:  DATA 42,52
00D12:  DATA 52,6D
00D14:  DATA 67,48
00D16:  DATA 4E,41
00D18:  DATA 42,52
00D1A:  DATA 51,54
00D1C:  DATA 52,6D
00D1E:  DATA 67,41
00D20:  DATA 6F,6F
00D22:  DATA 6F,6F
00D24:  DATA 41,4B
00D26:  DATA 4B,54
00D28:  DATA 64,53
00D2A:  DATA 35,35
00D2C:  DATA 6F,41
00D2E:  DATA 4B,4B
00D30:  DATA 4B,4B
00D32:  DATA 41,43
00D34:  DATA 69,67
00D36:  DATA 6E,46
00D38:  DATA 47,61
00D3A:  DATA 41,43
00D3C:  DATA 69,6B
00D3E:  DATA 33,69
00D40:  DATA 6C,42
00D42:  DATA 7A,51
00D44:  DATA 41,55
00D46:  DATA 55,5A
00D48:  DATA 6F,7A
00D4A:  DATA 51,41
00D4C:  DATA 20,0A
00D4E:  DATA 55,55
00D50:  DATA 55,55
00D52:  DATA 41,46
00D54:  DATA 46,46
00D56:  DATA 46,41
00D58:  DATA 42,52
00D5A:  DATA 52,52
00D5C:  DATA 51,41
00D5E:  DATA 55,55
00D60:  DATA 55,55
00D62:  DATA 41,46
00D64:  DATA 46,46
00D66:  DATA 46,41
00D68:  DATA 42,52
00D6A:  DATA 52,52
00D6C:  DATA 51,41
00D6E:  DATA 55,55
00D70:  DATA 55,55
00D72:  DATA 41,46
00D74:  DATA 46,42
00D76:  DATA 4F,4B
00D78:  DATA 61,4A
00D7A:  DATA 41,61
00D7C:  DATA 41,41
00D7E:  DATA 6B,55
00D80:  DATA 4C,31
00D82:  DATA 72,6A
00D84:  DATA 2F,6A
00D86:  DATA 6E,38
00D88:  DATA 62,76
00D8A:  DATA 44,66
00D8C:  DATA 37,4F
00D8E:  DATA 66,77
00D90:  DATA 72,31
00D92:  DATA 72,78
00D94:  DATA 6E,34
00D96:  DATA 75,31
00D98:  DATA 4B,48
00D9A:  DATA 20,0A
00D9C:  DATA 53,2F
00D9E:  DATA 44,2B
00DA0:  DATA 68,77
00DA2:  DATA 47,65
00DA4:  DATA 35,6E
00DA6:  DATA 63,2F
00DA8:  DATA 4D,65
00DAA:  DATA 79,6F
00DAC:  DATA 69,39
00DAE:  DATA 58,64
00DB0:  DATA 32,4B
00DB2:  DATA 71,71
00DB4:  DATA 6A,6C
00DB6:  DATA 6D,59
00DB8:  DATA 41,56
00DBA:  DATA 38,2B
00DBC:  DATA 66,38
00DBE:  DATA 45,70
00DC0:  DATA 50,2B
00DC2:  DATA 43,69
00DC4:  DATA 6B,33
00DC6:  DATA 2F,42
00DC8:  DATA 51,2F
00DCA:  DATA 77,6A
00DCC:  DATA 38,52
00DCE:  DATA 4E,59
00DD0:  DATA 76,4C
00DD2:  DATA 47,44
00DD4:  DATA 53,48
00DD6:  DATA 30,44
00DD8:  DATA 78,49
00DDA:  DATA 62,66
00DDC:  DATA 54,37
00DDE:  DATA 43,4D
00DE0:  DATA 6C,70
00DE2:  DATA 4C,66
00DE4:  DATA 54,5A
00DE6:  DATA 49,49
00DE8:  DATA 20,0A
00DEA:  DATA 7A,62
00DEC:  DATA 6D,56
00DEE:  DATA 73,2F
00DF0:  DATA 4E,4B
00DF2:  DATA 7A,70
00DF4:  DATA 4F,57
00DF6:  DATA 49,77
00DF8:  DATA 4D,38
00DFA:  DATA 44,67
00DFC:  DATA 56,74
00DFE:  DATA 48,44
00E00:  DATA 31,48
00E02:  DATA 53,64
00E04:  DATA 5A,4C
00E06:  DATA 33,55
00E08:  DATA 37,58
00E0A:  DATA 4D,58
00E0C:  DATA 57,67
00E0E:  DATA 71,6E
00E10:  DATA 73,6E
00E12:  DATA 75,7A
00E14:  DATA 36,31
00E16:  DATA 42,79
00E18:  DATA 4B,51
00E1A:  DATA 73,42
00E1C:  DATA 51,4F
00E1E:  DATA 4B,2B
00E20:  DATA 47,66
00E22:  DATA 2B,43
00E24:  DATA 7A,50
00E26:  DATA 2F,42
00E28:  DATA 55,4C
00E2A:  DATA 78,58
00E2C:  DATA 2F,77
00E2E:  DATA 54,72
00E30:  DATA 69,38
00E32:  DATA 41,32
00E34:  DATA 2F,67
00E36:  DATA 20,0A
00E38:  DATA 33,53
00E3A:  DATA 66,44
00E3C:  DATA 47,72
00E3E:  DATA 36,6A
00E40:  DATA 34,73
00E42:  DATA 61,2B
00E44:  DATA 6B,75
00E46:  DATA 6C,31
00E48:  DATA 69,47
00E4A:  DATA 65,5A
00E4C:  DATA 59,49
00E4E:  DATA 6F,50
00E50:  DATA 49,43
00E52:  DATA 6C,52
00E54:  DATA 46,4C
00E56:  DATA 47,63
00E58:  DATA 73,30
00E5A:  DATA 72,64
00E5C:  DATA 53,66
00E5E:  DATA 75,64
00E60:  DATA 4B,4D
00E62:  DATA 50,68
00E64:  DATA 35,31
00E66:  DATA 36,69
00E68:  DATA 70,55
00E6A:  DATA 39,78
00E6C:  DATA 31,71
00E6E:  DATA 30,61
00E70:  DATA 55,48
00E72:  DATA 4F,65
00E74:  DATA 78,39
00E76:  DATA 79,35
00E78:  DATA 33,48
00E7A:  DATA 76,53
00E7C:  DATA 68,73
00E7E:  DATA 64,36
00E80:  DATA 2F,44
00E82:  DATA 50,2F
00E84:  DATA 20,0A
00E86:  DATA 41,49
00E88:  DATA 69,62
00E8A:  DATA 76,6A
00E8C:  DATA 6A,2F
00E8E:  DATA 41,4E
00E90:  DATA 43,66
00E92:  DATA 38,4B
00E94:  DATA 2F,2F
00E96:  DATA 41,41
00E98:  DATA 41,76
00E9A:  DATA 38,2F
00E9C:  DATA 38,41
00E9E:  DATA 70,58
00EA0:  DATA 58,36
00EA2:  DATA 6F,2F
00EA4:  DATA 38,41
00EA6:  DATA 42,4E
00EA8:  DATA 62,39
00EAA:  DATA 70,48
00EAC:  DATA 78,5A
00EAE:  DATA 2B,31
00EB0:  DATA 33,2B
00EB2:  DATA 78,33
00EB4:  DATA 34,58
00EB6:  DATA 2B,49
00EB8:  DATA 6E,6A
00EBA:  DATA 4C,54
00EBC:  DATA 39,46
00EBE:  DATA 30,76
00EC0:  DATA 56,76
00EC2:  DATA 45,6A
00EC4:  DATA 33,54
00EC6:  DATA 72,62
00EC8:  DATA 61,58
00ECA:  DATA 46,4C
00ECC:  DATA 46,62
00ECE:  DATA 70,44
00ED0:  DATA 48,63
00ED2:  DATA 20,0A
00ED4:  DATA 79,77
00ED6:  DATA 6F,64
00ED8:  DATA 73,6A
00EDA:  DATA 75,32
00EDC:  DATA 57,45
00EDE:  DATA 65,37
00EE0:  DATA 4F,34
00EE2:  DATA 67,67
00EE4:  DATA 6A,70
00EE6:  DATA 58,5A
00EE8:  DATA 6A,4D
00EEA:  DATA 70,78
00EEC:  DATA 4F,46
00EEE:  DATA 69,70
00EF0:  DATA 31,6B
00EF2:  DATA 6B,6E
00EF4:  DATA 70,75
00EF6:  DATA 63,32
00EF8:  DATA 48,7A
00EFA:  DATA 43,6C
00EFC:  DATA 58,6C
00EFE:  DATA 79,30
00F00:  DATA 7A,33
00F02:  DATA 72,31
00F04:  DATA 35,6F
00F06:  DATA 43,35
00F08:  DATA 72,34
00F0A:  DATA 58,2F
00F0C:  DATA 41,4F
00F0E:  DATA 43,79
00F10:  DATA 2F,77
00F12:  DATA 44,77
00F14:  DATA 56,47
00F16:  DATA 38,57
00F18:  DATA 2F,77
00F1A:  DATA 44,42
00F1C:  DATA 4F,63
00F1E:  DATA 65,41
00F20:  DATA 20,0A
00F22:  DATA 4C,58
00F24:  DATA 77,66
00F26:  DATA 70,50
00F28:  DATA 68,6E
00F2A:  DATA 57,4E
00F2C:  DATA 51,38
00F2E:  DATA 56,66
00F30:  DATA 62,70
00F32:  DATA 72,74
00F34:  DATA 64,59
00F36:  DATA 67,6E
00F38:  DATA 6B,57
00F3A:  DATA 43,4B
00F3C:  DATA 44,79
00F3E:  DATA 41,6D
00F40:  DATA 77,52
00F42:  DATA 53,78
00F44:  DATA 6B,46
00F46:  DATA 6D,6C
00F48:  DATA 62,4F
00F4A:  DATA 53,66
00F4C:  DATA 75,64
00F4E:  DATA 71,2B
00F50:  DATA 48,66
00F52:  DATA 2B,49
00F54:  DATA 6D,37
00F56:  DATA 34,35
00F58:  DATA 44,2F
00F5A:  DATA 41,4A
00F5C:  DATA 6B,2F
00F5E:  DATA 34,56
00F60:  DATA 66,2B
00F62:  DATA 41,46
00F64:  DATA 2F,2F
00F66:  DATA 41,50
00F68:  DATA 4A,6C
00F6A:  DATA 61,59
00F6C:  DATA 58,4A
00F6E:  DATA 20,0A
00F70:  DATA 63,58
00F72:  DATA 58,70
00F74:  DATA 71,72
00F76:  DATA 54,57
00F78:  DATA 6A,38
00F7A:  DATA 79,61
00F7C:  DATA 2B,61
00F7E:  DATA 55,4B
00F80:  DATA 55,2B
00F82:  DATA 53,62
00F84:  DATA 31,50
00F86:  DATA 33,4D
00F88:  DATA 6F,72
00F8A:  DATA 38,4D
00F8C:  DATA 2F,77
00F8E:  DATA 44,69
00F90:  DATA 4A,77
00F92:  DATA 2B,4F
00F94:  DATA 50,2F
00F96:  DATA 51,6E
00F98:  DATA 66,43
00F9A:  DATA 72,2F
00F9C:  DATA 41,4D
00F9E:  DATA 41,4C
00FA0:  DATA 2F,77
00FA2:  DATA 44,2B
00FA4:  DATA 54,4B
00FA6:  DATA 50,2B
00FA8:  DATA 49,6E
00FAA:  DATA 44,34
00FAC:  DATA 35,66
00FAE:  DATA 38,41
00FB0:  DATA 51,6E
00FB2:  DATA 66,43
00FB4:  DATA 72,2F
00FB6:  DATA 77,41
00FB8:  DATA 76,2F
00FBA:  DATA 38,41
00FBC:  DATA 20,0A
00FBE:  DATA 35,4D
00FC0:  DATA 72,62
00FC2:  DATA 2F,56
00FC4:  DATA 76,48
00FC6:  DATA 66,79
00FC8:  DATA 72,37
00FCA:  DATA 30,59
00FCC:  DATA 2F,32
00FCE:  DATA 31,68
00FD0:  DATA 65,2F
00FD2:  DATA 34,48
00FD4:  DATA 37,6C
00FD6:  DATA 48,35
00FD8:  DATA 66,7A
00FDA:  DATA 6F,4A
00FDC:  DATA 7A,33
00FDE:  DATA 72,38
00FE0:  DATA 35,2F
00FE2:  DATA 2B,43
00FE4:  DATA 51,48
00FE6:  DATA 2F,42
00FE8:  DATA 57,6A
00FEA:  DATA 34,70
00FEC:  DATA 66,38
00FEE:  DATA 46,44
00FF0:  DATA 66,6A
00FF2:  DATA 33,34
00FF4:  DATA 69,38
00FF6:  DATA 50,2B
00FF8:  DATA 4B,76
00FFA:  DATA 44,76
00FFC:  DATA 67,6E
00FFE:  DATA 53,39
01000:  DATA 41,30
01002:  DATA 48,51
01004:  DATA 6D,31
01006:  DATA 42,37
01008:  DATA 6A,53
0100A:  DATA 20,0A
0100C:  DATA 4C,57
0100E:  DATA 36,6A
01010:  DATA 75,44
01012:  DATA 63,47
01014:  DATA 65,4B
01016:  DATA 4F,4A
01018:  DATA 43,5A
0101A:  DATA 5A,35
0101C:  DATA 46,32
0101E:  DATA 6C,57
01020:  DATA 6C,50
01022:  DATA 54,50
01024:  DATA 79,44
01026:  DATA 33,72
01028:  DATA 77,76
0102A:  DATA 38,41
0102C:  DATA 61,73
0102E:  DATA 2F,34
01030:  DATA 4F,4A
01032:  DATA 76,69
01034:  DATA 70,38
01036:  DATA 49,50
01038:  DATA 32,6C
0103A:  DATA 2F,48
0103C:  DATA 76,68
0103E:  DATA 4C,77
01040:  DATA 7A,34
01042:  DATA 58,2B
01044:  DATA 48,64
01046:  DATA 35,6F
01048:  DATA 50,68
0104A:  DATA 66,58
0104C:  DATA 62,7A
0104E:  DATA 52,37
01050:  DATA 53,65
01052:  DATA 2B,74
01054:  DATA 4C,79
01056:  DATA 53,34
01058:  DATA 20,0A
0105A:  DATA 6E,57
0105C:  DATA 33,6D
0105E:  DATA 61,49
01060:  DATA 75,37
01062:  DATA 4A,63
01064:  DATA 71,70
01066:  DATA 79,55
01068:  DATA 4A,47
0106A:  DATA 46,48
0106C:  DATA 42,48
0106E:  DATA 57,75
01070:  DATA 65,4F
01072:  DATA 53,34
01074:  DATA 6D,56
01076:  DATA 5A,30
01078:  DATA 55,76
0107A:  DATA 65,53
0107C:  DATA 75,39
0107E:  DATA 65,35
01080:  DATA 74,4C
01082:  DATA 4D,71
01084:  DATA 4B,70
01086:  DATA 71,72
01088:  DATA 66,52
0108A:  DATA 6E,37
0108C:  DATA 48,44
0108E:  DATA 70,52
01090:  DATA 58,34
01092:  DATA 5A,2F
01094:  DATA 38,41
01096:  DATA 45,54
01098:  DATA 66,38
0109A:  DATA 63,76
0109C:  DATA 38,41
0109E:  DATA 6F,54
010A0:  DATA 76,68
010A2:  DATA 56,2F
010A4:  DATA 34,41
010A6:  DATA 20,0A
010A8:  DATA 58,2F
010AA:  DATA 38,41
010AC:  DATA 38,6D
010AE:  DATA 55,66
010B0:  DATA 38,52
010B2:  DATA 4F,48
010B4:  DATA 78,79
010B6:  DATA 2F,36
010B8:  DATA 45,37
010BA:  DATA 34,56
010BC:  DATA 66,2B
010BE:  DATA 41,46
010C0:  DATA 2F,77
010C2:  DATA 44,2F
010C4:  DATA 41,43
010C6:  DATA 5A,58
010C8:  DATA 52,2F
010CA:  DATA 71,33
010CC:  DATA 6A,76
010CE:  DATA 35,56
010D0:  DATA 39,36
010D2:  DATA 4D,2F
010D4:  DATA 37,59
010D6:  DATA 77,33
010D8:  DATA 64,2F
010DA:  DATA 63,66
010DC:  DATA 75,55
010DE:  DATA 44,38
010E0:  DATA 31,4B
010E2:  DATA 47,79
010E4:  DATA 61,2F
010E6:  DATA 44,4D
010E8:  DATA 2F,77
010EA:  DATA 44,42
010EC:  DATA 7A,5A
010EE:  DATA 38,63
010F0:  DATA 4E,33
010F2:  DATA 2F,49
010F4:  DATA 20,0A
010F6:  DATA 6E,66
010F8:  DATA 43,76
010FA:  DATA 6E,2F
010FC:  DATA 70,77
010FE:  DATA 76,2F
01100:  DATA 38,41
01102:  DATA 35,4D
01104:  DATA 72,39
01106:  DATA 73,50
01108:  DATA 68,72
0110A:  DATA 71,75
0110C:  DATA 71,61
0110E:  DATA 7A,38
01110:  DATA 4F,74
01112:  DATA 41,76
01114:  DATA 4E,64
01116:  DATA 68,74
01118:  DATA 37,58
0111A:  DATA 57,37
0111C:  DATA 72,54
0111E:  DATA 72,65
01120:  DATA 58,55
01122:  DATA 49,6F
01124:  DATA 46,5A
01126:  DATA 59,59
01128:  DATA 72,68
0112A:  DATA 6F,6C
0112C:  DATA 4D,69
0112E:  DATA 6F,47
01130:  DATA 4C,45
01132:  DATA 4B,48
01134:  DATA 4C,41
01136:  DATA 41,73
01138:  DATA 54,6A
0113A:  DATA 47,53
0113C:  DATA 65,74
0113E:  DATA 63,4F
01140:  DATA 4D,79
01142:  DATA 20,0A
01144:  DATA 32,74
01146:  DATA 68,55
01148:  DATA 6E,57
0114A:  DATA 56,72
0114C:  DATA 2B,64
0114E:  DATA 7A,70
01150:  DATA 77,32
01152:  DATA 4E,70
01154:  DATA 31,32
01156:  DATA 31,54
01158:  DATA 36,47
0115A:  DATA 33,33
0115C:  DATA 37,30
0115E:  DATA 45,34
01160:  DATA 72,50
01162:  DATA 38,41
01164:  DATA 46,50
01166:  DATA 69,33
01168:  DATA 53,76
0116A:  DATA 41,6E
0116C:  DATA 68,36
0116E:  DATA 38,31
01170:  DATA 66,57
01172:  DATA 74,53
01174:  DATA 73,64
01176:  DATA 49,30
01178:  DATA 6E,54
0117A:  DATA 34,6A
0117C:  DATA 4E,64
0117E:  DATA 58,6C
01180:  DATA 37,63
01182:  DATA 4C,62
01184:  DATA 32,39
01186:  DATA 73,67
01188:  DATA 36,73
0118A:  DATA 37,75
0118C:  DATA 51,71
0118E:  DATA 6A,33
01190:  DATA 20,0A
01192:  DATA 4A,72
01194:  DATA 38,2B
01196:  DATA 66,32
01198:  DATA 71,2F
0119A:  DATA 2B,44
0119C:  DATA 6A,76
0119E:  DATA 34,56
011A0:  DATA 66,43
011A2:  DATA 47,39
011A4:  DATA 75,4E
011A6:  DATA 4D,2B
011A8:  DATA 48,75
011AA:  DATA 6B,36
011AC:  DATA 68,38
011AE:  DATA 54,4E
011B0:  DATA 54,68
011B2:  DATA 4A,55
011B4:  DATA 33,53
011B6:  DATA 53,48
011B8:  DATA 54,39
011BA:  DATA 4C,55
011BC:  DATA 39,4F
011BE:  DATA 4A,58
011C0:  DATA 52,70
011C2:  DATA 4A,4D
011C4:  DATA 48,2B
011C6:  DATA 37,48
011C8:  DATA 74,49
011CA:  DATA 36,4F
011CC:  DATA 51,63
011CE:  DATA 31,6A
011D0:  DATA 68,73
011D2:  DATA 44,57
011D4:  DATA 78,45
011D6:  DATA 75,57
011D8:  DATA 6C,47
011DA:  DATA 35,64
011DC:  DATA 66,46
011DE:  DATA 20,0A
011E0:  DATA 55,71
011E2:  DATA 4B,76
011E4:  DATA 55,64
011E6:  DATA 6A,39
011E8:  DATA 46,76
011EA:  DATA 4D,78
011EC:  DATA 2F,53
011EE:  DATA 67,6B
011F0:  DATA 59,72
011F2:  DATA 38,44
011F4:  DATA 2F,69
011F6:  DATA 6E,2F
011F8:  DATA 41,4D
011FA:  DATA 48,47
011FC:  DATA 58,37
011FE:  DATA 51,58
01200:  DATA 6A,69
01202:  DATA 34,6C
01204:  DATA 2F,73
01206:  DATA 48,2F
01208:  DATA 41,49
0120A:  DATA 52,44
0120C:  DATA 77,58
0120E:  DATA 62,6E
01210:  DATA 49,6A
01212:  DATA 46,6A
01214:  DATA 70,51
01216:  DATA 75,70
01218:  DATA 6C,48
0121A:  DATA 2B,30
0121C:  DATA 31,79
0121E:  DATA 30,71
01220:  DATA 73,66
01222:  DATA 63,49
01224:  DATA 6F,39
01226:  DATA 71,39
01228:  DATA 57,2F
0122A:  DATA 34,4A
0122C:  DATA 20,0A
0122E:  DATA 48,2F
01230:  DATA 38,41
01232:  DATA 42,54
01234:  DATA 6A,39
01236:  DATA 6F,7A
01238:  DATA 39,72
0123A:  DATA 66,39
0123C:  DATA 75,37
0123E:  DATA 77,72
01240:  DATA 34,52
01242:  DATA 38,56
01244:  DATA 66,45
01246:  DATA 47,54
01248:  DATA 56,2F
0124A:  DATA 43,73
0124C:  DATA 6B,46
0124E:  DATA 35,65
01250:  DATA 61,74
01252:  DATA 61,6A
01254:  DATA 51,39
01256:  DATA 4E,67
01258:  DATA 33,78
0125A:  DATA 52,57
0125C:  DATA 30,68
0125E:  DATA 51,62
01260:  DATA 34,34
01262:  DATA 46,64
01264:  DATA 66,33
01266:  DATA 78,68
01268:  DATA 79,56
0126A:  DATA 49,4F
0126C:  DATA 47,39
0126E:  DATA 4B,39
01270:  DATA 57,74
01272:  DATA 77,37
01274:  DATA 69,61
01276:  DATA 56,4A
01278:  DATA 31,71
0127A:  DATA 20,0A
0127C:  DATA 6A,53
0127E:  DATA 55,56
01280:  DATA 66,64
01282:  DATA 33,2F
01284:  DATA 41,43
01286:  DATA 73,63
01288:  DATA 4D,4D
0128A:  DATA 34,6F
0128C:  DATA 7A,71
0128E:  DATA 4B,6E
01290:  DATA 42,4F
01292:  DATA 37,2F
01294:  DATA 41,4B
01296:  DATA 37,6E
01298:  DATA 37,4F
0129A:  DATA 44,70
0129C:  DATA 52,53
0129E:  DATA 4C,77
012A0:  DATA 74,4A
012A2:  DATA 4A,4D
012A4:  DATA 73,53
012A6:  DATA 4D,7A
012A8:  DATA 4D,71
012AA:  DATA 71,6F
012AC:  DATA 79,78
012AE:  DATA 50,51
012B0:  DATA 44,31
012B2:  DATA 72,77
012B4:  DATA 6A,31
012B6:  DATA 68,31
012B8:  DATA 46,5A
012BA:  DATA 66,2F
012BC:  DATA 41,41
012BE:  DATA 6E,47
012C0:  DATA 69,2F
012C2:  DATA 38,41
012C4:  DATA 51,59
012C6:  DATA 30,76
012C8:  DATA 20,0A
012CA:  DATA 2F,77
012CC:  DATA 41,43
012CE:  DATA 6F,2F
012D0:  DATA 38,41
012D2:  DATA 47,6A
012D4:  DATA 2F,68
012D6:  DATA 4F,4E
012D8:  DATA 46,2F
012DA:  DATA 36,44
012DC:  DATA 47,6C
012DE:  DATA 2F,77
012E0:  DATA 44,67
012E2:  DATA 56,48
012E4:  DATA 2F,6A
012E6:  DATA 51,42
012E8:  DATA 71,55
012EA:  DATA 56,6C
012EC:  DATA 2F,38
012EE:  DATA 4A,78
012F0:  DATA 6F,76
012F2:  DATA 2F,51
012F4:  DATA 59,30
012F6:  DATA 76,2F
012F8:  DATA 77,4B
012FA:  DATA 6A,2F
012FC:  DATA 78,6F
012FE:  DATA 2F,77
01300:  DATA 43,45
01302:  DATA 34,30
01304:  DATA 58,2F
01306:  DATA 41,4B
01308:  DATA 44,47
0130A:  DATA 6C,2F
0130C:  DATA 38,41
0130E:  DATA 67,56
01310:  DATA 48,2F
01312:  DATA 41,49
01314:  DATA 30,41
01316:  DATA 20,0A
01318:  DATA 61,6C
0131A:  DATA 46,5A
0131C:  DATA 66,2F
0131E:  DATA 43,63
01320:  DATA 61,4C
01322:  DATA 2F,30
01324:  DATA 47,4E
01326:  DATA 4C,2F
01328:  DATA 41,50
0132A:  DATA 41,71
0132C:  DATA 50,2F
0132E:  DATA 47,72
01330:  DATA 6D,6E
01332:  DATA 61,72
01334:  DATA 61,36
01336:  DATA 76,43
01338:  DATA 30,6C
0133A:  DATA 70,63
0133C:  DATA 51,58
0133E:  DATA 55,61
01340:  DATA 74,74
01342:  DATA 4C,78
01344:  DATA 53,42
01346:  DATA 31,42
01348:  DATA 36,34
0134A:  DATA 79,50
0134C:  DATA 71,4B
0134E:  DATA 41,4C
01350:  DATA 46,46
01352:  DATA 46,46
01354:  DATA 41,42
01356:  DATA 52,52
01358:  DATA 52,51
0135A:  DATA 41,55
0135C:  DATA 55,5A
0135E:  DATA 34,6F
01360:  DATA 7A,51
01362:  DATA 41,68
01364:  DATA 20,0A
01366:  DATA 36,31
01368:  DATA 6D,2B
0136A:  DATA 4B,66
0136C:  DATA 45,32
0136E:  DATA 6E,2B
01370:  DATA 43,66
01372:  DATA 44,75
01374:  DATA 6F,61
01376:  DATA 78,72
01378:  DATA 46,39
0137A:  DATA 61,36
0137C:  DATA 62,70
0137E:  DATA 4F,6C
01380:  DATA 32,37
01382:  DATA 33,56
01384:  DATA 35,64
01386:  DATA 33,4D
01388:  DATA 6F,69
0138A:  DATA 68,74
0138C:  DATA 6F,6B
0138E:  DATA 42,5A
01390:  DATA 33,64
01392:  DATA 6A,77
01394:  DATA 71,71
01396:  DATA 6F,4A
01398:  DATA 4A,4A
0139A:  DATA 78,57
0139C:  DATA 69,30
0139E:  DATA 69,71
013A0:  DATA 75,35
013A2:  DATA 6A,67
013A4:  DATA 44,75
013A6:  DATA 65,31
013A8:  DATA 66,6B
013AA:  DATA 46,2F
013AC:  DATA 77,55
013AE:  DATA 78,2F
013B0:  DATA 61,6F
013B2:  DATA 20,0A
013B4:  DATA 2B,4A
013B6:  DATA 33,2F
013B8:  DATA 41,41
013BA:  DATA 56,49
013BC:  DATA 2B,4A
013BE:  DATA 64,39
013C0:  DATA 38,45
013C2:  DATA 2F,32
013C4:  DATA 65,4E
013C6:  DATA 44,31
013C8:  DATA 62,78
013CA:  DATA 46,34
013CC:  DATA 44,30
013CE:  DATA 4F,36
013D0:  DATA 38,76
013D2:  DATA 58,64
013D4:  DATA 5A,73
013D6:  DATA 54,35
013D8:  DATA 64,6A
013DA:  DATA 72,46
013DC:  DATA 30,68
013DE:  DATA 44,62
013E0:  DATA 58,75
013E2:  DATA 57,4B
013E4:  DATA 78,4A
013E6:  DATA 62,52
013E8:  DATA 73,50
013EA:  DATA 6C,79
013EC:  DATA 2F,77
013EE:  DATA 43,39
013F0:  DATA 63,62
013F2:  DATA 67,47
013F4:  DATA 43,6F
013F6:  DATA 54,32
013F8:  DATA 59,48
013FA:  DATA 42,75
013FC:  DATA 76,55
013FE:  DATA 35,4C
01400:  DATA 20,0A
01402:  DATA 32,6A
01404:  DATA 31,62
01406:  DATA 36,49
01408:  DATA 35,73
0140A:  DATA 56,69
0140C:  DATA 46,53
0140E:  DATA 6A,7A
01410:  DATA 57,75
01412:  DATA 2B,69
01414:  DATA 38,7A
01416:  DATA 35,63
01418:  DATA 2F,34
0141A:  DATA 4B,38
0141C:  DATA 2F,38
0141E:  DATA 46,52
01420:  DATA 4C,2F
01422:  DATA 41,50
01424:  DATA 62,37
01426:  DATA 2B,4B
01428:  DATA 71,36
0142A:  DATA 52,6F
0142C:  DATA 4D,31
0142E:  DATA 7A,5A
01430:  DATA 2F,43
01432:  DATA 2F,77
01434:  DATA 41,4D
01436:  DATA 7A,74
01438:  DATA 2F,59
0143A:  DATA 39,6F
0143C:  DATA 77,4D
0143E:  DATA 62,61
01440:  DATA 70,4C
01442:  DATA 79,72
01444:  DATA 58,30
01446:  DATA 79,48
01448:  DATA 6E,63
0144A:  DATA 51,53
0144C:  DATA 45,55
0144E:  DATA 20,0A
01450:  DATA 6A,4B
01452:  DATA 49,78
01454:  DATA 34,44
01456:  DATA 4D,34
01458:  DATA 50,73
0145A:  DATA 48,2F
0145C:  DATA 41,41
0145E:  DATA 62,4D
01460:  DATA 2F,46
01462:  DATA 35,76
01464:  DATA 43,6E
01466:  DATA 37,56
01468:  DATA 2F,6A
0146A:  DATA 4C,77
0146C:  DATA 5A,4A
0146E:  DATA 49,49
01470:  DATA 37,58
01472:  DATA 78,64
01474:  DATA 34,66
01476:  DATA 46,32
01478:  DATA 69,59
0147A:  DATA 2F,31
0147C:  DATA 6C,78
0147E:  DATA 5A,7A
01480:  DATA 41,6F
01482:  DATA 50,2B
01484:  DATA 2F,64
01486:  DATA 78,4F
01488:  DATA 66,54
0148A:  DATA 6A,36
0148C:  DATA 56,36
0148E:  DATA 42,2B
01490:  DATA 7A,78
01492:  DATA 2F,77
01494:  DATA 62,51
01496:  DATA 52,61
01498:  DATA 66,70
0149A:  DATA 63,65
0149C:  DATA 20,0A
0149E:  DATA 73,66
014A0:  DATA 47,62
014A2:  DATA 34,69
014A4:  DATA 51,36
014A6:  DATA 66,43
014A8:  DATA 67,45
014AA:  DATA 6C,78
014AC:  DATA 70,66
014AE:  DATA 68,37
014B0:  DATA 61,71
014B2:  DATA 78,4C
014B4:  DATA 36,50
014B6:  DATA 64,7A
014B8:  DATA 44,41
014BA:  DATA 50,59
014BC:  DATA 67,52
014BE:  DATA 45,5A
014C0:  DATA 36,4E
014C2:  DATA 33,72
014C4:  DATA 36,4B
014C6:  DATA 2B,45
014C8:  DATA 58,68
014CA:  DATA 50,39
014CC:  DATA 6A,58
014CE:  DATA 2F,67
014D0:  DATA 6E,76
014D2:  DATA 34,67
014D4:  DATA 68,31
014D6:  DATA 54,77
014D8:  DATA 64,61
014DA:  DATA 57,65
014DC:  DATA 6F,65
014DE:  DATA 4C,62
014E0:  DATA 46,48
014E2:  DATA 57,50
014E4:  DATA 55,62
014E6:  DATA 61,61
014E8:  DATA 66,56
014EA:  DATA 20,0A
014EC:  DATA 72,77
014EE:  DATA 37,6B
014F0:  DATA 61,4E
014F2:  DATA 39,73
014F4:  DATA 70,59
014F6:  DATA 77,78
014F8:  DATA 37,6C
014FA:  DATA 4A,55
014FC:  DATA 68,43
014FE:  DATA 67,4F
01500:  DATA 54,78
01502:  DATA 79,61
01504:  DATA 39,76
01506:  DATA 4E,2B
01508:  DATA 49,73
0150A:  DATA 6E,77
0150C:  DATA 65,43
0150E:  DATA 65,46
01510:  DATA 55,30
01512:  DATA 6C,62
01514:  DATA 66,52
01516:  DATA 4B,2F
01518:  DATA 66,58
0151A:  DATA 63,2B
0151C:  DATA 63,6A
0151E:  DATA 47,70
01520:  DATA 54,72
01522:  DATA 4C,45
01524:  DATA 34,75
01526:  DATA 61,68
01528:  DATA 36,74
0152A:  DATA 66,63
0152C:  DATA 66,65
0152E:  DATA 6F,4F
01530:  DATA 32,76
01532:  DATA 77,6F
01534:  DATA 2F,77
01536:  DATA 43,44
01538:  DATA 20,0A
0153A:  DATA 6C,50
0153C:  DATA 34,6B
0153E:  DATA 66,38
01540:  DATA 4A,56
01542:  DATA 2B,33
01544:  DATA 50,6F
01546:  DATA 65,67
01548:  DATA 52,79
0154A:  DATA 62,6F
0154C:  DATA 66,43
0154E:  DATA 2F,68
01550:  DATA 65,33
01552:  DATA 69,6B
01554:  DATA 51,48
01556:  DATA 6C,4A
01558:  DATA 35,35
0155A:  DATA 70,70
0155C:  DATA 57,50
0155E:  DATA 34,78
01560:  DATA 6D,43
01562:  DATA 76,31
01564:  DATA 68,2F
01566:  DATA 5A,66
01568:  DATA 38,41
0156A:  DATA 32,37
0156C:  DATA 4E,45
0156E:  DATA 2F,61
01570:  DATA 74,38
01572:  DATA 64,61
01574:  DATA 74,70
01576:  DATA 4F,67
01578:  DATA 36,4C
0157A:  DATA 71,39
0157C:  DATA 6E,62
0157E:  DATA 61,56
01580:  DATA 61,43
01582:  DATA 36,65
01584:  DATA 35,76
01586:  DATA 20,0A
01588:  DATA 6A,45
0158A:  DATA 6A,4D
0158C:  DATA 53,34
0158E:  DATA 55,4B
01590:  DATA 45,52
01592:  DATA 6D,50
01594:  DATA 50,4A
01596:  DATA 7A,6E
01598:  DATA 74,58
0159A:  DATA 34,4F
0159C:  DATA 2F,77
0159E:  DATA 44,42
015A0:  DATA 58,54
015A2:  DATA 34,6C
015A4:  DATA 66,38
015A6:  DATA 4C,58
015A8:  DATA 2F,77
015AA:  DATA 43,43
015AC:  DATA 6B,48
015AE:  DATA 78,63
015B0:  DATA 31,4A
015B2:  DATA 5A,50
015B4:  DATA 4D,57
015B6:  DATA 31,31
015B8:  DATA 74,74
015BA:  DATA 4A,54
015BC:  DATA 48,51
015BE:  DATA 43,79
015C0:  DATA 6A,53
015C2:  DATA 30,34
015C4:  DATA 2F,47
015C6:  DATA 41,2F
015C8:  DATA 58,4A
015CA:  DATA 4E,63
015CC:  DATA 66,42
015CE:  DATA 64,61
015D0:  DATA 6C,6A
015D2:  DATA 4B,2F
015D4:  DATA 20,0A
015D6:  DATA 31,69
015D8:  DATA 68,4C
015DA:  DATA 6D,69
015DC:  DATA 6B,39
015DE:  DATA 56,39
015E0:  DATA 78,31
015E2:  DATA 5A,70
015E4:  DATA 6A,61
015E6:  DATA 56,62
015E8:  DATA 43,71
015EA:  DATA 64,46
015EC:  DATA 38,79
015EE:  DATA 62,2F
015F0:  DATA 49,2B
015F2:  DATA 63,67
015F4:  DATA 4F,50
015F6:  DATA 30,77
015F8:  DATA 4B,2F
015FA:  DATA 71,4B
015FC:  DATA 2F,59
015FE:  DATA 49,2B
01600:  DATA 48,48
01602:  DATA 2F,43
01604:  DATA 70,66
01606:  DATA 32,4B
01608:  DATA 76,68
0160A:  DATA 54,34
0160C:  DATA 65,61
0160E:  DATA 4C,79
01610:  DATA 5A,74
01612:  DATA 4F,38
01614:  DATA 4B,36
01616:  DATA 65,4C
01618:  DATA 6C,66
0161A:  DATA 53,64
0161C:  DATA 72,64
0161E:  DATA 48,6D
01620:  DATA 2F,38
01622:  DATA 20,0A
01624:  DATA 69,4D
01626:  DATA 35,72
01628:  DATA 2B,5A
0162A:  DATA 2F,34
0162C:  DATA 46,66
0162E:  DATA 44,78
01630:  DATA 76,69
01632:  DATA 37,38
01634:  DATA 62,2F
01636:  DATA 42,76
01638:  DATA 68,53
0163A:  DATA 50,64
0163C:  DATA 75,38
0163E:  DATA 54,61
01640:  DATA 37,5A
01642:  DATA 61,53
01644:  DATA 4D,64
01646:  DATA 66,33
01648:  DATA 39,77
0164A:  DATA 6B,58
0164C:  DATA 2F,73
0164E:  DATA 39,66
01650:  DATA 31,63
01652:  DATA 57,73
01654:  DATA 43,32
01656:  DATA 73,45
01658:  DATA 63,63
0165A:  DATA 61,71
0165C:  DATA 6B,63
0165E:  DATA 61,68
01660:  DATA 56,56
01662:  DATA 52,67
01664:  DATA 4B,41
01666:  DATA 4D,41
01668:  DATA 43,76
0166A:  DATA 61,34
0166C:  DATA 75,72
0166E:  DATA 66,77
01670:  DATA 20,0A
01672:  DATA 36,66
01674:  DATA 65,37
01676:  DATA 2F,51
01678:  DATA 6A,68
0167A:  DATA 2B,6E
0167C:  DATA 38,55
0167E:  DATA 2F,6B
01680:  DATA 66,68
01682:  DATA 56,2F
01684:  DATA 77,63
01686:  DATA 6A,2B
01688:  DATA 50,70
0168A:  DATA 2F,47
0168C:  DATA 58,37
0168E:  DATA 64,75
01690:  DATA 6C,61
01692:  DATA 48,42
01694:  DATA 35,30
01696:  DATA 6C,74
01698:  DATA 34,55
0169A:  DATA 38,4D
0169C:  DATA 57,30
0169E:  DATA 45,69
016A0:  DATA 4B,70
016A2:  DATA 59,4A
016A4:  DATA 50,4E
016A6:  DATA 4C,4C
016A8:  DATA 4F,35
016AA:  DATA 39,69
016AC:  DATA 59,33
016AE:  DATA 68,7A
016B0:  DATA 37,4B
016B2:  DATA 4B,2F
016B4:  DATA 50,61
016B6:  DATA 65,31
016B8:  DATA 6B,74
016BA:  DATA 67,50
016BC:  DATA 4D,6A
016BE:  DATA 20,0A
016C0:  DATA 65,50
016C2:  DATA 50,54
016C4:  DATA 63,70
016C6:  DATA 58,4E
016C8:  DATA 66,31
016CA:  DATA 77,4D
016CC:  DATA 6D,54
016CE:  DATA 6B,6A
016D0:  DATA 32,7A
016D2:  DATA 36,56
016D4:  DATA 2B,4C
016D6:  DATA 2F,2F
016D8:  DATA 41,41
016DA:  DATA 64,42
016DC:  DATA 2F,45
016DE:  DATA 56,64
016E0:  DATA 52,2B
016E2:  DATA 4F,6E
016E4:  DATA 77,76
016E6:  DATA 38,41
016E8:  DATA 43,61
016EA:  DATA 79,63
016EC:  DATA 36,4C
016EE:  DATA 6F,64
016F0:  DATA 7A,71
016F2:  DATA 37,4B
016F4:  DATA 4F,78
016F6:  DATA 75,35
016F8:  DATA 78,45
016FA:  DATA 44,2F
016FC:  DATA 41,4F
016FE:  DATA 53,66
01700:  DATA 34,66
01702:  DATA 6A,7A
01704:  DATA 57,51
01706:  DATA 35,77
01708:  DATA 35,75
0170A:  DATA 47,44
0170C:  DATA 20,0A
0170E:  DATA 55,4E
01710:  DATA 45,6E
01712:  DATA 72,66
01714:  DATA 38,41
01716:  DATA 34,42
01718:  DATA 4F,61
0171A:  DATA 35,66
0171C:  DATA 79,71
0171E:  DATA 57,49
01720:  DATA 63,76
01722:  DATA 6C,62
01724:  DATA 2F,67
01726:  DATA 6E,35
01728:  DATA 64,31
0172A:  DATA 4A,48
0172C:  DATA 5A,7A
0172E:  DATA 54,4A
01730:  DATA 75,53
01732:  DATA 4B,52
01734:  DATA 6C,7A
01736:  DATA 6A,49
01738:  DATA 55,6B
0173A:  DATA 66,6E
0173C:  DATA 2B,4E
0173E:  DATA 52,6D
01740:  DATA 76,36
01742:  DATA 4F,76
01744:  DATA 38,41
01746:  DATA 67,69
01748:  DATA 70,38
0174A:  DATA 4D,76
0174C:  DATA 38,41
0174E:  DATA 68,57
01750:  DATA 66,2F
01752:  DATA 41,41
01754:  DATA 54,4F
01756:  DATA 2B,47
01758:  DATA 4D,45
0175A:  DATA 20,0A
0175C:  DATA 6B,65
0175E:  DATA 79,34
01760:  DATA 31,61
01762:  DATA 7A,6E
01764:  DATA 31,69
01766:  DATA 56,73
01768:  DATA 59,38
0176A:  DATA 7A,37
0176C:  DATA 54,63
0176E:  DATA 79,7A
01770:  DATA 52,6E
01772:  DATA 2F,76
01774:  DATA 30,30
01776:  DATA 59,79
01778:  DATA 4F,75
0177A:  DATA 4D,31
0177C:  DATA 37,57
0177E:  DATA 62,5A
01780:  DATA 6E,39
01782:  DATA 52,70
01784:  DATA 78,6E
01786:  DATA 79,38
01788:  DATA 31,2F
0178A:  DATA 6C,2F
0178C:  DATA 6D,65
0178E:  DATA 5A,6C
01790:  DATA 2B,43
01792:  DATA 65,49
01794:  DATA 71,4F
01796:  DATA 43,64
01798:  DATA 72,48
0179A:  DATA 79,44
0179C:  DATA 2F,77
0179E:  DATA 41,47
017A0:  DATA 31,6E
017A2:  DATA 68,65
017A4:  DATA 50,34
017A6:  DATA 61,2F
017A8:  DATA 20,0A
017AA:  DATA 42,48
017AC:  DATA 34,32
017AE:  DATA 66,45
017B0:  DATA 6A,56
017B2:  DATA 49,5A
017B4:  DATA 6F,62
017B6:  DATA 4F,4B
017B8:  DATA 61,32
017BA:  DATA 74,44
017BC:  DATA 49,79
017BE:  DATA 34,32
017C0:  DATA 4A,5A
017C2:  DATA 32,38
017C4:  DATA 31,78
017C6:  DATA 4E,6A
017C8:  DATA 38,4A
017CA:  DATA 30,4A
017CC:  DATA 2B,67
017CE:  DATA 72,38
017D0:  DATA 6B,2F
017D2:  DATA 46,33
017D4:  DATA 69,61
017D6:  DATA 35,38
017D8:  DATA 61,65
017DA:  DATA 4B,39
017DC:  DATA 55,31
017DE:  DATA 69,38
017E0:  DATA 4F,36
017E2:  DATA 38,31
017E4:  DATA 61,37
017E6:  DATA 6C,76
017E8:  DATA 4A,79
017EA:  DATA 4F,38
017EC:  DATA 6B,6A
017EE:  DATA 6C,32
017F0:  DATA 2F,55
017F2:  DATA 6D,76
017F4:  DATA 36,55
017F6:  DATA 20,0A
017F8:  DATA 50,2B
017FA:  DATA 43,72
017FC:  DATA 50,78
017FE:  DATA 46,2F
01800:  DATA 34,56
01802:  DATA 50,2F
01804:  DATA 41,4D
01806:  DATA 45,36
01808:  DATA 66,69
0180A:  DATA 2F,71
0180C:  DATA 6D,34
0180E:  DATA 78,74
01810:  DATA 4E,34
01812:  DATA 66,6D
01814:  DATA 30,74
01816:  DATA 47,44
01818:  DATA 59,4B
0181A:  DATA 76,65
0181C:  DATA 46,62
0181E:  DATA 52,63
01820:  DATA 66,6A
01822:  DATA 4F,44
01824:  DATA 78,7A
01826:  DATA 36,63
01828:  DATA 31,2F
0182A:  DATA 4D,2F
0182C:  DATA 2F,6E
0182E:  DATA 70,58
01830:  DATA 42,77
01832:  DATA 2F,57
01834:  DATA 2B,73
01836:  DATA 31,4B
01838:  DATA 75,4B
0183A:  DATA 6B,72
0183C:  DATA 63,7A
0183E:  DATA 53,39
01840:  DATA 4C,49
01842:  DATA 37,4D
01844:  DATA 20,0A
01846:  DATA 31,70
01848:  DATA 2B,78
0184A:  DATA 68,43
0184C:  DATA 67,74
0184E:  DATA 62,44
01850:  DATA 6F,59
01852:  DATA 48,75
01854:  DATA 44,2B
01856:  DATA 37,52
01858:  DATA 6E,78
0185A:  DATA 79,64
0185C:  DATA 6F,7A
0185E:  DATA 69,70
01860:  DATA 50,37
01862:  DATA 4E,75
01864:  DATA 50,2B
01866:  DATA 66,65
01868:  DATA 66,2F
0186A:  DATA 41,4C
0186C:  DATA 39,6D
0186E:  DATA 76,30
01870:  DATA 70,2F
01872:  DATA 34,4E
01874:  DATA 6A,50
01876:  DATA 68,77
01878:  DATA 32,74
0187A:  DATA 66,74
0187C:  DATA 53,66
0187E:  DATA 45,44
01880:  DATA 78,55
01882:  DATA 30,65
01884:  DATA 36,4C
01886:  DATA 51,50
01888:  DATA 44,53
0188A:  DATA 36,65
0188C:  DATA 47,49
0188E:  DATA 34,53
01890:  DATA 53,36
01892:  DATA 20,0A
01894:  DATA 75,59
01896:  DATA 33,55
01898:  DATA 35,37
0189A:  DATA 48,62
0189C:  DATA 62,53
0189E:  DATA 59,37
018A0:  DATA 45,46
018A2:  DATA 71,2B
018A4:  DATA 35,66
018A6:  DATA 48,48
018A8:  DATA 2F,42
018AA:  DATA 59,50
018AC:  DATA 53,2F
018AE:  DATA 42,6E
018B0:  DATA 6A,6A
018B2:  DATA 57,64
018B4:  DATA 49,6A
018B6:  DATA 38,45
018B8:  DATA 33,6C
018BA:  DATA 37,48
018BC:  DATA 70,64
018BE:  DATA 39,4E
018C0:  DATA 5A,72
018C2:  DATA 63,4C
018C4:  DATA 71,53
018C6:  DATA 6F,4A
018C8:  DATA 78,48
018CA:  DATA 49,55
018CC:  DATA 44,67
018CE:  DATA 65,57
018D0:  DATA 63,42
018D2:  DATA 73,5A
018D4:  DATA 78,6B
018D6:  DATA 39,65
018D8:  DATA 70,72
018DA:  DATA 7A,65
018DC:  DATA 4A,4F
018DE:  DATA 4F,4D
018E0:  DATA 20,0A
018E2:  DATA 4A,6B
018E4:  DATA 31,56
018E6:  DATA 51,78
018E8:  DATA 4E,6C
018EA:  DATA 66,72
018EC:  DATA 64,36
018EE:  DATA 75,32
018F0:  DATA 31,6B
018F2:  DATA 6D,63
018F4:  DATA 50,73
018F6:  DATA 63,50
018F8:  DATA 53,6F
018FA:  DATA 78,72
018FC:  DATA 59,6D
018FE:  DATA 70,79
01900:  DATA 4B,54
01902:  DATA 73,74
01904:  DATA 4C,6E
01906:  DATA 34,59
01908:  DATA 66,73
0190A:  DATA 70,66
0190C:  DATA 43,69
0190E:  DATA 62,34
01910:  DATA 75,2F
01912:  DATA 74,4F
01914:  DATA 2F,44
01916:  DATA 7A,77
01918:  DATA 75,39
0191A:  DATA 72,4D
0191C:  DATA 38,50
0191E:  DATA 69,44
01920:  DATA 78,4A
01922:  DATA 70,39
01924:  DATA 68,4D
01926:  DATA 44,47
01928:  DATA 78,56
0192A:  DATA 59,35
0192C:  DATA 4C,6D
0192E:  DATA 20,0A
01930:  DATA 4E,58
01932:  DATA 4A,34
01934:  DATA 2B,36
01936:  DATA 45,4C
01938:  DATA 45,2B
0193A:  DATA 77,4E
0193C:  DATA 66,30
0193E:  DATA 6D,2F
01940:  DATA 74,65
01942:  DATA 66,74
01944:  DATA 64,65
01946:  DATA 44,76
01948:  DATA 32,4A
0194A:  DATA 76,67
0194C:  DATA 70,71
0194E:  DATA 48,6A
01950:  DATA 62,78
01952:  DATA 6C,65
01954:  DATA 4E,42
01956:  DATA 5A,57
01958:  DATA 76,37
0195A:  DATA 71,30
0195C:  DATA 74,49
0195E:  DATA 63,4E
01960:  DATA 63,36
01962:  DATA 6E,63
01964:  DATA 45,45
01966:  DATA 70,42
01968:  DATA 43,75
0196A:  DATA 52,6C
0196C:  DATA 32,77
0196E:  DATA 54,6B
01970:  DATA 34,56
01972:  DATA 51,43
01974:  DATA 7A,45
01976:  DATA 41,45
01978:  DATA 31,6B
0197A:  DATA 66,73
0197C:  DATA 20,0A
0197E:  DATA 6E,2F
01980:  DATA 74,59
01982:  DATA 33,66
01984:  DATA 37,54
01986:  DATA 33,68
01988:  DATA 33,55
0198A:  DATA 64,63
0198C:  DATA 6C,38
0198E:  DATA 4A,54
01990:  DATA 65,47
01992:  DATA 50,44
01994:  DATA 39,6A
01996:  DATA 6C,59
01998:  DATA 37,2B
0199A:  DATA 36,76
0199C:  DATA 68,49
0199E:  DATA 74,32
019A0:  DATA 34,79
019A2:  DATA 58,32
019A4:  DATA 44,59
019A6:  DATA 76,79
019A8:  DATA 6F,42
019AA:  DATA 79,2B
019AC:  DATA 63,5A
019AE:  DATA 34,35
019B0:  DATA 77,32
019B2:  DATA 50,77
019B4:  DATA 6A,2F
019B6:  DATA 41,4F
019B8:  DATA 43,73
019BA:  DATA 48,37
019BC:  DATA 65,39
019BE:  DATA 39,2B
019C0:  DATA 33,66
019C2:  DATA 2B,31
019C4:  DATA 42,71
019C6:  DATA 47,6F
019C8:  DATA 57,31
019CA:  DATA 20,0A
019CC:  DATA 31,4D
019CE:  DATA 33,67
019D0:  DATA 66,77
019D2:  DATA 7A,4A
019D4:  DATA 4A,70
019D6:  DATA 33,68
019D8:  DATA 69,31
019DA:  DATA 35,56
019DC:  DATA 42,41
019DE:  DATA 47,41
019E0:  DATA 65,35
019E2:  DATA 4B,2F
019E4:  DATA 33,35
019E6:  DATA 6D,55
019E8:  DATA 4F,54
019EA:  DATA 67,45
019EC:  DATA 4B,49
019EE:  DATA 31,35
019F0:  DATA 32,31
019F2:  DATA 79,34
019F4:  DATA 50,47
019F6:  DATA 52,34
019F8:  DATA 6A,71
019FA:  DATA 51,72
019FC:  DATA 77,56
019FE:  DATA 71,61
01A00:  DATA 58,6E
01A02:  DATA 72,39
01A04:  DATA 36,57
01A06:  DATA 35,36
01A08:  DATA 74,47
01A0A:  DATA 74,53
01A0C:  DATA 77,6D
01A0E:  DATA 47,39
01A10:  DATA 72,53
01A12:  DATA 6C,7A
01A14:  DATA 63,32
01A16:  DATA 32,6C
01A18:  DATA 20,0A
01A1A:  DATA 76,77
01A1C:  DATA 37,47
01A1E:  DATA 50,2B
01A20:  DATA 33,78
01A22:  DATA 2F,77
01A24:  DATA 41,46
01A26:  DATA 4C,50
01A28:  DATA 69,4E
01A2A:  DATA 2B,33
01A2C:  DATA 39,34
01A2E:  DATA 30,6B
01A30:  DATA 6E,38
01A32:  DATA 52,58
01A34:  DATA 7A,61
01A36:  DATA 58,34
01A38:  DATA 56,74
01A3A:  DATA 5A,69
01A3C:  DATA 2B,6C
01A3E:  DATA 2B,47
01A40:  DATA 37,4F
01A42:  DATA 56,68
01A44:  DATA 59,32
01A46:  DATA 61,6A
01A48:  DATA 49,56
01A4A:  DATA 33,48
01A4C:  DATA 48,6E
01A4E:  DATA 54,41
01A50:  DATA 48,6D
01A52:  DATA 52,78
01A54:  DATA 6E,6C
01A56:  DATA 67,6F
01A58:  DATA 52,54
01A5A:  DATA 74,72
01A5C:  DATA 35,34
01A5E:  DATA 2B,36
01A60:  DATA 47,50
01A62:  DATA 34,6B
01A64:  DATA 31,4A
01A66:  DATA 20,0A
01A68:  DATA 59,57
01A6A:  DATA 4D,32
01A6C:  DATA 70,33
01A6E:  DATA 73,4E
01A70:  DATA 72,61
01A72:  DATA 77,79
01A74:  DATA 33,46
01A76:  DATA 78,63
01A78:  DATA 4F,73
01A7A:  DATA 63,55
01A7C:  DATA 55,53
01A7E:  DATA 46,6E
01A80:  DATA 6B,59
01A82:  DATA 6E,41
01A84:  DATA 56,56
01A86:  DATA 48,4A
01A88:  DATA 4A,50
01A8A:  DATA 47,42
01A8C:  DATA 58,37
01A8E:  DATA 4A,66
01A90:  DATA 38,45
01A92:  DATA 31,76
01A94:  DATA 2B,44
01A96:  DATA 66,4C
01A98:  DATA 77,2F
01A9A:  DATA 34,64
01A9C:  DATA 38,4E
01A9E:  DATA 61,62
01AA0:  DATA 34,79
01AA2:  DATA 2B,4F
01AA4:  DATA 31,6D
01AA6:  DATA 32,73
01AA8:  DATA 36,39
01AAA:  DATA 64,4B
01AAC:  DATA 6C,78
01AAE:  DATA 62,2B
01AB0:  DATA 46,52
01AB2:  DATA 4B,55
01AB4:  DATA 20,0A
01AB6:  DATA 73,39
01AB8:  DATA 4F,48
01ABA:  DATA 44,4B
01ABC:  DATA 4C,6F
01ABE:  DATA 6F,63
01AC0:  DATA 7A,53
01AC2:  DATA 64,4D
01AC4:  DATA 78,67
01AC6:  DATA 69,4E
01AC8:  DATA 65,51
01ACA:  DATA 52,4A
01ACC:  DATA 6E,6A
01ACE:  DATA 36,7A
01AD0:  DATA 46,59
01AD2:  DATA 7A,43
01AD4:  DATA 35,64
01AD6:  DATA 52,55
01AD8:  DATA 64,75
01ADA:  DATA 79,57
01ADC:  DATA 2F,39
01ADE:  DATA 65,5A
01AE0:  DATA 35,6C
01AE2:  DATA 47,68
01AE4:  DATA 58,78
01AE6:  DATA 64,56
01AE8:  DATA 74,4F
01AEA:  DATA 37,36
01AEC:  DATA 76,73
01AEE:  DATA 66,6A
01AF0:  DATA 37,34
01AF2:  DATA 58,38
01AF4:  DATA 45,36
01AF6:  DATA 31,34
01AF8:  DATA 34,76
01AFA:  DATA 32,74
01AFC:  DATA 64,46
01AFE:  DATA 30,6A
01B00:  DATA 56,4E
01B02:  DATA 20,0A
01B04:  DATA 59,75
01B06:  DATA 6C,47
01B08:  DATA 34,77
01B0A:  DATA 32,56
01B0C:  DATA 71,39
01B0E:  DATA 78,49
01B10:  DATA 42,2F
01B12:  DATA 75,6F
01B14:  DATA 43,61
01B16:  DATA 2F,55
01B18:  DATA 44,2F
01B1A:  DATA 67,32
01B1C:  DATA 2B,2F
01B1E:  DATA 5A,67
01B20:  DATA 38,56
01B22:  DATA 65,43
01B24:  DATA 2F,77
01B26:  DATA 42,70
01B28:  DATA 62,78
01B2A:  DATA 7A,34
01B2C:  DATA 73,38
01B2E:  DATA 54,65
01B30:  DATA 46,39
01B32:  DATA 65,30
01B34:  DATA 4B,50
01B36:  DATA 54,2F
01B38:  DATA 41,41
01B3A:  DATA 32,6D
01B3C:  DATA 6E,32
01B3E:  DATA 6A,61
01B40:  DATA 6E,70
01B42:  DATA 30,74
01B44:  DATA 6F,4A
01B46:  DATA 57,75
01B48:  DATA 62,68
01B4A:  DATA 48,33
01B4C:  DATA 4A,35
01B4E:  DATA 69,6A
01B50:  DATA 20,0A
01B52:  DATA 64,68
01B54:  DATA 62,59
01B56:  DATA 6A,49
01B58:  DATA 36,42
01B5A:  DATA 76,65
01B5C:  DATA 76,31
01B5E:  DATA 36,38
01B60:  DATA 44,2F
01B62:  DATA 41,41
01B64:  DATA 37,30
01B66:  DATA 48,34
01B68:  DATA 5A,65
01B6A:  DATA 47,34
01B6C:  DATA 4E,48
01B6E:  DATA 38,4E
01B70:  DATA 36,4A
01B72:  DATA 70,4F
01B74:  DATA 67,36
01B76:  DATA 54,61
01B78:  DATA 6A,45
01B7A:  DATA 4E,6C
01B7C:  DATA 70,31
01B7E:  DATA 70,48
01B80:  DATA 61,32
01B82:  DATA 38,58
01B84:  DATA 2B,36
01B86:  DATA 6B,59
01B88:  DATA 43,6A
01B8A:  DATA 38,42
01B8C:  DATA 57,74
01B8E:  DATA 35,65
01B90:  DATA 32,76
01B92:  DATA 6B,38
01B94:  DATA 66,78
01B96:  DATA 4C,4C
01B98:  DATA 45,55
01B9A:  DATA 5A,55
01B9C:  DATA 59,77
01B9E:  DATA 20,0A
01BA0:  DATA 73,6E
01BA2:  DATA 35,2F
01BA4:  DATA 38,41
01BA6:  DATA 39,2F
01BA8:  DATA 43,35
01BAA:  DATA 4F,71
01BAC:  DATA 56,52
01BAE:  DATA 56,48
01BB0:  DATA 4B,37
01BB2:  DATA 52,49
01BB4:  DATA 76,33
01BB6:  DATA 61,38
01BB8:  DATA 70,2F
01BBA:  DATA 62,62
01BBC:  DATA 38,5A
01BBE:  DATA 66,38
01BC0:  DATA 49,4A
01BC2:  DATA 2B,79
01BC4:  DATA 6C,34
01BC6:  DATA 36,76
01BC8:  DATA 76,4D
01BCA:  DATA 38,74
01BCC:  DATA 70,4E
01BCE:  DATA 4C,6B
01BD0:  DATA 73,30
01BD2:  DATA 4F,63
01BD4:  DATA 59,61
01BD6:  DATA 63,69
01BD8:  DATA 41,59
01BDA:  DATA 2F,37
01BDC:  DATA 2B,5A
01BDE:  DATA 2F,43
01BE0:  DATA 76,56
01BE2:  DATA 6C,47
01BE4:  DATA 46,72
01BE6:  DATA 35,52
01BE8:  DATA 2F,77
01BEA:  DATA 43,43
01BEC:  DATA 20,0A
01BEE:  DATA 76,58
01BF0:  DATA 6A,45
01BF2:  DATA 36,4A
01BF4:  DATA 2B,7A
01BF6:  DATA 66,70
01BF8:  DATA 2B,6B
01BFA:  DATA 6F,36
01BFC:  DATA 72,4A
01BFE:  DATA 72,6D
01C00:  DATA 73,78
01C02:  DATA 52,75
01C04:  DATA 70,50
01C06:  DATA 33,6F
01C08:  DATA 6F,30
01C0A:  DATA 64,79
01C0C:  DATA 63,65
01C0E:  DATA 7A,69
01C10:  DATA 50,38
01C12:  DATA 36,2B
01C14:  DATA 5A,50
01C16:  DATA 62,50
01C18:  DATA 7A,55
01C1A:  DATA 42,50
01C1C:  DATA 54,50
01C1E:  DATA 74,31
01C20:  DATA 72,30
01C22:  DATA 44,77
01C24:  DATA 46,2B
01C26:  DATA 79,7A
01C28:  DATA 38,51
01C2A:  DATA 2F,69
01C2C:  DATA 64,34
01C2E:  DATA 64,2F
01C30:  DATA 74,62
01C32:  DATA 51,76
01C34:  DATA 43,75
01C36:  DATA 71,61
01C38:  DATA 68,70
01C3A:  DATA 20,0A
01C3C:  DATA 37,49
01C3E:  DATA 30,73
01C40:  DATA 63,71
01C42:  DATA 37,55
01C44:  DATA 38,39
01C46:  DATA 56,4F
01C48:  DATA 43,59
01C4A:  DATA 77,78
01C4C:  DATA 42,6B
01C4E:  DATA 41,50
01C50:  DATA 48,79
01C52:  DATA 41,38
01C54:  DATA 38,64
01C56:  DATA 61,34
01C58:  DATA 41,4E
01C5A:  DATA 6B,66
01C5C:  DATA 33,75
01C5E:  DATA 2F,50
01C60:  DATA 31,7A
01C62:  DATA 7A,58
01C64:  DATA 30,6E
01C66:  DATA 2B,78
01C68:  DATA 74,38
01C6A:  DATA 4E,39
01C6C:  DATA 63,38
01C6E:  DATA 64,66
01C70:  DATA 46,58
01C72:  DATA 53,2F
01C74:  DATA 47,59
01C76:  DATA 38,53
01C78:  DATA 36,52
01C7A:  DATA 71,33
01C7C:  DATA 69,44
01C7E:  DATA 77,37
01C80:  DATA 47,74
01C82:  DATA 35,70
01C84:  DATA 2F,68
01C86:  DATA 35,4E
01C88:  DATA 20,0A
01C8A:  DATA 58,52
01C8C:  DATA 4E,54
01C8E:  DATA 31,4A
01C90:  DATA 59,6B
01C92:  DATA 77,6C
01C94:  DATA 75,70
01C96:  DATA 50,79
01C98:  DATA 52,52
01C9A:  DATA 42,42
01C9C:  DATA 68,6C
01C9E:  DATA 79,53
01CA0:  DATA 71,63
01CA2:  DATA 62,4F
01CA4:  DATA 34,41
01CA6:  DATA 50,6E
01CA8:  DATA 51,36
01CAA:  DATA 54,65
01CAC:  DATA 44,56
01CAE:  DATA 66,73
01CB0:  DATA 50,32
01CB2:  DATA 61,34
01CB4:  DATA 2B,33
01CB6:  DATA 65,62
01CB8:  DATA 39,6E
01CBA:  DATA 2B,7A
01CBC:  DATA 37,47
01CBE:  DATA 38,33
01CC0:  DATA 7A,4D
01CC2:  DATA 37,64
01CC4:  DATA 6D,33
01CC6:  DATA 47,64
01CC8:  DATA 32,65
01CCA:  DATA 4D,59
01CCC:  DATA 7A,6D
01CCE:  DATA 75,71
01CD0:  DATA 38,52
01CD2:  DATA 66,73
01CD4:  DATA 2B,65
01CD6:  DATA 20,0A
01CD8:  DATA 4D,2F
01CDA:  DATA 43,6D
01CDC:  DATA 69,58
01CDE:  DATA 75,6F
01CE0:  DATA 58,32
01CE2:  DATA 68,33
01CE4:  DATA 45,64
01CE6:  DATA 76,70
01CE8:  DATA 62,71
01CEA:  DATA 6C,2B
01CEC:  DATA 45,6D
01CEE:  DATA 6A,6C
01CF0:  DATA 6C,30
01CF2:  DATA 35,6D
01CF4:  DATA 4F,46
01CF6:  DATA 46,78
01CF8:  DATA 47,6A
01CFA:  DATA 46,34
01CFC:  DATA 63,6E
01CFE:  DATA 67,65
01D00:  DATA 59,71
01D02:  DATA 35,50
01D04:  DATA 48,57
01D06:  DATA 76,64
01D08:  DATA 50,67
01D0A:  DATA 2F,64
01D0C:  DATA 58,6C
01D0E:  DATA 6C,59
01D10:  DATA 66,47
01D12:  DATA 37,34
01D14:  DATA 33,36
01D16:  DATA 31,70
01D18:  DATA 36,57
01D1A:  DATA 48,69
01D1C:  DATA 54,52
01D1E:  DATA 35,70
01D20:  DATA 4C,54
01D22:  DATA 54,59
01D24:  DATA 20,0A
01D26:  DATA 43,68
01D28:  DATA 58,2B
01D2A:  DATA 7A,74
01D2C:  DATA 54,75
01D2E:  DATA 35,69
01D30:  DATA 6A,75
01D32:  DATA 71,6E
01D34:  DATA 6B,50
01D36:  DATA 44,35
01D38:  DATA 69,67
01D3A:  DATA 42,67
01D3C:  DATA 66,76
01D3E:  DATA 4E,6E
01D40:  DATA 6F,44
01D42:  DATA 57,54
01D44:  DATA 2F,77
01D46:  DATA 54,78
01D48:  DATA 74,2F
01D4A:  DATA 37,58
01D4C:  DATA 31,76
01D4E:  DATA 34,72
01D50:  DATA 33,6D
01D52:  DATA 71,4F
01D54:  DATA 30,32
01D56:  DATA 6B,2F
01D58:  DATA 38,41
01D5A:  DATA 43,44
01D5C:  DATA 61,6A
01D5E:  DATA 2F,61
01D60:  DATA 4A,6C
01D62:  DATA 4F,39
01D64:  DATA 58,4C
01D66:  DATA 4E,47
01D68:  DATA 32,57
01D6A:  DATA 7A,31
01D6C:  DATA 4F,31
01D6E:  DATA 5A,44
01D70:  DATA 6B,2B
01D72:  DATA 20,0A
01D74:  DATA 2F,71
01D76:  DATA 53,51
01D78:  DATA 44,35
01D7A:  DATA 76,42
01D7C:  DATA 4A,2F
01D7E:  DATA 38,41
01D80:  DATA 31,31
01D82:  DATA 2B,71
01D84:  DATA 2F,77
01D86:  DATA 44,77
01D88:  DATA 54,45
01D8A:  DATA 38,46
01D8C:  DATA 66,38
01D8E:  DATA 49,64
01D90:  DATA 2B,79
01D92:  DATA 42,6F
01D94:  DATA 4D,72
01D96:  DATA 4A,73
01D98:  DATA 6D,31
01D9A:  DATA 75,65
01D9C:  DATA 34,31
01D9E:  DATA 4B,55
01DA0:  DATA 59,36
01DA2:  DATA 37,70
01DA4:  DATA 43,69
01DA6:  DATA 6E,38
01DA8:  DATA 59,34
01DAA:  DATA 30,4E
01DAC:  DATA 66,6C
01DAE:  DATA 51,63
01DB0:  DATA 34,37
01DB2:  DATA 38,39
01DB4:  DATA 44,2B
01DB6:  DATA 4E,66
01DB8:  DATA 74,66
01DBA:  DATA 38,41
01DBC:  DATA 41,37
01DBE:  DATA 77,64
01DC0:  DATA 20,0A
01DC2:  DATA 2F,77
01DC4:  DATA 41,4B
01DC6:  DATA 39,2B
01DC8:  DATA 44,50
01DCA:  DATA 68,54
01DCC:  DATA 51,32
01DCE:  DATA 54,79
01DD0:  DATA 33,30
01DD2:  DATA 6E,53
01DD4:  DATA 4C,57
01DD6:  DATA 31,63
01DD8:  DATA 66,37
01DDA:  DATA 61,52
01DDC:  DATA 4B,47
01DDE:  DATA 4A,39
01DE0:  DATA 79,77
01DE2:  DATA 4A,6F
01DE4:  DATA 41,36
01DE6:  DATA 6D,69
01DE8:  DATA 69,69
01DEA:  DATA 67,41
01DEC:  DATA 6F,6F
01DEE:  DATA 7A,7A
01DF0:  DATA 52,51
01DF2:  DATA 41,30
01DF4:  DATA 38,55
01DF6:  DATA 30,74
01DF8:  DATA 68,73
01DFA:  DATA 63,30
01DFC:  DATA 37,50
01DFE:  DATA 7A,66
01E00:  DATA 6A,58
01E02:  DATA 68,33
01E04:  DATA 37,58
01E06:  DATA 33,37
01E08:  DATA 62,33
01E0A:  DATA 68,33
01E0C:  DATA 39,6C
01E0E:  DATA 20,0A
01E10:  DATA 66,52
01E12:  DATA 50,4A
01E14:  DATA 6B,4D
01E16:  DATA 65,73
01E18:  DATA 65,4A
01E1A:  DATA 37,70
01E1C:  DATA 41,39
01E1E:  DATA 72,70
01E20:  DATA 55,63
01E22:  DATA 75,31
01E24:  DATA 74,68
01E26:  DATA 4F,50
01E28:  DATA 4D,6C
01E2A:  DATA 62,42
01E2C:  DATA 38,74
01E2E:  DATA 4F,75
01E30:  DATA 4D,6A
01E32:  DATA 4C,45
01E34:  DATA 45,41
01E36:  DATA 48,44
01E38:  DATA 45,63
01E3A:  DATA 75,4D
01E3C:  DATA 78,6C
01E3E:  DATA 4C,43
01E40:  DATA 30,6E
01E42:  DATA 57,72
01E44:  DATA 79,35
01E46:  DATA 59,72
01E48:  DATA 64,6E
01E4A:  DATA 50,69
01E4C:  DATA 73,56
01E4E:  DATA 54,77
01E50:  DATA 39,4E
01E52:  DATA 31,61
01E54:  DATA 73,75
01E56:  DATA 56,49
01E58:  DATA 36,2F
01E5A:  DATA 38,41
01E5C:  DATA 20,0A
01E5E:  DATA 61,59
01E60:  DATA 74,66
01E62:  DATA 43,6D
01E64:  DATA 71,66
01E66:  DATA 43,58
01E68:  DATA 55,4C
01E6A:  DATA 58,78
01E6C:  DATA 78,72
01E6E:  DATA 6A,61
01E70:  DATA 4C,34
01E72:  DATA 54,75
01E74:  DATA 42,35
01E76:  DATA 65,71
01E78:  DATA 42,62
01E7A:  DATA 72,37
01E7C:  DATA 4E,2F
01E7E:  DATA 61,45
01E80:  DATA 4A,7A
01E82:  DATA 75,74
01E84:  DATA 57,64
01E86:  DATA 66,33
01E88:  DATA 6D,79
01E8A:  DATA 51,66
01E8C:  DATA 4B,56
01E8E:  DATA 69,4B
01E90:  DATA 75,34
01E92:  DATA 79,6F
01E94:  DATA 4F,43
01E96:  DATA 51,66
01E98:  DATA 6A,62
01E9A:  DATA 34,6B
01E9C:  DATA 66,38
01E9E:  DATA 46,52
01EA0:  DATA 4E,45
01EA2:  DATA 2B,47
01EA4:  DATA 48,68
01EA6:  DATA 75,33
01EA8:  DATA 38,4A
01EAA:  DATA 20,0A
01EAC:  DATA 2F,42
01EAE:  DATA 66,77
01EB0:  DATA 6A,70
01EB2:  DATA 57,69
01EB4:  DATA 36,48
01EB6:  DATA 70,71
01EB8:  DATA 47,47
01EBA:  DATA 32,6E
01EBC:  DATA 6C,73
01EBE:  DATA 78,62
01EC0:  DATA 57,38
01EC2:  DATA 53,2F
01EC4:  DATA 39,4D
01EC6:  DATA 62,61
01EC8:  DATA 50,62
01ECA:  DATA 6A,50
01ECC:  DATA 58,4C
01ECE:  DATA 38,6B
01ED0:  DATA 39,56
01ED2:  DATA 37,31
01ED4:  DATA 38,75
01ED6:  DATA 66,48
01ED8:  DATA 50,39
01EDA:  DATA 6F,4C
01EDC:  DATA 78,58
01EDE:  DATA 2B,30
01EE0:  DATA 52,34
01EE2:  DATA 71,62
01EE4:  DATA 56,76
01EE6:  DATA 46,57
01EE8:  DATA 70,50
01EEA:  DATA 64,79
01EEC:  DATA 49,53
01EEE:  DATA 49,4C
01EF0:  DATA 64,52
01EF2:  DATA 73,74
01EF4:  DATA 72,4A
01EF6:  DATA 43,63
01EF8:  DATA 20,0A
01EFA:  DATA 37,59
01EFC:  DATA 34,2B
01EFE:  DATA 67,48
01F00:  DATA 54,6B
01F02:  DATA 2F,4D
01F04:  DATA 32,42
01F06:  DATA 6B,74
01F08:  DATA 31,72
01F0A:  DATA 50,38
01F0C:  DATA 41,2F
01F0E:  DATA 42,7A
01F10:  DATA 78,5A
01F12:  DATA 38,55
01F14:  DATA 35,76
01F16:  DATA 4C,38
01F18:  DATA 4F,65
01F1A:  DATA 47,39
01F1C:  DATA 61,31
01F1E:  DATA 6E,35
01F20:  DATA 74,68
01F22:  DATA 65,30
01F24:  DATA 74,48
01F26:  DATA 6B,6A
01F28:  DATA 6A,50
01F2A:  DATA 2B,30
01F2C:  DATA 34,47
01F2E:  DATA 31,66
01F30:  DATA 78,49
01F32:  DATA 72,38
01F34:  DATA 6F,7A
01F36:  DATA 62,6A
01F38:  DATA 6E,47
01F3A:  DATA 34,74
01F3C:  DATA 2F,56
01F3E:  DATA 38,72
01F40:  DATA 54,6A
01F42:  DATA 48,75
01F44:  DATA 6C,65
01F46:  DATA 20,0A
01F48:  DATA 54,2B
01F4A:  DATA 58,54
01F4C:  DATA 35,61
01F4E:  DATA 6E,35
01F50:  DATA 6E,6D
01F52:  DATA 66,46
01F54:  DATA 6D,4A
01F56:  DATA 78,56
01F58:  DATA 54,32
01F5A:  DATA 57,41
01F5C:  DATA 6A,5A
01F5E:  DATA 64,37
01F60:  DATA 58,62
01F62:  DATA 2F,79
01F64:  DATA 4A,76
01F66:  DATA 69,64
01F68:  DATA 38,63
01F6A:  DATA 76,47
01F6C:  DATA 48,78
01F6E:  DATA 6B,76
01F70:  DATA 35,4C
01F72:  DATA 72,78
01F74:  DATA 4E,34
01F76:  DATA 69,31
01F78:  DATA 62,57
01F7A:  DATA 4A,47
01F7C:  DATA 62,7A
01F7E:  DATA 42,48
01F80:  DATA 4E,4B
01F82:  DATA 66,4A
01F84:  DATA 69,62
01F86:  DATA 74,74
01F88:  DATA 69,55
01F8A:  DATA 68,45
01F8C:  DATA 36,6E
01F8E:  DATA 37,6F
01F90:  DATA 48,66
01F92:  DATA 73,61
01F94:  DATA 20,0A
01F96:  DATA 35,58
01F98:  DATA 35,53
01F9A:  DATA 4F,43
01F9C:  DATA 70,58
01F9E:  DATA 70,31
01FA0:  DATA 34,72
01FA2:  DATA 61,2F
01FA4:  DATA 61,79
01FA6:  DATA 2B,47
01FA8:  DATA 58,69
01FAA:  DATA 62,39
01FAC:  DATA 69,62
01FAE:  DATA 77,5A
01FB0:  DATA 6F,75
01FB2:  DATA 76,66
01FB4:  DATA 45,44
01FB6:  DATA 51,62
01FB8:  DATA 2F,53
01FBA:  DATA 37,50
01FBC:  DATA 58,72
01FBE:  DATA 70,37
01FC0:  DATA 57,7A
01FC2:  DATA 57,46
01FC4:  DATA 34,72
01FC6:  DATA 69,52
01FC8:  DATA 33,56
01FCA:  DATA 64,78
01FCC:  DATA 7A,74
01FCE:  DATA 66,61
01FD0:  DATA 6D,46
01FD2:  DATA 50,41
01FD4:  DATA 59,67
01FD6:  DATA 6E,42
01FD8:  DATA 77,44
01FDA:  DATA 67,34
01FDC:  DATA 2B,66
01FDE:  DATA 39,53
01FE0:  DATA 2F,62
01FE2:  DATA 20,0A
01FE4:  DATA 64,38
01FE6:  DATA 4E,77
01FE8:  DATA 32,67
01FEA:  DATA 61,7A
01FEC:  DATA 30,7A
01FEE:  DATA 58,4A
01FF0:  DATA 37,6A
01FF2:  DATA 2B,35
01FF4:  DATA 4F,6B
01FF6:  DATA 63,53
01FF8:  DATA 64,44
01FFA:  DATA 2F,47
01FFC:  DATA 48,63
01FFE:  DATA 2B,6E
02000:  DATA 38,50
02002:  DATA 63,2B
02004:  DATA 67,7A
02006:  DATA 34,32
02008:  DATA 47,34
0200A:  DATA 4E,34
0200C:  DATA 69,7A
0200E:  DATA 48,39
02010:  DATA 39,47
02012:  DATA 68,4B
02014:  DATA 56,2B
02016:  DATA 72,30
02018:  DATA 2F,4E
0201A:  DATA 6E,7A
0201C:  DATA 4E,62
0201E:  DATA 4C,38
02020:  DATA 66,55
02022:  DATA 6E,65
02024:  DATA 72,46
02026:  DATA 33,38
02028:  DATA 39,48
0202A:  DATA 2B,4A
0202C:  DATA 2B,72
0202E:  DATA 2F,2F
02030:  DATA 20,0A
02032:  DATA 41,41
02034:  DATA 52,37
02036:  DATA 30,61
02038:  DATA 31,38
0203A:  DATA 49,2F
0203C:  DATA 43,33
0203E:  DATA 34,68
02040:  DATA 65,4D
02042:  DATA 72,32
02044:  DATA 52,59
02046:  DATA 62,52
02048:  DATA 5A,30
0204A:  DATA 74,70
0204C:  DATA 4A,47
0204E:  DATA 36,52
02050:  DATA 4A,62
02052:  DATA 51,74
02054:  DATA 4D,35
02056:  DATA 7A,39
02058:  DATA 4A,68
0205A:  DATA 6E,2F
0205C:  DATA 64,46
0205E:  DATA 66,67
02060:  DATA 78,34
02062:  DATA 39,38
02064:  DATA 58,58
02066:  DATA 48,78
02068:  DATA 41,38
0206A:  DATA 64,61
0206C:  DATA 33,72
0206E:  DATA 31,35
02070:  DATA 7A,65
02072:  DATA 61,35
02074:  DATA 66,7A
02076:  DATA 36,68
02078:  DATA 4F,63
0207A:  DATA 64,58
0207C:  DATA 6C,6B
0207E:  DATA 20,0A
02080:  DATA 61,52
02082:  DATA 76,31
02084:  DATA 59,31
02086:  DATA 2B,78
02088:  DATA 50,37
0208A:  DATA 4D,58
0208C:  DATA 37,55
0208E:  DATA 2B,6C
02090:  DATA 7A,2F
02092:  DATA 38,41
02094:  DATA 42,43
02096:  DATA 50,34
02098:  DATA 78,65
0209A:  DATA 4C,74
0209C:  DATA 4E,74
0209E:  DATA 5A,4E
020A0:  DATA 4C,76
020A2:  DATA 62,50
020A4:  DATA 2B,31
020A6:  DATA 64,46
020A8:  DATA 75,67
020AA:  DATA 38,6F
020AC:  DATA 62,62
020AE:  DATA 65,58
020B0:  DATA 45,55
020B2:  DATA 45,45
020B4:  DATA 54,71
020B6:  DATA 77,41
020B8:  DATA 2F,67
020BA:  DATA 75,72
020BC:  DATA 66,6A
020BE:  DATA 31,47
020C0:  DATA 4B,2F
020C2:  DATA 47,41
020C4:  DATA 64,4B
020C6:  DATA 2F,70
020C8:  DATA 72,77
020CA:  DATA 31,79
020CC:  DATA 20,0A
020CE:  DATA 57,70
020D0:  DATA 6C,2B
020D2:  DATA 58,2B
020D4:  DATA 77,78
020D6:  DATA 45,65
020D8:  DATA 57,63
020DA:  DATA 64,47
020DC:  DATA 72,33
020DE:  DATA 31,33
020E0:  DATA 65,78
020E2:  DATA 39,35
020E4:  DATA 37,50
020E6:  DATA 32,57
020E8:  DATA 42,6F
020EA:  DATA 55,48
020EC:  DATA 30,56
020EE:  DATA 33,36
020F0:  DATA 33,50
020F2:  DATA 71,62
020F4:  DATA 2F,67
020F6:  DATA 69,31
020F8:  DATA 38,4E
020FA:  DATA 66,2B
020FC:  DATA 46,6F
020FE:  DATA 66,38
02100:  DATA 46,4C
02102:  DATA 2F,68
02104:  DATA 6A,62
02106:  DATA 53,49
02108:  DATA 7A,57
0210A:  DATA 2B,6C
0210C:  DATA 58,6B
0210E:  DATA 2B,73
02110:  DATA 54,45
02112:  DATA 4C,6E
02114:  DATA 5A,39
02116:  DATA 6C,74
02118:  DATA 70,4A
0211A:  DATA 20,0A
0211C:  DATA 6F,79
0211E:  DATA 66,51
02120:  DATA 65,61
02122:  DATA 73,61
02124:  DATA 35,39
02126:  DATA 57,48
02128:  DATA 65,76
0212A:  DATA 36,51
0212C:  DATA 46,47
0212E:  DATA 4D,56
02130:  DATA 2B,48
02132:  DATA 2F,2F
02134:  DATA 41,41
02136:  DATA 62,4B
02138:  DATA 66,44
0213A:  DATA 56,76
0213C:  DATA 45,48
0213E:  DATA 37,58
02140:  DATA 48,6A
02142:  DATA 62,78
02144:  DATA 51,38
02146:  DATA 65,36
02148:  DATA 48,77
0214A:  DATA 33,34
0214C:  DATA 59,4E
0214E:  DATA 71,6A
02150:  DATA 59,34
02152:  DATA 69,6D
02154:  DATA 75,72
02156:  DATA 69,50
02158:  DATA 61,63
0215A:  DATA 2B,76
0215C:  DATA 6C,77
0215E:  DATA 54,44
02160:  DATA 48,75
02162:  DATA 66,53
02164:  DATA 76,33
02166:  DATA 41,79
02168:  DATA 20,0A
0216A:  DATA 4F,4B
0216C:  DATA 76,69
0216E:  DATA 69,72
02170:  DATA 7A,59
02172:  DATA 7A,6B
02174:  DATA 2F,6C
02176:  DATA 53,2F
02178:  DATA 48,55
0217A:  DATA 2B,6D
0217C:  DATA 79,53
0217E:  DATA 6E,79
02180:  DATA 34,66
02182:  DATA 6D,37
02184:  DATA 73,47
02186:  DATA 50,48
02188:  DATA 36,31
0218A:  DATA 2F,4F
0218C:  DATA 35,2F
0218E:  DATA 77,58
02190:  DATA 67,2B
02192:  DATA 49,37
02194:  DATA 66,45
02196:  DATA 50,2F
02198:  DATA 67,70
0219A:  DATA 72,34
0219C:  DATA 36,69
0219E:  DATA 57,51
021A0:  DATA 54,57
021A2:  DATA 33,68
021A4:  DATA 32,47
021A6:  DATA 78,30
021A8:  DATA 65,45
021AA:  DATA 37,74
021AC:  DATA 32,41
021AE:  DATA 6C,72
021B0:  DATA 47,38
021B2:  DATA 67,39
021B4:  DATA 73,53
021B6:  DATA 20,0A
021B8:  DATA 79,79
021BA:  DATA 44,48
021BC:  DATA 74,6E
021BE:  DATA 72,58
021C0:  DATA 39,45
021C2:  DATA 54,4E
021C4:  DATA 67,31
021C6:  DATA 2F,4B
021C8:  DATA 35,2B
021CA:  DATA 31,6E
021CC:  DATA 38,53
021CE:  DATA 76,2B
021D0:  DATA 46,78
021D2:  DATA 2F,74
021D4:  DATA 52,2F
021D6:  DATA 45,58
021D8:  DATA 78,59
021DA:  DATA 73,67
021DC:  DATA 6B,6A
021DE:  DATA 38,51
021E0:  DATA 2B,4A
021E2:  DATA 4E,51
021E4:  DATA 76,34
021E6:  DATA 53,44
021E8:  DATA 6B,43
021EA:  DATA 4F,53
021EC:  DATA 34,64
021EE:  DATA 6F,77
021F0:  DATA 44,33
021F2:  DATA 41,51
021F4:  DATA 71,42
021F6:  DATA 37,43
021F8:  DATA 74,75
021FA:  DATA 45,36
021FC:  DATA 58,4E
021FE:  DATA 69,4A
02200:  DATA 54,66
02202:  DATA 52,66
02204:  DATA 20,0A
02206:  DATA 6D,5A
02208:  DATA 5A,39
0220A:  DATA 55,2F
0220C:  DATA 64,52
0220E:  DATA 68,33
02210:  DATA 66,35
02212:  DATA 48,41
02214:  DATA 57,30
02216:  DATA 44,33
02218:  DATA 6C,78
0221A:  DATA 48,48
0221C:  DATA 47,70
0221E:  DATA 6B,6B
02220:  DATA 6D,5A
02222:  DATA 55,56
02224:  DATA 52,31
02226:  DATA 59,6B
02228:  DATA 39,50
0222A:  DATA 31,72
0222C:  DATA 2B,72
0222E:  DATA 76,34
02230:  DATA 49,2F
02232:  DATA 44,36
02234:  DATA 50,34
02236:  DATA 54,66
02238:  DATA 42,6E
0223A:  DATA 77,6A
0223C:  DATA 34,58
0223E:  DATA 6A,43
02240:  DATA 2B,58
02242:  DATA 34,61
02244:  DATA 30,61
02246:  DATA 7A,30
02248:  DATA 74,4D
0224A:  DATA 64,41
0224C:  DATA 49,49
0224E:  DATA 45,69
02250:  DATA 47,50
02252:  DATA 20,0A
02254:  DATA 77,57
02256:  DATA 76,35
02258:  DATA 6E,76
0225A:  DATA 32,42
0225C:  DATA 66,68
0225E:  DATA 74,2F
02260:  DATA 77,74
02262:  DATA 33,39
02264:  DATA 74,6E
02266:  DATA 34,56
02268:  DATA 65,48
0226A:  DATA 57,6A
0226C:  DATA 45,31
0226E:  DATA 76,71
02270:  DATA 48,69
02272:  DATA 6D,77
02274:  DATA 2B,30
02276:  DATA 72,74
02278:  DATA 79,44
0227A:  DATA 41,6B
0227C:  DATA 36,53
0227E:  DATA 53,2F
02280:  DATA 2B,51
02282:  DATA 30,62
02284:  DATA 38,66
02286:  DATA 61,76
02288:  DATA 36,69
0228A:  DATA 51,50
0228C:  DATA 6C,72
0228E:  DATA 6F,34
02290:  DATA 74,72
02292:  DATA 65,39
02294:  DATA 43,6E
02296:  DATA 36,73
02298:  DATA 79,34
0229A:  DATA 66,70
0229C:  DATA 2B,37
0229E:  DATA 4F,70
022A0:  DATA 20,0A
022A2:  DATA 35,32
022A4:  DATA 50,7A
022A6:  DATA 35,2F
022A8:  DATA 34,4F
022AA:  DATA 53,50
022AC:  DATA 69,53
022AE:  DATA 33,68
022B0:  DATA 44,39
022B2:  DATA 67,65
022B4:  DATA 77,30
022B6:  DATA 4F,4F
022B8:  DATA 51,72
022BA:  DATA 4C,34
022BC:  DATA 74,38
022BE:  DATA 54,32
022C0:  DATA 6C,71
022C2:  DATA 36,41
022C4:  DATA 39,59
022C6:  DATA 59,55
022C8:  DATA 6C,75
022CA:  DATA 43,66
022CC:  DATA 66,45
022CE:  DATA 6B,55
022D0:  DATA 50,48
022D2:  DATA 71,52
022D4:  DATA 36,56
022D6:  DATA 2B,44
022D8:  DATA 34,34
022DA:  DATA 72,39
022DC:  DATA 58,2F
022DE:  DATA 41,50
022E0:  DATA 67,36
022E2:  DATA 4D,2B
022E4:  DATA 4A,48
022E6:  DATA 32,6E
022E8:  DATA 78,6E
022EA:  DATA 38,4A
022EC:  DATA 66,42
022EE:  DATA 20,0A
022F0:  DATA 38,63
022F2:  DATA 6A,41
022F4:  DATA 32,4E
022F6:  DATA 6E,66
022F8:  DATA 36,78
022FA:  DATA 50,48
022FC:  DATA 6E,68
022FE:  DATA 2F,4F
02300:  DATA 65,4B
02302:  DATA 47,49
02304:  DATA 6B,65
02306:  DATA 33,6B
02308:  DATA 7A,59
0230A:  DATA 2B,70
0230C:  DATA 72,38
0230E:  DATA 6F,4B
02310:  DATA 39,6E
02312:  DATA 68,75
02314:  DATA 6C,79
02316:  DATA 59,4A
02318:  DATA 53,37
0231A:  DATA 74,73
0231C:  DATA 38,2F
0231E:  DATA 4F,4B
02320:  DATA 6E,4E
02322:  DATA 69,57
02324:  DATA 75,31
02326:  DATA 6A,39
02328:  DATA 6C,76
0232A:  DATA 38,41
0232C:  DATA 67,33
0232E:  DATA 51,38
02330:  DATA 4F,52
02332:  DATA 2F,44
02334:  DATA 54,39
02336:  DATA 69,48
02338:  DATA 34,75
0233A:  DATA 66,45
0233C:  DATA 20,0A
0233E:  DATA 4B,56
02340:  DATA 55,6A
02342:  DATA 61,36
02344:  DATA 31,64
02346:  DATA 34,74
02348:  DATA 7A,67
0234A:  DATA 67,4E
0234C:  DATA 46,59
0234E:  DATA 32,61
02350:  DATA 79,67
02352:  DATA 6B,39
02354:  DATA 31,33
02356:  DATA 58,4D
02358:  DATA 67,34
0235A:  DATA 39,43
0235C:  DATA 4B,35
0235E:  DATA 33,39
02360:  DATA 69,7A
02362:  DATA 39,6B
02364:  DATA 4C,56
02366:  DATA 50,32
02368:  DATA 74,50
0236A:  DATA 69,4B
0236C:  DATA 5A,4C
0236E:  DATA 72,37
02370:  DATA 52,62
02372:  DATA 2B,46
02374:  DATA 37,43
02376:  DATA 58,7A
02378:  DATA 4E,56
0237A:  DATA 76,39
0237C:  DATA 75,31
0237E:  DATA 70,43
02380:  DATA 65,66
02382:  DATA 4A,6A
02384:  DATA 4F,4D
02386:  DATA 47,52
02388:  DATA 73,38
0238A:  DATA 20,0A
0238C:  DATA 2F,77
0238E:  DATA 42,30
02390:  DATA 48,63
02392:  DATA 65,6F
02394:  DATA 56,76
02396:  DATA 6F,76
02398:  DATA 2F,67
0239A:  DATA 6D,4C
0239C:  DATA 2B,7A
0239E:  DATA 6C,71
023A0:  DATA 46,31
023A2:  DATA 2F,77
023A4:  DATA 52,73
023A6:  DATA 38,4C
023A8:  DATA 2B,46
023AA:  DATA 64,50
023AC:  DATA 6E,68
023AE:  DATA 30,33
023B0:  DATA 55,76
023B2:  DATA 48,4E
023B4:  DATA 70,63
023B6:  DATA 58,64
023B8:  DATA 31,63
023BA:  DATA 79,70
023BC:  DATA 75,56
023BE:  DATA 49,62
023C0:  DATA 79,37
023C2:  DATA 59,6C
023C4:  DATA 39,76
023C6:  DATA 47,34
023C8:  DATA 2F,5A
023CA:  DATA 43,75
023CC:  DATA 42,6B
023CE:  DATA 5A,49
023D0:  DATA 48,49
023D2:  DATA 7A,6B
023D4:  DATA 66,58
023D6:  DATA 76,77
023D8:  DATA 20,0A
023DA:  DATA 65,2B
023DC:  DATA 44,32
023DE:  DATA 69,2F
023E0:  DATA 41,33
023E2:  DATA 77,42
023E4:  DATA 59,2B
023E6:  DATA 47,2F
023E8:  DATA 44,39
023EA:  DATA 73,4C
023EC:  DATA 66,54
023EE:  DATA 37,46
023F0:  DATA 4D,5A
023F2:  DATA 59,37
023F4:  DATA 70,4A
023F6:  DATA 33,50
023F8:  DATA 4C,53
023FA:  DATA 53,4E
023FC:  DATA 2F,45
023FE:  DATA 7A,48
02400:  DATA 6B,6E
02402:  DATA 38,41
02404:  DATA 41,41
02406:  DATA 42,58
02408:  DATA 34,37
0240A:  DATA 78,62
0240C:  DATA 6B,2F
0240E:  DATA 39,71
02410:  DATA 35,77
02412:  DATA 71,6C
02414:  DATA 62,2B
02416:  DATA 48,42
02418:  DATA 74,74
0241A:  DATA 64,33
0241C:  DATA 30,58
0241E:  DATA 70,70
02420:  DATA 71,62
02422:  DATA 56,4D
02424:  DATA 6A,2B
02426:  DATA 20,0A
02428:  DATA 74,79
0242A:  DATA 6F,65
0242C:  DATA 31,2F
0242E:  DATA 68,77
02430:  DATA 56,32
02432:  DATA 75,37
02434:  DATA 37,48
02436:  DATA 7A,33
02438:  DATA 2F,77
0243A:  DATA 41,46
0243C:  DATA 58,76
0243E:  DATA 48,74
02440:  DATA 76,2B
02442:  DATA 79,68
02444:  DATA 2F,77
02446:  DATA 41,45
02448:  DATA 78,50
0244A:  DATA 69,42
0244C:  DATA 2F,77
0244E:  DATA 41,49
02450:  DATA 33,44
02452:  DATA 46,70
02454:  DATA 4F,2F
02456:  DATA 54,49
02458:  DATA 76,44
0245A:  DATA 32,6E
0245C:  DATA 51,32
0245E:  DATA 34,38
02460:  DATA 76,79
02462:  DATA 6C,75
02464:  DATA 35,55
02466:  DATA 74,33
02468:  DATA 32,48
0246A:  DATA 73,77
0246C:  DATA 69,6B
0246E:  DATA 6B,59
02470:  DATA 48,72
02472:  DATA 6C,63
02474:  DATA 20,0A
02476:  DATA 35,7A
02478:  DATA 7A,58
0247A:  DATA 38,34
0247C:  DATA 2F,53
0247E:  DATA 76,36
02480:  DATA 45,50
02482:  DATA 2B,44
02484:  DATA 67,48
02486:  DATA 77,72
02488:  DATA 65,65
0248A:  DATA 4A,76
0248C:  DATA 38,41
0248E:  DATA 67,6D
02490:  DATA 66,34
02492:  DATA 72,75
02494:  DATA 4C,56
02496:  DATA 43,34
02498:  DATA 30,58
0249A:  DATA 55,64
0249C:  DATA 4F,76
0249E:  DATA 35,6C
024A0:  DATA 41,79
024A2:  DATA 33,6C
024A4:  DATA 69,35
024A6:  DATA 53,4D
024A8:  DATA 6B,59
024AA:  DATA 39,50
024AC:  DATA 4E,44
024AE:  DATA 45,39
024B0:  DATA 67,70
024B2:  DATA 50,53
024B4:  DATA 76,35
024B6:  DATA 37,2F
024B8:  DATA 36,64
024BA:  DATA 51,4F
024BC:  DATA 31,66
024BE:  DATA 71,33
024C0:  DATA 43,4E
024C2:  DATA 20,0A
024C4:  DATA 4F,6E
024C6:  DATA 48,43
024C8:  DATA 74,52
024CA:  DATA 58,58
024CC:  DATA 62,38
024CE:  DATA 72,45
024D0:  DATA 35,33
024D2:  DATA 70,57
024D4:  DATA 55,45
024D6:  DATA 72,4A
024D8:  DATA 4C,52
024DA:  DATA 48,33
024DC:  DATA 6E,2F
024DE:  DATA 77,62
024E0:  DATA 78,2F
024E2:  DATA 73,36
024E4:  DATA 61,58
024E6:  DATA 38,61
024E8:  DATA 2F,77
024EA:  DATA 42,75
024EC:  DATA 4F,58
024EE:  DATA 58,39
024F0:  DATA 5A,68
024F2:  DATA 6A,75
024F4:  DATA 72,58
024F6:  DATA 34,65
024F8:  DATA 61,57
024FA:  DATA 32,73
024FC:  DATA 57,73
024FE:  DATA 4C,2F
02500:  DATA 41,44
02502:  DATA 4B,31
02504:  DATA 36,30
02506:  DATA 71,52
02508:  DATA 51,4D
0250A:  DATA 56,2F
0250C:  DATA 32,4E
0250E:  DATA 7A,79
02510:  DATA 20,0A
02512:  DATA 41,39
02514:  DATA 6E,52
02516:  DATA 44,37
02518:  DATA 31,2B
0251A:  DATA 2B,53
0251C:  DATA 64,46
0251E:  DATA 39,71
02520:  DATA 2F,6E
02522:  DATA 5A,2F
02524:  DATA 34,49
02526:  DATA 6F,2F
02528:  DATA 74,72
0252A:  DATA 36,50
0252C:  DATA 38,41
0252E:  DATA 73,57
02530:  DATA 66,74
02532:  DATA 69,52
02534:  DATA 33,58
02536:  DATA 69,69
02538:  DATA 34,57
0253A:  DATA 7A,38
0253C:  DATA 4A,2B
0253E:  DATA 4D,4C
02540:  DATA 4A,74
02542:  DATA 45,31
02544:  DATA 4B,37
02546:  DATA 62,6C
02548:  DATA 4E,4F
0254A:  DATA 5A,6E
0254C:  DATA 56,34
0254E:  DATA 62,68
02550:  DATA 2B,66
02552:  DATA 75,4B
02554:  DATA 36,37
02556:  DATA 57,50
02558:  DATA 52,55
0255A:  DATA 6B,64
0255C:  DATA 76,34
0255E:  DATA 20,0A
02560:  DATA 63,56
02562:  DATA 2F,52
02564:  DATA 42,70
02566:  DATA 75,71
02568:  DATA 57,32
0256A:  DATA 73,61
0256C:  DATA 64,62
0256E:  DATA 33,6C
02570:  DATA 70,63
02572:  DATA 51,33
02574:  DATA 56,72
02576:  DATA 64,52
02578:  DATA 72,4E
0257A:  DATA 44,4E
0257C:  DATA 43,34
0257E:  DATA 65,4F
02580:  DATA 57,4E
02582:  DATA 68,6C
02584:  DATA 57,56
02586:  DATA 68,77
02588:  DATA 51,51
0258A:  DATA 51,51
0258C:  DATA 52,77
0258E:  DATA 52,58
02590:  DATA 68,38
02592:  DATA 55,52
02594:  DATA 71,66
02596:  DATA 57,2B
02598:  DATA 61,58
0259A:  DATA 77,32
0259C:  DATA 56,6A
0259E:  DATA 31,4D
025A0:  DATA 6A,6C
025A2:  DATA 44,32
025A4:  DATA 46,6C
025A6:  DATA 76,66
025A8:  DATA 55,73
025AA:  DATA 30,55
025AC:  DATA 20,0A
025AE:  DATA 68,63
025B0:  DATA 41,30
025B2:  DATA 75,61
025B4:  DATA 2B,64
025B6:  DATA 50,61
025B8:  DATA 43,76
025BA:  DATA 7A,37
025BC:  DATA 2F,34
025BE:  DATA 4C,4E
025C0:  DATA 2B,4D
025C2:  DATA 76,74
025C4:  DATA 50,6A
025C6:  DATA 7A,77
025C8:  DATA 58,34
025CA:  DATA 66,44
025CC:  DATA 66,4C
025CE:  DATA 59,32
025D0:  DATA 45,2B
025D2:  DATA 6F,4F
025D4:  DATA 76,72
025D6:  DATA 35,30
025D8:  DATA 67,6A
025DA:  DATA 42,2F
025DC:  DATA 44,79
025DE:  DATA 47,2F
025E0:  DATA 4F,76
025E2:  DATA 30,45
025E4:  DATA 7A,58
025E6:  DATA 35,52
025E8:  DATA 2F,38
025EA:  DATA 46,4D
025EC:  DATA 66,47
025EE:  DATA 59,38
025F0:  DATA 58,2F
025F2:  DATA 41,4C
025F4:  DATA 59,50
025F6:  DATA 69,52
025F8:  DATA 45,62
025FA:  DATA 20,0A
025FC:  DATA 64,44
025FE:  DATA 6F,38
02600:  DATA 64,76
02602:  DATA 70,38
02604:  DATA 5A,42
02606:  DATA 7A,67
02608:  DATA 70,45
0260A:  DATA 47,63
0260C:  DATA 65,33
0260E:  DATA 7A,75
02610:  DATA 34,78
02612:  DATA 2B,50
02614:  DATA 57,67
02616:  DATA 44,79
02618:  DATA 72,34
0261A:  DATA 52,2F
0261C:  DATA 44,36
0261E:  DATA 31,2B
02620:  DATA 4B,48
02622:  DATA 6A,65
02624:  DATA 48,52
02626:  DATA 72,7A
02628:  DATA 78,44
0262A:  DATA 6F,2F
0262C:  DATA 68,6C
0262E:  DATA 62,69
02630:  DATA 4F,51
02632:  DATA 78,33
02634:  DATA 75,70
02636:  DATA 75,59
02638:  DATA 37,59
0263A:  DATA 79,68
0263C:  DATA 53,55
0263E:  DATA 52,6E
02640:  DATA 48,33
02642:  DATA 64,7A
02644:  DATA 41,44
02646:  DATA 63,54
02648:  DATA 20,0A
0264A:  DATA 67,44
0264C:  DATA 6E,6E
0264E:  DATA 37,70
02650:  DATA 39,4A
02652:  DATA 2B,44
02654:  DATA 4F,69
02656:  DATA 57,33
02658:  DATA 37,4B
0265A:  DATA 2F,77
0265C:  DATA 41,5A
0265E:  DATA 64,4F
02660:  DATA 38,56
02662:  DATA 65,4B
02664:  DATA 4E,63
02666:  DATA 30,4B
02668:  DATA 34,48
0266A:  DATA 68,31
0266C:  DATA 33,6E
0266E:  DATA 67,73
02670:  DATA 4E,46
02672:  DATA 31,53
02674:  DATA 48,55
02676:  DATA 72,6E
02678:  DATA 55,5A
0267A:  DATA 4E,72
0267C:  DATA 4B,69
0267E:  DATA 41,78
02680:  DATA 46,30
02682:  DATA 69,51
02684:  DATA 73,77
02686:  DATA 4C,4E
02688:  DATA 49,56
0268A:  DATA 49,42
0268C:  DATA 4F,46
0268E:  DATA 59,6B
02690:  DATA 43,75
02692:  DATA 48,2B
02694:  DATA 47,66
02696:  DATA 20,0A
02698:  DATA 77,58
0269A:  DATA 6D,38
0269C:  DATA 64,53
0269E:  DATA 36,4B
026A0:  DATA 31,31
026A2:  DATA 64,54
026A4:  DATA 57,46
026A6:  DATA 6E,34
026A8:  DATA 69,31
026AA:  DATA 55,61
026AC:  DATA 4C,70
026AE:  DATA 35,67
026B0:  DATA 74,76
026B2:  DATA 74,45
026B4:  DATA 39,33
026B6:  DATA 63,48
026B8:  DATA 59,47
026BA:  DATA 4B,6F
026BC:  DATA 58,51
026BE:  DATA 62,45
026C0:  DATA 38,32
026C2:  DATA 50,63
026C4:  DATA 78,63
026C6:  DATA 59,38
026C8:  DATA 78,51
026CA:  DATA 41,33
026CC:  DATA 7A,59
026CE:  DATA 37,37
026D0:  DATA 34,55
026D2:  DATA 66,73
026D4:  DATA 39,57
026D6:  DATA 6C,78
026D8:  DATA 4A,6F
026DA:  DATA 63,6B
026DC:  DATA 6C,35
026DE:  DATA 34,63
026E0:  DATA 31,69
026E2:  DATA 78,38
026E4:  DATA 20,0A
026E6:  DATA 57,65
026E8:  DATA 49,5A
026EA:  DATA 2F,44
026EC:  DATA 39,73
026EE:  DATA 62,2B
026F0:  DATA 31,75
026F2:  DATA 69,30
026F4:  DATA 5A,69
026F6:  DATA 61,4D
026F8:  DATA 43,56
026FA:  DATA 46,6A
026FC:  DATA 6C,6A
026FE:  DATA 4C,62
02700:  DATA 76,4E
02702:  DATA 44,74
02704:  DATA 7A,74
02706:  DATA 56,59
02708:  DATA 7A,6C
0270A:  DATA 2B,53
0270C:  DATA 72,41
0270E:  DATA 47,35
02710:  DATA 34,4F
02712:  DATA 2B,4D
02714:  DATA 55,66
02716:  DATA 78,30
02718:  DATA 2B,41
0271A:  DATA 58,78
0271C:  DATA 61,38
0271E:  DATA 4D,33
02720:  DATA 31,37
02722:  DATA 70,65
02724:  DATA 6D,2B
02726:  DATA 4B,66
02728:  DATA 46,47
0272A:  DATA 76,52
0272C:  DATA 2B,4A
0272E:  DATA 37,4F
02730:  DATA 43,35
02732:  DATA 20,0A
02734:  DATA 75,55
02736:  DATA 74,59
02738:  DATA 62,31
0273A:  DATA 6D,6B
0273C:  DATA 56,70
0273E:  DATA 6F,55
02740:  DATA 6C,6B
02742:  DATA 4B,71
02744:  DATA 47,56
02746:  DATA 56,42
02748:  DATA 56,57
0274A:  DATA 49,4C
0274C:  DATA 41,38
0274E:  DATA 5A,50
02750:  DATA 54,45
02752:  DATA 69,38
02754:  DATA 63,57
02756:  DATA 50,37
02758:  DATA 4F,58
0275A:  DATA 37,4D
0275C:  DATA 2B,76
0275E:  DATA 65,45
02760:  DATA 37,48
02762:  DATA 55,64
02764:  DATA 4E,31
02766:  DATA 4C,78
02768:  DATA 74,38
0276A:  DATA 51,70
0276C:  DATA 49,31
0276E:  DATA 31,5A
02770:  DATA 39,50
02772:  DATA 75,45
02774:  DATA 75,6F
02776:  DATA 64,4A
02778:  DATA 30,2B
0277A:  DATA 50,4F
0277C:  DATA 49,50
0277E:  DATA 4F,6A
02780:  DATA 20,0A
02782:  DATA 4A,6A
02784:  DATA 61,57
02786:  DATA 52,6D
02788:  DATA 63,4D
0278A:  DATA 71,73
0278C:  DATA 51,46
0278E:  DATA 62,42
02790:  DATA 77,51
02792:  DATA 4B,35
02794:  DATA 4C,77
02796:  DATA 66,2B
02798:  DATA 7A,77
0279A:  DATA 33,69
0279C:  DATA 54,55
0279E:  DATA 74,4A
027A0:  DATA 73,5A
027A2:  DATA 74,59
027A4:  DATA 68,73
027A6:  DATA 37,37
027A8:  DATA 78,4A
027AA:  DATA 61,33
027AC:  DATA 64,35
027AE:  DATA 6F,79
027B0:  DATA 6D,33
027B2:  DATA 33,70
027B4:  DATA 63,52
027B6:  DATA 57,2F
027B8:  DATA 6E,59
027BA:  DATA 6B,6D
027BC:  DATA 62,63
027BE:  DATA 44,43
027C0:  DATA 6B,6A
027C2:  DATA 51,4F
027C4:  DATA 71,6B
027C6:  DATA 42,7A
027C8:  DATA 38,70
027CA:  DATA 4A,55
027CC:  DATA 4C,67
027CE:  DATA 20,0A
027D0:  DATA 74,68
027D2:  DATA 2B,50
027D4:  DATA 50,68
027D6:  DATA 53,33
027D8:  DATA 77,2F
027DA:  DATA 38,41
027DC:  DATA 43,75
027DE:  DATA 68,33
027E0:  DATA 74,33
027E2:  DATA 64,58
027E4:  DATA 45,6C
027E6:  DATA 35,72
027E8:  DATA 74,74
027EA:  DATA 48,66
027EC:  DATA 57,38
027EE:  DATA 59,74
027F0:  DATA 66,39
027F2:  DATA 47,6C
027F4:  DATA 67,6B
027F6:  DATA 54,63
027F8:  DATA 47,6A
027FA:  DATA 6E,44
027FC:  DATA 48,65
027FE:  DATA 36,63
02800:  DATA 4A,49
02802:  DATA 6D,31
02804:  DATA 53,6A
02806:  DATA 67,6A
02808:  DATA 35,73
0280A:  DATA 5A,6F
0280C:  DATA 41,50
0280E:  DATA 67,44
02810:  DATA 34,4D
02812:  DATA 2F,34
02814:  DATA 57,46
02816:  DATA 38,63
02818:  DATA 66,43
0281A:  DATA 4F,68
0281C:  DATA 20,0A
0281E:  DATA 75,75
02820:  DATA 36,50
02822:  DATA 56,4E
02824:  DATA 59,74
02826:  DATA 72,65
02828:  DATA 55,45
0282A:  DATA 66,38
0282C:  DATA 73,32
0282E:  DATA 6C,58
02830:  DATA 66,2B
02832:  DATA 53,5A
02834:  DATA 72,39
02836:  DATA 71,71
02838:  DATA 2F,4B
0283A:  DATA 33,2F
0283C:  DATA 67,6C
0283E:  DATA 7A,34
02840:  DATA 4D,48
02842:  DATA 69,76
02844:  DATA 38,41
02846:  DATA 61,39
02848:  DATA 30,61
0284A:  DATA 34,5A
0284C:  DATA 66,4D
0284E:  DATA 69,30
02850:  DATA 4B,7A
02852:  DATA 75,64
02854:  DATA 52,59
02856:  DATA 66,77
02858:  DATA 6A,39
0285A:  DATA 33,35
0285C:  DATA 4B,6E
0285E:  DATA 38,47
02860:  DATA 6C,58
02862:  DATA 39,4B
02864:  DATA 2F,56
02866:  DATA 4B,67
02868:  DATA 41,6F
0286A:  DATA 20,0A
0286C:  DATA 6F,6F
0286E:  DATA 6F,41
02870:  DATA 51,6E
02872:  DATA 46,49
02874:  DATA 57,78
02876:  DATA 53,6B
02878:  DATA 31,6D
0287A:  DATA 65,4B
0287C:  DATA 74,58
0287E:  DATA 6B,30
02880:  DATA 44,77
02882:  DATA 2F,65
02884:  DATA 58,6B
02886:  DATA 64,74
02888:  DATA 4E,65
0288A:  DATA 79,32
0288C:  DATA 38,62
0288E:  DATA 4F,6C
02890:  DATA 76,43
02892:  DATA 50,33
02894:  DATA 6B,37
02896:  DATA 59,2B
02898:  DATA 56,46
0289A:  DATA 7A,78
0289C:  DATA 6C,6A
0289E:  DATA 67,5A
028A0:  DATA 4F,41
028A2:  DATA 4D,35
028A4:  DATA 4A,41
028A6:  DATA 79,61
028A8:  DATA 6D,54
028AA:  DATA 73,6D
028AC:  DATA 32,4B
028AE:  DATA 54,73
028B0:  DATA 72,6E
028B2:  DATA 69,2F
028B4:  DATA 37,63
028B6:  DATA 33,37
028B8:  DATA 20,0A
028BA:  DATA 5A,6C
028BC:  DATA 68,2B
028BE:  DATA 79,74
028C0:  DATA 34,49
028C2:  DATA 57,4B
028C4:  DATA 7A,2B
028C6:  DATA 7A,33
028C8:  DATA 33,69
028CA:  DATA 37,56
028CC:  DATA 31,49
028CE:  DATA 30,36
028D0:  DATA 7A,63
028D2:  DATA 35,57
028D4:  DATA 46,65
028D6:  DATA 68,75
028D8:  DATA 4A,51
028DA:  DATA 50,34
028DC:  DATA 46,50
028DE:  DATA 41,47
028E0:  DATA 51,58
028E2:  DATA 62,67
028E4:  DATA 59,41
028E6:  DATA 59,72
028E8:  DATA 38,57
028EA:  DATA 2F,42
028EC:  DATA 37,39
028EE:  DATA 67,37
028F0:  DATA 34,6F
028F2:  DATA 66,74
028F4:  DATA 65,65
028F6:  DATA 49,70
028F8:  DATA 50,46
028FA:  DATA 6E,69
028FC:  DATA 53,61
028FE:  DATA 62,52
02900:  DATA 37,4C
02902:  DATA 57,4A
02904:  DATA 66,74
02906:  DATA 20,0A
02908:  DATA 4D,2B
0290A:  DATA 71,36
0290C:  DATA 73,72
0290E:  DATA 47,34
02910:  DATA 75,38
02912:  DATA 34,47
02914:  DATA 36,4B
02916:  DATA 44,49
02918:  DATA 5A,68
0291A:  DATA 74,78
0291C:  DATA 74,79
0291E:  DATA 55,54
02920:  DATA 61,41
02922:  DATA 46,4F
02924:  DATA 41,42
02926:  DATA 58,32
02928:  DATA 68,38
0292A:  DATA 4A,66
0292C:  DATA 32,4C
0292E:  DATA 37,5A
02930:  DATA 2F,69
02932:  DATA 4E,65
02934:  DATA 66,45
02936:  DATA 54,34
02938:  DATA 69,74
0293A:  DATA 61,2B
0293C:  DATA 4A,76
0293E:  DATA 47,75
02940:  DATA 70,54
02942:  DATA 43,61
02944:  DATA 4B,46
02946:  DATA 6C,38
02948:  DATA 79,78
0294A:  DATA 30,52
0294C:  DATA 52,2F
0294E:  DATA 71,34
02950:  DATA 6F,46
02952:  DATA 59,66
02954:  DATA 20,0A
02956:  DATA 4D,55
02958:  DATA 47,41
0295A:  DATA 4A,47
0295C:  DATA 41,4F
0295E:  DATA 52,6B
02960:  DATA 41,45
02962:  DATA 6C,6D
02964:  DATA 39,34
02966:  DATA 53,50
02968:  DATA 48,59
0296A:  DATA 44,6A
0296C:  DATA 6F,4B
0296E:  DATA 2B,52
02970:  DATA 78,47
02972:  DATA 51,7A
02974:  DATA 7A,53
02976:  DATA 76,37
02978:  DATA 62,4D
0297A:  DATA 47,2F
0297C:  DATA 5A,72
0297E:  DATA 34,59
02980:  DATA 4C,38
02982:  DATA 35,65
02984:  DATA 62,38
02986:  DATA 76,76
02988:  DATA 50,6D
0298A:  DATA 63,52
0298C:  DATA 6B,39
0298E:  DATA 54,4D
02990:  DATA 4B,76
02992:  DATA 74,4D
02994:  DATA 61,37
02996:  DATA 51,57
02998:  DATA 30,46
0299A:  DATA 2B,62
0299C:  DATA 66,64
0299E:  DATA 39,76
029A0:  DATA 78,50
029A2:  DATA 20,0A
029A4:  DATA 6E,2F
029A6:  DATA 34,4A
029A8:  DATA 2F,77
029AA:  DATA 44,42
029AC:  DATA 4E,48
029AE:  DATA 34,59
029B0:  DATA 2F,42
029B2:  DATA 34,51
029B4:  DATA 33,4D
029B6:  DATA 32,6D
029B8:  DATA 4E,34
029BA:  DATA 6E,31
029BC:  DATA 4F,50
029BE:  DATA 42,2B
029C0:  DATA 31,61
029C2:  DATA 76,69
029C4:  DATA 5A,51
029C6:  DATA 32,4F
029C8:  DATA 53,73
029CA:  DATA 51,41
029CC:  DATA 6A,48
029CE:  DATA 73,53
029D0:  DATA 70,59
029D2:  DATA 66,33
029D4:  DATA 71,39
029D6:  DATA 38,73
029D8:  DATA 4E,4D
029DA:  DATA 74,39
029DC:  DATA 4C,74
029DE:  DATA 49,34
029E0:  DATA 62,65
029E2:  DATA 47,4B
029E4:  DATA 33,67
029E6:  DATA 68,55
029E8:  DATA 49,6B
029EA:  DATA 63,61
029EC:  DATA 42,55
029EE:  DATA 51,44
029F0:  DATA 20,0A
029F2:  DATA 67,41
029F4:  DATA 41,64
029F6:  DATA 41,42
029F8:  DATA 56,68
029FA:  DATA 52,69
029FC:  DATA 67,64
029FE:  DATA 61,2B
02A00:  DATA 69,77
02A02:  DATA 65,58
02A04:  DATA 34,62
02A06:  DATA 43,77
02A08:  DATA 35,63
02A0A:  DATA 50,42
02A0C:  DATA 52,58
02A0E:  DATA 6B,6A
02A10:  DATA 33,4D
02A12:  DATA 4C,67
02A14:  DATA 63,50
02A16:  DATA 68,6F
02A18:  DATA 38,6C
02A1A:  DATA 43,43
02A1C:  DATA 69,76
02A1E:  DATA 4A,48
02A20:  DATA 77,2F
02A22:  DATA 2F,77
02A24:  DATA 41,48
02A26:  DATA 43,58
02A28:  DATA 77,6F
02A2A:  DATA 2F,77
02A2C:  DATA 43,46
02A2E:  DATA 6B,66
02A30:  DATA 38,41
02A32:  DATA 42,4E
02A34:  DATA 76,57
02A36:  DATA 39,53
02A38:  DATA 56,6D
02A3A:  DATA 38,37
02A3C:  DATA 77,56
02A3E:  DATA 20,0A
02A40:  DATA 72,46
02A42:  DATA 68,72
02A44:  DATA 61,49
02A46:  DATA 71,37
02A48:  DATA 6D,6B
02A4A:  DATA 42,6B
02A4C:  DATA 2B,79
02A4E:  DATA 4F,50
02A50:  DATA 59,42
02A52:  DATA 4C,70
02A54:  DATA 32,50
02A56:  DATA 73,6C
02A58:  DATA 66,7A
02A5A:  DATA 38,34
02A5C:  DATA 78,58
02A5E:  DATA 39,56
02A60:  DATA 58,37
02A62:  DATA 55,66
02A64:  DATA 77,6E
02A66:  DATA 50,78
02A68:  DATA 34,2F
02A6A:  DATA 5A,74
02A6C:  DATA 38,66
02A6E:  DATA 65,43
02A70:  DATA 30,57
02A72:  DATA 4D,7A
02A74:  DATA 65,4B
02A76:  DATA 66,44
02A78:  DATA 39,39
02A7A:  DATA 70,63
02A7C:  DATA 42,6B
02A7E:  DATA 41,4B
02A80:  DATA 78,79
02A82:  DATA 79,77
02A84:  DATA 4F,6B
02A86:  DATA 62,38
02A88:  DATA 38,5A
02A8A:  DATA 56,79
02A8C:  DATA 20,0A
02A8E:  DATA 72,41
02A90:  DATA 39,69
02A92:  DATA 42,58
02A94:  DATA 38,34
02A96:  DATA 58,2F
02A98:  DATA 44,74
02A9A:  DATA 6A,39
02A9C:  DATA 6F,49
02A9E:  DATA 2F,77
02AA0:  DATA 44,4E
02AA2:  DATA 46,2F
02AA4:  DATA 69,58
02AA6:  DATA 2F,77
02AA8:  DATA 43,45
02AAA:  DATA 2F,63
02AAC:  DATA 2F,2F
02AAE:  DATA 41,42
02AB0:  DATA 46,66
02AB2:  DATA 6F,33
02AB4:  DATA 43,2B
02AB6:  DATA 4E,70
02AB8:  DATA 77,6F
02ABA:  DATA 79,70
02ABC:  DATA 31,4A
02ABE:  DATA 4A,57
02AC0:  DATA 65,6C
02AC2:  DATA 33,33
02AC4:  DATA 50,43
02AC6:  DATA 7A,72
02AC8:  DATA 44,79
02ACA:  DATA 6C,56
02ACC:  DATA 55,34
02ACE:  DATA 4B,2B
02AD0:  DATA 6E,51
02AD2:  DATA 6E,2B
02AD4:  DATA 46,6E
02AD6:  DATA 37,55
02AD8:  DATA 50,2F
02ADA:  DATA 20,0A
02ADC:  DATA 41,41
02ADE:  DATA 67,33
02AE0:  DATA 37,42
02AE2:  DATA 50,78
02AE4:  DATA 61,2B
02AE6:  DATA 46,30
02AE8:  DATA 6C,78
02AEA:  DATA 63,62
02AEC:  DATA 76,47
02AEE:  DATA 75,75
02AF0:  DATA 36,4A
02AF2:  DATA 65,57
02AF4:  DATA 73,49
02AF6:  DATA 48,79
02AF8:  DATA 42,49
02AFA:  DATA 44,50
02AFC:  DATA 4C,63
02AFE:  DATA 4D,53
02B00:  DATA 65,68
02B02:  DATA 4C,52
02B04:  DATA 57,51
02B06:  DATA 48,72
02B08:  DATA 74,48
02B0A:  DATA 70,58
02B0C:  DATA 68,5A
02B0E:  DATA 34,72
02B10:  DATA 33,43
02B12:  DATA 33,2F
02B14:  DATA 41,4F
02B16:  DATA 43,61
02B18:  DATA 48,37
02B1A:  DATA 51,6C
02B1C:  DATA 33,4D
02B1E:  DATA 73,61
02B20:  DATA 2F,42
02B22:  DATA 6E,34
02B24:  DATA 6A,68
02B26:  DATA 6D,36
02B28:  DATA 20,0A
02B2A:  DATA 62,39
02B2C:  DATA 42,6E
02B2E:  DATA 56,66
02B30:  DATA 78,4C
02B32:  DATA 4B,41
02B34:  DATA 4B,76
02B36:  DATA 66,38
02B38:  DATA 4F,73
02B3A:  DATA 66,32
02B3C:  DATA 69,69
02B3E:  DATA 66,2B
02B40:  DATA 53,4F
02B42:  DATA 65,4F
02B44:  DATA 76,2F
02B46:  DATA 41,41
02B48:  DATA 58,4E
02B4A:  DATA 58,30
02B4C:  DATA 46,50
02B4E:  DATA 45,59
02B50:  DATA 53,6D
02B52:  DATA 32,34
02B54:  DATA 7A,58
02B56:  DATA 76,4F
02B58:  DATA 2B,36
02B5A:  DATA 50,4A
02B5C:  DATA 6C,52
02B5E:  DATA 72,79
02B60:  DATA 73,6E
02B62:  DATA 46,36
02B64:  DATA 4B,32
02B66:  DATA 78,37
02B68:  DATA 42,2F
02B6A:  DATA 77,54
02B6C:  DATA 77,2F
02B6E:  DATA 62,2F
02B70:  DATA 30,33
02B72:  DATA 2F,67
02B74:  DATA 6E,56
02B76:  DATA 20,0A
02B78:  DATA 2B,78
02B7A:  DATA 72,38
02B7C:  DATA 53,4E
02B7E:  DATA 59,30
02B80:  DATA 58,37
02B82:  DATA 4C,66
02B84:  DATA 2F,46
02B86:  DATA 4C,34
02B88:  DATA 68,61
02B8A:  DATA 76,44
02B8C:  DATA 70,57
02B8E:  DATA 6A,57
02B90:  DATA 63,67
02B92:  DATA 33,72
02B94:  DATA 59,51
02B96:  DATA 57,73
02B98:  DATA 42,59
02B9A:  DATA 33,73
02B9C:  DATA 79,2F
02B9E:  DATA 38,41
02BA0:  DATA 50,4D
02BA2:  DATA 50,64
02BA4:  DATA 73,45
02BA6:  DATA 58,2F
02BA8:  DATA 41,4A
02BAA:  DATA 61,4F
02BAC:  DATA 43,4F
02BAE:  DATA 51,6A
02BB0:  DATA 6B,63
02BB2:  DATA 41,50
02BB4:  DATA 2B,43
02BB6:  DATA 7A,2F
02BB8:  DATA 41,4F
02BBA:  DATA 30,39
02BBC:  DATA 6A,6A
02BBE:  DATA 34,74
02BC0:  DATA 61,7A
02BC2:  DATA 6A,2F
02BC4:  DATA 20,0A
02BC6:  DATA 41,4B
02BC8:  DATA 38,72
02BCA:  DATA 50,2F
02BCC:  DATA 34,7A
02BCE:  DATA 58,50
02BD0:  DATA 66,38
02BD2:  DATA 4F,73
02BD4:  DATA 66,32
02BD6:  DATA 69,76
02BD8:  DATA 38,41
02BDA:  DATA 6F,6A
02BDC:  DATA 6E,6A
02BDE:  DATA 76,2F
02BE0:  DATA 77,58
02BE2:  DATA 4E,2F
02BE4:  DATA 6B,2F
02BE6:  DATA 79,2F
02BE8:  DATA 6C,52
02BEA:  DATA 2F,77
02BEC:  DATA 41,4F
02BEE:  DATA 73,50
02BF0:  DATA 32,69
02BF2:  DATA 2F,77
02BF4:  DATA 44,6F
02BF6:  DATA 6A,66
02BF8:  DATA 6A,72
02BFA:  DATA 2F,77
02BFC:  DATA 41,46
02BFE:  DATA 7A,56
02C00:  DATA 7A,52
02C02:  DATA 70,35
02C04:  DATA 64,7A
02C06:  DATA 79,71
02C08:  DATA 56,48
02C0A:  DATA 47,54
02C0C:  DATA 6B,37
02C0E:  DATA 36,32
02C10:  DATA 66,70
02C12:  DATA 20,0A
02C14:  DATA 75,62
02C16:  DATA 38,2B
02C18:  DATA 4C,55
02C1A:  DATA 56,47
02C1C:  DATA 43,61
02C1E:  DATA 53,39
02C20:  DATA 54,39
02C22:  DATA 55,76
02C24:  DATA 2B,43
02C26:  DATA 61,76
02C28:  DATA 37,58
02C2A:  DATA 58,78
02C2C:  DATA 49,38
02C2E:  DATA 5A,66
02C30:  DATA 38,45
02C32:  DATA 71,66
02C34:  DATA 69,31
02C36:  DATA 38,57
02C38:  DATA 76,69
02C3A:  DATA 52,34
02C3C:  DATA 6F,76
02C3E:  DATA 50,45
02C40:  DATA 57,71
02C42:  DATA 61,54
02C44:  DATA 2F,62
02C46:  DATA 45,32
02C48:  DATA 6C,54
02C4A:  DATA 58,43
02C4C:  DATA 52,51
02C4E:  DATA 46,49
02C50:  DATA 62,57
02C52:  DATA 77,52
02C54:  DATA 6B,56
02C56:  DATA 66,4C
02C58:  DATA 52,52
02C5A:  DATA 6C,72
02C5C:  DATA 67,79
02C5E:  DATA 41,48
02C60:  DATA 20,0A
02C62:  DATA 42,50
02C64:  DATA 54,6B
02C66:  DATA 39,4B
02C68:  DATA 2F,43
02C6A:  DATA 2F,4F
02C6C:  DATA 61,2F
02C6E:  DATA 63,4C
02C70:  DATA 56,2F
02C72:  DATA 32,58
02C74:  DATA 2F,69
02C76:  DATA 46,38
02C78:  DATA 4C,50
02C7A:  DATA 2B,44
02C7C:  DATA 66,71
02C7E:  DATA 33,2B
02C80:  DATA 47,65
02C82:  DATA 69,65
02C84:  DATA 45,74
02C86:  DATA 61,76
02C88:  DATA 50,69
02C8A:  DATA 42,72
02C8C:  DATA 56,6E
02C8E:  DATA 47,74
02C90:  DATA 31,70
02C92:  DATA 56,74
02C94:  DATA 62,6C
02C96:  DATA 72,75
02C98:  DATA 4A,72
02C9A:  DATA 6E,55
02C9C:  DATA 2F,74
02C9E:  DATA 45,77
02CA0:  DATA 64,65
02CA2:  DATA 78,57
02CA4:  DATA 41,73
02CA6:  DATA 70,39
02CA8:  DATA 4D,56
02CAA:  DATA 2B,58
02CAC:  DATA 66,2F
02CAE:  DATA 20,0A
02CB0:  DATA 41,41
02CB2:  DATA 36,77
02CB4:  DATA 2F,61
02CB6:  DATA 4C,7A
02CB8:  DATA 2F,77
02CBA:  DATA 41,6B
02CBC:  DATA 62,38
02CBE:  DATA 64,66
02CC0:  DATA 2B,43
02CC2:  DATA 31,71
02CC4:  DATA 34,4D
02CC6:  DATA 6D,72
02CC8:  DATA 34,65
02CCA:  DATA 45,36
02CCC:  DATA 30,32
02CCE:  DATA 31,46
02CD0:  DATA 4F,57
02CD2:  DATA 6D,71
02CD4:  DATA 32,52
02CD6:  DATA 30,35
02CD8:  DATA 68,54
02CDA:  DATA 72,53
02CDC:  DATA 6A,54
02CDE:  DATA 68,5A
02CE0:  DATA 74,70
02CE2:  DATA 61,2B
02CE4:  DATA 70,37
02CE6:  DATA 48,2F
02CE8:  DATA 41,4D
02CEA:  DATA 47,39
02CEC:  DATA 50,77
02CEE:  DATA 7A,2F
02CF0:  DATA 41,4F
02CF2:  DATA 45,39
02CF4:  DATA 2F,77
02CF6:  DATA 43,43
02CF8:  DATA 6B,57
02CFA:  DATA 6A,61
02CFC:  DATA 20,0A
02CFE:  DATA 6B,30
02D00:  DATA 66,6D
02D02:  DATA 52,2B
02D04:  DATA 45,4E
02D06:  DATA 47,31
02D08:  DATA 44,56
02D0A:  DATA 7A,6E
02D0C:  DATA 6F,70
02D0E:  DATA 61,4D
02D10:  DATA 57,69
02D12:  DATA 6B,2F
02D14:  DATA 6A,64
02D16:  DATA 6A,48
02D18:  DATA 76,39
02D1A:  DATA 4B,2F
02D1C:  DATA 6F,46
02D1E:  DATA 33,63
02D20:  DATA 44,36
02D22:  DATA 31,2B
02D24:  DATA 57,66
02D26:  DATA 2F,42
02D28:  DATA 76,48
02D2A:  DATA 2B,78
02D2C:  DATA 42,34
02D2E:  DATA 2B,2F
02D30:  DATA 5A,7A
02D32:  DATA 38,63
02D34:  DATA 2F,45
02D36:  DATA 7A,78
02D38:  DATA 4A,38
02D3A:  DATA 51,50
02D3C:  DATA 42,32
02D3E:  DATA 73,65
02D40:  DATA 45,37
02D42:  DATA 71,35
02D44:  DATA 73,4C
02D46:  DATA 4C,54
02D48:  DATA 64,4D
02D4A:  DATA 20,0A
02D4C:  DATA 47,70
02D4E:  DATA 57,33
02D50:  DATA 6C,50
02D52:  DATA 63,6F
02D54:  DATA 30,6B
02D56:  DATA 73,73
02D58:  DATA 2B,7A
02D5A:  DATA 76,67
02D5C:  DATA 47,4F
02D5E:  DATA 44,50
02D60:  DATA 71,53
02D62:  DATA 50,53
02D64:  DATA 76,31
02D66:  DATA 4A,4C
02D68:  DATA 63,66
02D6A:  DATA 72,78
02D6C:  DATA 58,7A
02D6E:  DATA 66,45
02D70:  DATA 57,49
02D72:  DATA 6A,57
02D74:  DATA 78,6A
02D76:  DATA 63,48
02D78:  DATA 64,4A
02D7A:  DATA 4A,61
02D7C:  DATA 48,74
02D7E:  DATA 5A,50
02D80:  DATA 52,64
02D82:  DATA 50,44
02D84:  DATA 72,6D
02D86:  DATA 56,6D
02D88:  DATA 32,66
02D8A:  DATA 7A,39
02D8C:  DATA 2F,77
02D8E:  DATA 44,42
02D90:  DATA 77,6E
02D92:  DATA 38,53
02D94:  DATA 2F,77
02D96:  DATA 44,68
02D98:  DATA 20,0A
02D9A:  DATA 50,50
02D9C:  DATA 38,41
02D9E:  DATA 67,70
02DA0:  DATA 52,72
02DA2:  DATA 6D,6E
02DA4:  DATA 71,34
02DA6:  DATA 5A,50
02DA8:  DATA 43,4F
02DAA:  DATA 6A,61
02DAC:  DATA 66,70
02DAE:  DATA 43,6B
02DB0:  DATA 5A,34
02DB2:  DATA 4A,69
02DB4:  DATA 4E,30
02DB6:  DATA 77,39
02DB8:  DATA 4F,44
02DBA:  DATA 64,48
02DBC:  DATA 38,51
02DBE:  DATA 61,2B
02DC0:  DATA 49,64
02DC2:  DATA 6D,34
02DC4:  DATA 65,2B
02DC6:  DATA 4D,67
02DC8:  DATA 44,30
02DCA:  DATA 2F,77
02DCC:  DATA 41,69
02DCE:  DATA 76,74
02DD0:  DATA 48,39
02DD2:  DATA 75,62
02DD4:  DATA 39,67
02DD6:  DATA 7A,39
02DD8:  DATA 6F,54
02DDA:  DATA 34,37
02DDC:  DATA 2F,74
02DDE:  DATA 6A,66
02DE0:  DATA 45,7A
02DE2:  DATA 78,66
02DE4:  DATA 5A,2F
02DE6:  DATA 20,0A
02DE8:  DATA 43,50
02DEA:  DATA 78,78
02DEC:  DATA 65,61
02DEE:  DATA 66,72
02DF0:  DATA 66,69
02DF2:  DATA 4F,39
02DF4:  DATA 6D,73
02DF6:  DATA 4A,6C
02DF8:  DATA 30,39
02DFA:  DATA 69,73
02DFC:  DATA 74,71
02DFE:  DATA 4A,57
02E00:  DATA 53,42
02E02:  DATA 76,78
02E04:  DATA 69,57
02E06:  DATA 4F,76
02E08:  DATA 4B,78
02E0A:  DATA 2F,77
02E0C:  DATA 53,78
02E0E:  DATA 2F,61
02E10:  DATA 4B,48
02E12:  DATA 2F,4E
02E14:  DATA 47,2F
02E16:  DATA 48,58
02E18:  DATA 62,2F
02E1A:  DATA 6D,48
02E1C:  DATA 4E,32
02E1E:  DATA 2F,7A
02E20:  DATA 2B,46
02E22:  DATA 66,61
02E24:  DATA 35,66
02E26:  DATA 69,4D
02E28:  DATA 50,54
02E2A:  DATA 77,73
02E2C:  DATA 4B,66
02E2E:  DATA 74,46
02E30:  DATA 6F,6B
02E32:  DATA 74,30
02E34:  DATA 20,0A
02E36:  DATA 66,4E
02E38:  DATA 34,71
02E3A:  DATA 6A,57
02E3C:  DATA 6E,57
02E3E:  DATA 6C,4C
02E40:  DATA 6C,65
02E42:  DATA 72,37
02E44:  DATA 48,30
02E46:  DATA 33,2B
02E48:  DATA 32,50
02E4A:  DATA 2F,77
02E4C:  DATA 41,46
02E4E:  DATA 6D,50
02E50:  DATA 45,33
02E52:  DATA 77,70
02E54:  DATA 38,4D
02E56:  DATA 2B,42
02E58:  DATA 76,68
02E5A:  DATA 4A,38
02E5C:  DATA 42,66
02E5E:  DATA 45,54
02E60:  DATA 61,4C
02E62:  DATA 6F,50
02E64:  DATA 77,31
02E66:  DATA 30,61
02E68:  DATA 7A,30
02E6A:  DATA 69,2B
02E6C:  DATA 38,51
02E6E:  DATA 57,38
02E70:  DATA 45,4D
02E72:  DATA 7A,61
02E74:  DATA 7A,63
02E76:  DATA 57,39
02E78:  DATA 75,6B
02E7A:  DATA 4C,43
02E7C:  DATA 45,75
02E7E:  DATA 72,72
02E80:  DATA 39,6E
02E82:  DATA 20,0A
02E84:  DATA 58,61
02E86:  DATA 66,6D
02E88:  DATA 41,7A
02E8A:  DATA 49,78
02E8C:  DATA 4C,41
02E8E:  DATA 37,51
02E90:  DATA 70,66
02E92:  DATA 77,55
02E94:  DATA 66,38
02E96:  DATA 46,6E
02E98:  DATA 76,32
02E9A:  DATA 6E,76
02E9C:  DATA 2B,69
02E9E:  DATA 74,61
02EA0:  DATA 7A,36
02EA2:  DATA 66,38
02EA4:  DATA 65,64
02EA6:  DATA 6E,2F
02EA8:  DATA 41,50
02EAA:  DATA 47,61
02EAC:  DATA 35,34
02EAE:  DATA 66,38
02EB0:  DATA 45,72
02EB2:  DATA 2F,32
02EB4:  DATA 69,6C
02EB6:  DATA 48,2F
02EB8:  DATA 41,43
02EBA:  DATA 52,76
02EBC:  DATA 78,31
02EBE:  DATA 2F,34
02EC0:  DATA 4C,57
02EC2:  DATA 6F,48
02EC4:  DATA 2F,42
02EC6:  DATA 4B,37
02EC8:  DATA 39,6F
02ECA:  DATA 75,52
02ECC:  DATA 39,76
02ECE:  DATA 38,41
02ED0:  DATA 20,0A
02ED2:  DATA 77,70
02ED4:  DATA 7A,78
02ED6:  DATA 78,6C
02ED8:  DATA 75,50
02EDA:  DATA 6D,30
02EDC:  DATA 39,6C
02EDE:  DATA 48,2B
02EE0:  DATA 65,61
02EE2:  DATA 79,70
02EE4:  DATA 55,73
02EE6:  DATA 73,70
02EE8:  DATA 77,73
02EEA:  DATA 2B,56
02EEC:  DATA 39,62
02EEE:  DATA 36,4E
02EF0:  DATA 73,71
02EF2:  DATA 56,54
02EF4:  DATA 47,53
02EF6:  DATA 6C,72
02EF8:  DATA 7A,4C
02EFA:  DATA 74,61
02EFC:  DATA 35,2B
02EFE:  DATA 35,76
02F00:  DATA 37,47
02F02:  DATA 76,68
02F04:  DATA 66,56
02F06:  DATA 2F,77
02F08:  DATA 42,72
02F0A:  DATA 4C,2F
02F0C:  DATA 67,6C
02F0E:  DATA 2F,77
02F10:  DATA 43,47
02F12:  DATA 64,50
02F14:  DATA 38,41
02F16:  DATA 69,78
02F18:  DATA 71,46
02F1A:  DATA 31,34
02F1C:  DATA 6C,76
02F1E:  DATA 20,0A
02F20:  DATA 2F,69
02F22:  DATA 50,34
02F24:  DATA 62,6E
02F26:  DATA 4F,72
02F28:  DATA 58,63
02F2A:  DATA 71,70
02F2C:  DATA 46,4E
02F2E:  DATA 50,42
02F30:  DATA 65,47
02F32:  DATA 56,34
02F34:  DATA 69,4E
02F36:  DATA 69,68
02F38:  DATA 56,4B
02F3A:  DATA 51,79
02F3C:  DATA 52,68
02F3E:  DATA 53,46
02F40:  DATA 79,4E
02F42:  DATA 6F,50
02F44:  DATA 58,6D
02F46:  DATA 76,77
02F48:  DATA 49,2F
02F4A:  DATA 62,48
02F4C:  DATA 2F,5A
02F4E:  DATA 4A,38
02F50:  DATA 56,66
02F52:  DATA 73,55
02F54:  DATA 2F,48
02F56:  DATA 66,56
02F58:  DATA 2F,41
02F5A:  DATA 2F,69
02F5C:  DATA 71,32
02F5E:  DATA 6B,57
02F60:  DATA 53,78
02F62:  DATA 6B,61
02F64:  DATA 53,77
02F66:  DATA 76,67
02F68:  DATA 68,45
02F6A:  DATA 47,71
02F6C:  DATA 20,0A
02F6E:  DATA 32,70
02F70:  DATA 4A,38
02F72:  DATA 71,35
02F74:  DATA 69,50
02F76:  DATA 54,44
02F78:  DATA 41,63
02F7A:  DATA 6A,4A
02F7C:  DATA 32,74
02F7E:  DATA 6C,54
02F80:  DATA 67,67
02F82:  DATA 69,76
02F84:  DATA 36,62
02F86:  DATA 50,67
02F88:  DATA 78,38
02F8A:  DATA 50,6F
02F8C:  DATA 2F,68
02F8E:  DATA 4E,38
02F90:  DATA 48,2F
02F92:  DATA 41,41
02F94:  DATA 6E,34
02F96:  DATA 56,74
02F98:  DATA 38,43
02F9A:  DATA 44,77
02F9C:  DATA 31,6F
02F9E:  DATA 31,70
02FA0:  DATA 70,4D
02FA2:  DATA 65,4F
02FA4:  DATA 79,77
02FA6:  DATA 51,70
02FA8:  DATA 45,50
02FAA:  DATA 30,57
02FAC:  DATA 75,48
02FAE:  DATA 2F,62
02FB0:  DATA 47,2F
02FB2:  DATA 59,66
02FB4:  DATA 38,41
02FB6:  DATA 68,37
02FB8:  DATA 2B,33
02FBA:  DATA 20,0A
02FBC:  DATA 4E,38
02FBE:  DATA 4E,2F
02FC0:  DATA 2B,45
02FC2:  DATA 62,38
02FC4:  DATA 65,61
02FC6:  DATA 52,39
02FC8:  DATA 70,2B
02FCA:  DATA 7A,37
02FCC:  DATA 6E,30
02FCE:  DATA 2F,55
02FD0:  DATA 72,5A
02FD2:  DATA 68,46
02FD4:  DATA 66,36
02FD6:  DATA 58,49
02FD8:  DATA 77,77
02FDA:  DATA 58,67
02FDC:  DATA 6C,77
02FDE:  DATA 53,75
02FE0:  DATA 63,44
02FE2:  DATA 4B,6B
02FE4:  DATA 46,57
02FE6:  DATA 77,4D
02FE8:  DATA 71,63
02FEA:  DATA 44,48
02FEC:  DATA 79,65
02FEE:  DATA 57,35
02FF0:  DATA 78,39
02FF2:  DATA 55,72
02FF4:  DATA 7A,75
02FF6:  DATA 76,63
02FF8:  DATA 6B,39
02FFA:  DATA 75,33
02FFC:  DATA 61,78
02FFE:  DATA 37,32
03000:  DATA 4D,79
03002:  DATA 37,32
03004:  DATA 39,47
03006:  DATA 4B,76
03008:  DATA 20,0A
0300A:  DATA 37,79
0300C:  DATA 57,35
0300E:  DATA 2F,4C
03010:  DATA 75,4F
03012:  DATA 6E,6F
03014:  DATA 71,34
03016:  DATA 35,2F
03018:  DATA 72,2F
0301A:  DATA 41,45
0301C:  DATA 79,66
0301E:  DATA 30,37
03020:  DATA 2B,39
03022:  DATA 66,73
03024:  DATA 77,66
03026:  DATA 38,46
03028:  DATA 4E,50
0302A:  DATA 6A,62
0302C:  DATA 2B,78
0302E:  DATA 2F,70
03030:  DATA 30,57
03032:  DATA 6E,65
03034:  DATA 43,66
03036:  DATA 48,47
03038:  DATA 6F,57
0303A:  DATA 2B,68
0303C:  DATA 77,37
0303E:  DATA 69,75
03040:  DATA 6B,58
03042:  DATA 30,61
03044:  DATA 58,74
03046:  DATA 67,6D
03048:  DATA 65,53
0304A:  DATA 45,6A
0304C:  DATA 6C,44
0304E:  DATA 65,56
03050:  DATA 6B,35
03052:  DATA 4A,38
03054:  DATA 73,72
03056:  DATA 20,0A
03058:  DATA 6B,38
0305A:  DATA 6E,71
0305C:  DATA 52,58
0305E:  DATA 30,4C
03060:  DATA 2B,31
03062:  DATA 64,2F
03064:  DATA 77,62
03066:  DATA 76,2F
03068:  DATA 41,42
0306A:  DATA 6D,2B
0306C:  DATA 44,4F
0306E:  DATA 71,58
03070:  DATA 56,35
03072:  DATA 34,44
03074:  DATA 4E,6A
03076:  DATA 38,54
03078:  DATA 50,44
0307A:  DATA 36,6C
0307C:  DATA 6D,6A
0307E:  DATA 61,31
03080:  DATA 6B,53
03082:  DATA 30,31
03084:  DATA 53,46
03086:  DATA 4D,66
03088:  DATA 38,74
0308A:  DATA 49,4A
0308C:  DATA 47,43
0308E:  DATA 73,52
03090:  DATA 30,48
03092:  DATA 6C,4F
03094:  DATA 35,62
03096:  DATA 72,74
03098:  DATA 58,70
0309A:  DATA 58,78
0309C:  DATA 35,34
0309E:  DATA 31,2F
030A0:  DATA 5A,61
030A2:  DATA 2B,4A
030A4:  DATA 20,0A
030A6:  DATA 6E,77
030A8:  DATA 33,76
030AA:  DATA 48,74
030AC:  DATA 2F,45
030AE:  DATA 48,77
030B0:  DATA 37,38
030B2:  DATA 63,61
030B4:  DATA 4A,4E
030B6:  DATA 48,31
030B8:  DATA 57,2B
030BA:  DATA 30,4F
030BC:  DATA 35,67
030BE:  DATA 34,39
030C0:  DATA 52,75
030C2:  DATA 54,6B
030C4:  DATA 65,34
030C6:  DATA 4A,48
030C8:  DATA 76,58
030CA:  DATA 33,45
030CC:  DATA 63,56
030CE:  DATA 67,73
030D0:  DATA 5A,47
030D2:  DATA 33,4D
030D4:  DATA 70,4C
030D6:  DATA 73,2B
030D8:  DATA 6E,79
030DA:  DATA 5A,38
030DC:  DATA 32,36
030DE:  DATA 4F,4A
030E0:  DATA 6F,54
030E2:  DATA 76,71
030E4:  DATA 6E,2F
030E6:  DATA 41,46
030E8:  DATA 31,52
030EA:  DATA 39,39
030EC:  DATA 2F,73
030EE:  DATA 6E,66
030F0:  DATA 38,41
030F2:  DATA 20,0A
030F4:  DATA 42,63
030F6:  DATA 6E,39
030F8:  DATA 6F,62
030FA:  DATA 39,70
030FC:  DATA 58,39
030FE:  DATA 71,48
03100:  DATA 34,62
03102:  DATA 2B,42
03104:  DATA 5A,70
03106:  DATA 76,43
03108:  DATA 46,6E
0310A:  DATA 5A,2B
0310C:  DATA 49,76
0310E:  DATA 45,4E
03110:  DATA 6C,5A
03112:  DATA 58,38
03114:  DATA 74,70
03116:  DATA 6F,2B
03118:  DATA 4A,6D
0311A:  DATA 74,57
0311C:  DATA 6D,54
0311E:  DATA 7A,79
03120:  DATA 43,37
03122:  DATA 73,41
03124:  DATA 33,6C
03126:  DATA 43,51
03128:  DATA 35,41
0312A:  DATA 47,4F
0312C:  DATA 31,66
0312E:  DATA 74,66
03130:  DATA 32,48
03132:  DATA 30,72
03134:  DATA 38,42
03136:  DATA 2F,2B
03138:  DATA 43,42
0313A:  DATA 2F,37
0313C:  DATA 4F,2B
0313E:  DATA 75,2B
03140:  DATA 20,0A
03142:  DATA 49,50
03144:  DATA 38,41
03146:  DATA 67,6F
03148:  DATA 6C,34
0314A:  DATA 62,31
0314C:  DATA 7A,55
0314E:  DATA 64,42
03150:  DATA 31,61
03152:  DATA 32,30
03154:  DATA 7A,77
03156:  DATA 72,70
03158:  DATA 39,2F
0315A:  DATA 71,52
0315C:  DATA 6E,75
0315E:  DATA 62,4B
03160:  DATA 53,4F
03162:  DATA 45,79
03164:  DATA 47,45
03166:  DATA 32,36
03168:  DATA 44,63
0316A:  DATA 77,41
0316C:  DATA 33,42
0316E:  DATA 72,6A
03170:  DATA 49,41
03172:  DATA 4F,66
03174:  DATA 6C,72
03176:  DATA 39,2B
03178:  DATA 46,35
0317A:  DATA 72,34
0317C:  DATA 58,69
0317E:  DATA 4B,6E
03180:  DATA 51,70
03182:  DATA 34,68
03184:  DATA 55,36
03186:  DATA 43,53
03188:  DATA 53,58
0318A:  DATA 54,71
0318C:  DATA 66,54
0318E:  DATA 20,0A
03190:  DATA 5A,50
03192:  DATA 4B,72
03194:  DATA 4B,6B
03196:  DATA 35,56
03198:  DATA 64,37
0319A:  DATA 68,6B
0319C:  DATA 49,4F
0319E:  DATA 76,48
031A0:  DATA 57,76
031A2:  DATA 78,4E
031A4:  DATA 2B,4D
031A6:  DATA 58,6A
031A8:  DATA 49,2F
031AA:  DATA 45,54
031AC:  DATA 34,73
031AE:  DATA 2B,4A
031B0:  DATA 74,65
031B2:  DATA 33,5A
031B4:  DATA 47,73
031B6:  DATA 61,70
031B8:  DATA 63,33
031BA:  DATA 71,59
031BC:  DATA 37,42
031BE:  DATA 35,57
031C0:  DATA 5A,52
031C2:  DATA 2B,52
031C4:  DATA 41,72
031C6:  DATA 39,72
031C8:  DATA 72,79
031CA:  DATA 79,6A
031CC:  DATA 76,72
031CE:  DATA 57,53
031D0:  DATA 47,52
031D2:  DATA 53,30
031D4:  DATA 55,79
031D6:  DATA 46,48
031D8:  DATA 41,59
031DA:  DATA 72,6B
031DC:  DATA 20,0A
031DE:  DATA 48,67
031E0:  DATA 6A,49
031E2:  DATA 35,48
031E4:  DATA 58,71
031E6:  DATA 4F,61
031E8:  DATA 38,56
031EA:  DATA 2F,77
031EC:  DATA 43,48
031EE:  DATA 63,50
031F0:  DATA 77,58
031F2:  DATA 50,2F
031F4:  DATA 4D,6B
031F6:  DATA 77,66
031F8:  DATA 38,41
031FA:  DATA 67,78
031FC:  DATA 75,2F
031FE:  DATA 2F,6A
03200:  DATA 74,65
03202:  DATA 43,65
03204:  DATA 73,66
03206:  DATA 6E,44
03208:  DATA 38,50
0320A:  DATA 2F,77
0320C:  DATA 42,70
0320E:  DATA 2F,57
03210:  DATA 76,68
03212:  DATA 78,70
03214:  DATA 58,68
03216:  DATA 69,33
03218:  DATA 73,64
0321A:  DATA 4E,30
0321C:  DATA 57,53
0321E:  DATA 62,77
03220:  DATA 6C,63
03222:  DATA 33,4E
03224:  DATA 7A,5A
03226:  DATA 58,4D
03228:  DATA 73,63
0322A:  DATA 20,0A
0322C:  DATA 6E,6E
0322E:  DATA 45,54
03230:  DATA 62,53
03232:  DATA 38,62
03234:  DATA 45,4F
03236:  DATA 42,73
03238:  DATA 4C,4B
0323A:  DATA 70,4A
0323C:  DATA 55,4B
0323E:  DATA 35,41
03240:  DATA 32,37
03242:  DATA 74,75
03244:  DATA 56,4E
03246:  DATA 50,51
03248:  DATA 50,32
0324A:  DATA 68,39
0324C:  DATA 57,38
0324E:  DATA 50,61
03250:  DATA 39,34
03252:  DATA 62,76
03254:  DATA 6F,64
03256:  DATA 50,30
03258:  DATA 64,6C
0325A:  DATA 38,4B
0325C:  DATA 77,58
0325E:  DATA 63,4E
03260:  DATA 70,62
03262:  DATA 6D,4B
03264:  DATA 52,59
03266:  DATA 57,4E
03268:  DATA 79,30
0326A:  DATA 37,74
0326C:  DATA 49,77
0326E:  DATA 44,67
03270:  DATA 37,31
03272:  DATA 4D,2F
03274:  DATA 79,37
03276:  DATA 53,6F
03278:  DATA 20,0A
0327A:  DATA 41,69
0327C:  DATA 6A,34
0327E:  DATA 34,4F
03280:  DATA 37,39
03282:  DATA 4B,76
03284:  DATA 38,41
03286:  DATA 68,33
03288:  DATA 42,38
0328A:  DATA 46,76
0328C:  DATA 38,41
0328E:  DATA 6F,53
03290:  DATA 59,66
03292:  DATA 2F,42
03294:  DATA 6A,65
03296:  DATA 66,2F
03298:  DATA 48,61
0329A:  DATA 50,2B
0329C:  DATA 48,63
0329E:  DATA 48,77
032A0:  DATA 57,2F
032A2:  DATA 36,45
032A4:  DATA 6D,48
032A6:  DATA 2F,77
032A8:  DATA 41,47
032AA:  DATA 4E,35
032AC:  DATA 2F,38
032AE:  DATA 64,6F
032B0:  DATA 41,2F
032B2:  DATA 4E,47
032B4:  DATA 37,2F
032B6:  DATA 41,47
032B8:  DATA 67,64
032BA:  DATA 57,75
032BC:  DATA 64,4A
032BE:  DATA 30,2B
032C0:  DATA 4E,62
032C2:  DATA 50,53
032C4:  DATA 72,66
032C6:  DATA 20,0A
032C8:  DATA 55,74
032CA:  DATA 4E,30
032CC:  DATA 71,54
032CE:  DATA 52,49
032D0:  DATA 64,55
032D2:  DATA 68,69
032D4:  DATA 64,4C
032D6:  DATA 68,62
032D8:  DATA 53,51
032DA:  DATA 79,46
032DC:  DATA 6B,43
032DE:  DATA 68,2F
032E0:  DATA 4B,55
032E2:  DATA 6C,5A
032E4:  DATA 70,59
032E6:  DATA 39,79
032E8:  DATA 6F,47
032EA:  DATA 43,4E
032EC:  DATA 67,64
032EE:  DATA 4D,31
032F0:  DATA 6E,2B
032F2:  DATA 50,66
032F4:  DATA 69,74
032F6:  DATA 64,65
032F8:  DATA 4F,64
032FA:  DATA 4A,74
032FC:  DATA 64,4E
032FE:  DATA 6A,73
03300:  DATA 4E,50
03302:  DATA 30,58
03304:  DATA 53,4C
03306:  DATA 53,36
03308:  DATA 6D,76
0330A:  DATA 6F,74
0330C:  DATA 50,73
0330E:  DATA 50,4E
03310:  DATA 2B,7A
03312:  DATA 78,54
03314:  DATA 20,0A
03316:  DATA 7A,4C
03318:  DATA 47,73
0331A:  DATA 6A,71
0331C:  DATA 4A,5A
0331E:  DATA 48,4B
03320:  DATA 37,76
03322:  DATA 4B,58
03324:  DATA 35,56
03326:  DATA 49,56
03328:  DATA 65,63
0332A:  DATA 41,5A
0332C:  DATA 72,39
0332E:  DATA 50,76
03330:  DATA 38,41
03332:  DATA 68,33
03334:  DATA 42,38
03336:  DATA 46,76
03338:  DATA 38,41
0333A:  DATA 6F,53
0333C:  DATA 59,66
0333E:  DATA 2F,42
03340:  DATA 6A,65
03342:  DATA 66,2F
03344:  DATA 48,61
03346:  DATA 50,2B
03348:  DATA 48,63
0334A:  DATA 48,77
0334C:  DATA 57,2F
0334E:  DATA 36,45
03350:  DATA 6D,48
03352:  DATA 2F,77
03354:  DATA 41,47
03356:  DATA 4E,35
03358:  DATA 2F,38
0335A:  DATA 64,6F
0335C:  DATA 41,2B
0335E:  DATA 64,66
03360:  DATA 38,41
03362:  DATA 20,0A
03364:  DATA 67,6A
03366:  DATA 4A,34
03368:  DATA 4F,38
0336A:  DATA 37,78
0336C:  DATA 48,34
0336E:  DATA 34,38
03370:  DATA 51,4D
03372:  DATA 71,67
03374:  DATA 32,39
03376:  DATA 74,62
03378:  DATA 32,45
0337A:  DATA 54,48
0337C:  DATA 72,2B
0337E:  DATA 38,5A
03380:  DATA 33,66
03382:  DATA 6E,30
03384:  DATA 2F,64
03386:  DATA 52,6B
03388:  DATA 2F,55
0338A:  DATA 56,39
0338C:  DATA 39,43
0338E:  DATA 75,51
03390:  DATA 2B,45
03392:  DATA 48,77
03394:  DATA 4A,38
03396:  DATA 4B,2F
03398:  DATA 41,58
0339A:  DATA 52,72
0339C:  DATA 72,54
0339E:  DATA 2F,43
033A0:  DATA 57,6B
033A2:  DATA 78,36
033A4:  DATA 50,5A
033A6:  DATA 33,73
033A8:  DATA 2F,77
033AA:  DATA 42,6F
033AC:  DATA 6D,6A
033AE:  DATA 57,61
033B0:  DATA 20,0A
033B2:  DATA 53,62
033B4:  DATA 66,4A
033B6:  DATA 74,43
033B8:  DATA 35,7A
033BA:  DATA 49,7A
033BC:  DATA 48,6F
033BE:  DATA 41,4D
033C0:  DATA 5A,78
033C2:  DATA 58,58
033C4:  DATA 6A,70
033C6:  DATA 51,41
033C8:  DATA 55,55
033CA:  DATA 55,55
033CC:  DATA 41,4E
033CE:  DATA 59,38
033D0:  DATA 56,78
033D2:  DATA 66,78
033D4:  DATA 6D,2F
033D6:  DATA 61,49
033D8:  DATA 38,43
033DA:  DATA 2F,73
033DC:  DATA 37,61
033DE:  DATA 50,61
033E0:  DATA 36,68
033E2:  DATA 34,36
033E4:  DATA 38,57
033E6:  DATA 61,48
033E8:  DATA 34,54
033EA:  DATA 73,72
033EC:  DATA 36,59
033EE:  DATA 32,39
033F0:  DATA 74,50
033F2:  DATA 71,64
033F4:  DATA 32,6C
033F6:  DATA 75,6B
033F8:  DATA 30,67
033FA:  DATA 58,63
033FC:  DATA 56,55
033FE:  DATA 20,0A
03400:  DATA 73,65
03402:  DATA 53,46
03404:  DATA 47,63
03406:  DATA 65,67
03408:  DATA 72,74
0340A:  DATA 53,4D
0340C:  DATA 31,38
0340E:  DATA 78,66
03410:  DATA 38,46
03412:  DATA 63,79
03414:  DATA 32,72
03416:  DATA 2F,73
03418:  DATA 5A,58
0341A:  DATA 2F,68
0341C:  DATA 61,48
0341E:  DATA 42,31
03420:  DATA 44,34
03422:  DATA 68,61
03424:  DATA 39,6F
03426:  DATA 76,68
03428:  DATA 57,30
0342A:  DATA 47,4D
0342C:  DATA 37,6D
0342E:  DATA 75,39
03430:  DATA 53,74
03432:  DATA 30,64
03434:  DATA 52,79
03436:  DATA 4F,73
03438:  DATA 51,6B
0343A:  DATA 48,55
0343C:  DATA 56,70
0343E:  DATA 52,68
03440:  DATA 47,63
03442:  DATA 31,47
03444:  DATA 52,6E
03446:  DATA 55,6B
03448:  DATA 34,78
0344A:  DATA 75,6A
0344C:  DATA 20,0A
0344E:  DATA 33,6A
03450:  DATA 34,55
03452:  DATA 66,47
03454:  DATA 48,77
03456:  DATA 72,38
03458:  DATA 63,2F
0345A:  DATA 43,45
0345C:  DATA 66,69
0345E:  DATA 44,77
03460:  DATA 66,72
03462:  DATA 32,6D
03464:  DATA 65,4A
03466:  DATA 4E,45
03468:  DATA 6D,6B
0346A:  DATA 65,47
0346C:  DATA 4F,2B
0346E:  DATA 30,2B
03470:  DATA 59,54
03472:  DATA 51,4F
03474:  DATA 36,48
03476:  DATA 44,41
03478:  DATA 4F,4F
0347A:  DATA 43,51
0347C:  DATA 65,44
0347E:  DATA 54,66
03480:  DATA 68,64
03482:  DATA 38,59
03484:  DATA 50,44
03486:  DATA 76,78
03488:  DATA 6F,30
0348A:  DATA 4F,38
0348C:  DATA 31,54
0348E:  DATA 77,33
03490:  DATA 71,48
03492:  DATA 39,6F
03494:  DATA 32,4F
03496:  DATA 6E,36
03498:  DATA 6C,64
0349A:  DATA 20,0A
0349C:  DATA 36,54
0349E:  DATA 4E,4E
034A0:  DATA 35,45
034A2:  DATA 6B,53
034A4:  DATA 69,35
034A6:  DATA 74,5A
034A8:  DATA 6D,68
034AA:  DATA 6D,51
034AC:  DATA 62,31
034AE:  DATA 55,73
034B0:  DATA 46,6B
034B2:  DATA 52,68
034B4:  DATA 75,58
034B6:  DATA 4B,6E
034B8:  DATA 47,51
034BA:  DATA 53,4F
034BC:  DATA 61,2B
034BE:  DATA 48,66
034C0:  DATA 42,2F
034C2:  DATA 78,62
034C4:  DATA 2B,49
034C6:  DATA 58,78
034C8:  DATA 61,2F
034CA:  DATA 61,34
034CC:  DATA 38,58
034CE:  DATA 61,39
034D0:  DATA 44,34
034D2:  DATA 30,74
034D4:  DATA 2F,43
034D6:  DATA 33,68
034D8:  DATA 50,34
034DA:  DATA 58,2B
034DC:  DATA 4E,37
034DE:  DATA 33,53
034E0:  DATA 35,74
034E2:  DATA 4B,2F
034E4:  DATA 34,53
034E6:  DATA 42,59
034E8:  DATA 20,0A
034EA:  DATA 59,37
034EC:  DATA 72,53
034EE:  DATA 4E,4F
034F0:  DATA 73,6E
034F2:  DATA 4D,39
034F4:  DATA 73,6D
034F6:  DATA 6C,69
034F8:  DATA 50,4D
034FA:  DATA 30,38
034FC:  DATA 38,6D
034FE:  DATA 5A,6A
03500:  DATA 63,53
03502:  DATA 76,68
03504:  DATA 49,77
03506:  DATA 4E,67
03508:  DATA 77,74
0350A:  DATA 65,4A
0350C:  DATA 2F,42
0350E:  DATA 44,78
03510:  DATA 6C,38
03512:  DATA 54,76
03514:  DATA 47,76
03516:  DATA 77,31
03518:  DATA 2B,48
0351A:  DATA 58,77
0351C:  DATA 7A,38
0351E:  DATA 48,65
03520:  DATA 4D,4C
03522:  DATA 62,77
03524:  DATA 65,5A
03526:  DATA 66,68
03528:  DATA 2B,6E
0352A:  DATA 6A,4C
0352C:  DATA 2B,30
0352E:  DATA 57,38
03530:  DATA 54,72
03532:  DATA 6F,67
03534:  DATA 4F,71
03536:  DATA 20,0A
03538:  DATA 36,78
0353A:  DATA 71,6C
0353C:  DATA 33,4E
0353E:  DATA 39,72
03540:  DATA 6B,78
03542:  DATA 47,38
03544:  DATA 6C,35
03546:  DATA 46,42
03548:  DATA 67,70
0354A:  DATA 39,6E
0354C:  DATA 55,42
0354E:  DATA 57,6B
03550:  DATA 6C,49
03552:  DATA 63,38
03554:  DATA 4C,6A
03556:  DATA 76,2F
03558:  DATA 41,4C
0355A:  DATA 4E,76
0355C:  DATA 65,7A
0355E:  DATA 38,39
03560:  DATA 39,6B
03562:  DATA 63,63
03564:  DATA 63,62
03566:  DATA 74,64
03568:  DATA 48,36
0356A:  DATA 35,35
0356C:  DATA 46,4B
0356E:  DATA 63,56
03570:  DATA 2B,63
03572:  DATA 48,78
03574:  DATA 4A,2F
03576:  DATA 61,6B
03578:  DATA 38,58
0357A:  DATA 57,66
0357C:  DATA 77,39
0357E:  DATA 2F,61
03580:  DATA 41,2B
03582:  DATA 4A,45
03584:  DATA 20,0A
03586:  DATA 50,78
03588:  DATA 4D,76
0358A:  DATA 6F,2F
0358C:  DATA 47,6E
0358E:  DATA 77,39
03590:  DATA 38,53
03592:  DATA 7A,2B
03594:  DATA 43,4E
03596:  DATA 43,38
03598:  DATA 4F,4C
0359A:  DATA 66,52
0359C:  DATA 57,2B
0359E:  DATA 6C,36
035A0:  DATA 54,61
035A2:  DATA 72,63
035A4:  DATA 32,6D
035A6:  DATA 6D,74
035A8:  DATA 71,74
035AA:  DATA 78,5A
035AC:  DATA 59,2F
035AE:  DATA 65,4E
035B0:  DATA 35,74
035B2:  DATA 79,39
035B4:  DATA 7A,35
035B6:  DATA 6B,70
035B8:  DATA 5A,46
035BA:  DATA 78,47
035BC:  DATA 6F,49
035BE:  DATA 55,45
035C0:  DATA 56,6E
035C2:  DATA 51,66
035C4:  DATA 46,58
035C6:  DATA 78,38
035C8:  DATA 6E,78
035CA:  DATA 57,31
035CC:  DATA 62,34
035CE:  DATA 65,65
035D0:  DATA 42,66
035D2:  DATA 20,0A
035D4:  DATA 69,78
035D6:  DATA 34,76
035D8:  DATA 38,51
035DA:  DATA 65,47
035DC:  DATA 39,51
035DE:  DATA 2B,4A
035E0:  DATA 2F,68
035E2:  DATA 33,77
035E4:  DATA 31,70
035E6:  DATA 66,69
035E8:  DATA 61,36
035EA:  DATA 76,6B
035EC:  DATA 31,4B
035EE:  DATA 37,6A
035F0:  DATA 4B,36
035F2:  DATA 58,63
035F4:  DATA 58,32
035F6:  DATA 74,72
035F8:  DATA 48,50
035FA:  DATA 74,4B
035FC:  DATA 53,49
035FE:  DATA 67,6A
03600:  DATA 68,48
03602:  DATA 6C,6E
03604:  DATA 63,69
03606:  DATA 4F,57
03608:  DATA 55,71
0360A:  DATA 46,79
0360C:  DATA 44,6B
0360E:  DATA 73,76
03610:  DATA 62,2B
03612:  DATA 30,76
03614:  DATA 78,38
03616:  DATA 76,38
03618:  DATA 7A,54
0361A:  DATA 36,37
0361C:  DATA 48,73
0361E:  DATA 7A,39
03620:  DATA 20,0A
03622:  DATA 4C,48
03624:  DATA 48,62
03626:  DATA 31,4E
03628:  DATA 4F,4F
0362A:  DATA 30,69
0362C:  DATA 76,79
0362E:  DATA 31,2B
03630:  DATA 47,2F
03632:  DATA 37,51
03634:  DATA 48,78
03636:  DATA 46,38
03638:  DATA 41,32
0363A:  DATA 58,67
0363C:  DATA 76,78
0363E:  DATA 6C,4E
03640:  DATA 38,53
03642:  DATA 66,47
03644:  DATA 57,76
03646:  DATA 36,50
03648:  DATA 63,57
0364A:  DATA 2F,77
0364C:  DATA 41,52
0364E:  DATA 74,55
03650:  DATA 68,30
03652:  DATA 36,2F
03654:  DATA 76,42
03656:  DATA 63,52
03658:  DATA 53,61
0365A:  DATA 46,70
0365C:  DATA 45,64
0365E:  DATA 79,74
03660:  DATA 6F,30
03662:  DATA 35,32
03664:  DATA 68,70
03666:  DATA 72,6A
03668:  DATA 37,53
0366A:  DATA 30,4C
0366C:  DATA 43,5A
0366E:  DATA 20,0A
03670:  DATA 6A,6E
03672:  DATA 59,46
03674:  DATA 52,63
03676:  DATA 4B,43
03678:  DATA 47,68
0367A:  DATA 38,55
0367C:  DATA 2F,74
0367E:  DATA 6B,2B
03680:  DATA 50,4C
03682:  DATA 33,34
03684:  DATA 55,50
03686:  DATA 5A,2B
03688:  DATA 46,66
0368A:  DATA 69,46
0368C:  DATA 71,75
0368E:  DATA 72,61
03690:  DATA 35,6F
03692:  DATA 48,77
03694:  DATA 6A,38
03696:  DATA 4D,36
03698:  DATA 66,64
0369A:  DATA 33,63
0369C:  DATA 4E,36
0369E:  DATA 5A,6B
036A0:  DATA 6D,38
036A2:  DATA 54,36
036A4:  DATA 35,71
036A6:  DATA 56,72
036A8:  DATA 48,35
036AA:  DATA 72,53
036AC:  DATA 4C,6B
036AE:  DATA 4E,4C
036B0:  DATA 46,44
036B2:  DATA 76,77
036B4:  DATA 63,6E
036B6:  DATA 41,64
036B8:  DATA 78,79
036BA:  DATA 79,38
036BC:  DATA 20,0A
036BE:  DATA 55,38
036C0:  DATA 74,6E
036C2:  DATA 30,61
036C4:  DATA 5A,4B
036C6:  DATA 78,30
036C8:  DATA 65,71
036CA:  DATA 50,30
036CC:  DATA 77,2B
036CE:  DATA 4B,6E
036D0:  DATA 78,57
036D2:  DATA 38,50
036D4:  DATA 38,41
036D6:  DATA 77,55
036D8:  DATA 38,44
036DA:  DATA 33,58
036DC:  DATA 69,54
036DE:  DATA 78,52
036E0:  DATA 71,55
036E2:  DATA 65,6B
036E4:  DATA 36,48
036E6:  DATA 59,79
036E8:  DATA 51,78
036EA:  DATA 54,58
036EC:  DATA 54,52
036EE:  DATA 50,49
036F0:  DATA 49,32
036F2:  DATA 6D,6D
036F4:  DATA 53,47
036F6:  DATA 49,62
036F8:  DATA 55,44
036FA:  DATA 4D,64
036FC:  DATA 30,6B
036FE:  DATA 69,4C
03700:  DATA 77,4F
03702:  DATA 72,64
03704:  DATA 68,58
03706:  DATA 51,34
03708:  DATA 35,72
0370A:  DATA 20,0A
0370C:  DATA 38,34
0370E:  DATA 4C,6E
03710:  DATA 78,39
03712:  DATA 38,51
03714:  DATA 4E,49
03716:  DATA 2B,4B
03718:  DATA 75,6F
0371A:  DATA 65,47
0371C:  DATA 37,50
0371E:  DATA 34,6A
03720:  DATA 2B,4F
03722:  DATA 74,61
03724:  DATA 73,59
03726:  DATA 50,6A
03728:  DATA 70,6F
0372A:  DATA 66,68
0372C:  DATA 79,32
0372E:  DATA 6D,6D
03730:  DATA 76,46
03732:  DATA 4E,78
03734:  DATA 63,52
03736:  DATA 52,61
03738:  DATA 51,74
0373A:  DATA 39,72
0373C:  DATA 4D,4C
0373E:  DATA 62,46
03740:  DATA 55,43
03742:  DATA 42,38
03744:  DATA 50,69
03746:  DATA 4A,63
03748:  DATA 4A,47
0374A:  DATA 53,75
0374C:  DATA 41,42
0374E:  DATA 6B,56
03750:  DATA 54,38
03752:  DATA 4C,2F
03754:  DATA 41,4C
03756:  DATA 54,57
03758:  DATA 20,0A
0375A:  DATA 75,65
0375C:  DATA 4D,50
0375E:  DATA 32,61
03760:  DATA 2F,68
03762:  DATA 2F,77
03764:  DATA 43,4F
03766:  DATA 4A,76
03768:  DATA 6A,42
0376A:  DATA 71,64
0376C:  DATA 6A,34
0376E:  DATA 69,2B
03770:  DATA 4F,33
03772:  DATA 6A,43
03774:  DATA 31,30
03776:  DATA 58,78
03778:  DATA 44,4A
0377A:  DATA 46,72
0377C:  DATA 55,50
0377E:  DATA 39,6E
03780:  DATA 2B,42
03782:  DATA 4E,4F
03784:  DATA 6B,65
03786:  DATA 38,75
03788:  DATA 44,44
0378A:  DATA 61,51
0378C:  DATA 73,4E
0378E:  DATA 6C,70
03790:  DATA 63,66
03792:  DATA 5A,37
03794:  DATA 54,79
03796:  DATA 42,4C
03798:  DATA 49,43
0379A:  DATA 2B,34
0379C:  DATA 75,35
0379E:  DATA 4A,49
037A0:  DATA 79,48
037A2:  DATA 2F,5A
037A4:  DATA 30,74
037A6:  DATA 20,0A
037A8:  DATA 4C,53
037AA:  DATA 43,4F
037AC:  DATA 4F,54
037AE:  DATA 36,48
037B0:  DATA 36,56
037B2:  DATA 62,6C
037B4:  DATA 59,56
037B6:  DATA 7A,33
037B8:  DATA 68,7A
037BA:  DATA 34,73
037BC:  DATA 2B,48
037BE:  DATA 66,46
037C0:  DATA 76,78
037C2:  DATA 41,38
037C4:  DATA 53,65
037C6:  DATA 46,64
037C8:  DATA 4F,31
037CA:  DATA 4F,4F
037CC:  DATA 36,31
037CE:  DATA 2F,77
037D0:  DATA 69,4C
037D2:  DATA 56,74
037D4:  DATA 58,74
037D6:  DATA 46,6A
037D8:  DATA 63,4E
037DA:  DATA 5A,43
037DC:  DATA 35,52
037DE:  DATA 70,49
037E0:  DATA 4D,73
037E2:  DATA 56,43
037E4:  DATA 6E,65
037E6:  DATA 69,73
037E8:  DATA 63,4B
037EA:  DATA 54,6A
037EC:  DATA 48,4F
037EE:  DATA 4D,69
037F0:  DATA 76,7A
037F2:  DATA 6D,2F
037F4:  DATA 20,0A
037F6:  DATA 5A,31
037F8:  DATA 2B,4F
037FA:  DATA 65,76
037FC:  DATA 66,46
037FE:  DATA 7A,78
03800:  DATA 46,34
03802:  DATA 50,38
03804:  DATA 44,36
03806:  DATA 68,38
03808:  DATA 58,76
0380A:  DATA 47,32
0380C:  DATA 69,2F
0380E:  DATA 44,2F
03810:  DATA 78,6E
03812:  DATA 34,67
03814:  DATA 38,57
03816:  DATA 36,74
03818:  DATA 59,61
0381A:  DATA 2F,64
0381C:  DATA 36,30
0381E:  DATA 4C,66
03820:  DATA 57,4E
03822:  DATA 54,30
03824:  DATA 2B,77
03826:  DATA 75,6F
03828:  DATA 4C,47
0382A:  DATA 77,73
0382C:  DATA 49,72
0382E:  DATA 32,52
03830:  DATA 64,34
03832:  DATA 79,2F
03834:  DATA 6D,7A
03836:  DATA 4F,42
03838:  DATA 38,37
0383A:  DATA 66,64
0383C:  DATA 7A,6A
0383E:  DATA 49,4E
03840:  DATA 39,50
03842:  DATA 20,0A
03844:  DATA 6A,33
03846:  DATA 34,6B
03848:  DATA 76,76
0384A:  DATA 6A,58
0384C:  DATA 65,65
0384E:  DATA 43,74
03850:  DATA 57,2B
03852:  DATA 4B,50
03854:  DATA 69,58
03856:  DATA 77,33
03858:  DATA 34,44
0385A:  DATA 38,54
0385C:  DATA 66,46
0385E:  DATA 50,78
03860:  DATA 50,59
03862:  DATA 33,4F
03864:  DATA 75,7A
03866:  DATA 36,78
03868:  DATA 39,6E
0386A:  DATA 76,4E
0386C:  DATA 50,30
0386E:  DATA 37,52
03870:  DATA 4C,43
03872:  DATA 42,7A
03874:  DATA 5A,57
03876:  DATA 39,30
03878:  DATA 34,2F
0387A:  DATA 64,4C
0387C:  DATA 4C,65
0387E:  DATA 53,53
03880:  DATA 35,4B
03882:  DATA 34,62
03884:  DATA 79,34
03886:  DATA 57,41
03888:  DATA 62,4F
0388A:  DATA 61,58
0388C:  DATA 39,6E
0388E:  DATA 79,54
03890:  DATA 20,0A
03892:  DATA 73,33
03894:  DATA 35,2F
03896:  DATA 31,70
03898:  DATA 2B,41
0389A:  DATA 66,58
0389C:  DATA 56,61
0389E:  DATA 36,52
038A0:  DATA 2B,6C
038A2:  DATA 5A,43
038A4:  DATA 68,75
038A6:  DATA 33,54
038A8:  DATA 76,53
038AA:  DATA 38,41
038AC:  DATA 64,61
038AE:  DATA 2F,4A
038B0:  DATA 68,50
038B2:  DATA 32,6C
038B4:  DATA 50,69
038B6:  DATA 78,34
038B8:  DATA 79,2F
038BA:  DATA 5A,33
038BC:  DATA 6D,76
038BE:  DATA 39,57
038C0:  DATA 2B,4A
038C2:  DATA 48,6A
038C4:  DATA 4C,52
038C6:  DATA 62,58
038C8:  DATA 77,58
038CA:  DATA 38,47
038CC:  DATA 4E,51
038CE:  DATA 38,57
038D0:  DATA 33,46
038D2:  DATA 31,62
038D4:  DATA 54,43
038D6:  DATA 33,76
038D8:  DATA 74,55
038DA:  DATA 75,72
038DC:  DATA 6E,56
038DE:  DATA 20,0A
038E0:  DATA 4C,75
038E2:  DATA 50,51
038E4:  DATA 7A,50
038E6:  DATA 4A,73
038E8:  DATA 79,47
038EA:  DATA 61,32
038EC:  DATA 74,37
038EE:  DATA 64,33
038F0:  DATA 59,41
038F2:  DATA 4D,34
038F4:  DATA 59,67
038F6:  DATA 35,45
038F8:  DATA 6A,35
038FA:  DATA 39,55
038FC:  DATA 2B,48
038FE:  DATA 33,78
03900:  DATA 4E,2B
03902:  DATA 4D,48
03904:  DATA 78,34
03906:  DATA 2F,61
03908:  DATA 74,6E
0390A:  DATA 73,37
0390C:  DATA 7A,78
0390E:  DATA 31,44
03910:  DATA 34,55
03912:  DATA 68,2B
03914:  DATA 47,33
03916:  DATA 69,48
03918:  DATA 52,64
0391A:  DATA 4F,76
0391C:  DATA 37,65
0391E:  DATA 34,38
03920:  DATA 53,4A
03922:  DATA 59,52
03924:  DATA 33,46
03926:  DATA 76,42
03928:  DATA 59,77
0392A:  DATA 58,4F
0392C:  DATA 20,0A
0392E:  DATA 70,42
03930:  DATA 39,4F
03932:  DATA 56,43
03934:  DATA 62,74
03936:  DATA 37,74
03938:  DATA 70,4A
0393A:  DATA 51,73
0393C:  DATA 6B,6A
0393E:  DATA 4B,6B
03940:  DATA 53,49
03942:  DATA 43,6D
03944:  DATA 47,56
03946:  DATA 73,6E
03948:  DATA 39,6D
0394A:  DATA 7A,74
0394C:  DATA 7A,63
0394E:  DATA 79,73
03950:  DATA 67,2B
03952:  DATA 75,78
03954:  DATA 76,61
03956:  DATA 7A,50
03958:  DATA 30,53
0395A:  DATA 34,78
0395C:  DATA 2F,54
0395E:  DATA 32,6F
03960:  DATA 78,6B
03962:  DATA 2F,70
03964:  DATA 58,79
03966:  DATA 6E,2F
03968:  DATA 77,54
0396A:  DATA 4C,38
0396C:  DATA 66,36
0396E:  DATA 78,34
03970:  DATA 74,76
03972:  DATA 76,69
03974:  DATA 70,70
03976:  DATA 76,69
03978:  DATA 7A,78
0397A:  DATA 20,0A
0397C:  DATA 4C,72
0397E:  DATA 6E,69
03980:  DATA 6A,78
03982:  DATA 6C,34
03984:  DATA 5A,31
03986:  DATA 2F,37
03988:  DATA 4A,71
0398A:  DATA 74,2B
0398C:  DATA 64,57
0398E:  DATA 46,2F
03990:  DATA 6F,4E
03992:  DATA 7A,48
03994:  DATA 4B,4A
03996:  DATA 4C,6D
03998:  DATA 31,6B
0399A:  DATA 30,35
0399C:  DATA 55,77
0399E:  DATA 6B,43
039A0:  DATA 2F,5A
039A2:  DATA 35,6F
039A4:  DATA 31,65
039A6:  DATA 49,44
039A8:  DATA 4B,6D
039AA:  DATA 4E,64
039AC:  DATA 33,4F
039AE:  DATA 61,34
039B0:  DATA 54,2F
039B2:  DATA 67,6D
039B4:  DATA 44,38
039B6:  DATA 59,66
039B8:  DATA 48,33
039BA:  DATA 37,52
039BC:  DATA 48,6A
039BE:  DATA 69,33
039C0:  DATA 54,58
039C2:  DATA 50,45
039C4:  DATA 6D,74
039C6:  DATA 33,32
039C8:  DATA 20,0A
039CA:  DATA 6C,66
039CC:  DATA 43,66
039CE:  DATA 54,64
039D0:  DATA 54,30
039D2:  DATA 54,58
039D4:  DATA 66,74
039D6:  DATA 45,35
039D8:  DATA 4C,61
039DA:  DATA 74,72
039DC:  DATA 73,32
039DE:  DATA 72,33
039E0:  DATA 53,6F
039E2:  DATA 4A,6A
039E4:  DATA 30,6B
039E6:  DATA 2B,7A
039E8:  DATA 57,4E
039EA:  DATA 74,43
039EC:  DATA 51,44
039EE:  DATA 30,4E
039F0:  DATA 34,68
039F2:  DATA 48,54
039F4:  DATA 4E,59
039F6:  DATA 79,77
039F8:  DATA 63,76
039FA:  DATA 65,64
039FC:  DATA 2F,68
039FE:  DATA 74,66
03A00:  DATA 35,6D
03A02:  DATA 73,63
03A04:  DATA 51,6D
03A06:  DATA 6F,36
03A08:  DATA 62,6E
03A0A:  DATA 31,66
03A0C:  DATA 71,58
03A0E:  DATA 37,53
03A10:  DATA 2F,77
03A12:  DATA 2F,77
03A14:  DATA 42,49
03A16:  DATA 20,0A
03A18:  DATA 2B,4D
03A1A:  DATA 64,72
03A1C:  DATA 38,4F
03A1E:  DATA 35,2F
03A20:  DATA 46,32
03A22:  DATA 68,72
03A24:  DATA 34,34
03A26:  DATA 76,55
03A28:  DATA 33,78
03A2A:  DATA 61,4B
03A2C:  DATA 4C,6B
03A2E:  DATA 4E,65
03A30:  DATA 45,65
03A32:  DATA 57,30
03A34:  DATA 6F,33
03A36:  DATA 49,4D
03A38:  DATA 6C,53
03A3A:  DATA 59,30
03A3C:  DATA 5A,77
03A3E:  DATA 47,77
03A40:  DATA 57,56
03A42:  DATA 53,52
03A44:  DATA 6B,56
03A46:  DATA 71,2F
03A48:  DATA 43,62
03A4A:  DATA 34,76
03A4C:  DATA 65,47
03A4E:  DATA 2F,6A
03A50:  DATA 70,38
03A52:  DATA 50,64
03A54:  DATA 50,38
03A56:  DATA 56,65
03A58:  DATA 45,39
03A5A:  DATA 56,67
03A5C:  DATA 31,72
03A5E:  DATA 77,39
03A60:  DATA 71,77
03A62:  DATA 6B,4E
03A64:  DATA 20,0A
03A66:  DATA 70,65
03A68:  DATA 78,49
03A6A:  DATA 79,78
03A6C:  DATA 7A,69
03A6E:  DATA 4F,52
03A70:  DATA 6F,6E
03A72:  DATA 77,48
03A74:  DATA 41,50
03A76:  DATA 44,6F
03A78:  DATA 77,35
03A7A:  DATA 48,62
03A7C:  DATA 30,72
03A7E:  DATA 34,61
03A80:  DATA 2B,4A
03A82:  DATA 50,78
03A84:  DATA 62,68
03A86:  DATA 2F,5A
03A88:  DATA 66,2F
03A8A:  DATA 41,47
03A8C:  DATA 6F,2F
03A8E:  DATA 6A,56
03A90:  DATA 61,2B
03A92:  DATA 46,2F
03A94:  DATA 46,57
03A96:  DATA 6D,2B
03A98:  DATA 4B,4E
03A9A:  DATA 41,2B
03A9C:  DATA 4B,50
03A9E:  DATA 67,37
03AA0:  DATA 57,2F
03AA2:  DATA 47,32
03AA4:  DATA 6F,79
03AA6:  DATA 61,56
03AA8:  DATA 65,6F
03AAA:  DATA 32,72
03AAC:  DATA 2B,43
03AAE:  DATA 72,37
03AB0:  DATA 54,4C
03AB2:  DATA 20,0A
03AB4:  DATA 4A,59
03AB6:  DATA 53,7A
03AB8:  DATA 53,6F
03ABA:  DATA 57,41
03ABC:  DATA 68,6C
03ABE:  DATA 49,56
03AC0:  DATA 49,67
03AC2:  DATA 77,44
03AC4:  DATA 4A,4B
03AC6:  DATA 70,41
03AC8:  DATA 2B,36
03ACA:  DATA 53,2F
03ACC:  DATA 50,61
03ACE:  DATA 46,38
03AD0:  DATA 59,66
03AD2:  DATA 47,48
03AD4:  DATA 77,2B
03AD6:  DATA 38,57
03AD8:  DATA 65,46
03ADA:  DATA 49,66
03ADC:  DATA 48,6E
03ADE:  DATA 6A,37
03AE0:  DATA 78,6A
03AE2:  DATA 71,30
03AE4:  DATA 65,6F
03AE6:  DATA 66,42
03AE8:  DATA 78,39
03AEA:  DATA 59,30
03AEC:  DATA 38,61
03AEE:  DATA 4C,34
03AF0:  DATA 68,45
03AF2:  DATA 63,6D
03AF4:  DATA 6E,61
03AF6:  DATA 70,61
03AF8:  DATA 61,54
03AFA:  DATA 4A,63
03AFC:  DATA 61,6D
03AFE:  DATA 32,70
03B00:  DATA 20,0A
03B02:  DATA 57,36
03B04:  DATA 2F,4D
03B06:  DATA 37,74
03B08:  DATA 35,38
03B0A:  DATA 62,77
03B0C:  DATA 7A,50
03B0E:  DATA 6C,55
03B10:  DATA 5A,49
03B12:  DATA 31,43
03B14:  DATA 35,72
03B16:  DATA 6F,57
03B18:  DATA 41,35
03B1A:  DATA 74,59
03B1C:  DATA 76,70
03B1E:  DATA 31,4D
03B20:  DATA 6E,69
03B22:  DATA 32,6E
03B24:  DATA 71,6A
03B26:  DATA 39,48
03B28:  DATA 64,43
03B2A:  DATA 38,52
03B2C:  DATA 61,66
03B2E:  DATA 34,6E
03B30:  DATA 30,39
03B32:  DATA 62,7A
03B34:  DATA 54,62
03B36:  DATA 36,7A
03B38:  DATA 31,43
03B3A:  DATA 7A,5A
03B3C:  DATA 33,69
03B3E:  DATA 57,65
03B40:  DATA 32,6D
03B42:  DATA 57,61
03B44:  DATA 49,75
03B46:  DATA 6A,6D
03B48:  DATA 4E,31
03B4A:  DATA 33,4B
03B4C:  DATA 53,4D
03B4E:  DATA 20,0A
03B50:  DATA 71,36
03B52:  DATA 73,70
03B54:  DATA 48,55
03B56:  DATA 4D,70
03B58:  DATA 42,35
03B5A:  DATA 42,71
03B5C:  DATA 32,36
03B5E:  DATA 38,2F
03B60:  DATA 58,38
03B62:  DATA 4B,2F
03B64:  DATA 4A,62
03B66:  DATA 34,61
03B68:  DATA 33,58
03B6A:  DATA 6A,76
03B6C:  DATA 53,76
03B6E:  DATA 68,78
03B70:  DATA 38,4B
03B72:  DATA 66,68
03B74:  DATA 42,34
03B76:  DATA 48,2B
03B78:  DATA 49,46
03B7A:  DATA 33,70
03B7C:  DATA 43,33
03B7E:  DATA 2F,77
03B80:  DATA 74,69
03B82:  DATA 38,63
03B84:  DATA 79,36
03B86:  DATA 72,64
03B88:  DATA 65,4D
03B8A:  DATA 2F,37
03B8C:  DATA 4B,6A
03B8E:  DATA 67,31
03B90:  DATA 62,55
03B92:  DATA 70,7A
03B94:  DATA 43,47
03B96:  DATA 4D,32
03B98:  DATA 31,35
03B9A:  DATA 4A,72
03B9C:  DATA 20,0A
03B9E:  DATA 61,31
03BA0:  DATA 6B,53
03BA2:  DATA 56,6A
03BA4:  DATA 61,78
03BA6:  DATA 67,42
03BA8:  DATA 35,5A
03BAA:  DATA 76,6E
03BAC:  DATA 50,61
03BAE:  DATA 76,51
03BB0:  DATA 50,69
03BB2:  DATA 56,34
03BB4:  DATA 2F,2B
03BB6:  DATA 4C,58
03BB8:  DATA 6A,48
03BBA:  DATA 34,77
03BBC:  DATA 36,67
03BBE:  DATA 2B,6C
03BC0:  DATA 66,46
03BC2:  DATA 62,78
03BC4:  DATA 58,70
03BC6:  DATA 70,2F
03BC8:  DATA 34,58
03BCA:  DATA 42,6F
03BCC:  DATA 33,77
03BCE:  DATA 34,30
03BD0:  DATA 69,47
03BD2:  DATA 77,38
03BD4:  DATA 74,62
03BD6:  DATA 58,4D
03BD8:  DATA 57,6C
03BDA:  DATA 52,50
03BDC:  DATA 71,39
03BDE:  DATA 31,4A
03BE0:  DATA 41,56
03BE2:  DATA 4B,79
03BE4:  DATA 4B,64
03BE6:  DATA 6B,73
03BE8:  DATA 69,78
03BEA:  DATA 20,0A
03BEC:  DATA 6E,39
03BEE:  DATA 32,6A
03BF0:  DATA 68,75
03BF2:  DATA 43,53
03BF4:  DATA 43,44
03BF6:  DATA 2B,7A
03BF8:  DATA 6E,66
03BFA:  DATA 53,53
03BFC:  DATA 42,59
03BFE:  DATA 31,66
03C00:  DATA 79,73
03C02:  DATA 2F,53
03C04:  DATA 73,50
03C06:  DATA 75,48
03C08:  DATA 30,6F
03C0A:  DATA 44,38
03C0C:  DATA 2F,70
03C0E:  DATA 58,35
03C10:  DATA 5A,57
03C12:  DATA 58,37
03C14:  DATA 55,2F
03C16:  DATA 69,4B
03C18:  DATA 44,77
03C1A:  DATA 7A,62
03C1C:  DATA 2B,46
03C1E:  DATA 2F,45
03C20:  DATA 48,78
03C22:  DATA 54,38
03C24:  DATA 59,61
03C26:  DATA 4C,34
03C28:  DATA 4A,74
03C2A:  DATA 37,6E
03C2C:  DATA 78,7A
03C2E:  DATA 34,6A
03C30:  DATA 69,31
03C32:  DATA 6C,74
03C34:  DATA 57,38
03C36:  DATA 6E,58
03C38:  DATA 20,0A
03C3A:  DATA 74,62
03C3C:  DATA 73,64
03C3E:  DATA 4E,31
03C40:  DATA 48,37
03C42:  DATA 48,70
03C44:  DATA 32,6E
03C46:  DATA 78,33
03C48:  DATA 6A,71
03C4A:  DATA 5A,4E
03C4C:  DATA 37,53
03C4E:  DATA 6D,51
03C50:  DATA 34,51
03C52:  DATA 62,33
03C54:  DATA 43,71
03C56:  DATA 67,77
03C58:  DATA 42,67
03C5A:  DATA 2B,67
03C5C:  DATA 2F,73
03C5E:  DATA 76,2F
03C60:  DATA 46,6E
03C62:  DATA 78,74
03C64:  DATA 4A,38
03C66:  DATA 63,50
03C68:  DATA 32,62
03C6A:  DATA 64,50
03C6C:  DATA 38,41
03C6E:  DATA 48,33
03C70:  DATA 6A,62
03C72:  DATA 78,4A
03C74:  DATA 34,67
03C76:  DATA 74,76
03C78:  DATA 48,66
03C7A:  DATA 67,53
03C7C:  DATA 33,75
03C7E:  DATA 62,53
03C80:  DATA 44,54
03C82:  DATA 74,64
03C84:  DATA 45,55
03C86:  DATA 20,0A
03C88:  DATA 6C,76
03C8A:  DATA 72,4B
03C8C:  DATA 57,30
03C8E:  DATA 6D,6F
03C90:  DATA 7A,6E
03C92:  DATA 56,62
03C94:  DATA 5A,63
03C96:  DATA 50,4E
03C98:  DATA 48,4A
03C9A:  DATA 61,53
03C9C:  DATA 52,42
03C9E:  DATA 47,59
03CA0:  DATA 73,71
03CA2:  DATA 6D,4C
03CA4:  DATA 42,58
03CA6:  DATA 35,74
03CA8:  DATA 39,54
03CAA:  DATA 4C,4C
03CAC:  DATA 5A,52
03CAE:  DATA 58,4D
03CB0:  DATA 32,67
03CB2:  DATA 6A,6A
03CB4:  DATA 45,33
03CB6:  DATA 61,78
03CB8:  DATA 39,6F
03CBA:  DATA 2F,47
03CBC:  DATA 50,39
03CBE:  DATA 70,33
03CC0:  DATA 34,66
03CC2:  DATA 38,41
03CC4:  DATA 37,50
03CC6:  DATA 38,41
03CC8:  DATA 66,61
03CCA:  DATA 56,61
03CCC:  DATA 2B,4E
03CCE:  DATA 50,46
03CD0:  DATA 32,68
03CD2:  DATA 2B,48
03CD4:  DATA 20,0A
03CD6:  DATA 62,76
03CD8:  DATA 58,48
03CDA:  DATA 38,75
03CDC:  DATA 77,74
03CDE:  DATA 37,79
03CE0:  DATA 35,43
03CE2:  DATA 54,58
03CE4:  DATA 5A,79
03CE6:  DATA 46,4F
03CE8:  DATA 78,42
03CEA:  DATA 6C,69
03CEC:  DATA 41,57
03CEE:  DATA 55,46
03CF0:  DATA 73,59
03CF2:  DATA 42,59
03CF4:  DATA 41,6E
03CF6:  DATA 6B,56
03CF8:  DATA 59,2B
03CFA:  DATA 4D,33
03CFC:  DATA 37,51
03CFE:  DATA 2F,67
03D00:  DATA 62,39
03D02:  DATA 6E,66
03D04:  DATA 53,62
03D06:  DATA 50,55
03D08:  DATA 50,48
03D0A:  DATA 58,69
03D0C:  DATA 72,51
03D0E:  DATA 2F,43
03D10:  DATA 64,6A
03D12:  DATA 66,7A
03D14:  DATA 66,5A
03D16:  DATA 72,61
03D18:  DATA 66,56
03D1A:  DATA 4C,70
03D1C:  DATA 4C,65
03D1E:  DATA 4F,61
03D20:  DATA 54,42
03D22:  DATA 20,0A
03D24:  DATA 4F,78
03D26:  DATA 53,33
03D28:  DATA 56,73
03D2A:  DATA 41,6E
03D2C:  DATA 46,66
03D2E:  DATA 4D,76
03D30:  DATA 37,59
03D32:  DATA 6E,6A
03D34:  DATA 4B,33
03D36:  DATA 2B,42
03D38:  DATA 48,37
03D3A:  DATA 65,76
03D3C:  DATA 77,79
03D3E:  DATA 2B,49
03D40:  DATA 33,68
03D42:  DATA 37,78
03D44:  DATA 42,34
03D46:  DATA 64,31
03D48:  DATA 6A,58
03D4A:  DATA 4E,63
03D4C:  DATA 6C,73
03D4E:  DATA 2F,68
03D50:  DATA 6A,34
03D52:  DATA 67,38
03D54:  DATA 4A,53
03D56:  DATA 7A,6F
03D58:  DATA 32,6F
03D5A:  DATA 66,59
03D5C:  DATA 62,75
03D5E:  DATA 35,2B
03D60:  DATA 30,70
03D62:  DATA 64,32
03D64:  DATA 34,42
03D66:  DATA 4C,78
03D68:  DATA 50,45
03D6A:  DATA 57,45
03D6C:  DATA 6B,67
03D6E:  DATA 59,42
03D70:  DATA 20,0A
03D72:  DATA 48,69
03D74:  DATA 43,6B
03D76:  DATA 6C,63
03D78:  DATA 4B,61
03D7A:  DATA 35,37
03D7C:  DATA 39,73
03D7E:  DATA 44,34
03D80:  DATA 30,32
03D82:  DATA 66,78
03D84:  DATA 66,2F
03D86:  DATA 41,47
03D88:  DATA 30,66
03D8A:  DATA 67,48
03D8C:  DATA 64,65
03D8E:  DATA 41,2F
03D90:  DATA 69,56
03D92:  DATA 38,50
03D94:  DATA 74,44
03D96:  DATA 74,74
03D98:  DATA 43,38
03D9A:  DATA 50,36
03D9C:  DATA 39,34
03D9E:  DATA 72,74
03DA0:  DATA 74,65
03DA2:  DATA 31,6A
03DA4:  DATA 5A,66
03DA6:  DATA 61,52
03DA8:  DATA 63,43
03DAA:  DATA 62,79
03DAC:  DATA 4E,4F
03DAE:  DATA 51,4C
03DB0:  DATA 74,75
03DB2:  DATA 49,64
03DB4:  DATA 37,59
03DB6:  DATA 65,35
03DB8:  DATA 55,59
03DBA:  DATA 6B,42
03DBC:  DATA 47,47
03DBE:  DATA 20,0A
03DC0:  DATA 4F,44
03DC2:  DATA 74,4F
03DC4:  DATA 46,54
03DC6:  DATA 77,6B
03DC8:  DATA 5A,4B
03DCA:  DATA 46,37
03DCC:  DATA 32,61
03DCE:  DATA 62,66
03DD0:  DATA 79,2B
03DD2:  DATA 58,2B
03DD4:  DATA 5A,55
03DD6:  DATA 38,51
03DD8:  DATA 31,65
03DDA:  DATA 33,63
03DDC:  DATA 2B,32
03DDE:  DATA 66,42
03DE0:  DATA 50,6A
03DE2:  DATA 50,53
03DE4:  DATA 66,69
03DE6:  DATA 50,34
03DE8:  DATA 55,30
03DEA:  DATA 2F,58
03DEC:  DATA 74,43
03DEE:  DATA 76,37
03DF0:  DATA 50,56
03DF2:  DATA 74,48
03DF4:  DATA 31,61
03DF6:  DATA 42,62
03DF8:  DATA 6D,7A
03DFA:  DATA 76,62
03DFC:  DATA 56,78
03DFE:  DATA 4A,44
03E00:  DATA 63,78
03E02:  DATA 4D,4D
03E04:  DATA 71,36
03E06:  DATA 4E,30
03E08:  DATA 4B,6B
03E0A:  DATA 59,49
03E0C:  DATA 20,0A
03E0E:  DATA 49,36
03E10:  DATA 31,72
03E12:  DATA 4B,66
03E14:  DATA 78,72
03E16:  DATA 44,38
03E18:  DATA 49,65
03E1A:  DATA 50,4E
03E1C:  DATA 46,38
03E1E:  DATA 62,76
03E20:  DATA 71,56
03E22:  DATA 76,70
03E24:  DATA 65,73
03E26:  DATA 36,58
03E28:  DATA 72,46
03E2A:  DATA 31,6F
03E2C:  DATA 46,32
03E2E:  DATA 64,4D
03E30:  DATA 31,52
03E32:  DATA 62,4F
03E34:  DATA 5A,5A
03E36:  DATA 50,73
03E38:  DATA 56,32
03E3A:  DATA 69,71
03E3C:  DATA 37,77
03E3E:  DATA 79,41
03E40:  DATA 45,37
03E42:  DATA 48,41
03E44:  DATA 64,53
03E46:  DATA 55,50
03E48:  DATA 49,33
03E4A:  DATA 43,74
03E4C:  DATA 77,66
03E4E:  DATA 64,2F
03E50:  DATA 38,41
03E52:  DATA 72,31
03E54:  DATA 77,53
03E56:  DATA 56,74
03E58:  DATA 6A,71
03E5A:  DATA 20,0A
03E5C:  DATA 6A,35
03E5E:  DATA 44,71
03E60:  DATA 4B,42
03E62:  DATA 30,6F
03E64:  DATA 6F,4B
03E66:  DATA 43,69
03E68:  DATA 69,69
03E6A:  DATA 67,41
03E6C:  DATA 6F,6F
03E6E:  DATA 6F,6F
03E70:  DATA 41,4B
03E72:  DATA 4B,4B
03E74:  DATA 4B,41
03E76:  DATA 43,69
03E78:  DATA 69,69
03E7A:  DATA 67,41
03E7C:  DATA 72,4F
03E7E:  DATA 31,33
03E80:  DATA 77,6E
03E82:  DATA 70,76
03E84:  DATA 69,6A
03E86:  DATA 37,4A
03E88:  DATA 2F,61
03E8A:  DATA 57,6E
03E8C:  DATA 32,4F
03E8E:  DATA 6F,43
03E90:  DATA 77,75
03E92:  DATA 55,76
03E94:  DATA 62,55
03E96:  DATA 58,4D
03E98:  DATA 43,79
03E9A:  DATA 2F,5A
03E9C:  DATA 70,30
03E9E:  DATA 35,6A
03EA0:  DATA 6C,54
03EA2:  DATA 63,44
03EA4:  DATA 74,6B
03EA6:  DATA 58,50
03EA8:  DATA 20,0A
03EAA:  DATA 44,44
03EAC:  DATA 42,48
03EAE:  DATA 59,69
03EB0:  DATA 74,47
03EB2:  DATA 69,6A
03EB4:  DATA 59,4E
03EB6:  DATA 7A,6B
03EB8:  DATA 7A,38
03EBA:  DATA 43,2F
03EBC:  DATA 42,6A
03EBE:  DATA 65,4F
03EC0:  DATA 72,6E
03EC2:  DATA 78,51
03EC4:  DATA 33,68
03EC6:  DATA 48,77
03EC8:  DATA 75,33
03ECA:  DATA 69,65
03ECC:  DATA 38,69
03ECE:  DATA 4D,45
03ED0:  DATA 2B,72
03ED2:  DATA 6E,53
03ED4:  DATA 34,44
03ED6:  DATA 66,7A
03ED8:  DATA 52,6C
03EDA:  DATA 4E,68
03EDC:  DATA 52,70
03EDE:  DATA 39,6E
03EE0:  DATA 6D,4D
03EE2:  DATA 70,51
03EE4:  DATA 6C,63
03EE6:  DATA 45,34
03EE8:  DATA 32,38
03EEA:  DATA 64,4B
03EEC:  DATA 71,74
03EEE:  DATA 2B,7A
03EF0:  DATA 64,38
03EF2:  DATA 50,70
03EF4:  DATA 46,30
03EF6:  DATA 20,20
03EF8:  DATA 20,20
03EFA:  DATA 20,20
03EFC:  DATA 20,20
03EFE:  DATA 20,20
03F00:  DATA 20,20
03F02:  DATA 20,20
03F04:  DATA 20,20
03F06:  DATA 20,20
03F08:  DATA 20,20
03F0A:  DATA 20,0A
03F0C:  DATA 62,64
03F0E:  DATA 34,44
03F10:  DATA 38,46
03F12:  DATA 73,50
03F14:  DATA 44,71
03F16:  DATA 6C,64
03F18:  DATA 4A,42
03F1A:  DATA 30,57
03F1C:  DATA 32,78
03F1E:  DATA 70,59
03F20:  DATA 4C,46
03F22:  DATA 38,51
03F24:  DATA 66,4A
03F26:  DATA 2B,36
03F28:  DATA 47,34
03F2A:  DATA 37,76
03F2C:  DATA 6B,78
03F2E:  DATA 7A,7A
03F30:  DATA 31,72
03F32:  DATA 74,71
03F34:  DATA 4B,72
03F36:  DATA 6D,6C
03F38:  DATA 33,4A
03F3A:  DATA 39,6E
03F3C:  DATA 48,73
03F3E:  DATA 63,76
03F40:  DATA 63,2F
03F42:  DATA 42,58
03F44:  DATA 77,68
03F46:  DATA 64,36
03F48:  DATA 7A,72
03F4A:  DATA 47,6F
03F4C:  DATA 79,2B
03F4E:  DATA 46,66
03F50:  DATA 44,63
03F52:  DATA 6D,6F
03F54:  DATA 65,49
03F56:  DATA 62,66
03F58:  DATA 20,0A
03F5A:  DATA 37,4A
03F5C:  DATA 71,74
03F5E:  DATA 79,2B
03F60:  DATA 6D,77
03F62:  DATA 6D,62
03F64:  DATA 55,6F
03F66:  DATA 65,42
03F68:  DATA 35,55
03F6A:  DATA 37,37
03F6C:  DATA 64,30
03F6E:  DATA 71,59
03F70:  DATA 41,47
03F72:  DATA 31,79
03F74:  DATA 52,77
03F76:  DATA 4F,4B
03F78:  DATA 6C,38
03F7A:  DATA 4F,2F
03F7C:  DATA 43,50
03F7E:  DATA 77,74
03F80:  DATA 34,52
03F82:  DATA 30,37
03F84:  DATA 53,4C
03F86:  DATA 50,53
03F88:  DATA 66,44
03F8A:  DATA 50,68
03F8C:  DATA 37,53
03F8E:  DATA 37,54
03F90:  DATA 77,2B
03F92:  DATA 37,79
03F94:  DATA 61,5A
03F96:  DATA 42,61
03F98:  DATA 61,66
03F9A:  DATA 46,44
03F9C:  DATA 48,70
03F9E:  DATA 72,4F
03FA0:  DATA 72,49
03FA2:  DATA 35,68
03FA4:  DATA 56,56
03FA6:  DATA 20,0A
03FA8:  DATA 41,6A
03FAA:  DATA 4C,4B
03FAC:  DATA 7A,4B
03FAE:  DATA 53,75
03FB0:  DATA 4D,68
03FB2:  DATA 69,44
03FB4:  DATA 31,4E
03FB6:  DATA 64,48
03FB8:  DATA 52,52
03FBA:  DATA 7A,53
03FBC:  DATA 37,68
03FBE:  DATA 79,78
03FC0:  DATA 37,48
03FC2:  DATA 4F,32
03FC4:  DATA 48,77
03FC6:  DATA 6E,38
03FC8:  DATA 4D,36
03FCA:  DATA 58,42
03FCC:  DATA 62,77
03FCE:  DATA 32,33
03FD0:  DATA 68,33
03FD2:  DATA 51,62
03FD4:  DATA 65,47
03FD6:  DATA 7A,74
03FD8:  DATA 70,62
03FDA:  DATA 4B,33
03FDC:  DATA 53,4B
03FDE:  DATA 77,69
03FE0:  DATA 56,59
03FE2:  DATA 4C,65
03FE4:  DATA 55,68
03FE6:  DATA 70,59
03FE8:  DATA 55,41
03FEA:  DATA 55,42
03FEC:  DATA 59,33
03FEE:  DATA 49,42
03FF0:  DATA 5A,52
03FF2:  DATA 77,78
03FF4:  DATA 20,0A
03FF6:  DATA 41,4A
03FF8:  DATA 79,61
03FFA:  DATA 71,36
03FFC:  DATA 4E,38
03FFE:  DATA 43,2F
04000:  DATA 42,6E
04002:  DATA 68,7A
04004:  DATA 54,6F
04006:  DATA 62,50
04008:  DATA 54,2F
0400A:  DATA 41,41
0400C:  DATA 6A,34
0400E:  DATA 58,73
04010:  DATA 62,57
04012:  DATA 33,4D
04014:  DATA 44,52
04016:  DATA 51,32
04018:  DATA 2B,6C
0401A:  DATA 77,52
0401C:  DATA 52,78
0401E:  DATA 6D,43
04020:  DATA 52,35
04022:  DATA 59,53
04024:  DATA 71,71
04026:  DATA 67,41
04028:  DATA 4D,63
0402A:  DATA 6B,6A
0402C:  DATA 75,6D
0402E:  DATA 42,38
04030:  DATA 72,4F
04032:  DATA 78,47
04034:  DATA 43,54
04036:  DATA 58,57
04038:  DATA 55,55
0403A:  DATA 63,30
0403C:  DATA 75,34
0403E:  DATA 2B,56
04040:  DATA 64,6A
04042:  DATA 20,0A
04044:  DATA 42,68
04046:  DATA 2B,47
04048:  DATA 50,68
0404A:  DATA 32,32
0404C:  DATA 31,46
0404E:  DATA 4C,79
04050:  DATA 50,51
04052:  DATA 64,46
04054:  DATA 6A,76
04056:  DATA 49,37
04058:  DATA 79,54
0405A:  DATA 55,6B
0405C:  DATA 6E,57
0405E:  DATA 79,6A
04060:  DATA 57,52
04062:  DATA 62,71
04064:  DATA 52,50
04066:  DATA 4C,6B
04068:  DATA 6E,44
0406A:  DATA 62,63
0406C:  DATA 69,56
0406E:  DATA 6B,2B
04070:  DATA 55,76
04072:  DATA 6E,63
04074:  DATA 56,34
04076:  DATA 4A,49
04078:  DATA 72,4A
0407A:  DATA 50,37
0407C:  DATA 4F,66
0407E:  DATA 77,2F
04080:  DATA 62,54
04082:  DATA 4E,51
04084:  DATA 73,6A
04086:  DATA 34,46
04088:  DATA 38,48
0408A:  DATA 47,7A
0408C:  DATA 31,61
0408E:  DATA 37,57
04090:  DATA 20,0A
04092:  DATA 2F,76
04094:  DATA 72,66
04096:  DATA 2B,78
04098:  DATA 72,66
0409A:  DATA 79,37
0409C:  DATA 79,34
0409E:  DATA 55,6C
040A0:  DATA 6C,6D
040A2:  DATA 6B,58
040A4:  DATA 5A,68
040A6:  DATA 35,41
040A8:  DATA 53,53
040AA:  DATA 48,59
040AC:  DATA 46,67
040AE:  DATA 53,65
040B0:  DATA 61,37
040B2:  DATA 53,69
040B4:  DATA 6A,6D
040B6:  DATA 6C,33
040B8:  DATA 46,79
040BA:  DATA 78,37
040BC:  DATA 48,4B
040BE:  DATA 36,74
040C0:  DATA 38,44
040C2:  DATA 2F,42
040C4:  DATA 76,69
040C6:  DATA 43,31
040C8:  DATA 30,32
040CA:  DATA 44,55
040CC:  DATA 50,43
040CE:  DATA 66,68
040D0:  DATA 6D,2B
040D2:  DATA 68,30
040D4:  DATA 65,36
040D6:  DATA 61,39
040D8:  DATA 30,2B
040DA:  DATA 4F,66
040DC:  DATA 53,34
040DE:  DATA 20,0A
040E0:  DATA 4A,45
040E2:  DATA 73,62
040E4:  DATA 68,6E
040E6:  DATA 33,76
040E8:  DATA 4C,45
040EA:  DATA 47,55
040EC:  DATA 2B,58
040EE:  DATA 49,7A
040F0:  DATA 6B,73
040F2:  DATA 57,58
040F4:  DATA 42,4C
040F6:  DATA 48,4F
040F8:  DATA 63,30
040FA:  DATA 7A,78
040FC:  DATA 46,38
040FE:  DATA 42,2F
04100:  DATA 42,50
04102:  DATA 69,2F
04104:  DATA 51,50
04106:  DATA 37,4B
04108:  DATA 31,62
0410A:  DATA 77,66
0410C:  DATA 34,56
0410E:  DATA 31,54
04110:  DATA 54,50
04112:  DATA 74,72
04114:  DATA 61,6B
04116:  DATA 4C,4F
04118:  DATA 37,30
0411A:  DATA 6D,43
0411C:  DATA 65,33
0411E:  DATA 46,30
04120:  DATA 7A,46
04122:  DATA 6D,6E
04124:  DATA 32,4D
04126:  DATA 68,58
04128:  DATA 7A,53
0412A:  DATA 7A,4D
0412C:  DATA 20,0A
0412E:  DATA 53,2B
04130:  DATA 4E,78
04132:  DATA 4C,45
04134:  DATA 35,79
04136:  DATA 61,36
04138:  DATA 32,69
0413A:  DATA 6A,6D
0413C:  DATA 6C,33
0413E:  DATA 44,6C
04140:  DATA 58,59
04142:  DATA 35,2F
04144:  DATA 56,50
04146:  DATA 68,5A
04148:  DATA 34,62
0414A:  DATA 31,74
0414C:  DATA 62,34
0414E:  DATA 58,6E
04150:  DATA 68,2F
04152:  DATA 51,37
04154:  DATA 7A,2B
04156:  DATA 30,34
04158:  DATA 49,72
0415A:  DATA 61,38
0415C:  DATA 45,31
0415E:  DATA 6A,46
04160:  DATA 4A,39
04162:  DATA 73,69
04164:  DATA 69,4A
04166:  DATA 61,4B
04168:  DATA 4F,54
0416A:  DATA 4B,6E
0416C:  DATA 63,71
0416E:  DATA 4D,53
04170:  DATA 56,42
04172:  DATA 79,46
04174:  DATA 4A,4A
04176:  DATA 41,7A
04178:  DATA 56,54
0417A:  DATA 20,0A
0417C:  DATA 55,76
0417E:  DATA 67,5A
04180:  DATA 34,4D
04182:  DATA 31,6A
04184:  DATA 78,6F
04186:  DATA 33,69
04188:  DATA 53,38
0418A:  DATA 38,49
0418C:  DATA 2B,47
0418E:  DATA 62,76
04190:  DATA 78,45
04192:  DATA 30,5A
04194:  DATA 68,62
04196:  DATA 56,4A
04198:  DATA 74,4C
0419A:  DATA 67,65
0419C:  DATA 39,4B
0419E:  DATA 46,44
041A0:  DATA 48,73
041A2:  DATA 4D,78
041A4:  DATA 51,76
041A6:  DATA 74,4B
041A8:  DATA 45,72
041AA:  DATA 6A,4F
041AC:  DATA 4E,70
041AE:  DATA 49,36
041B0:  DATA 63,56
041B2:  DATA 31,64
041B4:  DATA 46,48
041B6:  DATA 50,4C
041B8:  DATA 75,48
041BA:  DATA 4A,48
041BC:  DATA 73,63
041BE:  DATA 66,46
041C0:  DATA 38,49
041C2:  DATA 72,50
041C4:  DATA 77,52
041C6:  DATA 38,4D
041C8:  DATA 20,0A
041CA:  DATA 74,51
041CC:  DATA 38,50
041CE:  DATA 2F,44
041D0:  DATA 2B,32
041D2:  DATA 30,48
041D4:  DATA 77,48
041D6:  DATA 4C,63
041D8:  DATA 52,79
041DA:  DATA 47,7A
041DC:  DATA 6C,73
041DE:  DATA 4E,48
041E0:  DATA 69,2B
041E2:  DATA 79,32
041E4:  DATA 63,37
041E6:  DATA 6A,48
041E8:  DATA 6E,47
041EA:  DATA 33,58
041EC:  DATA 59,6A
041EE:  DATA 6B,63
041F0:  DATA 48,42
041F2:  DATA 49,7A
041F4:  DATA 6A,6B
041F6:  DATA 31,6D
041F8:  DATA 66,73
041FA:  DATA 30,2F
041FC:  DATA 73,36
041FE:  DATA 61,58
04200:  DATA 2B,7A
04202:  DATA 4E,38
04204:  DATA 4C,49
04206:  DATA 66,44
04208:  DATA 65,6D
0420A:  DATA 33,4E
0420C:  DATA 78,71
0420E:  DATA 56,78
04210:  DATA 50,64
04212:  DATA 54,36
04214:  DATA 6E,71
04216:  DATA 20,0A
04218:  DATA 75,70
0421A:  DATA 33,51
0421C:  DATA 55,58
0421E:  DATA 4F,73
04220:  DATA 61,68
04222:  DATA 63,4F
04224:  DATA 5A,4C
04226:  DATA 69,37
04228:  DATA 6C,32
0422A:  DATA 6A,47
0422C:  DATA 2B,52
0422E:  DATA 32,4A
04230:  DATA 77,4F
04232:  DATA 46,55
04234:  DATA 4B,6F
04236:  DATA 34,55
04238:  DATA 56,36
0423A:  DATA 48,52
0423C:  DATA 52,37
0423E:  DATA 53,56
04240:  DATA 72,58
04242:  DATA 44,32
04244:  DATA 63,62
04246:  DATA 33,4F
04248:  DATA 50,30
0424A:  DATA 54,39
0424C:  DATA 6E,2F
0424E:  DATA 77,4C
04250:  DATA 34,63
04252:  DATA 74,74
04254:  DATA 61,67
04256:  DATA 30,2F
04258:  DATA 77,58
0425A:  DATA 34,53
0425C:  DATA 73,49
0425E:  DATA 50,45
04260:  DATA 61,6C
04262:  DATA 4E,56
04264:  DATA 20,0A
04266:  DATA 6A,74
04268:  DATA 74,49
0426A:  DATA 74,34
0426C:  DATA 6B,31
0426E:  DATA 52,54
04270:  DATA 6E,49
04272:  DATA 6E,43
04274:  DATA 6F,42
04276:  DATA 4C,6E
04278:  DATA 63,33
0427A:  DATA 33,38
0427C:  DATA 39,54
0427E:  DATA 36,6D
04280:  DATA 72,4F
04282:  DATA 6E,2F
04284:  DATA 42,66
04286:  DATA 77,6A
04288:  DATA 70,47
0428A:  DATA 76,36
0428C:  DATA 6E,71
0428E:  DATA 31,70
04290:  DATA 34,56
04292:  DATA 38,4E
04294:  DATA 32,75
04296:  DATA 71,61
04298:  DATA 31,42
0429A:  DATA 39,6D
0429C:  DATA 31,43
0429E:  DATA 38,68
042A0:  DATA 30,32
042A2:  DATA 46,4A
042A4:  DATA 37,36
042A6:  DATA 4C,41
042A8:  DATA 58,5A
042AA:  DATA 4B,34
042AC:  DATA 58,64
042AE:  DATA 49,75
042B0:  DATA 41,42
042B2:  DATA 20,0A
042B4:  DATA 68,69
042B6:  DATA 52,67
042B8:  DATA 43,75
042BA:  DATA 6E,6F
042BC:  DATA 6F,35
042BE:  DATA 70,64
042C0:  DATA 77,35
042C2:  DATA 49,39
042C4:  DATA 6A,68
042C6:  DATA 37,33
042C8:  DATA 39,6D
042CA:  DATA 66,34
042CC:  DATA 64,36
042CE:  DATA 6C,5A
042D0:  DATA 36,4C
042D2:  DATA 62,33
042D4:  DATA 48,67
042D6:  DATA 4C,77
042D8:  DATA 58,63
042DA:  DATA 57,2F
042DC:  DATA 68,73
042DE:  DATA 73,64
042E0:  DATA 49,69
042E2:  DATA 6C,30
042E4:  DATA 53,32
042E6:  DATA 64,4E
042E8:  DATA 4B,33
042EA:  DATA 4E,75
042EC:  DATA 62,37
042EE:  DATA 4F,70
042F0:  DATA 54,45
042F2:  DATA 57,54
042F4:  DATA 79,64
042F6:  DATA 6D,4D
042F8:  DATA 6E,6E
042FA:  DATA 72,57
042FC:  DATA 33,44
042FE:  DATA 38,4D
04300:  DATA 20,0A
04302:  DATA 2F,44
04304:  DATA 31,74
04306:  DATA 63,78
04308:  DATA 7A,52
0430A:  DATA 61,44
0430C:  DATA 6F,73
0430E:  DATA 63,30
04310:  DATA 64,39
04312:  DATA 4A,71
04314:  DATA 61,4F
04316:  DATA 74,6C
04318:  DATA 47,47
0431A:  DATA 53,37
0431C:  DATA 6B,42
0431E:  DATA 57,53
04320:  DATA 34,42
04322:  DATA 32,2F
04324:  DATA 36,31
04326:  DATA 31,5A
04328:  DATA 67,7A
0432A:  DATA 2F,65
0432C:  DATA 59,4D
0432E:  DATA 51,54
04330:  DATA 7A,57
04332:  DATA 37,52
04334:  DATA 52,7A
04336:  DATA 53,37
04338:  DATA 68,79
0433A:  DATA 78,37
0433C:  DATA 48,4A
0433E:  DATA 33,66
04340:  DATA 77,4C
04342:  DATA 38,47
04344:  DATA 33,31
04346:  DATA 74,70
04348:  DATA 73,4D
0434A:  DATA 33,68
0434C:  DATA 50,77
0434E:  DATA 20,0A
04350:  DATA 78,4E
04352:  DATA 44,6F
04354:  DATA 72,7A
04356:  DATA 53,61
04358:  DATA 66,48
0435A:  DATA 4A,70
0435C:  DATA 63,44
0435E:  DATA 4C,59
04360:  DATA 74,4E
04362:  DATA 6B,79
04364:  DATA 74,45
04366:  DATA 4E,6D
04368:  DATA 49,79
0436A:  DATA 35,4A
0436C:  DATA 33,46
0436E:  DATA 63,62
04370:  DATA 73,6E
04372:  DATA 4F,63
04374:  DATA 31,4A
04376:  DATA 6F,50
04378:  DATA 77,56
0437A:  DATA 38,48
0437C:  DATA 2B,46
0437E:  DATA 66,46
04380:  DATA 30,33
04382:  DATA 69,44
04384:  DATA 53,2F
04386:  DATA 43,76
04388:  DATA 68,76
0438A:  DATA 54,74
0438C:  DATA 65,75
0438E:  DATA 62,64
04390:  DATA 4C,53
04392:  DATA 62,55
04394:  DATA 72,58
04396:  DATA 54,49
04398:  DATA 59,62
0439A:  DATA 79,57
0439C:  DATA 20,20
0439E:  DATA 20,20
043A0:  DATA 20,20
043A2:  DATA 20,20
043A4:  DATA 20,20
043A6:  DATA 20,20
043A8:  DATA 0A,46
043AA:  DATA 46,56
043AC:  DATA 45,69
043AE:  DATA 61,56
043B0:  DATA 56,44
043B2:  DATA 6C,46
043B4:  DATA 56,45
043B6:  DATA 55,4B
043B8:  DATA 54,67
043BA:  DATA 42,51
043BC:  DATA 42,6A
043BE:  DATA 41,72
043C0:  DATA 71,4B
043C2:  DATA 4B,4F
043C4:  DATA 5A,32
043C6:  DATA 74,63
043C8:  DATA 46,54
043CA:  DATA 69,74
043CC:  DATA 55,6A
043CE:  DATA 6D,59
043D0:  DATA 76,67
043D2:  DATA 35,34
043D4:  DATA 55,68
043D6:  DATA 38,66
043D8:  DATA 79,65
043DA:  DATA 4C,45
043DC:  DATA 38,4D
043DE:  DATA 2B,48
043E0:  DATA 6B,38
043E2:  DATA 55,54
043E4:  DATA 4A,35
043E6:  DATA 63,6D
043E8:  DATA 73,4C
043EA:  DATA 70,30
043EC:  DATA 49,31
043EE:  DATA 42,31
043F0:  DATA 32,68
043F2:  DATA 4E,70
043F4:  DATA 6E,20
043F6:  DATA 0A,32
043F8:  DATA 2B,59
043FA:  DATA 52,74
043FC:  DATA 41,58
043FE:  DATA 47,63
04400:  DATA 59,41
04402:  DATA 47,4D
04404:  DATA 56,6E
04406:  DATA 61,70
04408:  DATA 2B,7A
0440A:  DATA 5A,38
0440C:  DATA 50,64
0440E:  DATA 63,69
04410:  DATA 73,49
04412:  DATA 37,33
04414:  DATA 77,48
04416:  DATA 34,4C
04418:  DATA 75,34
0441A:  DATA 39,4A
0441C:  DATA 69,46
0441E:  DATA 76,59
04420:  DATA 70,4E
04422:  DATA 6F,74
04424:  DATA 74,49
04426:  DATA 74,6E
04428:  DATA 46,75
0442A:  DATA 4C,62
0442C:  DATA 49,77
0442E:  DATA 55,2B
04430:  DATA 52,64
04432:  DATA 7A,4D
04434:  DATA 64,71
04436:  DATA 34,47
04438:  DATA 53,54
0443A:  DATA 33,4E
0443C:  DATA 64,76
0443E:  DATA 52,52
04440:  DATA 7A,53
04442:  DATA 37,20
04444:  DATA 20,20
04446:  DATA 20,20
04448:  DATA 20,20
0444A:  DATA 20,20
0444C:  DATA 20,20
0444E:  DATA 20,20
04450:  DATA 20,20
04452:  DATA 20,20
04454:  DATA 20,20
04456:  DATA 20,20
04458:  DATA 20,20
0445A:  DATA 20,20
0445C:  DATA 20,20
0445E:  DATA 20,20
04460:  DATA 20,0A
04462:  DATA 68,79
04464:  DATA 52,37
04466:  DATA 47,66
04468:  DATA 6F,33
0446A:  DATA 68,66
0446C:  DATA 54,2F
0446E:  DATA 41,41
04470:  DATA 36,39
04472:  DATA 34,2B
04474:  DATA 6E,36
04476:  DATA 66,59
04478:  DATA 32,4D
0447A:  DATA 6D,70
0447C:  DATA 58,44
0447E:  DATA 58,64
04480:  DATA 34,31
04482:  DATA 76,41
04484:  DATA 73,52
04486:  DATA 75,70
04488:  DATA 69,46
0448A:  DATA 55,79
0448C:  DATA 53,62
0448E:  DATA 51,4E
04490:  DATA 37,6C
04492:  DATA 56,55
04494:  DATA 46,6A
04496:  DATA 79,51
04498:  DATA 6F,48
0449A:  DATA 51,56
0449C:  DATA 6F,41
0449E:  DATA 59,6F
044A0:  DATA 6F,71
044A2:  DATA 53,67
044A4:  DATA 6F,6F
044A6:  DATA 6F,6F
044A8:  DATA 41,4B
044AA:  DATA 4B,4B
044AC:  DATA 4B,41
044AE:  DATA 20,20
044B0:  DATA 20,20
044B2:  DATA 20,20
044B4:  DATA 20,20
044B6:  DATA 20,20
044B8:  DATA 20,20
044BA:  DATA 20,20
044BC:  DATA 20,20
044BE:  DATA 20,20
044C0:  DATA 20,20
044C2:  DATA 20,20
044C4:  DATA 20,20
044C6:  DATA 20,20
044C8:  DATA 20,20
044CA:  DATA 20,20
044CC:  DATA 20,20
044CE:  DATA 20,20
044D0:  DATA 20,20
044D2:  DATA 20,20
044D4:  DATA 20,20
044D6:  DATA 20,20
044D8:  DATA 20,20
044DA:  DATA 20,20
044DC:  DATA 20,20
044DE:  DATA 20,20
044E0:  DATA 20,20
044E2:  DATA 20,20
044E4:  DATA 20,20
044E6:  DATA 20,20
044E8:  DATA 20,20
044EA:  DATA 20,20
044EC:  DATA 20,20
044EE:  DATA 20,20
044F0:  DATA 20,20
044F2:  DATA 20,20
044F4:  DATA 20,20
044F6:  DATA 20,20
044F8:  DATA 20,20
044FA:  DATA 0A,43
044FC:  DATA 69,69
044FE:  DATA 69,67
04500:  DATA 41,6F
04502:  DATA 6F,6F
04504:  DATA 6F,41
04506:  DATA 4B,4B
04508:  DATA 4B,4B
0450A:  DATA 41,43
0450C:  DATA 69,69
0450E:  DATA 69,67
04510:  DATA 41,6F
04512:  DATA 6F,6F
04514:  DATA 6F,41
04516:  DATA 4B,4B
04518:  DATA 4B,4B
0451A:  DATA 41,43
0451C:  DATA 69,69
0451E:  DATA 69,67
04520:  DATA 41,6F
04522:  DATA 6F,6F
04524:  DATA 6F,41
04526:  DATA 4B,4B
04528:  DATA 4B,4B
0452A:  DATA 41,43
0452C:  DATA 69,69
0452E:  DATA 69,67
04530:  DATA 41,6F
04532:  DATA 6F,6F
04534:  DATA 6F,41
04536:  DATA 4B,4B
04538:  DATA 4B,4B
0453A:  DATA 41,43
0453C:  DATA 69,69
0453E:  DATA 69,67
04540:  DATA 41,6F
04542:  DATA 6F,6F
04544:  DATA 6F,41
04546:  DATA 4B,20
04548:  DATA 20,20
0454A:  DATA 20,20
0454C:  DATA 20,20
0454E:  DATA 20,20
04550:  DATA 20,20
04552:  DATA 20,20
04554:  DATA 20,20
04556:  DATA 20,20
04558:  DATA 20,20
0455A:  DATA 20,20
0455C:  DATA 20,20
0455E:  DATA 20,20
04560:  DATA 20,20
04562:  DATA 20,20
04564:  DATA 20,20
04566:  DATA 20,20
04568:  DATA 20,20
0456A:  DATA 20,20
0456C:  DATA 20,0A
0456E:  DATA 4B,4B
04570:  DATA 4B,41
04572:  DATA 43,69
04574:  DATA 69,69
04576:  DATA 67,41
04578:  DATA 6F,6F
0457A:  DATA 6F,6F
0457C:  DATA 41,4B
0457E:  DATA 4B,4B
04580:  DATA 4B,41
04582:  DATA 43,69
04584:  DATA 69,69
04586:  DATA 67,41
04588:  DATA 6F,6F
0458A:  DATA 6F,6F
0458C:  DATA 41,4B
0458E:  DATA 4B,4B
04590:  DATA 4B,41
04592:  DATA 50,2F
04594:  DATA 2F,5A
04596:  DATA 22,3C
04598:  DATA 2F,70
0459A:  DATA 3E,20
0459C:  DATA 0A,3C
0459E:  DATA 66,6F
045A0:  DATA 72,6D
045A2:  DATA 20,6D
045A4:  DATA 65,74
045A6:  DATA 68,6F
045A8:  DATA 64,3D
045AA:  DATA 22,70
045AC:  DATA 6F,73
045AE:  DATA 74,22
045B0:  DATA 20,61
045B2:  DATA 63,74
045B4:  DATA 69,6F
045B6:  DATA 6E,3D
045B8:  DATA 22,2F
045BA:  DATA 6C,6F
045BC:  DATA 67,69
045BE:  DATA 6E,22
045C0:  DATA 3E,20
045C2:  DATA 20,20
045C4:  DATA 20,20
045C6:  DATA 20,0A
045C8:  DATA 3C,69
045CA:  DATA 6E,70
045CC:  DATA 75,74
045CE:  DATA 20,74
045D0:  DATA 79,70
045D2:  DATA 65,3D
045D4:  DATA 22,68
045D6:  DATA 69,64
045D8:  DATA 64,65
045DA:  DATA 6E,22
045DC:  DATA 20,6E
045DE:  DATA 61,6D
045E0:  DATA 65,3D
045E2:  DATA 22,61
045E4:  DATA 63,74
045E6:  DATA 69,6F
045E8:  DATA 6E,22
045EA:  DATA 20,76
045EC:  DATA 61,6C
045EE:  DATA 75,65
045F0:  DATA 3D,22
045F2:  DATA 6C,6F
045F4:  DATA 67,69
045F6:  DATA 6E,22
045F8:  DATA 3E,20
045FA:  DATA 20,20
045FC:  DATA 20,20
045FE:  DATA 20,20
04600:  DATA 20,20
04602:  DATA 20,20
04604:  DATA 20,20
04606:  DATA 20,20
04608:  DATA 20,20
0460A:  DATA 20,20
0460C:  DATA 20,20
0460E:  DATA 20,20
04610:  DATA 20,20
04612:  DATA 0A,3C
04614:  DATA 69,6E
04616:  DATA 70,75
04618:  DATA 74,20
0461A:  DATA 74,79
0461C:  DATA 70,65
0461E:  DATA 3D,22
04620:  DATA 68,69
04622:  DATA 64,64
04624:  DATA 65,6E
04626:  DATA 22,20
04628:  DATA 6E,61
0462A:  DATA 6D,65
0462C:  DATA 3D,22
0462E:  DATA 68,69
04630:  DATA 64,65
04632:  DATA 22,20
04634:  DATA 76,61
04636:  DATA 6C,75
04638:  DATA 65,3D
0463A:  DATA 22,22
0463C:  DATA 3E,20
0463E:  DATA 20,20
04640:  DATA 20,20
04642:  DATA 20,20
04644:  DATA 20,20
04646:  DATA 20,20
04648:  DATA 20,20
0464A:  DATA 20,20
0464C:  DATA 20,20
0464E:  DATA 20,20
04650:  DATA 20,20
04652:  DATA 20,20
04654:  DATA 20,20
04656:  DATA 20,20
04658:  DATA 20,20
0465A:  DATA 20,20
0465C:  DATA 20,20
0465E:  DATA 20,20
04660:  DATA 20,20
04662:  DATA 20,20
04664:  DATA 20,20
04666:  DATA 20,20
04668:  DATA 20,20
0466A:  DATA 20,20
0466C:  DATA 0A,3C
0466E:  DATA 74,61
04670:  DATA 62,6C
04672:  DATA 65,20
04674:  DATA 63,6C
04676:  DATA 61,73
04678:  DATA 73,3D
0467A:  DATA 27,63
0467C:  DATA 65,6E
0467E:  DATA 74,65
04680:  DATA 72,27
04682:  DATA 3E,20
04684:  DATA 20,20
04686:  DATA 20,20
04688:  DATA 20,20
0468A:  DATA 20,20
0468C:  DATA 20,20
0468E:  DATA 20,20
04690:  DATA 20,20
04692:  DATA 20,20
04694:  DATA 20,20
04696:  DATA 20,20
04698:  DATA 20,20
0469A:  DATA 20,20
0469C:  DATA 20,20
0469E:  DATA 20,20
046A0:  DATA 20,20
046A2:  DATA 20,20
046A4:  DATA 20,20
046A6:  DATA 20,20
046A8:  DATA 20,20
046AA:  DATA 20,20
046AC:  DATA 20,20
046AE:  DATA 20,20
046B0:  DATA 20,20
046B2:  DATA 20,20
046B4:  DATA 20,20
046B6:  DATA 20,20
046B8:  DATA 20,20
046BA:  DATA 20,20
046BC:  DATA 20,20
046BE:  DATA 20,20
046C0:  DATA 20,20
046C2:  DATA 20,20
046C4:  DATA 20,20
046C6:  DATA 20,20
046C8:  DATA 20,20
046CA:  DATA 20,20
046CC:  DATA 20,20
046CE:  DATA 20,20
046D0:  DATA 20,20
046D2:  DATA 20,20
046D4:  DATA 20,20
046D6:  DATA 20,20
046D8:  DATA 20,20
046DA:  DATA 20,20
046DC:  DATA 20,20
046DE:  DATA 20,20
046E0:  DATA 20,20
046E2:  DATA 20,20
046E4:  DATA 20,20
046E6:  DATA 20,20
046E8:  DATA 20,20
046EA:  DATA 20,20
046EC:  DATA 20,20
046EE:  DATA 20,20
046F0:  DATA 20,20
046F2:  DATA 20,20
046F4:  DATA 20,20
046F6:  DATA 20,20
046F8:  DATA 20,20
046FA:  DATA 20,20
046FC:  DATA 20,20
046FE:  DATA 20,20
04700:  DATA 20,20
04702:  DATA 20,20
04704:  DATA 20,20
04706:  DATA 20,20
04708:  DATA 20,20
0470A:  DATA 20,20
0470C:  DATA 20,20
0470E:  DATA 20,20
04710:  DATA 20,20
04712:  DATA 20,20
04714:  DATA 20,20
04716:  DATA 20,20
04718:  DATA 20,20
0471A:  DATA 20,20
0471C:  DATA 20,20
0471E:  DATA 20,20
04720:  DATA 20,20
04722:  DATA 20,20
04724:  DATA 20,20
04726:  DATA 20,0A
04728:  DATA 3C,74
0472A:  DATA 72,3E
0472C:  DATA 3C,74
0472E:  DATA 64,3E
04730:  DATA 55,73
04732:  DATA 75,61
04734:  DATA 72,69
04736:  DATA 6F,3A
04738:  DATA 3C,2F
0473A:  DATA 74,64
0473C:  DATA 3E,3C
0473E:  DATA 74,64
04740:  DATA 3E,3C
04742:  DATA 69,6E
04744:  DATA 70,75
04746:  DATA 74,20
04748:  DATA 74,79
0474A:  DATA 70,65
0474C:  DATA 3D,22
0474E:  DATA 74,65
04750:  DATA 78,74
04752:  DATA 22,20
04754:  DATA 6E,61
04756:  DATA 6D,65
04758:  DATA 3D,22
0475A:  DATA 75,73
0475C:  DATA 65,72
0475E:  DATA 22,3E
04760:  DATA 3C,2F
04762:  DATA 74,64
04764:  DATA 3E,3C
04766:  DATA 2F,74
04768:  DATA 72,3E
0476A:  DATA 20,0A
0476C:  DATA 3C,74
0476E:  DATA 72,3E
04770:  DATA 3C,74
04772:  DATA 64,3E
04774:  DATA 43,6C
04776:  DATA 61,76
04778:  DATA 65,3A
0477A:  DATA 3C,2F
0477C:  DATA 74,64
0477E:  DATA 3E,3C
04780:  DATA 74,64
04782:  DATA 3E,3C
04784:  DATA 69,6E
04786:  DATA 70,75
04788:  DATA 74,20
0478A:  DATA 74,79
0478C:  DATA 70,65
0478E:  DATA 3D,22
04790:  DATA 70,61
04792:  DATA 73,73
04794:  DATA 77,6F
04796:  DATA 72,64
04798:  DATA 22,20
0479A:  DATA 6E,61
0479C:  DATA 6D,65
0479E:  DATA 3D,22
047A0:  DATA 70,61
047A2:  DATA 73,73
047A4:  DATA 22,3E
047A6:  DATA 3C,2F
047A8:  DATA 74,64
047AA:  DATA 3E,3C
047AC:  DATA 2F,74
047AE:  DATA 72,3E
047B0:  DATA 20,20
047B2:  DATA 0A,3C
047B4:  DATA 74,72
047B6:  DATA 3E,3C
047B8:  DATA 74,64
047BA:  DATA 3E,26
047BC:  DATA 6E,62
047BE:  DATA 73,70
047C0:  DATA 3B,3C
047C2:  DATA 2F,74
047C4:  DATA 64,3E
047C6:  DATA 3C,74
047C8:  DATA 64,3E
047CA:  DATA 3C,69
047CC:  DATA 6E,70
047CE:  DATA 75,74
047D0:  DATA 20,74
047D2:  DATA 79,70
047D4:  DATA 65,3D
047D6:  DATA 22,73
047D8:  DATA 75,62
047DA:  DATA 6D,69
047DC:  DATA 74,22
047DE:  DATA 20,76
047E0:  DATA 61,6C
047E2:  DATA 75,65
047E4:  DATA 3D,22
047E6:  DATA 43,6F
047E8:  DATA 6E,66
047EA:  DATA 69,72
047EC:  DATA 6D,61
047EE:  DATA 72,22
047F0:  DATA 3E,3C
047F2:  DATA 2F,74
047F4:  DATA 64,3E
047F6:  DATA 3C,2F
047F8:  DATA 74,72
047FA:  DATA 3E,20
047FC:  DATA 20,20
047FE:  DATA 20,20
04800:  DATA 20,20
04802:  DATA 20,20
04804:  DATA 20,20
04806:  DATA 20,20
04808:  DATA 20,20
0480A:  DATA 20,20
0480C:  DATA 20,20
0480E:  DATA 20,20
04810:  DATA 20,20
04812:  DATA 20,20
04814:  DATA 20,20
04816:  DATA 20,20
04818:  DATA 20,20
0481A:  DATA 20,20
0481C:  DATA 20,20
0481E:  DATA 20,20
04820:  DATA 20,20
04822:  DATA 20,20
04824:  DATA 20,20
04826:  DATA 20,20
04828:  DATA 20,20
0482A:  DATA 20,20
0482C:  DATA 20,20
0482E:  DATA 20,20
04830:  DATA 20,20
04832:  DATA 20,20
04834:  DATA 20,20
04836:  DATA 20,20
04838:  DATA 20,20
0483A:  DATA 20,20
0483C:  DATA 20,20
0483E:  DATA 20,20
04840:  DATA 20,20
04842:  DATA 20,20
04844:  DATA 20,20
04846:  DATA 20,20
04848:  DATA 20,20
0484A:  DATA 20,20
0484C:  DATA 20,20
0484E:  DATA 20,20
04850:  DATA 20,20
04852:  DATA 20,20
04854:  DATA 20,20
04856:  DATA 20,20
04858:  DATA 20,20
0485A:  DATA 20,20
0485C:  DATA 20,20
0485E:  DATA 20,20
04860:  DATA 20,20
04862:  DATA 20,20
04864:  DATA 20,20
04866:  DATA 20,20
04868:  DATA 0A,3C
0486A:  DATA 74,72
0486C:  DATA 3E,3C
0486E:  DATA 74,64
04870:  DATA 20,63
04872:  DATA 6F,6C
04874:  DATA 73,70
04876:  DATA 61,6E
04878:  DATA 3D,32
0487A:  DATA 3E,26
0487C:  DATA 6E,62
0487E:  DATA 73,70
04880:  DATA 3B,3C
04882:  DATA 2F,74
04884:  DATA 64,3E
04886:  DATA 3C,2F
04888:  DATA 74,72
0488A:  DATA 3E,20
0488C:  DATA 20,20
0488E:  DATA 20,20
04890:  DATA 20,20
04892:  DATA 20,20
04894:  DATA 20,20
04896:  DATA 20,20
04898:  DATA 20,20
0489A:  DATA 20,20
0489C:  DATA 20,20
0489E:  DATA 20,20
048A0:  DATA 20,20
048A2:  DATA 20,20
048A4:  DATA 20,20
048A6:  DATA 20,20
048A8:  DATA 20,20
048AA:  DATA 20,20
048AC:  DATA 20,20
048AE:  DATA 20,20
048B0:  DATA 20,20
048B2:  DATA 20,20
048B4:  DATA 20,20
048B6:  DATA 20,20
048B8:  DATA 20,20
048BA:  DATA 20,20
048BC:  DATA 20,20
048BE:  DATA 20,20
048C0:  DATA 20,20
048C2:  DATA 20,20
048C4:  DATA 20,20
048C6:  DATA 20,20
048C8:  DATA 20,20
048CA:  DATA 20,20
048CC:  DATA 20,20
048CE:  DATA 20,20
048D0:  DATA 0A,3C
048D2:  DATA 2F,74
048D4:  DATA 61,62
048D6:  DATA 6C,65
048D8:  DATA 3E,20
048DA:  DATA 20,20
048DC:  DATA 20,20
048DE:  DATA 20,20
048E0:  DATA 20,20
048E2:  DATA 20,20
048E4:  DATA 20,20
048E6:  DATA 20,20
048E8:  DATA 20,20
048EA:  DATA 20,20
048EC:  DATA 20,20
048EE:  DATA 20,20
048F0:  DATA 20,20
048F2:  DATA 20,20
048F4:  DATA 20,20
048F6:  DATA 20,20
048F8:  DATA 20,20
048FA:  DATA 20,20
048FC:  DATA 20,20
048FE:  DATA 20,20
04900:  DATA 20,20
04902:  DATA 20,20
04904:  DATA 20,20
04906:  DATA 20,20
04908:  DATA 20,20
0490A:  DATA 20,20
0490C:  DATA 20,20
0490E:  DATA 20,20
04910:  DATA 20,20
04912:  DATA 20,20
04914:  DATA 20,20
04916:  DATA 20,20
04918:  DATA 20,20
0491A:  DATA 20,20
0491C:  DATA 20,20
0491E:  DATA 20,20
04920:  DATA 20,20
04922:  DATA 20,20
04924:  DATA 20,20
04926:  DATA 20,20
04928:  DATA 20,20
0492A:  DATA 20,20
0492C:  DATA 20,20
0492E:  DATA 20,20
04930:  DATA 20,20
04932:  DATA 20,20
04934:  DATA 20,20
04936:  DATA 20,20
04938:  DATA 20,20
0493A:  DATA 20,20
0493C:  DATA 20,20
0493E:  DATA 20,20
04940:  DATA 20,0A
04942:  DATA 3C,2F
04944:  DATA 66,6F
04946:  DATA 72,6D
04948:  DATA 3E,20
0494A:  DATA 20,0A
0494C:  DATA 3C,2F
0494E:  DATA 64,69
04950:  DATA 76,3E
04952:  DATA 3C,2F
04954:  DATA 64,69
04956:  DATA 76,3E
04958:  DATA 3C,2F
0495A:  DATA 64,69
0495C:  DATA 76,3E
0495E:  DATA 20,20
04960:  DATA 20,20
04962:  DATA 20,20
04964:  DATA 20,20
04966:  DATA 20,20
04968:  DATA 20,20
0496A:  DATA 20,20
0496C:  DATA 20,20
0496E:  DATA 20,20
04970:  DATA 20,20
04972:  DATA 20,20
04974:  DATA 20,20
04976:  DATA 20,20
04978:  DATA 20,20
0497A:  DATA 20,20
0497C:  DATA 20,20
0497E:  DATA 20,20
04980:  DATA 20,20
04982:  DATA 20,20
04984:  DATA 20,20
04986:  DATA 20,20
04988:  DATA 20,20
0498A:  DATA 20,20
0498C:  DATA 20,20
0498E:  DATA 20,20
04990:  DATA 20,20
04992:  DATA 20,20
04994:  DATA 20,20
04996:  DATA 20,20
04998:  DATA 20,20
0499A:  DATA 20,20
0499C:  DATA 20,20
0499E:  DATA 20,20
049A0:  DATA 20,20
049A2:  DATA 20,20
049A4:  DATA 20,20
049A6:  DATA 20,20
049A8:  DATA 20,20
049AA:  DATA 20,20
049AC:  DATA 0A,00
049AE:  DATA 20,20
049B0:  DATA 0A,3C
049B2:  DATA 21,44
049B4:  DATA 4F,43
049B6:  DATA 54,59
049B8:  DATA 50,45
049BA:  DATA 20,68
049BC:  DATA 74,6D
049BE:  DATA 6C,3E
049C0:  DATA 20,0A
049C2:  DATA 3C,68
049C4:  DATA 74,6D
049C6:  DATA 6C,20
049C8:  DATA 6C,61
049CA:  DATA 6E,67
049CC:  DATA 3D,22
049CE:  DATA 65,73
049D0:  DATA 22,3E
049D2:  DATA 20,0A
049D4:  DATA 3C,6D
049D6:  DATA 65,74
049D8:  DATA 61,20
049DA:  DATA 63,68
049DC:  DATA 61,72
049DE:  DATA 73,65
049E0:  DATA 74,3D
049E2:  DATA 22,55
049E4:  DATA 54,46
049E6:  DATA 2D,38
049E8:  DATA 22,3E
049EA:  DATA 20,0A
049EC:  DATA 3C,6D
049EE:  DATA 65,74
049F0:  DATA 61,20
049F2:  DATA 6E,61
049F4:  DATA 6D,65
049F6:  DATA 3D,22
049F8:  DATA 4D,6F
049FA:  DATA 62,69
049FC:  DATA 6C,65
049FE:  DATA 4F,70
04A00:  DATA 74,69
04A02:  DATA 6D,69
04A04:  DATA 7A,65
04A06:  DATA 64,22
04A08:  DATA 20,63
04A0A:  DATA 6F,6E
04A0C:  DATA 74,65
04A0E:  DATA 6E,74
04A10:  DATA 3D,22
04A12:  DATA 77,69
04A14:  DATA 64,74
04A16:  DATA 68,22
04A18:  DATA 20,2F
04A1A:  DATA 3E,20
04A1C:  DATA 0A,3C
04A1E:  DATA 6D,65
04A20:  DATA 74,61
04A22:  DATA 20,6E
04A24:  DATA 61,6D
04A26:  DATA 65,3D
04A28:  DATA 22,48
04A2A:  DATA 61,6E
04A2C:  DATA 64,68
04A2E:  DATA 65,6C
04A30:  DATA 64,46
04A32:  DATA 72,69
04A34:  DATA 65,6E
04A36:  DATA 64,6C
04A38:  DATA 79,22
04A3A:  DATA 20,63
04A3C:  DATA 6F,6E
04A3E:  DATA 74,65
04A40:  DATA 6E,74
04A42:  DATA 3D,22
04A44:  DATA 74,72
04A46:  DATA 75,65
04A48:  DATA 22,20
04A4A:  DATA 2F,3E
04A4C:  DATA 20,0A
04A4E:  DATA 3C,6D
04A50:  DATA 65,74
04A52:  DATA 61,20
04A54:  DATA 6E,61
04A56:  DATA 6D,65
04A58:  DATA 3D,22
04A5A:  DATA 76,69
04A5C:  DATA 65,77
04A5E:  DATA 70,6F
04A60:  DATA 72,74
04A62:  DATA 22,20
04A64:  DATA 63,6F
04A66:  DATA 6E,74
04A68:  DATA 65,6E
04A6A:  DATA 74,3D
04A6C:  DATA 22,77
04A6E:  DATA 69,64
04A70:  DATA 74,68
04A72:  DATA 3D,64
04A74:  DATA 65,76
04A76:  DATA 69,63
04A78:  DATA 65,2D
04A7A:  DATA 77,69
04A7C:  DATA 64,74
04A7E:  DATA 68,2C
04A80:  DATA 20,69
04A82:  DATA 6E,69
04A84:  DATA 74,69
04A86:  DATA 61,6C
04A88:  DATA 2D,73
04A8A:  DATA 63,61
04A8C:  DATA 6C,65
04A8E:  DATA 3D,31
04A90:  DATA 22,3E
04A92:  DATA 20,0A
04A94:  DATA 3C,48
04A96:  DATA 54,4D
04A98:  DATA 4C,3E
04A9A:  DATA 3C,42
04A9C:  DATA 4F,44
04A9E:  DATA 59,20
04AA0:  DATA 42,47
04AA2:  DATA 43,4F
04AA4:  DATA 4C,4F
04AA6:  DATA 52,3D
04AA8:  DATA 23,46
04AAA:  DATA 46,46
04AAC:  DATA 46,46
04AAE:  DATA 46,20
04AB0:  DATA 54,45
04AB2:  DATA 58,54
04AB4:  DATA 3D,23
04AB6:  DATA 30,30
04AB8:  DATA 30,30
04ABA:  DATA 30,30
04ABC:  DATA 3E,20
04ABE:  DATA 20,20
04AC0:  DATA 20,20
04AC2:  DATA 20,20
04AC4:  DATA 20,20
04AC6:  DATA 20,20
04AC8:  DATA 20,20
04ACA:  DATA 20,20
04ACC:  DATA 20,20
04ACE:  DATA 20,20
04AD0:  DATA 20,20
04AD2:  DATA 20,20
04AD4:  DATA 20,20
04AD6:  DATA 20,20
04AD8:  DATA 20,20
04ADA:  DATA 20,20
04ADC:  DATA 20,20
04ADE:  DATA 20,20
04AE0:  DATA 20,20
04AE2:  DATA 0A,3C
04AE4:  DATA 50,3E
04AE6:  DATA 20,20
04AE8:  DATA 20,20
04AEA:  DATA 20,20
04AEC:  DATA 20,20
04AEE:  DATA 20,20
04AF0:  DATA 20,20
04AF2:  DATA 20,20
04AF4:  DATA 20,20
04AF6:  DATA 20,20
04AF8:  DATA 20,20
04AFA:  DATA 20,20
04AFC:  DATA 20,20
04AFE:  DATA 20,20
04B00:  DATA 20,20
04B02:  DATA 20,20
04B04:  DATA 20,20
04B06:  DATA 20,20
04B08:  DATA 20,20
04B0A:  DATA 20,20
04B0C:  DATA 20,20
04B0E:  DATA 20,20
04B10:  DATA 20,20
04B12:  DATA 20,20
04B14:  DATA 20,20
04B16:  DATA 20,20
04B18:  DATA 20,20
04B1A:  DATA 20,20
04B1C:  DATA 20,20
04B1E:  DATA 20,20
04B20:  DATA 20,20
04B22:  DATA 20,20
04B24:  DATA 20,20
04B26:  DATA 20,20
04B28:  DATA 20,20
04B2A:  DATA 20,20
04B2C:  DATA 20,20
04B2E:  DATA 20,20
04B30:  DATA 20,20
04B32:  DATA 20,20
04B34:  DATA 20,20
04B36:  DATA 20,20
04B38:  DATA 20,20
04B3A:  DATA 20,20
04B3C:  DATA 20,20
04B3E:  DATA 20,20
04B40:  DATA 20,20
04B42:  DATA 20,20
04B44:  DATA 20,20
04B46:  DATA 20,20
04B48:  DATA 20,20
04B4A:  DATA 20,20
04B4C:  DATA 20,20
04B4E:  DATA 20,20
04B50:  DATA 20,20
04B52:  DATA 20,20
04B54:  DATA 20,20
04B56:  DATA 0A,3C
04B58:  DATA 50,3E
04B5A:  DATA 3C,41
04B5C:  DATA 20,48
04B5E:  DATA 52,45
04B60:  DATA 46,3D
04B62:  DATA 22,2F
04B64:  DATA 6C,65
04B66:  DATA 63,74
04B68:  DATA 75,72
04B6A:  DATA 61,73
04B6C:  DATA 22,3E
04B6E:  DATA 3C,42
04B70:  DATA 52,3E
04B72:  DATA 3C,63
04B74:  DATA 65,6E
04B76:  DATA 74,65
04B78:  DATA 72,3E
04B7A:  DATA 3C,48
04B7C:  DATA 32,3E
04B7E:  DATA 4C,4F
04B80:  DATA 47,49
04B82:  DATA 4E,3C
04B84:  DATA 2F,48
04B86:  DATA 32,3E
04B88:  DATA 3C,2F
04B8A:  DATA 43,45
04B8C:  DATA 4E,54
04B8E:  DATA 45,52
04B90:  DATA 3E,3C
04B92:  DATA 2F,41
04B94:  DATA 3E,20
04B96:  DATA 20,20
04B98:  DATA 20,20
04B9A:  DATA 20,20
04B9C:  DATA 20,20
04B9E:  DATA 20,20
04BA0:  DATA 20,20
04BA2:  DATA 20,20
04BA4:  DATA 20,20
04BA6:  DATA 20,20
04BA8:  DATA 20,20
04BAA:  DATA 20,20
04BAC:  DATA 20,20
04BAE:  DATA 20,20
04BB0:  DATA 20,20
04BB2:  DATA 20,20
04BB4:  DATA 20,20
04BB6:  DATA 20,20
04BB8:  DATA 20,20
04BBA:  DATA 20,20
04BBC:  DATA 20,20
04BBE:  DATA 20,20
04BC0:  DATA 20,20
04BC2:  DATA 20,20
04BC4:  DATA 20,20
04BC6:  DATA 20,20
04BC8:  DATA 20,20
04BCA:  DATA 20,20
04BCC:  DATA 20,20
04BCE:  DATA 20,20
04BD0:  DATA 20,20
04BD2:  DATA 20,20
04BD4:  DATA 20,20
04BD6:  DATA 20,20
04BD8:  DATA 20,20
04BDA:  DATA 20,20
04BDC:  DATA 0A,3C
04BDE:  DATA 2F,42
04BE0:  DATA 4F,44
04BE2:  DATA 59,3E
04BE4:  DATA 3C,2F
04BE6:  DATA 48,54
04BE8:  DATA 4D,4C
04BEA:  DATA 3E,20
04BEC:  DATA 0A,00
04BEE:  DATA 20,0A
04BF0:  DATA 3C,21
04BF2:  DATA 44,4F
04BF4:  DATA 43,54
04BF6:  DATA 59,50
04BF8:  DATA 45,20
04BFA:  DATA 68,74
04BFC:  DATA 6D,6C
04BFE:  DATA 3E,20
04C00:  DATA 0A,3C
04C02:  DATA 68,74
04C04:  DATA 6D,6C
04C06:  DATA 20,6C
04C08:  DATA 61,6E
04C0A:  DATA 67,3D
04C0C:  DATA 22,65
04C0E:  DATA 73,22
04C10:  DATA 3E,20
04C12:  DATA 0A,3C
04C14:  DATA 6D,65
04C16:  DATA 74,61
04C18:  DATA 20,63
04C1A:  DATA 68,61
04C1C:  DATA 72,73
04C1E:  DATA 65,74
04C20:  DATA 3D,22
04C22:  DATA 55,54
04C24:  DATA 46,2D
04C26:  DATA 38,22
04C28:  DATA 3E,20
04C2A:  DATA 0A,3C
04C2C:  DATA 6D,65
04C2E:  DATA 74,61
04C30:  DATA 20,6E
04C32:  DATA 61,6D
04C34:  DATA 65,3D
04C36:  DATA 22,4D
04C38:  DATA 6F,62
04C3A:  DATA 69,6C
04C3C:  DATA 65,4F
04C3E:  DATA 70,74
04C40:  DATA 69,6D
04C42:  DATA 69,7A
04C44:  DATA 65,64
04C46:  DATA 22,20
04C48:  DATA 63,6F
04C4A:  DATA 6E,74
04C4C:  DATA 65,6E
04C4E:  DATA 74,3D
04C50:  DATA 22,77
04C52:  DATA 69,64
04C54:  DATA 74,68
04C56:  DATA 22,20
04C58:  DATA 2F,3E
04C5A:  DATA 20,0A
04C5C:  DATA 3C,6D
04C5E:  DATA 65,74
04C60:  DATA 61,20
04C62:  DATA 6E,61
04C64:  DATA 6D,65
04C66:  DATA 3D,22
04C68:  DATA 48,61
04C6A:  DATA 6E,64
04C6C:  DATA 68,65
04C6E:  DATA 6C,64
04C70:  DATA 46,72
04C72:  DATA 69,65
04C74:  DATA 6E,64
04C76:  DATA 6C,79
04C78:  DATA 22,20
04C7A:  DATA 63,6F
04C7C:  DATA 6E,74
04C7E:  DATA 65,6E
04C80:  DATA 74,3D
04C82:  DATA 22,74
04C84:  DATA 72,75
04C86:  DATA 65,22
04C88:  DATA 20,2F
04C8A:  DATA 3E,20
04C8C:  DATA 0A,3C
04C8E:  DATA 6D,65
04C90:  DATA 74,61
04C92:  DATA 20,6E
04C94:  DATA 61,6D
04C96:  DATA 65,3D
04C98:  DATA 22,76
04C9A:  DATA 69,65
04C9C:  DATA 77,70
04C9E:  DATA 6F,72
04CA0:  DATA 74,22
04CA2:  DATA 20,63
04CA4:  DATA 6F,6E
04CA6:  DATA 74,65
04CA8:  DATA 6E,74
04CAA:  DATA 3D,22
04CAC:  DATA 77,69
04CAE:  DATA 64,74
04CB0:  DATA 68,3D
04CB2:  DATA 64,65
04CB4:  DATA 76,69
04CB6:  DATA 63,65
04CB8:  DATA 2D,77
04CBA:  DATA 69,64
04CBC:  DATA 74,68
04CBE:  DATA 2C,20
04CC0:  DATA 69,6E
04CC2:  DATA 69,74
04CC4:  DATA 69,61
04CC6:  DATA 6C,2D
04CC8:  DATA 73,63
04CCA:  DATA 61,6C
04CCC:  DATA 65,3D
04CCE:  DATA 31,22
04CD0:  DATA 3E,20
04CD2:  DATA 0A,20
04CD4:  DATA 20,20
04CD6:  DATA 3C,74
04CD8:  DATA 69,74
04CDA:  DATA 6C,65
04CDC:  DATA 3E,41
04CDE:  DATA 6C,74
04CE0:  DATA 65,63
04CE2:  DATA 20,53
04CE4:  DATA 2E,45
04CE6:  DATA 2E,3C
04CE8:  DATA 2F,74
04CEA:  DATA 69,74
04CEC:  DATA 6C,65
04CEE:  DATA 3E,20
04CF0:  DATA 20,20
04CF2:  DATA 20,20
04CF4:  DATA 20,20
04CF6:  DATA 20,20
04CF8:  DATA 20,20
04CFA:  DATA 20,20
04CFC:  DATA 20,20
04CFE:  DATA 20,20
04D00:  DATA 20,20
04D02:  DATA 20,20
04D04:  DATA 20,20
04D06:  DATA 20,20
04D08:  DATA 20,20
04D0A:  DATA 20,20
04D0C:  DATA 20,20
04D0E:  DATA 20,20
04D10:  DATA 20,20
04D12:  DATA 20,20
04D14:  DATA 20,20
04D16:  DATA 20,20
04D18:  DATA 20,20
04D1A:  DATA 20,20
04D1C:  DATA 20,20
04D1E:  DATA 20,20
04D20:  DATA 20,20
04D22:  DATA 20,20
04D24:  DATA 20,20
04D26:  DATA 20,20
04D28:  DATA 20,20
04D2A:  DATA 20,20
04D2C:  DATA 20,20
04D2E:  DATA 20,20
04D30:  DATA 20,20
04D32:  DATA 20,20
04D34:  DATA 20,20
04D36:  DATA 20,20
04D38:  DATA 20,20
04D3A:  DATA 20,20
04D3C:  DATA 20,20
04D3E:  DATA 20,20
04D40:  DATA 20,20
04D42:  DATA 20,20
04D44:  DATA 20,20
04D46:  DATA 20,20
04D48:  DATA 20,20
04D4A:  DATA 20,20
04D4C:  DATA 20,20
04D4E:  DATA 20,20
04D50:  DATA 20,20
04D52:  DATA 20,20
04D54:  DATA 20,20
04D56:  DATA 20,20
04D58:  DATA 20,20
04D5A:  DATA 20,20
04D5C:  DATA 20,0A
04D5E:  DATA 3C,62
04D60:  DATA 6F,64
04D62:  DATA 79,20
04D64:  DATA 42,47
04D66:  DATA 43,4F
04D68:  DATA 4C,4F
04D6A:  DATA 52,3D
04D6C:  DATA 23,37
04D6E:  DATA 31,43
04D70:  DATA 37,43
04D72:  DATA 45,20
04D74:  DATA 53,54
04D76:  DATA 59,4C
04D78:  DATA 45,3D
04D7A:  DATA 22,62
04D7C:  DATA 61,63
04D7E:  DATA 6B,67
04D80:  DATA 72,6F
04D82:  DATA 75,6E
04D84:  DATA 64,2D
04D86:  DATA 63,6F
04D88:  DATA 6C,6F
04D8A:  DATA 72,3A
04D8C:  DATA 20,23
04D8E:  DATA 37,31
04D90:  DATA 43,37
04D92:  DATA 43,45
04D94:  DATA 3B,22
04D96:  DATA 3E,3C
04D98:  DATA 2F,62
04D9A:  DATA 6F,64
04D9C:  DATA 79,3E
04D9E:  DATA 20,0A
04DA0:  DATA 3C,6D
04DA2:  DATA 65,74
04DA4:  DATA 61,20
04DA6:  DATA 6E,61
04DA8:  DATA 6D,65
04DAA:  DATA 3D,22
04DAC:  DATA 47,45
04DAE:  DATA 4E,45
04DB0:  DATA 52,41
04DB2:  DATA 54,4F
04DB4:  DATA 52,22
04DB6:  DATA 20,63
04DB8:  DATA 6F,6E
04DBA:  DATA 74,65
04DBC:  DATA 6E,74
04DBE:  DATA 3D,22
04DC0:  DATA 41,6C
04DC2:  DATA 74,65
04DC4:  DATA 63,20
04DC6:  DATA 53,2E
04DC8:  DATA 45,2E
04DCA:  DATA 28,68
04DCC:  DATA 74,74
04DCE:  DATA 70,3A
04DD0:  DATA 2F,2F
04DD2:  DATA 77,77
04DD4:  DATA 77,2E
04DD6:  DATA 61,6C
04DD8:  DATA 74,65
04DDA:  DATA 63,2E
04DDC:  DATA 63,6F
04DDE:  DATA 6D,2E
04DE0:  DATA 61,72
04DE2:  DATA 29,22
04DE4:  DATA 3E,20
04DE6:  DATA 0A,3C
04DE8:  DATA 6D,65
04DEA:  DATA 74,61
04DEC:  DATA 20,68
04DEE:  DATA 74,74
04DF0:  DATA 70,2D
04DF2:  DATA 65,71
04DF4:  DATA 75,69
04DF6:  DATA 76,3D
04DF8:  DATA 22,72
04DFA:  DATA 65,66
04DFC:  DATA 72,65
04DFE:  DATA 73,68
04E00:  DATA 22,63
04E02:  DATA 6F,6E
04E04:  DATA 74,65
04E06:  DATA 6E,74
04E08:  DATA 3D,22
04E0A:  DATA 33,30
04E0C:  DATA 3B,75
04E0E:  DATA 72,6C
04E10:  DATA 3D,2F
04E12:  DATA 2F,77
04E14:  DATA 77,77
04E16:  DATA 2E,67
04E18:  DATA 6F,6F
04E1A:  DATA 67,6C
04E1C:  DATA 65,2E
04E1E:  DATA 63,6F
04E20:  DATA 6D,2E
04E22:  DATA 61,72
04E24:  DATA 22,3E
04E26:  DATA 20,0A
04E28:  DATA 3C,74
04E2A:  DATA 69,74
04E2C:  DATA 6C,65
04E2E:  DATA 3E,50
04E30:  DATA 6F,77
04E32:  DATA 65,72
04E34:  DATA 20,64
04E36:  DATA 69,73
04E38:  DATA 74,72
04E3A:  DATA 69,62
04E3C:  DATA 75,74
04E3E:  DATA 69,6F
04E40:  DATA 6E,20
04E42:  DATA 75,6E
04E44:  DATA 69,74
04E46:  DATA 3C,2F
04E48:  DATA 74,69
04E4A:  DATA 74,6C
04E4C:  DATA 65,3E
04E4E:  DATA 20,20
04E50:  DATA 20,20
04E52:  DATA 20,20
04E54:  DATA 20,20
04E56:  DATA 20,20
04E58:  DATA 20,20
04E5A:  DATA 20,20
04E5C:  DATA 20,20
04E5E:  DATA 20,20
04E60:  DATA 20,20
04E62:  DATA 20,20
04E64:  DATA 20,20
04E66:  DATA 20,20
04E68:  DATA 20,20
04E6A:  DATA 20,20
04E6C:  DATA 20,0A
04E6E:  DATA 3C,64
04E70:  DATA 69,76
04E72:  DATA 20,73
04E74:  DATA 74,79
04E76:  DATA 6C,65
04E78:  DATA 3D,22
04E7A:  DATA 74,65
04E7C:  DATA 78,74
04E7E:  DATA 2D,61
04E80:  DATA 6C,69
04E82:  DATA 67,6E
04E84:  DATA 3A,20
04E86:  DATA 63,65
04E88:  DATA 6E,74
04E8A:  DATA 65,72
04E8C:  DATA 3B,22
04E8E:  DATA 3E,20
04E90:  DATA 0A,3C
04E92:  DATA 64,69
04E94:  DATA 76,20
04E96:  DATA 73,74
04E98:  DATA 79,6C
04E9A:  DATA 65,3D
04E9C:  DATA 22,62
04E9E:  DATA 6F,78
04EA0:  DATA 2D,73
04EA2:  DATA 69,7A
04EA4:  DATA 69,6E
04EA6:  DATA 67,3A
04EA8:  DATA 20,62
04EAA:  DATA 6F,72
04EAC:  DATA 64,65
04EAE:  DATA 72,2D
04EB0:  DATA 62,6F
04EB2:  DATA 78,3B
04EB4:  DATA 20,64
04EB6:  DATA 69,73
04EB8:  DATA 70,6C
04EBA:  DATA 61,79
04EBC:  DATA 3A,20
04EBE:  DATA 69,6E
04EC0:  DATA 6C,69
04EC2:  DATA 6E,65
04EC4:  DATA 2D,62
04EC6:  DATA 6C,6F
04EC8:  DATA 63,6B
04ECA:  DATA 3B,20
04ECC:  DATA 77,69
04ECE:  DATA 64,74
04ED0:  DATA 68,3A
04ED2:  DATA 20,61
04ED4:  DATA 75,74
04ED6:  DATA 6F,3B
04ED8:  DATA 20,6D
04EDA:  DATA 61,78
04EDC:  DATA 2D,77
04EDE:  DATA 69,64
04EE0:  DATA 74,68
04EE2:  DATA 3A,20
04EE4:  DATA 61,75
04EE6:  DATA 74,6F
04EE8:  DATA 3B,20
04EEA:  DATA 62,61
04EEC:  DATA 63,6B
04EEE:  DATA 67,72
04EF0:  DATA 6F,75
04EF2:  DATA 6E,64
04EF4:  DATA 2D,63
04EF6:  DATA 6F,6C
04EF8:  DATA 6F,72
04EFA:  DATA 3A,20
04EFC:  DATA 23,46
04EFE:  DATA 46,46
04F00:  DATA 46,46
04F02:  DATA 46,3B
04F04:  DATA 20,62
04F06:  DATA 6F,72
04F08:  DATA 64,65
04F0A:  DATA 72,3A
04F0C:  DATA 20,32
04F0E:  DATA 70,78
04F10:  DATA 20,73
04F12:  DATA 6F,6C
04F14:  DATA 69,64
04F16:  DATA 20,23
04F18:  DATA 30,33
04F1A:  DATA 36,31
04F1C:  DATA 41,38
04F1E:  DATA 3B,20
04F20:  DATA 62,6F
04F22:  DATA 72,64
04F24:  DATA 65,72
04F26:  DATA 2D,72
04F28:  DATA 61,64
04F2A:  DATA 69,75
04F2C:  DATA 73,3A
04F2E:  DATA 20,35
04F30:  DATA 70,78
04F32:  DATA 3B,20
04F34:  DATA 62,6F
04F36:  DATA 78,2D
04F38:  DATA 73,68
04F3A:  DATA 61,64
04F3C:  DATA 6F,77
04F3E:  DATA 3A,20
04F40:  DATA 30,70
04F42:  DATA 78,20
04F44:  DATA 30,70
04F46:  DATA 78,20
04F48:  DATA 38,70
04F4A:  DATA 78,20
04F4C:  DATA 23,30
04F4E:  DATA 33,36
04F50:  DATA 31,41
04F52:  DATA 38,3B
04F54:  DATA 20,6D
04F56:  DATA 61,72
04F58:  DATA 67,69
04F5A:  DATA 6E,3A
04F5C:  DATA 20,61
04F5E:  DATA 75,74
04F60:  DATA 6F,20
04F62:  DATA 61,75
04F64:  DATA 74,6F
04F66:  DATA 20,61
04F68:  DATA 75,74
04F6A:  DATA 6F,3B
04F6C:  DATA 22,3E
04F6E:  DATA 20,0A
04F70:  DATA 3C,64
04F72:  DATA 69,76
04F74:  DATA 20,73
04F76:  DATA 74,79
04F78:  DATA 6C,65
04F7A:  DATA 3D,22
04F7C:  DATA 62,61
04F7E:  DATA 63,6B
04F80:  DATA 67,72
04F82:  DATA 6F,75
04F84:  DATA 6E,64
04F86:  DATA 3A,20
04F88:  DATA 23,30
04F8A:  DATA 33,36
04F8C:  DATA 31,41
04F8E:  DATA 38,3B
04F90:  DATA 20,62
04F92:  DATA 6F,72
04F94:  DATA 64,65
04F96:  DATA 72,2D
04F98:  DATA 72,61
04F9A:  DATA 64,69
04F9C:  DATA 75,73
04F9E:  DATA 3A,20
04FA0:  DATA 35,70
04FA2:  DATA 78,20
04FA4:  DATA 35,70
04FA6:  DATA 78,20
04FA8:  DATA 30,70
04FAA:  DATA 78,20
04FAC:  DATA 30,70
04FAE:  DATA 78,3B
04FB0:  DATA 20,70
04FB2:  DATA 61,64
04FB4:  DATA 64,69
04FB6:  DATA 6E,67
04FB8:  DATA 3A,20
04FBA:  DATA 31,35
04FBC:  DATA 70,78
04FBE:  DATA 3B,22
04FC0:  DATA 3E,3C
04FC2:  DATA 73,70
04FC4:  DATA 61,6E
04FC6:  DATA 20,73
04FC8:  DATA 74,79
04FCA:  DATA 6C,65
04FCC:  DATA 3D,22
04FCE:  DATA 66,6F
04FD0:  DATA 6E,74
04FD2:  DATA 2D,66
04FD4:  DATA 61,6D
04FD6:  DATA 69,6C
04FD8:  DATA 79,3A
04FDA:  DATA 20,76
04FDC:  DATA 65,72
04FDE:  DATA 64,61
04FE0:  DATA 6E,61
04FE2:  DATA 2C,61
04FE4:  DATA 72,69
04FE6:  DATA 61,6C
04FE8:  DATA 3B,20
04FEA:  DATA 63,6F
04FEC:  DATA 6C,6F
04FEE:  DATA 72,3A
04FF0:  DATA 20,23
04FF2:  DATA 44,34
04FF4:  DATA 44,34
04FF6:  DATA 44,34
04FF8:  DATA 3B,20
04FFA:  DATA 66,6F
04FFC:  DATA 6E,74
04FFE:  DATA 2D,73
05000:  DATA 69,7A
05002:  DATA 65,3A
05004:  DATA 20,31
05006:  DATA 2E,30
05008:  DATA 30,65
0500A:  DATA 6D,3B
0500C:  DATA 20,66
0500E:  DATA 6F,6E
05010:  DATA 74,2D
05012:  DATA 77,65
05014:  DATA 69,67
05016:  DATA 68,74
05018:  DATA 3A,62
0501A:  DATA 6F,6C
0501C:  DATA 64,3B
0501E:  DATA 22,3E
05020:  DATA 52,65
05022:  DATA 6D,6F
05024:  DATA 74,65
05026:  DATA 20,45
05028:  DATA 6D,62
0502A:  DATA 65,64
0502C:  DATA 20,53
0502E:  DATA 65,72
05030:  DATA 76,65
05032:  DATA 72,20
05034:  DATA 41,6C
05036:  DATA 74,65
05038:  DATA 63,3C
0503A:  DATA 2F,73
0503C:  DATA 70,61
0503E:  DATA 6E,3E
05040:  DATA 3C,2F
05042:  DATA 64,69
05044:  DATA 76,3E
05046:  DATA 20,20
05048:  DATA 20,20
0504A:  DATA 20,20
0504C:  DATA 20,20
0504E:  DATA 20,20
05050:  DATA 0A,3C
05052:  DATA 64,69
05054:  DATA 76,20
05056:  DATA 73,74
05058:  DATA 79,6C
0505A:  DATA 65,3D
0505C:  DATA 22,62
0505E:  DATA 61,63
05060:  DATA 6B,67
05062:  DATA 72,6F
05064:  DATA 75,6E
05066:  DATA 64,3A
05068:  DATA 20,3B
0506A:  DATA 20,70
0506C:  DATA 61,64
0506E:  DATA 64,69
05070:  DATA 6E,67
05072:  DATA 3A,20
05074:  DATA 31,35
05076:  DATA 70,78
05078:  DATA 22,20
0507A:  DATA 69,64
0507C:  DATA 3D,22
0507E:  DATA 61,70
05080:  DATA 5F,73
05082:  DATA 74,79
05084:  DATA 6C,65
05086:  DATA 22,3E
05088:  DATA 20,20
0508A:  DATA 20,20
0508C:  DATA 20,20
0508E:  DATA 20,20
05090:  DATA 20,20
05092:  DATA 20,20
05094:  DATA 20,20
05096:  DATA 20,20
05098:  DATA 20,20
0509A:  DATA 20,20
0509C:  DATA 20,20
0509E:  DATA 20,20
050A0:  DATA 20,20
050A2:  DATA 20,20
050A4:  DATA 20,20
050A6:  DATA 20,20
050A8:  DATA 20,20
050AA:  DATA 20,20
050AC:  DATA 20,20
050AE:  DATA 20,20
050B0:  DATA 20,20
050B2:  DATA 20,20
050B4:  DATA 20,20
050B6:  DATA 20,20
050B8:  DATA 20,20
050BA:  DATA 20,20
050BC:  DATA 20,20
050BE:  DATA 20,20
050C0:  DATA 20,20
050C2:  DATA 20,20
050C4:  DATA 20,20
050C6:  DATA 20,20
050C8:  DATA 20,20
050CA:  DATA 20,20
050CC:  DATA 20,20
050CE:  DATA 20,20
050D0:  DATA 20,20
050D2:  DATA 20,20
050D4:  DATA 20,20
050D6:  DATA 20,20
050D8:  DATA 20,20
050DA:  DATA 20,20
050DC:  DATA 20,20
050DE:  DATA 20,20
050E0:  DATA 20,20
050E2:  DATA 20,20
050E4:  DATA 20,20
050E6:  DATA 20,20
050E8:  DATA 20,20
050EA:  DATA 20,20
050EC:  DATA 20,20
050EE:  DATA 20,20
050F0:  DATA 20,20
050F2:  DATA 20,20
050F4:  DATA 20,20
050F6:  DATA 20,20
050F8:  DATA 20,20
050FA:  DATA 20,20
050FC:  DATA 20,20
050FE:  DATA 20,20
05100:  DATA 20,20
05102:  DATA 20,20
05104:  DATA 20,20
05106:  DATA 20,20
05108:  DATA 20,20
0510A:  DATA 20,20
0510C:  DATA 20,20
0510E:  DATA 20,20
05110:  DATA 20,20
05112:  DATA 20,20
05114:  DATA 20,20
05116:  DATA 20,20
05118:  DATA 20,20
0511A:  DATA 20,20
0511C:  DATA 20,20
0511E:  DATA 20,20
05120:  DATA 20,20
05122:  DATA 20,20
05124:  DATA 20,20
05126:  DATA 20,20
05128:  DATA 20,20
0512A:  DATA 20,20
0512C:  DATA 20,20
0512E:  DATA 20,20
05130:  DATA 20,20
05132:  DATA 20,20
05134:  DATA 20,20
05136:  DATA 20,20
05138:  DATA 20,20
0513A:  DATA 20,20
0513C:  DATA 20,20
0513E:  DATA 20,0A
05140:  DATA 3C,73
05142:  DATA 74,79
05144:  DATA 6C,65
05146:  DATA 20,74
05148:  DATA 79,70
0514A:  DATA 65,3D
0514C:  DATA 22,74
0514E:  DATA 65,78
05150:  DATA 74,2F
05152:  DATA 63,73
05154:  DATA 73,22
05156:  DATA 20,73
05158:  DATA 63,6F
0515A:  DATA 70,65
0515C:  DATA 64,3E
0515E:  DATA 20,20
05160:  DATA 20,20
05162:  DATA 20,20
05164:  DATA 20,20
05166:  DATA 20,20
05168:  DATA 20,20
0516A:  DATA 20,20
0516C:  DATA 20,20
0516E:  DATA 20,20
05170:  DATA 20,20
05172:  DATA 20,20
05174:  DATA 20,20
05176:  DATA 20,20
05178:  DATA 20,20
0517A:  DATA 20,20
0517C:  DATA 20,20
0517E:  DATA 20,20
05180:  DATA 20,20
05182:  DATA 20,20
05184:  DATA 20,20
05186:  DATA 20,20
05188:  DATA 20,20
0518A:  DATA 20,20
0518C:  DATA 20,20
0518E:  DATA 20,20
05190:  DATA 20,20
05192:  DATA 20,20
05194:  DATA 20,20
05196:  DATA 20,20
05198:  DATA 20,20
0519A:  DATA 20,20
0519C:  DATA 20,20
0519E:  DATA 20,20
051A0:  DATA 20,20
051A2:  DATA 20,20
051A4:  DATA 20,20
051A6:  DATA 20,20
051A8:  DATA 20,20
051AA:  DATA 20,20
051AC:  DATA 20,20
051AE:  DATA 20,20
051B0:  DATA 20,20
051B2:  DATA 20,20
051B4:  DATA 20,20
051B6:  DATA 20,20
051B8:  DATA 20,20
051BA:  DATA 20,20
051BC:  DATA 20,20
051BE:  DATA 20,20
051C0:  DATA 20,20
051C2:  DATA 20,20
051C4:  DATA 20,20
051C6:  DATA 20,20
051C8:  DATA 20,20
051CA:  DATA 20,20
051CC:  DATA 20,20
051CE:  DATA 20,20
051D0:  DATA 20,20
051D2:  DATA 20,20
051D4:  DATA 20,20
051D6:  DATA 20,20
051D8:  DATA 20,20
051DA:  DATA 20,20
051DC:  DATA 20,20
051DE:  DATA 20,20
051E0:  DATA 20,20
051E2:  DATA 20,0A
051E4:  DATA 23,61
051E6:  DATA 70,5F
051E8:  DATA 73,74
051EA:  DATA 79,6C
051EC:  DATA 65,20
051EE:  DATA 74,64
051F0:  DATA 20,7B
051F2:  DATA 20,74
051F4:  DATA 65,78
051F6:  DATA 74,2D
051F8:  DATA 61,6C
051FA:  DATA 69,67
051FC:  DATA 6E,3A
051FE:  DATA 6C,65
05200:  DATA 66,74
05202:  DATA 3B,20
05204:  DATA 66,6F
05206:  DATA 6E,74
05208:  DATA 2D,66
0520A:  DATA 61,6D
0520C:  DATA 69,6C
0520E:  DATA 79,3A
05210:  DATA 20,76
05212:  DATA 65,72
05214:  DATA 64,61
05216:  DATA 6E,61
05218:  DATA 2C,61
0521A:  DATA 72,69
0521C:  DATA 61,6C
0521E:  DATA 3B,20
05220:  DATA 63,6F
05222:  DATA 6C,6F
05224:  DATA 72,3A
05226:  DATA 20,23
05228:  DATA 30,36
0522A:  DATA 34,30
0522C:  DATA 37,33
0522E:  DATA 3B,20
05230:  DATA 66,6F
05232:  DATA 6E,74
05234:  DATA 2D,73
05236:  DATA 69,7A
05238:  DATA 65,3A
0523A:  DATA 20,31
0523C:  DATA 2E,30
0523E:  DATA 30,65
05240:  DATA 6D,3B
05242:  DATA 20,7D
05244:  DATA 20,0A
05246:  DATA 23,61
05248:  DATA 70,5F
0524A:  DATA 73,74
0524C:  DATA 79,6C
0524E:  DATA 65,20
05250:  DATA 69,6E
05252:  DATA 70,75
05254:  DATA 74,20
05256:  DATA 7B,20
05258:  DATA 62,6F
0525A:  DATA 72,64
0525C:  DATA 65,72
0525E:  DATA 3A,20
05260:  DATA 31,70
05262:  DATA 78,20
05264:  DATA 73,6F
05266:  DATA 6C,69
05268:  DATA 64,20
0526A:  DATA 23,43
0526C:  DATA 43,43
0526E:  DATA 43,43
05270:  DATA 43,3B
05272:  DATA 20,62
05274:  DATA 6F,72
05276:  DATA 64,65
05278:  DATA 72,2D
0527A:  DATA 72,61
0527C:  DATA 64,69
0527E:  DATA 75,73
05280:  DATA 3A,20
05282:  DATA 35,70
05284:  DATA 78,3B
05286:  DATA 20,63
05288:  DATA 6F,6C
0528A:  DATA 6F,72
0528C:  DATA 3A,20
0528E:  DATA 23,36
05290:  DATA 36,36
05292:  DATA 36,36
05294:  DATA 36,3B
05296:  DATA 20,64
05298:  DATA 69,73
0529A:  DATA 70,6C
0529C:  DATA 61,79
0529E:  DATA 3A,20
052A0:  DATA 69,6E
052A2:  DATA 6C,69
052A4:  DATA 6E,65
052A6:  DATA 2D,62
052A8:  DATA 6C,6F
052AA:  DATA 63,6B
052AC:  DATA 3B,20
052AE:  DATA 66,6F
052B0:  DATA 6E,74
052B2:  DATA 2D,73
052B4:  DATA 69,7A
052B6:  DATA 65,3A
052B8:  DATA 20,31
052BA:  DATA 2E,30
052BC:  DATA 30,65
052BE:  DATA 6D,3B
052C0:  DATA 20,20
052C2:  DATA 70,61
052C4:  DATA 64,64
052C6:  DATA 69,6E
052C8:  DATA 67,3A
052CA:  DATA 20,35
052CC:  DATA 70,78
052CE:  DATA 3B,20
052D0:  DATA 7D,20
052D2:  DATA 0A,23
052D4:  DATA 61,70
052D6:  DATA 5F,73
052D8:  DATA 74,79
052DA:  DATA 6C,65
052DC:  DATA 20,74
052DE:  DATA 61,62
052E0:  DATA 6C,65
052E2:  DATA 2E,63
052E4:  DATA 65,6E
052E6:  DATA 74,65
052E8:  DATA 72,20
052EA:  DATA 7B,20
052EC:  DATA 6D,61
052EE:  DATA 72,67
052F0:  DATA 69,6E
052F2:  DATA 2D,6C
052F4:  DATA 65,66
052F6:  DATA 74,3A
052F8:  DATA 61,75
052FA:  DATA 74,6F
052FC:  DATA 3B,20
052FE:  DATA 6D,61
05300:  DATA 72,67
05302:  DATA 69,6E
05304:  DATA 2D,72
05306:  DATA 69,67
05308:  DATA 68,74
0530A:  DATA 3A,61
0530C:  DATA 75,74
0530E:  DATA 6F,3B
05310:  DATA 20,7D
05312:  DATA 20,0A
05314:  DATA 23,61
05316:  DATA 70,5F
05318:  DATA 73,74
0531A:  DATA 79,6C
0531C:  DATA 65,20
0531E:  DATA 2E,65
05320:  DATA 72,72
05322:  DATA 6F,72
05324:  DATA 20,7B
05326:  DATA 20,66
05328:  DATA 6F,6E
0532A:  DATA 74,2D
0532C:  DATA 66,61
0532E:  DATA 6D,69
05330:  DATA 6C,79
05332:  DATA 3A,20
05334:  DATA 76,65
05336:  DATA 72,64
05338:  DATA 61,6E
0533A:  DATA 61,2C
0533C:  DATA 61,72
0533E:  DATA 69,61
05340:  DATA 6C,3B
05342:  DATA 20,63
05344:  DATA 6F,6C
05346:  DATA 6F,72
05348:  DATA 3A,20
0534A:  DATA 23,44
0534C:  DATA 34,31
0534E:  DATA 33,31
05350:  DATA 33,3B
05352:  DATA 20,66
05354:  DATA 6F,6E
05356:  DATA 74,2D
05358:  DATA 73,69
0535A:  DATA 7A,65
0535C:  DATA 3A,20
0535E:  DATA 31,2E
05360:  DATA 30,30
05362:  DATA 65,6D
05364:  DATA 3B,20
05366:  DATA 7D,20
05368:  DATA 0A,3C
0536A:  DATA 2F,73
0536C:  DATA 74,79
0536E:  DATA 6C,65
05370:  DATA 3E,20
05372:  DATA 0A,3C
05374:  DATA 2F,68
05376:  DATA 65,61
05378:  DATA 64,3E
0537A:  DATA 20,20
0537C:  DATA 0A,20
0537E:  DATA 0A,3C
05380:  DATA 62,6F
05382:  DATA 64,79
05384:  DATA 3E,20
05386:  DATA 20,20
05388:  DATA 20,20
0538A:  DATA 20,20
0538C:  DATA 20,20
0538E:  DATA 20,20
05390:  DATA 20,20
05392:  DATA 20,20
05394:  DATA 20,20
05396:  DATA 20,20
05398:  DATA 20,20
0539A:  DATA 20,20
0539C:  DATA 20,20
0539E:  DATA 20,20
053A0:  DATA 20,20
053A2:  DATA 20,20
053A4:  DATA 20,20
053A6:  DATA 20,20
053A8:  DATA 20,20
053AA:  DATA 20,20
053AC:  DATA 20,20
053AE:  DATA 20,20
053B0:  DATA 20,20
053B2:  DATA 20,20
053B4:  DATA 20,20
053B6:  DATA 20,20
053B8:  DATA 20,20
053BA:  DATA 20,20
053BC:  DATA 20,20
053BE:  DATA 20,20
053C0:  DATA 20,20
053C2:  DATA 20,20
053C4:  DATA 20,20
053C6:  DATA 20,20
053C8:  DATA 20,20
053CA:  DATA 20,20
053CC:  DATA 20,20
053CE:  DATA 20,20
053D0:  DATA 20,20
053D2:  DATA 20,20
053D4:  DATA 20,20
053D6:  DATA 20,20
053D8:  DATA 20,20
053DA:  DATA 20,20
053DC:  DATA 20,20
053DE:  DATA 20,20
053E0:  DATA 20,20
053E2:  DATA 20,20
053E4:  DATA 20,20
053E6:  DATA 20,20
053E8:  DATA 0A,20
053EA:  DATA 0A,3C
053EC:  DATA 68,31
053EE:  DATA 20,61
053F0:  DATA 6C,69
053F2:  DATA 67,6E
053F4:  DATA 3D,22
053F6:  DATA 63,65
053F8:  DATA 6E,74
053FA:  DATA 65,72
053FC:  DATA 22,3E
053FE:  DATA 3C,66
05400:  DATA 6F,6E
05402:  DATA 74,20
05404:  DATA 63,6F
05406:  DATA 6C,6F
05408:  DATA 72,3D
0540A:  DATA 22,23
0540C:  DATA 30,30
0540E:  DATA 30,30
05410:  DATA 30,30
05412:  DATA 22,3E
05414:  DATA 3C,66
05416:  DATA 6F,6E
05418:  DATA 74,20
0541A:  DATA 63,6F
0541C:  DATA 6C,6F
0541E:  DATA 72,3D
05420:  DATA 22,23
05422:  DATA 30,30
05424:  DATA 30,30
05426:  DATA 30,30
05428:  DATA 22,3E
0542A:  DATA 28,50
0542C:  DATA 44,55
0542E:  DATA 29,20
05430:  DATA 50,6F
05432:  DATA 77,65
05434:  DATA 72,20
05436:  DATA 64,69
05438:  DATA 73,74
0543A:  DATA 72,69
0543C:  DATA 62,75
0543E:  DATA 74,69
05440:  DATA 6F,6E
05442:  DATA 20,75
05444:  DATA 6E,69
05446:  DATA 74,20
05448:  DATA 3C,2F
0544A:  DATA 66,6F
0544C:  DATA 6E,74
0544E:  DATA 3E,3C
05450:  DATA 2F,66
05452:  DATA 6F,6E
05454:  DATA 74,3E
05456:  DATA 3C,2F
05458:  DATA 68,31
0545A:  DATA 3E,20
0545C:  DATA 0A,20
0545E:  DATA 20,20
05460:  DATA 20,20
05462:  DATA 20,20
05464:  DATA 20,20
05466:  DATA 20,20
05468:  DATA 20,20
0546A:  DATA 20,20
0546C:  DATA 20,20
0546E:  DATA 20,20
05470:  DATA 20,20
05472:  DATA 20,20
05474:  DATA 20,20
05476:  DATA 20,20
05478:  DATA 20,20
0547A:  DATA 20,20
0547C:  DATA 20,20
0547E:  DATA 20,20
05480:  DATA 20,20
05482:  DATA 20,20
05484:  DATA 20,20
05486:  DATA 20,20
05488:  DATA 20,20
0548A:  DATA 20,20
0548C:  DATA 20,20
0548E:  DATA 20,20
05490:  DATA 20,20
05492:  DATA 0A,20
05494:  DATA 20,20
05496:  DATA 20,20
05498:  DATA 20,20
0549A:  DATA 20,20
0549C:  DATA 20,20
0549E:  DATA 20,20
054A0:  DATA 20,20
054A2:  DATA 20,20
054A4:  DATA 20,3C
054A6:  DATA 74,61
054A8:  DATA 62,6C
054AA:  DATA 65,20
054AC:  DATA 61,6C
054AE:  DATA 69,67
054B0:  DATA 6E,3D
054B2:  DATA 22,63
054B4:  DATA 65,6E
054B6:  DATA 74,65
054B8:  DATA 72,22
054BA:  DATA 20,62
054BC:  DATA 67,63
054BE:  DATA 6F,6C
054C0:  DATA 6F,72
054C2:  DATA 3D,22
054C4:  DATA 23,30
054C6:  DATA 30,46
054C8:  DATA 46,30
054CA:  DATA 30,22
054CC:  DATA 20,62
054CE:  DATA 6F,72
054D0:  DATA 64,65
054D2:  DATA 72,3D
054D4:  DATA 22,32
054D6:  DATA 22,20
054D8:  DATA 63,65
054DA:  DATA 6C,6C
054DC:  DATA 70,61
054DE:  DATA 64,64
054E0:  DATA 69,6E
054E2:  DATA 67,3D
054E4:  DATA 22,36
054E6:  DATA 22,20
054E8:  DATA 63,65
054EA:  DATA 6C,6C
054EC:  DATA 73,70
054EE:  DATA 61,63
054F0:  DATA 69,6E
054F2:  DATA 67,3D
054F4:  DATA 22,31
054F6:  DATA 22,20
054F8:  DATA 77,69
054FA:  DATA 64,74
054FC:  DATA 68,3D
054FE:  DATA 61,75
05500:  DATA 74,6F
05502:  DATA 3E,20
05504:  DATA 0A,20
05506:  DATA 20,20
05508:  DATA 20,20
0550A:  DATA 20,20
0550C:  DATA 20,20
0550E:  DATA 20,20
05510:  DATA 20,20
05512:  DATA 20,20
05514:  DATA 20,20
05516:  DATA 20,20
05518:  DATA 0A,20
0551A:  DATA 20,20
0551C:  DATA 20,20
0551E:  DATA 20,20
05520:  DATA 20,20
05522:  DATA 20,20
05524:  DATA 20,20
05526:  DATA 20,20
05528:  DATA 20,20
0552A:  DATA 20,3C
0552C:  DATA 74,62
0552E:  DATA 6F,64
05530:  DATA 79,3E
05532:  DATA 20,20
05534:  DATA 20,20
05536:  DATA 20,20
05538:  DATA 20,20
0553A:  DATA 20,20
0553C:  DATA 20,20
0553E:  DATA 20,20
05540:  DATA 20,20
05542:  DATA 20,20
05544:  DATA 20,20
05546:  DATA 20,20
05548:  DATA 20,20
0554A:  DATA 20,20
0554C:  DATA 20,20
0554E:  DATA 20,20
05550:  DATA 20,20
05552:  DATA 20,20
05554:  DATA 20,20
05556:  DATA 20,20
05558:  DATA 20,20
0555A:  DATA 20,0A
0555C:  DATA 20,20
0555E:  DATA 20,20
05560:  DATA 20,20
05562:  DATA 20,20
05564:  DATA 20,20
05566:  DATA 20,20
05568:  DATA 20,20
0556A:  DATA 20,20
0556C:  DATA 20,20
0556E:  DATA 20,20
05570:  DATA 20,20
05572:  DATA 20,20
05574:  DATA 20,20
05576:  DATA 20,20
05578:  DATA 0A,20
0557A:  DATA 20,20
0557C:  DATA 20,20
0557E:  DATA 20,20
05580:  DATA 20,20
05582:  DATA 20,20
05584:  DATA 20,20
05586:  DATA 20,20
05588:  DATA 20,20
0558A:  DATA 20,3C
0558C:  DATA 74,72
0558E:  DATA 3E,20
05590:  DATA 20,20
05592:  DATA 20,20
05594:  DATA 20,20
05596:  DATA 20,20
05598:  DATA 20,20
0559A:  DATA 20,20
0559C:  DATA 20,20
0559E:  DATA 20,20
055A0:  DATA 20,20
055A2:  DATA 20,20
055A4:  DATA 20,20
055A6:  DATA 20,20
055A8:  DATA 20,20
055AA:  DATA 20,20
055AC:  DATA 20,20
055AE:  DATA 20,20
055B0:  DATA 20,20
055B2:  DATA 20,20
055B4:  DATA 20,20
055B6:  DATA 20,20
055B8:  DATA 20,0A
055BA:  DATA 20,20
055BC:  DATA 20,20
055BE:  DATA 20,20
055C0:  DATA 20,20
055C2:  DATA 20,20
055C4:  DATA 20,20
055C6:  DATA 20,20
055C8:  DATA 20,20
055CA:  DATA 20,20
055CC:  DATA 3C,74
055CE:  DATA 68,3E
055D0:  DATA 3C,70
055D2:  DATA 20,61
055D4:  DATA 6C,69
055D6:  DATA 67,6E
055D8:  DATA 3D,22
055DA:  DATA 63,65
055DC:  DATA 6E,74
055DE:  DATA 65,72
055E0:  DATA 22,3E
055E2:  DATA 4C,65
055E4:  DATA 63,74
055E6:  DATA 75,72
055E8:  DATA 61,73
055EA:  DATA 20,50
055EC:  DATA 69,63
055EE:  DATA 20,28
055F0:  DATA 20,31
055F2:  DATA 20,3D
055F4:  DATA 20,4F
055F6:  DATA 4E,20
055F8:  DATA 29,20
055FA:  DATA 28,20
055FC:  DATA 30,20
055FE:  DATA 3D,20
05600:  DATA 4F,46
05602:  DATA 46,29
05604:  DATA 3C,2F
05606:  DATA 70,3E
05608:  DATA 3C,2F
0560A:  DATA 74,68
0560C:  DATA 3E,20
0560E:  DATA 20,20
05610:  DATA 20,20
05612:  DATA 20,20
05614:  DATA 20,20
05616:  DATA 20,20
05618:  DATA 20,20
0561A:  DATA 20,20
0561C:  DATA 20,20
0561E:  DATA 20,20
05620:  DATA 0A,20
05622:  DATA 20,20
05624:  DATA 20,20
05626:  DATA 20,20
05628:  DATA 20,20
0562A:  DATA 20,20
0562C:  DATA 20,20
0562E:  DATA 20,20
05630:  DATA 20,20
05632:  DATA 20,3C
05634:  DATA 74,68
05636:  DATA 3E,3C
05638:  DATA 70,20
0563A:  DATA 61,6C
0563C:  DATA 69,67
0563E:  DATA 6E,3D
05640:  DATA 22,63
05642:  DATA 65,6E
05644:  DATA 74,65
05646:  DATA 72,22
05648:  DATA 3E,4F
0564A:  DATA 4E,2F
0564C:  DATA 4F,46
0564E:  DATA 46,20
05650:  DATA 52,65
05652:  DATA 6C,61
05654:  DATA 79,20
05656:  DATA 43,6F
05658:  DATA 72,72
0565A:  DATA 65,73
0565C:  DATA 70,6F
0565E:  DATA 6E,64
05660:  DATA 69,65
05662:  DATA 6E,74
05664:  DATA 65,20
05666:  DATA 28,50
05668:  DATA 52,45
0566A:  DATA 43,41
0566C:  DATA 55,43
0566E:  DATA 49,4F
05670:  DATA 4E,29
05672:  DATA 3C,2F
05674:  DATA 70,3E
05676:  DATA 3C,2F
05678:  DATA 74,68
0567A:  DATA 3E,20
0567C:  DATA 0A,20
0567E:  DATA 20,20
05680:  DATA 20,20
05682:  DATA 20,20
05684:  DATA 20,20
05686:  DATA 20,20
05688:  DATA 20,20
0568A:  DATA 20,20
0568C:  DATA 20,20
0568E:  DATA 20,3C
05690:  DATA 74,68
05692:  DATA 3E,3C
05694:  DATA 70,20
05696:  DATA 61,6C
05698:  DATA 69,67
0569A:  DATA 6E,3D
0569C:  DATA 22,63
0569E:  DATA 65,6E
056A0:  DATA 74,65
056A2:  DATA 72,22
056A4:  DATA 3E,52
056A6:  DATA 45,42
056A8:  DATA 4F,4F
056AA:  DATA 54,20
056AC:  DATA 52,65
056AE:  DATA 6C,61
056B0:  DATA 79,20
056B2:  DATA 3C,2F
056B4:  DATA 70,3E
056B6:  DATA 3C,2F
056B8:  DATA 74,68
056BA:  DATA 3E,20
056BC:  DATA 0A,20
056BE:  DATA 20,20
056C0:  DATA 20,20
056C2:  DATA 20,20
056C4:  DATA 20,20
056C6:  DATA 20,20
056C8:  DATA 20,20
056CA:  DATA 20,20
056CC:  DATA 20,20
056CE:  DATA 20,20
056D0:  DATA 0A,20
056D2:  DATA 20,20
056D4:  DATA 20,20
056D6:  DATA 20,20
056D8:  DATA 20,20
056DA:  DATA 20,20
056DC:  DATA 20,20
056DE:  DATA 20,20
056E0:  DATA 20,20
056E2:  DATA 20,3C
056E4:  DATA 2F,74
056E6:  DATA 72,3E
056E8:  DATA 20,0A
056EA:  DATA 20,20
056EC:  DATA 20,20
056EE:  DATA 20,20
056F0:  DATA 20,20
056F2:  DATA 20,20
056F4:  DATA 20,20
056F6:  DATA 20,20
056F8:  DATA 20,20
056FA:  DATA 20,20
056FC:  DATA 20,20
056FE:  DATA 20,20
05700:  DATA 20,20
05702:  DATA 20,20
05704:  DATA 20,20
05706:  DATA 20,20
05708:  DATA 20,20
0570A:  DATA 20,20
0570C:  DATA 20,20
0570E:  DATA 20,20
05710:  DATA 20,20
05712:  DATA 20,20
05714:  DATA 20,20
05716:  DATA 20,20
05718:  DATA 20,20
0571A:  DATA 20,20
0571C:  DATA 20,20
0571E:  DATA 20,20
05720:  DATA 20,20
05722:  DATA 20,20
05724:  DATA 20,0A
05726:  DATA 20,20
05728:  DATA 20,20
0572A:  DATA 20,20
0572C:  DATA 20,20
0572E:  DATA 20,20
05730:  DATA 20,20
05732:  DATA 20,20
05734:  DATA 20,20
05736:  DATA 20,20
05738:  DATA 3C,74
0573A:  DATA 72,3E
0573C:  DATA 20,20
0573E:  DATA 20,20
05740:  DATA 20,20
05742:  DATA 20,20
05744:  DATA 20,20
05746:  DATA 20,20
05748:  DATA 20,20
0574A:  DATA 20,20
0574C:  DATA 20,20
0574E:  DATA 20,20
05750:  DATA 20,20
05752:  DATA 20,20
05754:  DATA 20,20
05756:  DATA 20,20
05758:  DATA 20,20
0575A:  DATA 20,20
0575C:  DATA 20,20
0575E:  DATA 20,20
05760:  DATA 20,20
05762:  DATA 20,20
05764:  DATA 20,20
05766:  DATA 20,20
05768:  DATA 20,20
0576A:  DATA 20,20
0576C:  DATA 20,20
0576E:  DATA 20,20
05770:  DATA 20,20
05772:  DATA 20,20
05774:  DATA 20,20
05776:  DATA 20,20
05778:  DATA 20,20
0577A:  DATA 20,20
0577C:  DATA 20,20
0577E:  DATA 20,20
05780:  DATA 20,20
05782:  DATA 20,20
05784:  DATA 20,20
05786:  DATA 20,20
05788:  DATA 20,20
0578A:  DATA 20,20
0578C:  DATA 20,20
0578E:  DATA 20,20
05790:  DATA 20,20
05792:  DATA 0A,20
05794:  DATA 20,20
05796:  DATA 20,20
05798:  DATA 20,20
0579A:  DATA 20,20
0579C:  DATA 20,20
0579E:  DATA 20,20
057A0:  DATA 20,20
057A2:  DATA 20,20
057A4:  DATA 20,3C
057A6:  DATA 74,64
057A8:  DATA 3E,3C
057AA:  DATA 62,3E
057AC:  DATA 43,6F
057AE:  DATA 72,72
057B0:  DATA 69,65
057B2:  DATA 6E,74
057B4:  DATA 65,3A
057B6:  DATA 20,3C
057B8:  DATA 2F,62
057BA:  DATA 3E,25
057BC:  DATA 30,3C
057BE:  DATA 2F,74
057C0:  DATA 64,3E
057C2:  DATA 20,0A
057C4:  DATA 20,20
057C6:  DATA 20,20
057C8:  DATA 20,20
057CA:  DATA 20,20
057CC:  DATA 20,20
057CE:  DATA 20,20
057D0:  DATA 20,20
057D2:  DATA 20,20
057D4:  DATA 20,20
057D6:  DATA 3C,46
057D8:  DATA 4F,52
057DA:  DATA 4D,20
057DC:  DATA 4D,45
057DE:  DATA 54,48
057E0:  DATA 4F,44
057E2:  DATA 3D,50
057E4:  DATA 4F,53
057E6:  DATA 54,3E
057E8:  DATA 3C,74
057EA:  DATA 64,3E
057EC:  DATA 50,75
057EE:  DATA 6C,73
057F0:  DATA 65,20
057F2:  DATA 20,4F
057F4:  DATA 4E,2F
057F6:  DATA 4F,46
057F8:  DATA 46,20
057FA:  DATA 3D,20
057FC:  DATA 49,6E
057FE:  DATA 74,65
05800:  DATA 72,72
05802:  DATA 75,70
05804:  DATA 74,6F
05806:  DATA 72,20
05808:  DATA 46,75
0580A:  DATA 65,6E
0580C:  DATA 74,65
0580E:  DATA 20,31
05810:  DATA 20,3C
05812:  DATA 69,6E
05814:  DATA 70,75
05816:  DATA 74,20
05818:  DATA 74,79
0581A:  DATA 70,65
0581C:  DATA 3D,22
0581E:  DATA 73,75
05820:  DATA 62,6D
05822:  DATA 69,74
05824:  DATA 22,20
05826:  DATA 6E,61
05828:  DATA 6D,65
0582A:  DATA 3D,22
0582C:  DATA 62,6F
0582E:  DATA 74,6F
05830:  DATA 6E,31
05832:  DATA 22,20
05834:  DATA 76,61
05836:  DATA 6C,75
05838:  DATA 65,3D
0583A:  DATA 22,52
0583C:  DATA 65,6C
0583E:  DATA 61,79
05840:  DATA 20,31
05842:  DATA 22,3E
05844:  DATA 3C,2F
05846:  DATA 74,64
05848:  DATA 3E,3C
0584A:  DATA 2F,46
0584C:  DATA 4F,52
0584E:  DATA 4D,3E
05850:  DATA 20,0A
05852:  DATA 20,20
05854:  DATA 20,20
05856:  DATA 20,20
05858:  DATA 20,20
0585A:  DATA 20,20
0585C:  DATA 20,20
0585E:  DATA 20,20
05860:  DATA 20,20
05862:  DATA 20,20
05864:  DATA 3C,46
05866:  DATA 4F,52
05868:  DATA 4D,20
0586A:  DATA 4D,45
0586C:  DATA 54,48
0586E:  DATA 4F,44
05870:  DATA 3D,50
05872:  DATA 4F,53
05874:  DATA 54,3E
05876:  DATA 3C,74
05878:  DATA 64,3E
0587A:  DATA 52,65
0587C:  DATA 62,6F
0587E:  DATA 6F,74
05880:  DATA 20,3D
05882:  DATA 20,46
05884:  DATA 75,65
05886:  DATA 6E,74
05888:  DATA 65,20
0588A:  DATA 31,20
0588C:  DATA 3C,69
0588E:  DATA 6E,70
05890:  DATA 75,74
05892:  DATA 20,74
05894:  DATA 79,70
05896:  DATA 65,3D
05898:  DATA 22,73
0589A:  DATA 75,62
0589C:  DATA 6D,69
0589E:  DATA 74,22
058A0:  DATA 20,6E
058A2:  DATA 61,6D
058A4:  DATA 65,3D
058A6:  DATA 22,72
058A8:  DATA 65,62
058AA:  DATA 6F,6F
058AC:  DATA 74,31
058AE:  DATA 22,20
058B0:  DATA 76,61
058B2:  DATA 6C,75
058B4:  DATA 65,3D
058B6:  DATA 22,52
058B8:  DATA 65,62
058BA:  DATA 6F,6F
058BC:  DATA 74,20
058BE:  DATA 52,65
058C0:  DATA 6C,61
058C2:  DATA 79,20
058C4:  DATA 31,22
058C6:  DATA 3E,3C
058C8:  DATA 2F,74
058CA:  DATA 64,3E
058CC:  DATA 3C,2F
058CE:  DATA 46,4F
058D0:  DATA 52,4D
058D2:  DATA 3E,20
058D4:  DATA 0A,20
058D6:  DATA 20,20
058D8:  DATA 20,20
058DA:  DATA 20,20
058DC:  DATA 20,20
058DE:  DATA 20,20
058E0:  DATA 20,20
058E2:  DATA 20,20
058E4:  DATA 20,20
058E6:  DATA 20,3C
058E8:  DATA 2F,74
058EA:  DATA 72,3E
058EC:  DATA 20,20
058EE:  DATA 20,20
058F0:  DATA 20,20
058F2:  DATA 20,20
058F4:  DATA 20,20
058F6:  DATA 20,20
058F8:  DATA 20,20
058FA:  DATA 20,20
058FC:  DATA 20,20
058FE:  DATA 20,20
05900:  DATA 20,20
05902:  DATA 20,20
05904:  DATA 20,20
05906:  DATA 20,20
05908:  DATA 20,20
0590A:  DATA 20,20
0590C:  DATA 20,20
0590E:  DATA 20,20
05910:  DATA 20,20
05912:  DATA 20,20
05914:  DATA 20,20
05916:  DATA 20,20
05918:  DATA 20,20
0591A:  DATA 20,20
0591C:  DATA 20,20
0591E:  DATA 20,20
05920:  DATA 20,20
05922:  DATA 20,20
05924:  DATA 20,20
05926:  DATA 20,0A
05928:  DATA 20,20
0592A:  DATA 20,20
0592C:  DATA 20,20
0592E:  DATA 20,20
05930:  DATA 20,20
05932:  DATA 20,20
05934:  DATA 20,20
05936:  DATA 20,20
05938:  DATA 20,20
0593A:  DATA 20,20
0593C:  DATA 20,20
0593E:  DATA 20,20
05940:  DATA 20,20
05942:  DATA 20,20
05944:  DATA 20,20
05946:  DATA 20,20
05948:  DATA 20,20
0594A:  DATA 20,20
0594C:  DATA 20,20
0594E:  DATA 20,20
05950:  DATA 20,20
05952:  DATA 20,20
05954:  DATA 20,20
05956:  DATA 20,20
05958:  DATA 20,20
0595A:  DATA 20,20
0595C:  DATA 20,20
0595E:  DATA 20,20
05960:  DATA 20,20
05962:  DATA 20,20
05964:  DATA 20,20
05966:  DATA 20,20
05968:  DATA 20,20
0596A:  DATA 20,20
0596C:  DATA 20,20
0596E:  DATA 20,20
05970:  DATA 20,20
05972:  DATA 20,20
05974:  DATA 20,20
05976:  DATA 20,20
05978:  DATA 20,20
0597A:  DATA 20,20
0597C:  DATA 20,20
0597E:  DATA 20,20
05980:  DATA 20,20
05982:  DATA 20,20
05984:  DATA 20,20
05986:  DATA 20,20
05988:  DATA 20,20
0598A:  DATA 20,20
0598C:  DATA 20,20
0598E:  DATA 20,20
05990:  DATA 20,20
05992:  DATA 20,20
05994:  DATA 20,20
05996:  DATA 20,20
05998:  DATA 20,20
0599A:  DATA 20,20
0599C:  DATA 20,20
0599E:  DATA 20,20
059A0:  DATA 20,20
059A2:  DATA 20,20
059A4:  DATA 20,20
059A6:  DATA 20,20
059A8:  DATA 20,20
059AA:  DATA 20,20
059AC:  DATA 20,20
059AE:  DATA 20,20
059B0:  DATA 20,20
059B2:  DATA 20,20
059B4:  DATA 20,20
059B6:  DATA 20,20
059B8:  DATA 20,20
059BA:  DATA 20,20
059BC:  DATA 20,20
059BE:  DATA 20,20
059C0:  DATA 20,20
059C2:  DATA 20,20
059C4:  DATA 20,20
059C6:  DATA 20,20
059C8:  DATA 20,20
059CA:  DATA 20,20
059CC:  DATA 20,20
059CE:  DATA 0A,20
059D0:  DATA 20,20
059D2:  DATA 20,20
059D4:  DATA 20,20
059D6:  DATA 20,20
059D8:  DATA 20,20
059DA:  DATA 20,20
059DC:  DATA 20,20
059DE:  DATA 20,20
059E0:  DATA 20,3C
059E2:  DATA 74,72
059E4:  DATA 3E,20
059E6:  DATA 0A,20
059E8:  DATA 20,20
059EA:  DATA 20,20
059EC:  DATA 20,20
059EE:  DATA 20,20
059F0:  DATA 20,20
059F2:  DATA 20,20
059F4:  DATA 20,20
059F6:  DATA 20,20
059F8:  DATA 20,3C
059FA:  DATA 74,64
059FC:  DATA 3E,3C
059FE:  DATA 62,3E
05A00:  DATA 45,73
05A02:  DATA 74,61
05A04:  DATA 64,6F
05A06:  DATA 3A,20
05A08:  DATA 3C,2F
05A0A:  DATA 62,3E
05A0C:  DATA 25,31
05A0E:  DATA 3C,2F
05A10:  DATA 74,64
05A12:  DATA 3E,20
05A14:  DATA 20,20
05A16:  DATA 20,20
05A18:  DATA 20,20
05A1A:  DATA 20,20
05A1C:  DATA 20,20
05A1E:  DATA 20,20
05A20:  DATA 20,20
05A22:  DATA 20,20
05A24:  DATA 20,20
05A26:  DATA 20,20
05A28:  DATA 20,20
05A2A:  DATA 20,20
05A2C:  DATA 20,20
05A2E:  DATA 20,20
05A30:  DATA 20,20
05A32:  DATA 20,20
05A34:  DATA 20,20
05A36:  DATA 20,20
05A38:  DATA 20,20
05A3A:  DATA 20,20
05A3C:  DATA 20,20
05A3E:  DATA 20,20
05A40:  DATA 20,20
05A42:  DATA 20,20
05A44:  DATA 20,20
05A46:  DATA 20,20
05A48:  DATA 20,20
05A4A:  DATA 20,20
05A4C:  DATA 20,20
05A4E:  DATA 20,20
05A50:  DATA 20,20
05A52:  DATA 20,20
05A54:  DATA 20,20
05A56:  DATA 20,20
05A58:  DATA 20,20
05A5A:  DATA 20,20
05A5C:  DATA 20,20
05A5E:  DATA 20,20
05A60:  DATA 20,20
05A62:  DATA 20,20
05A64:  DATA 20,20
05A66:  DATA 20,20
05A68:  DATA 20,20
05A6A:  DATA 0A,20
05A6C:  DATA 20,20
05A6E:  DATA 20,20
05A70:  DATA 20,20
05A72:  DATA 20,20
05A74:  DATA 20,20
05A76:  DATA 20,20
05A78:  DATA 20,20
05A7A:  DATA 20,20
05A7C:  DATA 20,3C
05A7E:  DATA 46,4F
05A80:  DATA 52,4D
05A82:  DATA 20,4D
05A84:  DATA 45,54
05A86:  DATA 48,4F
05A88:  DATA 44,3D
05A8A:  DATA 50,4F
05A8C:  DATA 53,54
05A8E:  DATA 3E,3C
05A90:  DATA 74,64
05A92:  DATA 3E,50
05A94:  DATA 75,6C
05A96:  DATA 73,65
05A98:  DATA 20,20
05A9A:  DATA 4F,4E
05A9C:  DATA 2F,4F
05A9E:  DATA 46,46
05AA0:  DATA 20,3D
05AA2:  DATA 20,49
05AA4:  DATA 6E,74
05AA6:  DATA 65,72
05AA8:  DATA 72,75
05AAA:  DATA 70,74
05AAC:  DATA 6F,72
05AAE:  DATA 20,46
05AB0:  DATA 75,65
05AB2:  DATA 6E,74
05AB4:  DATA 65,20
05AB6:  DATA 32,20
05AB8:  DATA 3C,69
05ABA:  DATA 6E,70
05ABC:  DATA 75,74
05ABE:  DATA 20,74
05AC0:  DATA 79,70
05AC2:  DATA 65,3D
05AC4:  DATA 22,73
05AC6:  DATA 75,62
05AC8:  DATA 6D,69
05ACA:  DATA 74,22
05ACC:  DATA 20,6E
05ACE:  DATA 61,6D
05AD0:  DATA 65,3D
05AD2:  DATA 22,62
05AD4:  DATA 6F,74
05AD6:  DATA 6F,6E
05AD8:  DATA 32,22
05ADA:  DATA 20,76
05ADC:  DATA 61,6C
05ADE:  DATA 75,65
05AE0:  DATA 3D,22
05AE2:  DATA 52,65
05AE4:  DATA 6C,61
05AE6:  DATA 79,20
05AE8:  DATA 32,22
05AEA:  DATA 3E,3C
05AEC:  DATA 2F,74
05AEE:  DATA 64,3E
05AF0:  DATA 3C,2F
05AF2:  DATA 46,4F
05AF4:  DATA 52,4D
05AF6:  DATA 3E,20
05AF8:  DATA 0A,20
05AFA:  DATA 20,20
05AFC:  DATA 20,20
05AFE:  DATA 20,20
05B00:  DATA 20,20
05B02:  DATA 20,20
05B04:  DATA 20,20
05B06:  DATA 20,20
05B08:  DATA 20,20
05B0A:  DATA 20,3C
05B0C:  DATA 46,4F
05B0E:  DATA 52,4D
05B10:  DATA 20,4D
05B12:  DATA 45,54
05B14:  DATA 48,4F
05B16:  DATA 44,3D
05B18:  DATA 50,4F
05B1A:  DATA 53,54
05B1C:  DATA 3E,3C
05B1E:  DATA 74,64
05B20:  DATA 3E,52
05B22:  DATA 65,62
05B24:  DATA 6F,6F
05B26:  DATA 74,20
05B28:  DATA 3D,20
05B2A:  DATA 46,75
05B2C:  DATA 65,6E
05B2E:  DATA 74,65
05B30:  DATA 20,32
05B32:  DATA 20,3C
05B34:  DATA 69,6E
05B36:  DATA 70,75
05B38:  DATA 74,20
05B3A:  DATA 74,79
05B3C:  DATA 70,65
05B3E:  DATA 3D,22
05B40:  DATA 73,75
05B42:  DATA 62,6D
05B44:  DATA 69,74
05B46:  DATA 22,20
05B48:  DATA 6E,61
05B4A:  DATA 6D,65
05B4C:  DATA 3D,22
05B4E:  DATA 72,65
05B50:  DATA 62,6F
05B52:  DATA 6F,74
05B54:  DATA 32,22
05B56:  DATA 20,76
05B58:  DATA 61,6C
05B5A:  DATA 75,65
05B5C:  DATA 3D,22
05B5E:  DATA 52,65
05B60:  DATA 62,6F
05B62:  DATA 6F,74
05B64:  DATA 20,52
05B66:  DATA 65,6C
05B68:  DATA 61,79
05B6A:  DATA 20,32
05B6C:  DATA 22,3E
05B6E:  DATA 3C,2F
05B70:  DATA 74,64
05B72:  DATA 3E,3C
05B74:  DATA 2F,46
05B76:  DATA 4F,52
05B78:  DATA 4D,3E
05B7A:  DATA 20,0A
05B7C:  DATA 20,20
05B7E:  DATA 20,20
05B80:  DATA 20,20
05B82:  DATA 20,20
05B84:  DATA 20,20
05B86:  DATA 20,20
05B88:  DATA 20,20
05B8A:  DATA 20,20
05B8C:  DATA 20,20
05B8E:  DATA 3C,2F
05B90:  DATA 74,72
05B92:  DATA 3E,20
05B94:  DATA 0A,20
05B96:  DATA 20,20
05B98:  DATA 20,20
05B9A:  DATA 20,20
05B9C:  DATA 20,20
05B9E:  DATA 20,20
05BA0:  DATA 20,20
05BA2:  DATA 20,20
05BA4:  DATA 20,20
05BA6:  DATA 20,20
05BA8:  DATA 20,20
05BAA:  DATA 20,20
05BAC:  DATA 20,20
05BAE:  DATA 20,20
05BB0:  DATA 20,20
05BB2:  DATA 20,20
05BB4:  DATA 20,20
05BB6:  DATA 20,20
05BB8:  DATA 20,20
05BBA:  DATA 20,20
05BBC:  DATA 20,20
05BBE:  DATA 20,20
05BC0:  DATA 20,20
05BC2:  DATA 20,20
05BC4:  DATA 20,20
05BC6:  DATA 20,20
05BC8:  DATA 20,20
05BCA:  DATA 20,20
05BCC:  DATA 20,0A
05BCE:  DATA 20,20
05BD0:  DATA 20,20
05BD2:  DATA 20,20
05BD4:  DATA 20,20
05BD6:  DATA 20,20
05BD8:  DATA 20,20
05BDA:  DATA 20,20
05BDC:  DATA 20,20
05BDE:  DATA 20,20
05BE0:  DATA 3C,74
05BE2:  DATA 72,3E
05BE4:  DATA 20,0A
05BE6:  DATA 20,20
05BE8:  DATA 20,20
05BEA:  DATA 20,20
05BEC:  DATA 20,20
05BEE:  DATA 20,20
05BF0:  DATA 20,20
05BF2:  DATA 20,20
05BF4:  DATA 20,20
05BF6:  DATA 20,20
05BF8:  DATA 3C,74
05BFA:  DATA 64,3E
05BFC:  DATA 3C,62
05BFE:  DATA 3E,52
05C00:  DATA 65,6C
05C02:  DATA 65,20
05C04:  DATA 31,3D
05C06:  DATA 3C,2F
05C08:  DATA 62,3E
05C0A:  DATA 25,32
05C0C:  DATA 3C,2F
05C0E:  DATA 74,64
05C10:  DATA 3E,20
05C12:  DATA 20,20
05C14:  DATA 20,20
05C16:  DATA 20,20
05C18:  DATA 20,20
05C1A:  DATA 20,20
05C1C:  DATA 20,20
05C1E:  DATA 20,20
05C20:  DATA 20,20
05C22:  DATA 20,20
05C24:  DATA 20,20
05C26:  DATA 20,20
05C28:  DATA 20,20
05C2A:  DATA 20,20
05C2C:  DATA 20,20
05C2E:  DATA 20,20
05C30:  DATA 20,20
05C32:  DATA 20,20
05C34:  DATA 20,20
05C36:  DATA 20,20
05C38:  DATA 20,20
05C3A:  DATA 20,20
05C3C:  DATA 20,20
05C3E:  DATA 20,20
05C40:  DATA 20,20
05C42:  DATA 20,20
05C44:  DATA 20,20
05C46:  DATA 20,20
05C48:  DATA 20,20
05C4A:  DATA 20,20
05C4C:  DATA 20,20
05C4E:  DATA 20,20
05C50:  DATA 20,20
05C52:  DATA 20,20
05C54:  DATA 20,20
05C56:  DATA 20,20
05C58:  DATA 20,20
05C5A:  DATA 20,20
05C5C:  DATA 20,20
05C5E:  DATA 20,20
05C60:  DATA 20,20
05C62:  DATA 20,20
05C64:  DATA 20,20
05C66:  DATA 20,0A
05C68:  DATA 20,20
05C6A:  DATA 20,20
05C6C:  DATA 20,20
05C6E:  DATA 20,20
05C70:  DATA 20,20
05C72:  DATA 20,20
05C74:  DATA 20,20
05C76:  DATA 20,20
05C78:  DATA 20,20
05C7A:  DATA 3C,46
05C7C:  DATA 4F,52
05C7E:  DATA 4D,20
05C80:  DATA 4D,45
05C82:  DATA 54,48
05C84:  DATA 4F,44
05C86:  DATA 3D,50
05C88:  DATA 4F,53
05C8A:  DATA 54,3E
05C8C:  DATA 3C,74
05C8E:  DATA 64,3E
05C90:  DATA 50,75
05C92:  DATA 6C,73
05C94:  DATA 65,20
05C96:  DATA 20,4F
05C98:  DATA 4E,2F
05C9A:  DATA 4F,46
05C9C:  DATA 46,20
05C9E:  DATA 3D,20
05CA0:  DATA 49,6E
05CA2:  DATA 74,65
05CA4:  DATA 72,72
05CA6:  DATA 75,70
05CA8:  DATA 74,6F
05CAA:  DATA 72,20
05CAC:  DATA 46,75
05CAE:  DATA 65,6E
05CB0:  DATA 74,65
05CB2:  DATA 20,33
05CB4:  DATA 20,3C
05CB6:  DATA 69,6E
05CB8:  DATA 70,75
05CBA:  DATA 74,20
05CBC:  DATA 74,79
05CBE:  DATA 70,65
05CC0:  DATA 3D,22
05CC2:  DATA 73,75
05CC4:  DATA 62,6D
05CC6:  DATA 69,74
05CC8:  DATA 22,20
05CCA:  DATA 6E,61
05CCC:  DATA 6D,65
05CCE:  DATA 3D,22
05CD0:  DATA 62,6F
05CD2:  DATA 74,6F
05CD4:  DATA 6E,33
05CD6:  DATA 22,20
05CD8:  DATA 76,61
05CDA:  DATA 6C,75
05CDC:  DATA 65,3D
05CDE:  DATA 22,52
05CE0:  DATA 65,6C
05CE2:  DATA 61,79
05CE4:  DATA 20,33
05CE6:  DATA 22,3E
05CE8:  DATA 3C,2F
05CEA:  DATA 74,64
05CEC:  DATA 3E,3C
05CEE:  DATA 2F,46
05CF0:  DATA 4F,52
05CF2:  DATA 4D,3E
05CF4:  DATA 20,0A
05CF6:  DATA 20,20
05CF8:  DATA 20,20
05CFA:  DATA 20,20
05CFC:  DATA 20,20
05CFE:  DATA 20,20
05D00:  DATA 20,20
05D02:  DATA 20,20
05D04:  DATA 20,20
05D06:  DATA 20,20
05D08:  DATA 3C,46
05D0A:  DATA 4F,52
05D0C:  DATA 4D,20
05D0E:  DATA 4D,45
05D10:  DATA 54,48
05D12:  DATA 4F,44
05D14:  DATA 3D,50
05D16:  DATA 4F,53
05D18:  DATA 54,3E
05D1A:  DATA 3C,74
05D1C:  DATA 64,3E
05D1E:  DATA 52,65
05D20:  DATA 62,6F
05D22:  DATA 6F,74
05D24:  DATA 20,3D
05D26:  DATA 20,46
05D28:  DATA 75,65
05D2A:  DATA 6E,74
05D2C:  DATA 65,20
05D2E:  DATA 33,20
05D30:  DATA 3C,69
05D32:  DATA 6E,70
05D34:  DATA 75,74
05D36:  DATA 20,74
05D38:  DATA 79,70
05D3A:  DATA 65,3D
05D3C:  DATA 22,73
05D3E:  DATA 75,62
05D40:  DATA 6D,69
05D42:  DATA 74,22
05D44:  DATA 20,6E
05D46:  DATA 61,6D
05D48:  DATA 65,3D
05D4A:  DATA 22,72
05D4C:  DATA 65,62
05D4E:  DATA 6F,6F
05D50:  DATA 74,33
05D52:  DATA 22,20
05D54:  DATA 76,61
05D56:  DATA 6C,75
05D58:  DATA 65,3D
05D5A:  DATA 22,52
05D5C:  DATA 65,62
05D5E:  DATA 6F,6F
05D60:  DATA 74,20
05D62:  DATA 52,65
05D64:  DATA 6C,61
05D66:  DATA 79,20
05D68:  DATA 33,22
05D6A:  DATA 3E,3C
05D6C:  DATA 2F,74
05D6E:  DATA 64,3E
05D70:  DATA 3C,2F
05D72:  DATA 46,4F
05D74:  DATA 52,4D
05D76:  DATA 3E,20
05D78:  DATA 0A,20
05D7A:  DATA 20,20
05D7C:  DATA 20,20
05D7E:  DATA 20,20
05D80:  DATA 20,20
05D82:  DATA 20,20
05D84:  DATA 20,20
05D86:  DATA 20,20
05D88:  DATA 20,20
05D8A:  DATA 20,3C
05D8C:  DATA 2F,74
05D8E:  DATA 72,3E
05D90:  DATA 20,0A
05D92:  DATA 20,0A
05D94:  DATA 20,20
05D96:  DATA 20,20
05D98:  DATA 20,20
05D9A:  DATA 20,20
05D9C:  DATA 20,20
05D9E:  DATA 20,20
05DA0:  DATA 20,20
05DA2:  DATA 20,20
05DA4:  DATA 20,20
05DA6:  DATA 3C,74
05DA8:  DATA 72,3E
05DAA:  DATA 20,0A
05DAC:  DATA 20,20
05DAE:  DATA 20,20
05DB0:  DATA 20,20
05DB2:  DATA 20,20
05DB4:  DATA 20,20
05DB6:  DATA 20,20
05DB8:  DATA 20,20
05DBA:  DATA 20,20
05DBC:  DATA 20,20
05DBE:  DATA 3C,74
05DC0:  DATA 64,3E
05DC2:  DATA 3C,62
05DC4:  DATA 3E,52
05DC6:  DATA 65,6C
05DC8:  DATA 65,20
05DCA:  DATA 32,3D
05DCC:  DATA 3C,2F
05DCE:  DATA 62,3E
05DD0:  DATA 25,33
05DD2:  DATA 3C,2F
05DD4:  DATA 74,64
05DD6:  DATA 3E,20
05DD8:  DATA 0A,20
05DDA:  DATA 20,20
05DDC:  DATA 20,20
05DDE:  DATA 20,20
05DE0:  DATA 20,20
05DE2:  DATA 20,20
05DE4:  DATA 20,20
05DE6:  DATA 20,20
05DE8:  DATA 20,20
05DEA:  DATA 20,3C
05DEC:  DATA 46,4F
05DEE:  DATA 52,4D
05DF0:  DATA 20,4D
05DF2:  DATA 45,54
05DF4:  DATA 48,4F
05DF6:  DATA 44,3D
05DF8:  DATA 50,4F
05DFA:  DATA 53,54
05DFC:  DATA 3E,3C
05DFE:  DATA 74,64
05E00:  DATA 3E,50
05E02:  DATA 75,6C
05E04:  DATA 73,65
05E06:  DATA 20,20
05E08:  DATA 4F,4E
05E0A:  DATA 2F,4F
05E0C:  DATA 46,46
05E0E:  DATA 20,3D
05E10:  DATA 20,49
05E12:  DATA 6E,74
05E14:  DATA 65,72
05E16:  DATA 72,75
05E18:  DATA 70,74
05E1A:  DATA 6F,72
05E1C:  DATA 20,46
05E1E:  DATA 75,65
05E20:  DATA 6E,74
05E22:  DATA 65,20
05E24:  DATA 34,20
05E26:  DATA 3C,69
05E28:  DATA 6E,70
05E2A:  DATA 75,74
05E2C:  DATA 20,74
05E2E:  DATA 79,70
05E30:  DATA 65,3D
05E32:  DATA 22,73
05E34:  DATA 75,62
05E36:  DATA 6D,69
05E38:  DATA 74,22
05E3A:  DATA 20,6E
05E3C:  DATA 61,6D
05E3E:  DATA 65,3D
05E40:  DATA 22,62
05E42:  DATA 6F,74
05E44:  DATA 6F,6E
05E46:  DATA 34,22
05E48:  DATA 20,76
05E4A:  DATA 61,6C
05E4C:  DATA 75,65
05E4E:  DATA 3D,22
05E50:  DATA 52,65
05E52:  DATA 6C,61
05E54:  DATA 79,20
05E56:  DATA 34,22
05E58:  DATA 3E,3C
05E5A:  DATA 2F,74
05E5C:  DATA 64,3E
05E5E:  DATA 3C,2F
05E60:  DATA 46,4F
05E62:  DATA 52,4D
05E64:  DATA 3E,20
05E66:  DATA 0A,20
05E68:  DATA 20,20
05E6A:  DATA 20,20
05E6C:  DATA 20,20
05E6E:  DATA 20,20
05E70:  DATA 20,20
05E72:  DATA 20,20
05E74:  DATA 20,20
05E76:  DATA 20,20
05E78:  DATA 20,3C
05E7A:  DATA 46,4F
05E7C:  DATA 52,4D
05E7E:  DATA 20,4D
05E80:  DATA 45,54
05E82:  DATA 48,4F
05E84:  DATA 44,3D
05E86:  DATA 50,4F
05E88:  DATA 53,54
05E8A:  DATA 3E,3C
05E8C:  DATA 74,64
05E8E:  DATA 3E,52
05E90:  DATA 65,62
05E92:  DATA 6F,6F
05E94:  DATA 74,20
05E96:  DATA 3D,20
05E98:  DATA 46,75
05E9A:  DATA 65,6E
05E9C:  DATA 74,65
05E9E:  DATA 20,34
05EA0:  DATA 20,3C
05EA2:  DATA 69,6E
05EA4:  DATA 70,75
05EA6:  DATA 74,20
05EA8:  DATA 74,79
05EAA:  DATA 70,65
05EAC:  DATA 3D,22
05EAE:  DATA 73,75
05EB0:  DATA 62,6D
05EB2:  DATA 69,74
05EB4:  DATA 22,20
05EB6:  DATA 6E,61
05EB8:  DATA 6D,65
05EBA:  DATA 3D,22
05EBC:  DATA 72,65
05EBE:  DATA 62,6F
05EC0:  DATA 6F,74
05EC2:  DATA 34,22
05EC4:  DATA 20,76
05EC6:  DATA 61,6C
05EC8:  DATA 75,65
05ECA:  DATA 3D,22
05ECC:  DATA 52,65
05ECE:  DATA 62,6F
05ED0:  DATA 6F,74
05ED2:  DATA 20,52
05ED4:  DATA 65,6C
05ED6:  DATA 61,79
05ED8:  DATA 20,34
05EDA:  DATA 22,3E
05EDC:  DATA 3C,2F
05EDE:  DATA 74,64
05EE0:  DATA 3E,3C
05EE2:  DATA 2F,46
05EE4:  DATA 4F,52
05EE6:  DATA 4D,3E
05EE8:  DATA 20,0A
05EEA:  DATA 20,20
05EEC:  DATA 20,20
05EEE:  DATA 20,20
05EF0:  DATA 20,20
05EF2:  DATA 20,20
05EF4:  DATA 20,20
05EF6:  DATA 20,20
05EF8:  DATA 20,20
05EFA:  DATA 20,20
05EFC:  DATA 3C,2F
05EFE:  DATA 74,72
05F00:  DATA 3E,20
05F02:  DATA 0A,20
05F04:  DATA 20,20
05F06:  DATA 20,20
05F08:  DATA 20,20
05F0A:  DATA 20,20
05F0C:  DATA 20,20
05F0E:  DATA 20,20
05F10:  DATA 20,20
05F12:  DATA 20,20
05F14:  DATA 20,20
05F16:  DATA 20,20
05F18:  DATA 20,20
05F1A:  DATA 20,20
05F1C:  DATA 20,20
05F1E:  DATA 20,20
05F20:  DATA 20,20
05F22:  DATA 20,20
05F24:  DATA 20,20
05F26:  DATA 20,20
05F28:  DATA 20,20
05F2A:  DATA 20,20
05F2C:  DATA 20,20
05F2E:  DATA 20,20
05F30:  DATA 20,20
05F32:  DATA 20,20
05F34:  DATA 20,20
05F36:  DATA 20,20
05F38:  DATA 20,20
05F3A:  DATA 20,20
05F3C:  DATA 20,20
05F3E:  DATA 20,20
05F40:  DATA 20,20
05F42:  DATA 20,20
05F44:  DATA 20,20
05F46:  DATA 20,20
05F48:  DATA 20,20
05F4A:  DATA 20,20
05F4C:  DATA 20,20
05F4E:  DATA 20,20
05F50:  DATA 20,20
05F52:  DATA 20,20
05F54:  DATA 20,20
05F56:  DATA 20,20
05F58:  DATA 20,20
05F5A:  DATA 20,20
05F5C:  DATA 20,20
05F5E:  DATA 20,20
05F60:  DATA 20,20
05F62:  DATA 20,20
05F64:  DATA 20,20
05F66:  DATA 20,20
05F68:  DATA 20,20
05F6A:  DATA 20,0A
05F6C:  DATA 20,20
05F6E:  DATA 20,20
05F70:  DATA 20,20
05F72:  DATA 20,20
05F74:  DATA 20,20
05F76:  DATA 20,20
05F78:  DATA 20,20
05F7A:  DATA 20,20
05F7C:  DATA 20,20
05F7E:  DATA 3C,74
05F80:  DATA 72,3E
05F82:  DATA 20,0A
05F84:  DATA 20,20
05F86:  DATA 20,20
05F88:  DATA 20,20
05F8A:  DATA 20,20
05F8C:  DATA 20,20
05F8E:  DATA 20,20
05F90:  DATA 20,20
05F92:  DATA 20,20
05F94:  DATA 20,20
05F96:  DATA 3C,74
05F98:  DATA 64,3E
05F9A:  DATA 3C,62
05F9C:  DATA 3E,52
05F9E:  DATA 65,6C
05FA0:  DATA 61,79
05FA2:  DATA 20,33
05FA4:  DATA 3D,3C
05FA6:  DATA 2F,62
05FA8:  DATA 3E,25
05FAA:  DATA 34,3C
05FAC:  DATA 2F,74
05FAE:  DATA 64,3E
05FB0:  DATA 20,0A
05FB2:  DATA 20,20
05FB4:  DATA 20,20
05FB6:  DATA 20,20
05FB8:  DATA 20,20
05FBA:  DATA 20,20
05FBC:  DATA 20,20
05FBE:  DATA 20,20
05FC0:  DATA 20,20
05FC2:  DATA 20,20
05FC4:  DATA 3C,2F
05FC6:  DATA 74,72
05FC8:  DATA 3E,20
05FCA:  DATA 20,20
05FCC:  DATA 20,20
05FCE:  DATA 20,20
05FD0:  DATA 20,20
05FD2:  DATA 20,20
05FD4:  DATA 20,20
05FD6:  DATA 20,20
05FD8:  DATA 20,20
05FDA:  DATA 20,20
05FDC:  DATA 20,20
05FDE:  DATA 20,20
05FE0:  DATA 20,20
05FE2:  DATA 20,20
05FE4:  DATA 20,20
05FE6:  DATA 20,20
05FE8:  DATA 20,20
05FEA:  DATA 20,0A
05FEC:  DATA 20,20
05FEE:  DATA 20,20
05FF0:  DATA 20,20
05FF2:  DATA 20,20
05FF4:  DATA 20,20
05FF6:  DATA 20,20
05FF8:  DATA 20,20
05FFA:  DATA 20,20
05FFC:  DATA 20,20
05FFE:  DATA 20,20
06000:  DATA 20,20
06002:  DATA 20,20
06004:  DATA 20,20
06006:  DATA 20,20
06008:  DATA 20,20
0600A:  DATA 20,20
0600C:  DATA 20,20
0600E:  DATA 20,20
06010:  DATA 20,20
06012:  DATA 20,20
06014:  DATA 20,20
06016:  DATA 20,20
06018:  DATA 20,20
0601A:  DATA 20,20
0601C:  DATA 20,20
0601E:  DATA 20,20
06020:  DATA 20,20
06022:  DATA 20,20
06024:  DATA 20,20
06026:  DATA 20,20
06028:  DATA 20,20
0602A:  DATA 20,20
0602C:  DATA 20,20
0602E:  DATA 20,20
06030:  DATA 20,0A
06032:  DATA 20,20
06034:  DATA 20,20
06036:  DATA 20,20
06038:  DATA 20,20
0603A:  DATA 20,20
0603C:  DATA 20,20
0603E:  DATA 20,20
06040:  DATA 20,20
06042:  DATA 20,20
06044:  DATA 3C,74
06046:  DATA 72,3E
06048:  DATA 20,0A
0604A:  DATA 20,20
0604C:  DATA 20,20
0604E:  DATA 20,20
06050:  DATA 20,20
06052:  DATA 20,20
06054:  DATA 20,20
06056:  DATA 20,20
06058:  DATA 20,20
0605A:  DATA 20,20
0605C:  DATA 3C,74
0605E:  DATA 64,3E
06060:  DATA 3C,62
06062:  DATA 3E,52
06064:  DATA 65,6C
06066:  DATA 61,79
06068:  DATA 20,34
0606A:  DATA 3D,3C
0606C:  DATA 2F,62
0606E:  DATA 3E,25
06070:  DATA 35,3C
06072:  DATA 2F,74
06074:  DATA 64,3E
06076:  DATA 20,20
06078:  DATA 20,20
0607A:  DATA 20,20
0607C:  DATA 20,20
0607E:  DATA 20,20
06080:  DATA 20,20
06082:  DATA 20,20
06084:  DATA 20,20
06086:  DATA 20,20
06088:  DATA 20,20
0608A:  DATA 20,20
0608C:  DATA 20,20
0608E:  DATA 20,20
06090:  DATA 20,20
06092:  DATA 20,20
06094:  DATA 20,20
06096:  DATA 20,20
06098:  DATA 20,20
0609A:  DATA 20,20
0609C:  DATA 20,20
0609E:  DATA 20,20
060A0:  DATA 20,20
060A2:  DATA 20,20
060A4:  DATA 20,20
060A6:  DATA 20,20
060A8:  DATA 20,20
060AA:  DATA 20,20
060AC:  DATA 20,20
060AE:  DATA 20,20
060B0:  DATA 20,20
060B2:  DATA 20,20
060B4:  DATA 20,20
060B6:  DATA 20,20
060B8:  DATA 20,20
060BA:  DATA 20,20
060BC:  DATA 20,20
060BE:  DATA 20,20
060C0:  DATA 20,20
060C2:  DATA 20,20
060C4:  DATA 20,20
060C6:  DATA 20,20
060C8:  DATA 20,20
060CA:  DATA 20,20
060CC:  DATA 20,20
060CE:  DATA 20,20
060D0:  DATA 20,20
060D2:  DATA 20,20
060D4:  DATA 20,20
060D6:  DATA 20,20
060D8:  DATA 20,20
060DA:  DATA 20,20
060DC:  DATA 20,20
060DE:  DATA 20,20
060E0:  DATA 20,20
060E2:  DATA 20,20
060E4:  DATA 20,20
060E6:  DATA 20,20
060E8:  DATA 20,20
060EA:  DATA 20,20
060EC:  DATA 20,20
060EE:  DATA 20,20
060F0:  DATA 20,20
060F2:  DATA 20,20
060F4:  DATA 20,20
060F6:  DATA 20,20
060F8:  DATA 20,20
060FA:  DATA 20,20
060FC:  DATA 20,20
060FE:  DATA 20,20
06100:  DATA 20,20
06102:  DATA 20,20
06104:  DATA 20,20
06106:  DATA 20,20
06108:  DATA 20,20
0610A:  DATA 20,20
0610C:  DATA 20,20
0610E:  DATA 20,20
06110:  DATA 20,20
06112:  DATA 20,20
06114:  DATA 20,20
06116:  DATA 20,20
06118:  DATA 20,20
0611A:  DATA 20,20
0611C:  DATA 20,20
0611E:  DATA 20,20
06120:  DATA 20,0A
06122:  DATA 20,20
06124:  DATA 20,20
06126:  DATA 20,20
06128:  DATA 20,20
0612A:  DATA 20,20
0612C:  DATA 20,20
0612E:  DATA 20,20
06130:  DATA 20,20
06132:  DATA 20,20
06134:  DATA 3C,2F
06136:  DATA 74,72
06138:  DATA 3E,20
0613A:  DATA 20,20
0613C:  DATA 20,20
0613E:  DATA 20,20
06140:  DATA 20,20
06142:  DATA 20,20
06144:  DATA 20,0A
06146:  DATA 20,20
06148:  DATA 20,20
0614A:  DATA 20,20
0614C:  DATA 20,20
0614E:  DATA 20,20
06150:  DATA 20,20
06152:  DATA 20,20
06154:  DATA 20,20
06156:  DATA 3C,2F
06158:  DATA 74,61
0615A:  DATA 62,6C
0615C:  DATA 65,3E
0615E:  DATA 20,0A
06160:  DATA 20,20
06162:  DATA 20,20
06164:  DATA 20,3C
06166:  DATA 2F,74
06168:  DATA 61,62
0616A:  DATA 6C,65
0616C:  DATA 3E,20
0616E:  DATA 20,20
06170:  DATA 20,20
06172:  DATA 20,20
06174:  DATA 20,20
06176:  DATA 20,20
06178:  DATA 20,20
0617A:  DATA 20,20
0617C:  DATA 20,20
0617E:  DATA 20,20
06180:  DATA 20,20
06182:  DATA 20,20
06184:  DATA 20,20
06186:  DATA 20,20
06188:  DATA 20,20
0618A:  DATA 20,20
0618C:  DATA 20,20
0618E:  DATA 20,20
06190:  DATA 20,20
06192:  DATA 20,20
06194:  DATA 20,20
06196:  DATA 20,20
06198:  DATA 20,20
0619A:  DATA 20,20
0619C:  DATA 20,20
0619E:  DATA 20,20
061A0:  DATA 20,20
061A2:  DATA 20,20
061A4:  DATA 20,20
061A6:  DATA 20,20
061A8:  DATA 20,20
061AA:  DATA 20,20
061AC:  DATA 20,20
061AE:  DATA 20,20
061B0:  DATA 20,20
061B2:  DATA 20,20
061B4:  DATA 20,20
061B6:  DATA 20,0A
061B8:  DATA 20,20
061BA:  DATA 20,3C
061BC:  DATA 2F,74
061BE:  DATA 62,6F
061C0:  DATA 64,79
061C2:  DATA 3E,20
061C4:  DATA 0A,20
061C6:  DATA 20,20
061C8:  DATA 20,0A
061CA:  DATA 3C,70
061CC:  DATA 20,61
061CE:  DATA 6C,69
061D0:  DATA 67,6E
061D2:  DATA 3D,22
061D4:  DATA 63,65
061D6:  DATA 6E,74
061D8:  DATA 65,72
061DA:  DATA 22,3E
061DC:  DATA 3C,66
061DE:  DATA 6F,6E
061E0:  DATA 74,20
061E2:  DATA 73,69
061E4:  DATA 7A,65
061E6:  DATA 3D,22
061E8:  DATA 32,22
061EA:  DATA 3E,3C
061EC:  DATA 66,6F
061EE:  DATA 6E,74
061F0:  DATA 20,73
061F2:  DATA 69,7A
061F4:  DATA 65,3D
061F6:  DATA 22,32
061F8:  DATA 22,3E
061FA:  DATA 3C,66
061FC:  DATA 6F,6E
061FE:  DATA 74,20
06200:  DATA 73,69
06202:  DATA 7A,65
06204:  DATA 3D,22
06206:  DATA 32,22
06208:  DATA 3E,3C
0620A:  DATA 66,6F
0620C:  DATA 6E,74
0620E:  DATA 20,73
06210:  DATA 69,7A
06212:  DATA 65,3D
06214:  DATA 22,32
06216:  DATA 22,3E
06218:  DATA 3C,66
0621A:  DATA 6F,6E
0621C:  DATA 74,20
0621E:  DATA 73,69
06220:  DATA 7A,65
06222:  DATA 3D,22
06224:  DATA 32,22
06226:  DATA 3E,4C
06228:  DATA 61,62
0622A:  DATA 6F,72
0622C:  DATA 61,74
0622E:  DATA 6F,72
06230:  DATA 69,6F
06232:  DATA 20,64
06234:  DATA 65,20
06236:  DATA 49,2B
06238:  DATA 44,2E
0623A:  DATA 20,50
0623C:  DATA 6F,77
0623E:  DATA 65,72
06240:  DATA 20,64
06242:  DATA 69,73
06244:  DATA 74,72
06246:  DATA 69,62
06248:  DATA 75,74
0624A:  DATA 69,6F
0624C:  DATA 6E,20
0624E:  DATA 75,6E
06250:  DATA 69,74
06252:  DATA 20,3C
06254:  DATA 2F,66
06256:  DATA 6F,6E
06258:  DATA 74,3E
0625A:  DATA 3C,61
0625C:  DATA 20,68
0625E:  DATA 72,65
06260:  DATA 66,3D
06262:  DATA 22,68
06264:  DATA 74,74
06266:  DATA 70,3A
06268:  DATA 2F,2F
0626A:  DATA 77,77
0626C:  DATA 77,2E
0626E:  DATA 61,6C
06270:  DATA 74,65
06272:  DATA 63,2E
06274:  DATA 63,6F
06276:  DATA 6D,2E
06278:  DATA 61,72
0627A:  DATA 22,20
0627C:  DATA 74,61
0627E:  DATA 72,67
06280:  DATA 65,74
06282:  DATA 3D,22
06284:  DATA 5F,62
06286:  DATA 6C,61
06288:  DATA 6E,6B
0628A:  DATA 22,3E
0628C:  DATA 3C,66
0628E:  DATA 6F,6E
06290:  DATA 74,20
06292:  DATA 73,69
06294:  DATA 7A,65
06296:  DATA 3D,22
06298:  DATA 34,22
0629A:  DATA 3E,20
0629C:  DATA 41,6C
0629E:  DATA 74,65
062A0:  DATA 63,20
062A2:  DATA 53,2E
062A4:  DATA 45,2E
062A6:  DATA 3C,2F
062A8:  DATA 66,6F
062AA:  DATA 6E,74
062AC:  DATA 3E,3C
062AE:  DATA 2F,61
062B0:  DATA 3E,3C
062B2:  DATA 66,6F
062B4:  DATA 6E,74
062B6:  DATA 20,73
062B8:  DATA 69,7A
062BA:  DATA 65,3D
062BC:  DATA 22,34
062BE:  DATA 22,3E
062C0:  DATA 26,6E
062C2:  DATA 62,73
062C4:  DATA 70,3B
062C6:  DATA 20,3C
062C8:  DATA 2F,66
062CA:  DATA 6F,6E
062CC:  DATA 74,3E
062CE:  DATA 3C,2F
062D0:  DATA 66,6F
062D2:  DATA 6E,74
062D4:  DATA 3E,3C
062D6:  DATA 2F,66
062D8:  DATA 6F,6E
062DA:  DATA 74,3E
062DC:  DATA 3C,2F
062DE:  DATA 66,6F
062E0:  DATA 6E,74
062E2:  DATA 3E,3C
062E4:  DATA 2F,66
062E6:  DATA 6F,6E
062E8:  DATA 74,3E
062EA:  DATA 3C,2F
062EC:  DATA 70,3E
062EE:  DATA 20,0A
062F0:  DATA 3C,46
062F2:  DATA 4F,52
062F4:  DATA 4D,3E
062F6:  DATA 20,0A
062F8:  DATA 20,20
062FA:  DATA 20,3C
062FC:  DATA 49,4E
062FE:  DATA 50,55
06300:  DATA 54,20
06302:  DATA 54,59
06304:  DATA 50,45
06306:  DATA 3D,22
06308:  DATA 73,75
0630A:  DATA 62,6D
0630C:  DATA 69,74
0630E:  DATA 22,20
06310:  DATA 6F,6E
06312:  DATA 43,6C
06314:  DATA 69,63
06316:  DATA 6B,3D
06318:  DATA 22,68
0631A:  DATA 69,73
0631C:  DATA 74,6F
0631E:  DATA 72,79
06320:  DATA 2E,67
06322:  DATA 6F,28
06324:  DATA 30,29
06326:  DATA 22,20
06328:  DATA 56,41
0632A:  DATA 4C,55
0632C:  DATA 45,3D
0632E:  DATA 22,52
06330:  DATA 65,66
06332:  DATA 72,65
06334:  DATA 73,68
06336:  DATA 22,3E
06338:  DATA 20,0A
0633A:  DATA 3C,2F
0633C:  DATA 46,4F
0633E:  DATA 52,4D
06340:  DATA 3E,20
06342:  DATA 0A,3C
06344:  DATA 50,3E
06346:  DATA 3C,41
06348:  DATA 20,48
0634A:  DATA 52,45
0634C:  DATA 46,3D
0634E:  DATA 22,68
06350:  DATA 74,74
06352:  DATA 70,3A
06354:  DATA 2F,2F
06356:  DATA 77,77
06358:  DATA 77,2E
0635A:  DATA 67,6F
0635C:  DATA 6F,67
0635E:  DATA 6C,65
06360:  DATA 2E,63
06362:  DATA 6F,6D
06364:  DATA 2E,61
06366:  DATA 72,22
06368:  DATA 3E,53
0636A:  DATA 41,4C
0636C:  DATA 49,52
0636E:  DATA 3C,2F
06370:  DATA 41,3E
06372:  DATA 20,0A
06374:  DATA 3C,2F
06376:  DATA 62,6F
06378:  DATA 64,79
0637A:  DATA 3E,20
0637C:  DATA 0A,00
*
068FA:  MOVLB  3
068FC:  CLRF   x5C
068FE:  CLRF   x5D
06900:  MOVLW  01
06902:  MOVWF  x5E
06904:  CLRF   FDA
06906:  CLRF   FD9
06908:  MOVLW  03
0690A:  MOVWF  x61
0690C:  MOVLW  54
0690E:  MOVWF  x60
06910:  MOVLW  03
06912:  MOVWF  FEA
06914:  MOVLW  58
06916:  MOVWF  FE9
06918:  MOVFF  361,FE2
0691C:  MOVFF  360,FE1
06920:  MOVFF  35E,35F
06924:  BCF    FD8.0
06926:  MOVF   FE5,W
06928:  MULWF  FEE
0692A:  MOVF   FF3,W
0692C:  ADDWFC x5C,F
0692E:  MOVF   FF4,W
06930:  ADDWFC x5D,F
06932:  DECFSZ x5F,F
06934:  BRA    6924
06936:  MOVFF  35C,FDE
0693A:  MOVFF  35D,35C
0693E:  CLRF   x5D
06940:  BTFSC  FD8.0
06942:  INCF   x5D,F
06944:  INCF   x60,F
06946:  BTFSC  FD8.2
06948:  INCF   x61,F
0694A:  INCF   x5E,F
0694C:  MOVF   x5E,W
0694E:  SUBLW  05
06950:  BNZ   6910
06952:  MOVLB  0
06954:  GOTO   69C6 (RETURN)
06958:  CLRF   01
0695A:  CLRF   02
0695C:  CLRF   00
0695E:  CLRF   03
06960:  MOVLB  3
06962:  MOVF   x5A,W
06964:  BNZ   696A
06966:  MOVF   x59,W
06968:  BZ    699A
0696A:  MOVLW  10
0696C:  MOVWF  x5B
0696E:  BCF    FD8.0
06970:  RLCF   x57,F
06972:  RLCF   x58,F
06974:  RLCF   00,F
06976:  RLCF   03,F
06978:  MOVF   x5A,W
0697A:  SUBWF  03,W
0697C:  BNZ   6982
0697E:  MOVF   x59,W
06980:  SUBWF  00,W
06982:  BNC   6992
06984:  MOVF   x59,W
06986:  SUBWF  00,F
06988:  BTFSS  FD8.0
0698A:  DECF   03,F
0698C:  MOVF   x5A,W
0698E:  SUBWF  03,F
06990:  BSF    FD8.0
06992:  RLCF   01,F
06994:  RLCF   02,F
06996:  DECFSZ x5B,F
06998:  BRA    696E
0699A:  MOVLB  0
0699C:  GOTO   6A06 (RETURN)
*
0998C:  ADDWF  FE8,W
0998E:  CLRF   FF7
09990:  RLCF   FF7,F
09992:  ADDLW  A7
09994:  MOVWF  FF6
09996:  MOVLW  99
09998:  ADDWFC FF7,F
0999A:  TBLRD*-
0999C:  MOVF   FF5,W
0999E:  MOVWF  FFA
099A0:  TBLRD*
099A2:  MOVF   FF5,W
099A4:  MOVWF  FF9
099A6:  DATA 2C,97
099A8:  DATA 34,97
099AA:  DATA 7C,97
099AC:  DATA 1C,98
099AE:  DATA 48,98
099B0:  DATA 48,98
099B2:  DATA 58,98
099B4:  DATA 68,98
099B6:  DATA 7C,98
*
09DA6:  MOVLB  3
09DA8:  MOVF   xB0,W
09DAA:  XORWF  xB2,W
09DAC:  ANDLW  80
09DAE:  MOVWF  xB4
09DB0:  BTFSS  xB0.7
09DB2:  BRA    9DBE
09DB4:  COMF   xAF,F
09DB6:  COMF   xB0,F
09DB8:  INCF   xAF,F
09DBA:  BTFSC  FD8.2
09DBC:  INCF   xB0,F
09DBE:  BTFSS  xB2.7
09DC0:  BRA    9DCC
09DC2:  COMF   xB1,F
09DC4:  COMF   xB2,F
09DC6:  INCF   xB1,F
09DC8:  BTFSC  FD8.2
09DCA:  INCF   xB2,F
09DCC:  MOVF   xAF,W
09DCE:  MULWF  xB1
09DD0:  MOVFF  FF3,01
09DD4:  MOVFF  FF4,00
09DD8:  MULWF  xB2
09DDA:  MOVF   FF3,W
09DDC:  ADDWF  00,F
09DDE:  MOVF   xB0,W
09DE0:  MULWF  xB1
09DE2:  MOVF   FF3,W
09DE4:  ADDWFC 00,W
09DE6:  MOVWF  02
09DE8:  BTFSS  xB4.7
09DEA:  BRA    9DF6
09DEC:  COMF   01,F
09DEE:  COMF   02,F
09DF0:  INCF   01,F
09DF2:  BTFSC  FD8.2
09DF4:  INCF   02,F
09DF6:  MOVLB  0
09DF8:  RETURN 0
*
0ACDC:  TBLRD*+
0ACDE:  MOVFF  FF6,370
0ACE2:  MOVFF  FF7,371
0ACE6:  MOVFF  FF5,38D
0ACEA:  RCALL  ACCE
0ACEC:  MOVFF  370,FF6
0ACF0:  MOVFF  371,FF7
0ACF4:  MOVLB  3
0ACF6:  DECFSZ x6F,F
0ACF8:  BRA    ACFC
0ACFA:  BRA    AD00
0ACFC:  MOVLB  0
0ACFE:  BRA    ACDC
0AD00:  MOVLB  0
0AD02:  GOTO   B6F8 (RETURN)
0AD06:  MOVFF  FEA,377
0AD0A:  MOVFF  FE9,376
0AD0E:  MOVLB  3
0AD10:  SWAPF  x70,W
0AD12:  IORLW  F0
0AD14:  MOVWF  x72
0AD16:  ADDWF  x72,F
0AD18:  ADDLW  E2
0AD1A:  MOVWF  x73
0AD1C:  ADDLW  32
0AD1E:  MOVWF  x75
0AD20:  MOVF   x70,W
0AD22:  ANDLW  0F
0AD24:  ADDWF  x73,F
0AD26:  ADDWF  x73,F
0AD28:  ADDWF  x75,F
0AD2A:  ADDLW  E9
0AD2C:  MOVWF  x74
0AD2E:  ADDWF  x74,F
0AD30:  ADDWF  x74,F
0AD32:  SWAPF  x6F,W
0AD34:  ANDLW  0F
0AD36:  ADDWF  x74,F
0AD38:  ADDWF  x75,F
0AD3A:  RLCF   x74,F
0AD3C:  RLCF   x75,F
0AD3E:  COMF   x75,F
0AD40:  RLCF   x75,F
0AD42:  MOVF   x6F,W
0AD44:  ANDLW  0F
0AD46:  ADDWF  x75,F
0AD48:  RLCF   x72,F
0AD4A:  MOVLW  07
0AD4C:  MOVWF  x71
0AD4E:  MOVLW  0A
0AD50:  DECF   x74,F
0AD52:  ADDWF  x75,F
0AD54:  BNC   AD50
0AD56:  DECF   x73,F
0AD58:  ADDWF  x74,F
0AD5A:  BNC   AD56
0AD5C:  DECF   x72,F
0AD5E:  ADDWF  x73,F
0AD60:  BNC   AD5C
0AD62:  DECF   x71,F
0AD64:  ADDWF  x72,F
0AD66:  BNC   AD62
0AD68:  MOVLW  03
0AD6A:  MOVWF  FEA
0AD6C:  MOVLW  71
0AD6E:  MOVWF  FE9
0AD70:  MOVLW  07
0AD72:  ANDWF  x76,W
0AD74:  BCF    x76.6
0AD76:  ADDWF  FE9,F
0AD78:  MOVLW  00
0AD7A:  ADDWFC FEA,F
0AD7C:  MOVF   FE9,W
0AD7E:  SUBLW  75
0AD80:  BNZ   AD8A
0AD82:  MOVF   FEA,W
0AD84:  SUBLW  03
0AD86:  BNZ   AD8A
0AD88:  BSF    x76.6
0AD8A:  MOVF   FEF,W
0AD8C:  MOVWF  00
0AD8E:  BNZ   ADA0
0AD90:  BTFSC  x76.6
0AD92:  BRA    ADA0
0AD94:  BTFSC  x76.4
0AD96:  BRA    ADC2
0AD98:  BTFSC  x76.3
0AD9A:  BRA    ADA0
0AD9C:  MOVLW  20
0AD9E:  BRA    ADA6
0ADA0:  BSF    x76.3
0ADA2:  BCF    x76.4
0ADA4:  MOVLW  30
0ADA6:  ADDWF  00,F
0ADA8:  MOVFF  FEA,370
0ADAC:  MOVFF  FE9,36F
0ADB0:  MOVFF  00,38D
0ADB4:  MOVLB  0
0ADB6:  RCALL  ACCE
0ADB8:  MOVFF  370,FEA
0ADBC:  MOVFF  36F,FE9
0ADC0:  MOVLB  3
0ADC2:  MOVF   FEE,W
0ADC4:  BTFSS  x76.6
0ADC6:  BRA    AD7C
0ADC8:  MOVLB  0
0ADCA:  GOTO   B708 (RETURN)
0ADCE:  TBLRD*+
0ADD0:  MOVF   FF5,F
0ADD2:  BZ    ADEC
0ADD4:  MOVFF  FF6,36F
0ADD8:  MOVFF  FF7,370
0ADDC:  MOVFF  FF5,38D
0ADE0:  RCALL  ACCE
0ADE2:  MOVFF  36F,FF6
0ADE6:  MOVFF  370,FF7
0ADEA:  BRA    ADCE
0ADEC:  RETURN 0
0ADEE:  MOVF   FEF,F
0ADF0:  BZ    AE10
0ADF2:  MOVFF  FEA,370
0ADF6:  MOVFF  FE9,36F
0ADFA:  MOVFF  FEF,38D
0ADFE:  RCALL  ACCE
0AE00:  MOVFF  370,FEA
0AE04:  MOVFF  36F,FE9
0AE08:  INCF   FE9,F
0AE0A:  BTFSC  FD8.2
0AE0C:  INCF   FEA,F
0AE0E:  BRA    ADEE
0AE10:  GOTO   B7BE (RETURN)
*
0AFC8:  MOVFF  392,01
0AFCC:  MOVFF  391,00
0AFD0:  TSTFSZ 00
0AFD2:  INCF   01,F
0AFD4:  TBLRD*+
0AFD6:  MOVFF  FF5,FEE
0AFDA:  DECFSZ 00,F
0AFDC:  BRA    AFD4
0AFDE:  DECFSZ 01,F
0AFE0:  BRA    AFD4
0AFE2:  CLRF   FF8
0AFE4:  RETURN 0
*
0B278:  MOVFF  154,FEA
0B27C:  MOVFF  153,FE9
0B280:  MOVLB  3
0B282:  MOVFF  398,FEF
0B286:  INCF   FE9,F
0B288:  BTFSC  FD8.2
0B28A:  INCF   FEA,F
0B28C:  CLRF   FEF
0B28E:  MOVLB  1
0B290:  INCF   x53,F
0B292:  BTFSC  FD8.2
0B294:  INCF   x54,F
0B296:  MOVLB  0
0B298:  RETURN 0
0B29A:  MOVLB  3
0B29C:  BTFSC  x93.7
0B29E:  BRA    B2C2
0B2A0:  MOVLW  0F
0B2A2:  MOVWF  00
0B2A4:  SWAPF  x92,W
0B2A6:  ANDWF  00,F
0B2A8:  MOVLW  0A
0B2AA:  SUBWF  00,W
0B2AC:  BC    B2B4
0B2AE:  MOVLW  30
0B2B0:  ADDWF  00,F
0B2B2:  BRA    B2B8
0B2B4:  MOVF   x93,W
0B2B6:  ADDWF  00,F
0B2B8:  MOVFF  00,398
0B2BC:  MOVLB  0
0B2BE:  RCALL  B278
0B2C0:  MOVLB  3
0B2C2:  MOVLW  0F
0B2C4:  ANDWF  x92,F
0B2C6:  MOVLW  0A
0B2C8:  SUBWF  x92,W
0B2CA:  BC    B2D0
0B2CC:  MOVLW  30
0B2CE:  BRA    B2D4
0B2D0:  BCF    x93.7
0B2D2:  MOVF   x93,W
0B2D4:  ADDWF  x92,F
0B2D6:  MOVFF  392,398
0B2DA:  MOVLB  0
0B2DC:  RCALL  B278
0B2DE:  GOTO   B4D8 (RETURN)
0B2E2:  MOVLB  3
0B2E4:  MOVF   x99,W
0B2E6:  CLRF   01
0B2E8:  SUBWF  x98,W
0B2EA:  BC    B2F2
0B2EC:  MOVFF  398,00
0B2F0:  BRA    B30A
0B2F2:  CLRF   00
0B2F4:  MOVLW  08
0B2F6:  MOVWF  x9A
0B2F8:  RLCF   x98,F
0B2FA:  RLCF   00,F
0B2FC:  MOVF   x99,W
0B2FE:  SUBWF  00,W
0B300:  BTFSC  FD8.0
0B302:  MOVWF  00
0B304:  RLCF   01,F
0B306:  DECFSZ x9A,F
0B308:  BRA    B2F8
0B30A:  MOVLB  0
0B30C:  RETURN 0
0B30E:  MOVLW  20
0B310:  MOVLB  3
0B312:  BTFSS  x93.4
0B314:  MOVLW  30
0B316:  MOVWF  x94
0B318:  MOVFF  392,00
0B31C:  BTFSS  x92.7
0B31E:  BRA    B330
0B320:  COMF   00,F
0B322:  INCF   00,F
0B324:  MOVFF  00,392
0B328:  MOVLW  2D
0B32A:  MOVWF  x94
0B32C:  BSF    x93.7
0B32E:  BSF    x93.0
0B330:  MOVF   01,W
0B332:  MOVFF  392,398
0B336:  MOVLW  64
0B338:  MOVWF  x99
0B33A:  MOVLB  0
0B33C:  RCALL  B2E2
0B33E:  MOVFF  00,392
0B342:  MOVLW  30
0B344:  ADDWF  01,W
0B346:  MOVLB  3
0B348:  MOVWF  x95
0B34A:  MOVFF  392,398
0B34E:  MOVLW  0A
0B350:  MOVWF  x99
0B352:  MOVLB  0
0B354:  RCALL  B2E2
0B356:  MOVLW  30
0B358:  ADDWF  00,W
0B35A:  MOVLB  3
0B35C:  MOVWF  x97
0B35E:  MOVLW  30
0B360:  ADDWF  01,W
0B362:  MOVWF  x96
0B364:  MOVFF  394,00
0B368:  MOVLW  30
0B36A:  SUBWF  x95,W
0B36C:  BZ    B376
0B36E:  BSF    x93.1
0B370:  BTFSC  x93.7
0B372:  BSF    x93.2
0B374:  BRA    B39A
0B376:  MOVFF  394,395
0B37A:  MOVLW  20
0B37C:  MOVWF  x94
0B37E:  MOVLW  30
0B380:  SUBWF  x96,W
0B382:  BZ    B38C
0B384:  BSF    x93.0
0B386:  BTFSC  x93.7
0B388:  BSF    x93.1
0B38A:  BRA    B39A
0B38C:  BTFSS  FD8.2
0B38E:  BSF    x93.0
0B390:  BNZ   B39A
0B392:  MOVFF  395,396
0B396:  MOVLW  20
0B398:  MOVWF  x95
0B39A:  BTFSC  x93.2
0B39C:  BRA    B3A8
0B39E:  BTFSC  x93.1
0B3A0:  BRA    B3B0
0B3A2:  BTFSC  x93.0
0B3A4:  BRA    B3B8
0B3A6:  BRA    B3C0
0B3A8:  MOVFF  394,398
0B3AC:  MOVLB  0
0B3AE:  RCALL  B278
0B3B0:  MOVFF  395,398
0B3B4:  MOVLB  0
0B3B6:  RCALL  B278
0B3B8:  MOVFF  396,398
0B3BC:  MOVLB  0
0B3BE:  RCALL  B278
0B3C0:  MOVFF  397,398
0B3C4:  MOVLB  0
0B3C6:  RCALL  B278
0B3C8:  RETURN 0
*
0C8CC:  ADDWF  FE8,W
0C8CE:  CLRF   FF7
0C8D0:  RLCF   FF7,F
0C8D2:  ADDLW  E7
0C8D4:  MOVWF  FF6
0C8D6:  MOVLW  C8
0C8D8:  ADDWFC FF7,F
0C8DA:  TBLRD*-
0C8DC:  MOVF   FF5,W
0C8DE:  MOVWF  FFA
0C8E0:  TBLRD*
0C8E2:  MOVF   FF5,W
0C8E4:  MOVWF  FF9
0C8E6:  DATA 12,C7
0C8E8:  DATA 12,C7
0C8EA:  DATA 72,C7
0C8EC:  DATA 08,C8
0C8EE:  DATA 6E,C8
0C8F0:  DATA 60,C7
0C8F2:  DATA DA,C7
....................  
.................... #list 
....................  
....................                                                                                                      
.................... #device ADC=10 
....................  
.................... #DEVICE PASS_STRINGS = IN_RAM      //para trabajar con CONST en RAM     
....................  
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTC                   //Configuration registers not write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOWDT 
....................                                                              
.................... #use delay(internal=32MHz) 
*
0637E:  MOVLW  03
06380:  MOVWF  FEA
06382:  MOVLW  52
06384:  MOVWF  FE9
06386:  MOVF   FEF,W
06388:  BZ    63A4
0638A:  MOVLW  0A
0638C:  MOVWF  01
0638E:  CLRF   00
06390:  DECFSZ 00,F
06392:  BRA    6390
06394:  DECFSZ 01,F
06396:  BRA    638E
06398:  MOVLW  5F
0639A:  MOVWF  00
0639C:  DECFSZ 00,F
0639E:  BRA    639C
063A0:  DECFSZ FEF,F
063A2:  BRA    638A
063A4:  RETURN 0
*
0B252:  MOVLW  02
0B254:  MOVLB  3
0B256:  SUBWF  x92,F
0B258:  BNC   B272
0B25A:  MOVLW  03
0B25C:  MOVWF  FEA
0B25E:  MOVLW  92
0B260:  MOVWF  FE9
0B262:  MOVF   FEF,W
0B264:  BZ    B272
0B266:  BRA    B26E
0B268:  BRA    B26A
0B26A:  BRA    B26C
0B26C:  NOP   
0B26E:  DECFSZ FEF,F
0B270:  BRA    B268
0B272:  MOVLB  0
0B274:  GOTO   B4A0 (RETURN)
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8)  
....................  
.................... //#include <18f4620+enc28j60_RyP.h> 
....................  
.................... //intenal regiter  
.................... //byte porta = 0xF80  
.................... #byte portb = 0xF81  
.................... #byte portc = 0xF82  
.................... //#byte portd = 0xF83  
.................... //#byte porte = 0xF84  
.................... //#byte trisa = 0xF92                                                
.................... //#byte trisb = 0xF93                      
.................... //#byte trisc = 0xF94                                                        
.................... //#byte trisd = 0xF95  
.................... //#byte trise = 0xF96  
....................  
.................... /** Configuración para el uso del stack tcip **/ 
.................... #define STACK_USE_ICMP        1  //Módulo de respuesta ICMP (ping) 
.................... #define STACK_USE_ARP         1  //Para solucionar direccionamiento MAC de las IP 
.................... #define STACK_USE_TCP         1  //Para enviar paquetes TCP  
.................... #define STACK_USE_HTTP        1  //Uso de las funciones http del stack. 
.................... #define STACK_USE_CCS_PICENS  1  //CCS PICENS (Embedded Ethernet) 18F4620 + ENC28J60 
.................... #define STACK_USE_MCPENC      1  //Uso del enc28j60 por el stack (stacktsk.c) 
.................... #define STACK_USE_MAC         1  //Uso de la tarjeta de red 
....................  
.................... #define HTTP_SOCKET 80         //Nº de puerto asociado al socket. 
....................  
.................... /********** Definición del patillaje de conexión al enc28j60 ******************/ 
.................... /* Existen varias posibilidades: 
....................  
.................... Opción 1. No definir nada, en cuyo caso se implementará una comunicación SPI por  
.................... software y se tomarán la definición de patillas establecida en enc28j60.c 
....................  
.................... SO  PIN_D7 ---- ENC >>>> PIC 
.................... SI  PIN_D6 ---- PIC >>>> ENC 
.................... CLK PIN_D5 
.................... CS  PIN_D4 
.................... RST PIN_D3 
.................... INT PIN_D2 
.................... WOL PIN_D1 
....................  
.................... Opción 2. Definir todas las patillas de la comunicación SPI, en cuyo caso se  
.................... implementará una comunicación SPI por software con la definición de patillas  
.................... elegida. Por ejemplo... 
....................  
.................... #define PIN_ENC_MAC_SO  PIN_C4   //Entrada serie de datos 
.................... #define PIN_ENC_MAC_SI  PIN_C5   //Salida serie de datos                                
.................... #define PIN_ENC_MAC_CLK PIN_B4   //Señal de reloj 
.................... #define PIN_ENC_MAC_CS  PIN_B5   //Chip select 
.................... #define PIN_ENC_MAC_RST PIN_B6   //Reset                                                                                   
.................... #define PIN_ENC_MAC_INT PIN_B7   //Interrupción 
....................  
.................... Opción 3. El que aquí se ha utilizado, que consiste en habilitar el uso de SPI  
.................... por hardware del PIC y definir las patillas ajenas al hardware del módulo SPI  
.................... (CS, INT y RST). En este caso es imprescindible definir también la patilla SO  
.................... para que el stack (dentro de enc28j60.c) no habilite SPI por software. Da igual  
.................... que patilla SO se defina, la que se deberá cablear será la SO real del PIC    */ 
....................  
.................... #define ENC_MAC_USE_SPI 1           //Uso del SPI por hardware 
....................                
.................... #define PIN_ENC_MAC_SO  PIN_B4      //Entrada serie de datos 
.................... //#define PIN_ENC_MAC_SI  PIN_C7    //Salida serie de datos (no necesario definir) 
.................... //#define PIN_ENC_MAC_CLK PIN_B1    //Señal de reloj  (no necesario definir) 
.................... #define PIN_ENC_MAC_CS  PIN_B6      //Chip select 
.................... #define PIN_ENC_MAC_RST PIN_B7      //Reset               
.................... #define PIN_ENC_MAC_INT PIN_B5      //Interrupción 
....................                   
.................... /******************************************************************************/ 
....................                                                                            
.................... //#define use_portd_lcd TRUE       //Uso del puerto d para control del lcd 
.................... //#include <LCD420PIC18F_RyP.c>    //Carga librería del lcd de 4x20 para familia 18F 
....................  
.................... #include "tcpip/stacktsk.c"      //Carga el stack TCP/IP de Microchip  
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #case 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        192   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        168   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        1 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        10 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           1 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x02 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x04 
.................... #define MY_DEFAULT_MAC_BYTE5            0x05 
.................... #define MY_DEFAULT_MAC_BYTE6            0x06 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     5 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
*
0A16A:  MOVFF  380,386
0A16E:  MOVFF  37F,385
....................    sc2=s2; 
0A172:  MOVFF  382,388
0A176:  MOVFF  381,387
....................    if(sc2<sc1 && sc1 <sc2 +n) 
0A17A:  MOVLB  3
0A17C:  MOVF   x88,W
0A17E:  SUBWF  x86,W
0A180:  BNC   A1FE
0A182:  BNZ   A18A
0A184:  MOVF   x85,W
0A186:  SUBWF  x87,W
0A188:  BC    A1FE
0A18A:  MOVF   x83,W
0A18C:  ADDWF  x87,W
0A18E:  MOVWF  01
0A190:  MOVF   x84,W
0A192:  ADDWFC x88,W
0A194:  MOVWF  03
0A196:  MOVF   x86,W
0A198:  SUBWF  03,W
0A19A:  BNC   A1FE
0A19C:  BNZ   A1A4
0A19E:  MOVF   01,W
0A1A0:  SUBWF  x85,W
0A1A2:  BC    A1FE
....................       for(sc1+=n,sc2+=n;0<n;--n) 
0A1A4:  MOVF   x83,W
0A1A6:  ADDWF  x85,F
0A1A8:  MOVF   x84,W
0A1AA:  ADDWFC x86,F
0A1AC:  MOVF   x83,W
0A1AE:  ADDWF  x87,F
0A1B0:  MOVF   x84,W
0A1B2:  ADDWFC x88,F
0A1B4:  MOVF   x84,F
0A1B6:  BNZ   A1BE
0A1B8:  MOVF   x83,W
0A1BA:  SUBLW  00
0A1BC:  BC    A1FC
....................          *--sc1=*--sc2; 
0A1BE:  MOVF   x85,W
0A1C0:  BTFSC  FD8.2
0A1C2:  DECF   x86,F
0A1C4:  DECF   x85,F
0A1C6:  MOVFF  385,389
0A1CA:  MOVFF  386,38A
0A1CE:  MOVF   x87,W
0A1D0:  BTFSC  FD8.2
0A1D2:  DECF   x88,F
0A1D4:  DECF   x87,F
0A1D6:  MOVFF  388,03
0A1DA:  MOVFF  387,FE9
0A1DE:  MOVFF  388,FEA
0A1E2:  MOVFF  FEF,38B
0A1E6:  MOVFF  386,FEA
0A1EA:  MOVFF  385,FE9
0A1EE:  MOVFF  38B,FEF
0A1F2:  MOVF   x83,W
0A1F4:  BTFSC  FD8.2
0A1F6:  DECF   x84,F
0A1F8:  DECF   x83,F
0A1FA:  BRA    A1B4
0A1FC:  BRA    A242
....................    else 
....................       for(;0<n;--n) 
0A1FE:  MOVF   x84,F
0A200:  BNZ   A208
0A202:  MOVF   x83,W
0A204:  SUBLW  00
0A206:  BC    A242
....................          *sc1++=*sc2++; 
0A208:  MOVFF  386,38A
0A20C:  MOVF   x85,W
0A20E:  INCF   x85,F
0A210:  BTFSC  FD8.2
0A212:  INCF   x86,F
0A214:  MOVWF  x89
0A216:  MOVFF  388,03
0A21A:  MOVF   x87,W
0A21C:  INCF   x87,F
0A21E:  BTFSC  FD8.2
0A220:  INCF   x88,F
0A222:  MOVWF  FE9
0A224:  MOVFF  03,FEA
0A228:  MOVFF  FEF,38B
0A22C:  MOVFF  38A,FEA
0A230:  MOVFF  389,FE9
0A234:  MOVFF  38B,FEF
0A238:  MOVF   x83,W
0A23A:  BTFSC  FD8.2
0A23C:  DECF   x84,F
0A23E:  DECF   x83,F
0A240:  BRA    A1FE
....................   return s1; 
0A242:  MOVFF  37F,01
0A246:  MOVFF  380,02
0A24A:  MOVLB  0
0A24C:  GOTO   A322 (RETURN)
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0B3CA:  MOVFF  393,399
0B3CE:  MOVFF  392,398
0B3D2:  MOVLB  3
0B3D4:  MOVF   x96,F
0B3D6:  BNZ   B3DC
0B3D8:  MOVF   x97,F
0B3DA:  BZ    B426
0B3DC:  MOVFF  395,03
0B3E0:  MOVFF  394,FE9
0B3E4:  MOVFF  395,FEA
0B3E8:  MOVF   FEF,F
0B3EA:  BZ    B426
....................      *s++ = *s2++; 
0B3EC:  MOVFF  399,39B
0B3F0:  MOVF   x98,W
0B3F2:  INCF   x98,F
0B3F4:  BTFSC  FD8.2
0B3F6:  INCF   x99,F
0B3F8:  MOVWF  x9A
0B3FA:  MOVFF  395,03
0B3FE:  MOVF   x94,W
0B400:  INCF   x94,F
0B402:  BTFSC  FD8.2
0B404:  INCF   x95,F
0B406:  MOVWF  FE9
0B408:  MOVFF  03,FEA
0B40C:  MOVFF  FEF,39C
0B410:  MOVFF  39B,FEA
0B414:  MOVFF  39A,FE9
0B418:  MOVFF  39C,FEF
0B41C:  MOVF   x96,W
0B41E:  BTFSC  FD8.2
0B420:  DECF   x97,F
0B422:  DECF   x96,F
0B424:  BRA    B3D4
....................   for (; n > 0; n--) 
0B426:  MOVF   x96,F
0B428:  BNZ   B42E
0B42A:  MOVF   x97,F
0B42C:  BZ    B44C
....................      *s++ = '\0'; 
0B42E:  MOVFF  399,03
0B432:  MOVF   x98,W
0B434:  INCF   x98,F
0B436:  BTFSC  FD8.2
0B438:  INCF   x99,F
0B43A:  MOVWF  FE9
0B43C:  MOVFF  03,FEA
0B440:  CLRF   FEF
0B442:  MOVF   x96,W
0B444:  BTFSC  FD8.2
0B446:  DECF   x97,F
0B448:  DECF   x96,F
0B44A:  BRA    B426
....................  
....................   return(s1); 
0B44C:  MOVFF  392,01
0B450:  MOVFF  393,02
0B454:  MOVLB  0
0B456:  GOTO   B638 (RETURN)
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
09CE0:  MOVLB  3
09CE2:  MOVFF  35F,FE9
09CE6:  MOVFF  360,FEA
09CEA:  MOVFF  FEF,363
09CEE:  MOVFF  362,03
09CF2:  MOVFF  361,FE9
09CF6:  MOVFF  362,FEA
09CFA:  MOVF   FEF,W
09CFC:  SUBWF  x63,W
09CFE:  BNZ   9D2A
....................       if (*s1 == '\0') 
09D00:  MOVFF  360,03
09D04:  MOVFF  35F,FE9
09D08:  MOVFF  03,FEA
09D0C:  MOVF   FEF,F
09D0E:  BNZ   9D16
....................          return(0); 
09D10:  MOVLW  00
09D12:  MOVWF  01
09D14:  BRA    9D54
09D16:  MOVFF  360,03
09D1A:  MOVF   x5F,W
09D1C:  INCF   x5F,F
09D1E:  BTFSC  FD8.2
09D20:  INCF   x60,F
09D22:  INCF   x61,F
09D24:  BTFSC  FD8.2
09D26:  INCF   x62,F
09D28:  BRA    9CE2
....................    return((*s1 < *s2) ? -1: 1); 
09D2A:  MOVFF  360,03
09D2E:  MOVFF  35F,FE9
09D32:  MOVFF  360,FEA
09D36:  MOVFF  FEF,363
09D3A:  MOVFF  362,03
09D3E:  MOVFF  361,FE9
09D42:  MOVFF  362,FEA
09D46:  MOVF   FEF,W
09D48:  SUBWF  x63,W
09D4A:  BC    9D50
09D4C:  MOVLW  FF
09D4E:  BRA    9D52
09D50:  MOVLW  01
09D52:  MOVWF  01
09D54:  MOVLB  0
09D56:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
09D58:  MOVFF  3B0,3B3
....................    for(su=s;0<n;++su,--n) 
09D5C:  MOVFF  3AF,3B5
09D60:  MOVFF  3AE,3B4
09D64:  MOVLB  3
09D66:  MOVF   xB2,F
09D68:  BNZ   9D70
09D6A:  MOVF   xB1,W
09D6C:  SUBLW  00
09D6E:  BC    9D9C
....................       if(*su==uc) 
09D70:  MOVFF  3B5,03
09D74:  MOVFF  3B4,FE9
09D78:  MOVFF  3B5,FEA
09D7C:  MOVF   xB3,W
09D7E:  SUBWF  FEF,W
09D80:  BNZ   9D8C
....................       return su; 
09D82:  MOVFF  3B4,01
09D86:  MOVFF  3B5,02
09D8A:  BRA    9DA2
09D8C:  INCF   xB4,F
09D8E:  BTFSC  FD8.2
09D90:  INCF   xB5,F
09D92:  MOVF   xB1,W
09D94:  BTFSC  FD8.2
09D96:  DECF   xB2,F
09D98:  DECF   xB1,F
09D9A:  BRA    9D66
....................    return NULL; 
09D9C:  MOVLW  00
09D9E:  MOVWF  01
09DA0:  MOVWF  02
09DA2:  MOVLB  0
09DA4:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09B72:  MOVFF  36C,370
09B76:  MOVFF  36B,36F
09B7A:  MOVFF  370,03
09B7E:  MOVLB  3
09B80:  MOVFF  36F,FE9
09B84:  MOVFF  370,FEA
09B88:  MOVF   FEF,F
09B8A:  BZ    9BE0
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
09B8C:  MOVFF  36E,372
09B90:  MOVFF  36D,371
09B94:  MOVFF  372,03
09B98:  MOVFF  371,FE9
09B9C:  MOVFF  372,FEA
09BA0:  MOVF   FEF,F
09BA2:  BZ    9BD4
....................          if (*sc1 == *sc2) 
09BA4:  MOVFF  36F,FE9
09BA8:  MOVFF  370,FEA
09BAC:  MOVFF  FEF,373
09BB0:  MOVFF  372,03
09BB4:  MOVFF  371,FE9
09BB8:  MOVFF  372,FEA
09BBC:  MOVF   FEF,W
09BBE:  SUBWF  x73,W
09BC0:  BNZ   9BCC
....................             return(sc1); 
09BC2:  MOVFF  36F,01
09BC6:  MOVFF  370,02
09BCA:  BRA    9BE6
09BCC:  INCF   x71,F
09BCE:  BTFSC  FD8.2
09BD0:  INCF   x72,F
09BD2:  BRA    9B94
09BD4:  INCF   x6F,F
09BD6:  BTFSC  FD8.2
09BD8:  INCF   x70,F
09BDA:  MOVLB  0
09BDC:  BRA    9B7A
09BDE:  MOVLB  3
....................    return(0); 
09BE0:  MOVLW  00
09BE2:  MOVWF  01
09BE4:  MOVWF  02
09BE6:  MOVLB  0
09BE8:  GOTO   9C8E (RETURN)
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09AE2:  MOVFF  36C,370
09AE6:  MOVFF  36B,36F
09AEA:  MOVFF  370,03
09AEE:  MOVLB  3
09AF0:  MOVFF  36F,FE9
09AF4:  MOVFF  370,FEA
09AF8:  MOVF   FEF,F
09AFA:  BZ    9B5C
....................       for (sc2 = s2; ; sc2++) 
09AFC:  MOVFF  36E,372
09B00:  MOVFF  36D,371
....................     if (*sc2 == '\0') 
09B04:  MOVFF  372,03
09B08:  MOVFF  371,FE9
09B0C:  MOVFF  372,FEA
09B10:  MOVF   FEF,F
09B12:  BNZ   9B28
....................        return(sc1 - s1); 
09B14:  MOVF   x6B,W
09B16:  SUBWF  x6F,W
09B18:  MOVWF  00
09B1A:  MOVF   x6C,W
09B1C:  SUBWFB x70,W
09B1E:  MOVWF  03
09B20:  MOVFF  00,01
09B24:  BRA    9B6C
09B26:  BRA    9B48
....................          else if (*sc1 == *sc2) 
09B28:  MOVFF  36F,FE9
09B2C:  MOVFF  370,FEA
09B30:  MOVFF  FEF,373
09B34:  MOVFF  372,03
09B38:  MOVFF  371,FE9
09B3C:  MOVFF  372,FEA
09B40:  MOVF   FEF,W
09B42:  SUBWF  x73,W
09B44:  BNZ   9B48
....................             break; 
09B46:  BRA    9B50
09B48:  INCF   x71,F
09B4A:  BTFSC  FD8.2
09B4C:  INCF   x72,F
09B4E:  BRA    9B04
09B50:  INCF   x6F,F
09B52:  BTFSC  FD8.2
09B54:  INCF   x70,F
09B56:  MOVLB  0
09B58:  BRA    9AEA
09B5A:  MOVLB  3
....................    return(sc1 - s1); 
09B5C:  MOVF   x6B,W
09B5E:  SUBWF  x6F,W
09B60:  MOVWF  00
09B62:  MOVF   x6C,W
09B64:  SUBWFB x70,W
09B66:  MOVWF  03
09B68:  MOVFF  00,01
09B6C:  MOVLB  0
09B6E:  GOTO   9C58 (RETURN)
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
09BEC:  MOVFF  393,395
09BF0:  MOVFF  392,394
09BF4:  MOVFF  395,03
09BF8:  MOVLB  3
09BFA:  MOVFF  394,FE9
09BFE:  MOVFF  395,FEA
09C02:  MOVF   FEF,F
09C04:  BZ    9C12
09C06:  INCF   x94,F
09C08:  BTFSC  FD8.2
09C0A:  INCF   x95,F
09C0C:  MOVLB  0
09C0E:  BRA    9BF4
09C10:  MOVLB  3
....................    return(sc - s); 
09C12:  MOVF   x92,W
09C14:  SUBWF  x94,W
09C16:  MOVWF  00
09C18:  MOVF   x93,W
09C1A:  SUBWFB x95,W
09C1C:  MOVWF  03
09C1E:  MOVFF  00,01
09C22:  MOVWF  02
09C24:  MOVLB  0
09C26:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
09C28:  MOVLB  3
09C2A:  MOVF   x63,W
09C2C:  IORWF  x64,W
09C2E:  BZ    9C38
09C30:  MOVFF  364,03
09C34:  MOVF   x63,W
09C36:  BRA    9C3E
09C38:  MOVFF  4B,03
09C3C:  MOVF   4A,W
09C3E:  MOVWF  x67
09C40:  MOVFF  03,368
....................    beg += strspn(beg, s2); 
09C44:  MOVFF  368,36C
09C48:  MOVFF  367,36B
09C4C:  MOVFF  366,36E
09C50:  MOVFF  365,36D
09C54:  MOVLB  0
09C56:  BRA    9AE2
09C58:  MOVF   01,W
09C5A:  MOVLB  3
09C5C:  ADDWF  x67,F
09C5E:  MOVLW  00
09C60:  ADDWFC x68,F
....................    if (*beg == '\0') 
09C62:  MOVFF  368,03
09C66:  MOVFF  367,FE9
09C6A:  MOVFF  368,FEA
09C6E:  MOVF   FEF,F
09C70:  BNZ   9C7A
....................       return(0); 
09C72:  MOVLW  00
09C74:  MOVWF  01
09C76:  MOVWF  02
09C78:  BRA    9CDC
....................        
....................    end = strpbrk(beg, s2); 
09C7A:  MOVFF  368,36C
09C7E:  MOVFF  367,36B
09C82:  MOVFF  366,36E
09C86:  MOVFF  365,36D
09C8A:  MOVLB  0
09C8C:  BRA    9B72
09C8E:  MOVFF  02,36A
09C92:  MOVFF  01,369
....................    if (end != '\0') 
09C96:  MOVLB  3
09C98:  MOVF   x69,F
09C9A:  BNZ   9CA0
09C9C:  MOVF   x6A,F
09C9E:  BZ    9CBA
....................    { 
....................       *end = '\0'; 
09CA0:  MOVFF  369,FE9
09CA4:  MOVFF  36A,FEA
09CA8:  CLRF   FEF
....................       end++; 
09CAA:  INCF   x69,F
09CAC:  BTFSC  FD8.2
09CAE:  INCF   x6A,F
....................       save = end; 
09CB0:  MOVFF  36A,4B
09CB4:  MOVFF  369,4A
....................    } 
09CB8:  BRA    9CD4
....................    else 
....................       save = beg + strlen(beg); 
09CBA:  MOVFF  368,393
09CBE:  MOVFF  367,392
09CC2:  MOVLB  0
09CC4:  RCALL  9BEC
09CC6:  MOVF   01,W
09CC8:  MOVLB  3
09CCA:  ADDWF  x67,W
09CCC:  MOVWF  4A
09CCE:  MOVF   02,W
09CD0:  ADDWFC x68,W
09CD2:  MOVWF  4B
....................     
....................    return(beg); 
09CD4:  MOVFF  367,01
09CD8:  MOVFF  368,02
09CDC:  MOVLB  0
09CDE:  RETURN 0
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
*
0A33C:  MOVLB  3
0A33E:  MOVFF  37A,FE9
0A342:  MOVFF  37B,FEA
0A346:  MOVFF  FEF,37E
0A34A:  MOVFF  37D,03
0A34E:  MOVFF  37C,FE9
0A352:  MOVFF  37D,FEA
0A356:  MOVF   FEF,W
0A358:  SUBWF  x7E,W
0A35A:  BZ    A3EC
0A35C:  MOVFF  37B,03
0A360:  MOVFF  37A,FE9
0A364:  MOVFF  37B,FEA
0A368:  MOVFF  FEF,37E
0A36C:  MOVF   x7E,W
0A36E:  SUBLW  40
0A370:  BC    A378
0A372:  MOVF   x7E,W
0A374:  SUBLW  5A
0A376:  BC    A384
0A378:  MOVF   x7E,W
0A37A:  SUBLW  60
0A37C:  BC    A416
0A37E:  MOVF   x7E,W
0A380:  SUBLW  7A
0A382:  BNC   A416
0A384:  MOVFF  37D,03
0A388:  MOVFF  37C,FE9
0A38C:  MOVFF  37D,FEA
0A390:  MOVFF  FEF,37E
0A394:  MOVF   x7E,W
0A396:  SUBLW  40
0A398:  BC    A3A0
0A39A:  MOVF   x7E,W
0A39C:  SUBLW  5A
0A39E:  BC    A3AC
0A3A0:  MOVF   x7E,W
0A3A2:  SUBLW  60
0A3A4:  BC    A416
0A3A6:  MOVF   x7E,W
0A3A8:  SUBLW  7A
0A3AA:  BNC   A416
0A3AC:  MOVFF  37A,FE9
0A3B0:  MOVFF  37B,FEA
0A3B4:  MOVFF  FEF,37E
0A3B8:  MOVFF  37D,03
0A3BC:  MOVFF  37C,FE9
0A3C0:  MOVFF  37D,FEA
0A3C4:  MOVLW  20
0A3C6:  ADDWF  FEF,W
0A3C8:  SUBWF  x7E,W
0A3CA:  BZ    A3EC
0A3CC:  MOVFF  37C,FE9
0A3D0:  MOVFF  37D,FEA
0A3D4:  MOVFF  FEF,37E
0A3D8:  MOVFF  37B,03
0A3DC:  MOVFF  37A,FE9
0A3E0:  MOVFF  37B,FEA
0A3E4:  MOVLW  20
0A3E6:  ADDWF  FEF,W
0A3E8:  SUBWF  x7E,W
0A3EA:  BNZ   A416
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
0A3EC:  MOVFF  37B,03
0A3F0:  MOVFF  37A,FE9
0A3F4:  MOVFF  37B,FEA
0A3F8:  MOVF   FEF,F
0A3FA:  BNZ   A402
....................        return(0); 
0A3FC:  MOVLW  00
0A3FE:  MOVWF  01
0A400:  BRA    A440
0A402:  MOVFF  37B,03
0A406:  MOVF   x7A,W
0A408:  INCF   x7A,F
0A40A:  BTFSC  FD8.2
0A40C:  INCF   x7B,F
0A40E:  INCF   x7C,F
0A410:  BTFSC  FD8.2
0A412:  INCF   x7D,F
0A414:  BRA    A33E
....................  return((*s1 < *s2) ? -1: 1); 
0A416:  MOVFF  37B,03
0A41A:  MOVFF  37A,FE9
0A41E:  MOVFF  37B,FEA
0A422:  MOVFF  FEF,37E
0A426:  MOVFF  37D,03
0A42A:  MOVFF  37C,FE9
0A42E:  MOVFF  37D,FEA
0A432:  MOVF   FEF,W
0A434:  SUBWF  x7E,W
0A436:  BC    A43C
0A438:  MOVLW  FF
0A43A:  BRA    A43E
0A43C:  MOVLW  01
0A43E:  MOVWF  01
0A440:  MOVLB  0
0A442:  RETURN 0
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A724:  MOVLB  3
0A726:  CLRF   x67
....................    sign = 0; 
0A728:  CLRF   x65
....................    base = 10; 
0A72A:  MOVLW  0A
0A72C:  MOVWF  x66
....................    result = 0; 
0A72E:  CLRF   x64
0A730:  CLRF   x63
....................  
....................    if (!s) 
0A732:  MOVF   x61,W
0A734:  IORWF  x62,W
0A736:  BNZ   A740
....................       return 0; 
0A738:  MOVLW  00
0A73A:  MOVWF  01
0A73C:  MOVWF  02
0A73E:  BRA    A906
....................    c = s[index++]; 
0A740:  MOVF   x67,W
0A742:  INCF   x67,F
0A744:  ADDWF  x61,W
0A746:  MOVWF  FE9
0A748:  MOVLW  00
0A74A:  ADDWFC x62,W
0A74C:  MOVWF  FEA
0A74E:  MOVFF  FEF,368
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A752:  MOVF   x68,W
0A754:  SUBLW  2D
0A756:  BNZ   A770
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A758:  MOVLW  01
0A75A:  MOVWF  x65
....................       c = s[index++]; 
0A75C:  MOVF   x67,W
0A75E:  INCF   x67,F
0A760:  ADDWF  x61,W
0A762:  MOVWF  FE9
0A764:  MOVLW  00
0A766:  ADDWFC x62,W
0A768:  MOVWF  FEA
0A76A:  MOVFF  FEF,368
....................    } 
0A76E:  BRA    A788
....................    else if (c == '+') 
0A770:  MOVF   x68,W
0A772:  SUBLW  2B
0A774:  BNZ   A788
....................    { 
....................       c = s[index++]; 
0A776:  MOVF   x67,W
0A778:  INCF   x67,F
0A77A:  ADDWF  x61,W
0A77C:  MOVWF  FE9
0A77E:  MOVLW  00
0A780:  ADDWFC x62,W
0A782:  MOVWF  FEA
0A784:  MOVFF  FEF,368
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0A788:  MOVF   x68,W
0A78A:  SUBLW  2F
0A78C:  BTFSC  FD8.0
0A78E:  BRA    A8EA
0A790:  MOVF   x68,W
0A792:  SUBLW  39
0A794:  BTFSS  FD8.0
0A796:  BRA    A8EA
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0A798:  MOVF   x68,W
0A79A:  SUBLW  30
0A79C:  BNZ   A7DA
0A79E:  MOVF   x67,W
0A7A0:  ADDWF  x61,W
0A7A2:  MOVWF  FE9
0A7A4:  MOVLW  00
0A7A6:  ADDWFC x62,W
0A7A8:  MOVWF  FEA
0A7AA:  MOVF   FEF,W
0A7AC:  SUBLW  78
0A7AE:  BZ    A7C2
0A7B0:  MOVF   x67,W
0A7B2:  ADDWF  x61,W
0A7B4:  MOVWF  FE9
0A7B6:  MOVLW  00
0A7B8:  ADDWFC x62,W
0A7BA:  MOVWF  FEA
0A7BC:  MOVF   FEF,W
0A7BE:  SUBLW  58
0A7C0:  BNZ   A7DA
....................       { 
....................          base = 16; 
0A7C2:  MOVLW  10
0A7C4:  MOVWF  x66
....................          index++; 
0A7C6:  INCF   x67,F
....................          c = s[index++]; 
0A7C8:  MOVF   x67,W
0A7CA:  INCF   x67,F
0A7CC:  ADDWF  x61,W
0A7CE:  MOVWF  FE9
0A7D0:  MOVLW  00
0A7D2:  ADDWFC x62,W
0A7D4:  MOVWF  FEA
0A7D6:  MOVFF  FEF,368
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0A7DA:  MOVF   x66,W
0A7DC:  SUBLW  0A
0A7DE:  BNZ   A826
....................       { 
....................          while (c >= '0' && c <= '9') 
0A7E0:  MOVF   x68,W
0A7E2:  SUBLW  2F
0A7E4:  BC    A824
0A7E6:  MOVF   x68,W
0A7E8:  SUBLW  39
0A7EA:  BNC   A824
....................          { 
....................             result = 10*result + (c - '0'); 
0A7EC:  CLRF   xB0
0A7EE:  MOVLW  0A
0A7F0:  MOVWF  xAF
0A7F2:  MOVFF  364,3B2
0A7F6:  MOVFF  363,3B1
0A7FA:  MOVLB  0
0A7FC:  CALL   9DA6
0A800:  MOVLW  30
0A802:  MOVLB  3
0A804:  SUBWF  x68,W
0A806:  ADDWF  01,W
0A808:  MOVWF  x63
0A80A:  MOVLW  00
0A80C:  ADDWFC 02,W
0A80E:  MOVWF  x64
....................             c = s[index++]; 
0A810:  MOVF   x67,W
0A812:  INCF   x67,F
0A814:  ADDWF  x61,W
0A816:  MOVWF  FE9
0A818:  MOVLW  00
0A81A:  ADDWFC x62,W
0A81C:  MOVWF  FEA
0A81E:  MOVFF  FEF,368
0A822:  BRA    A7E0
....................          } 
....................       } 
0A824:  BRA    A8EA
....................       else if (base == 16)    // The number is a hexa number 
0A826:  MOVF   x66,W
0A828:  SUBLW  10
0A82A:  BNZ   A8EA
....................       { 
....................          c = toupper(c); 
0A82C:  MOVF   x68,W
0A82E:  SUBLW  60
0A830:  BC    A83E
0A832:  MOVF   x68,W
0A834:  SUBLW  7A
0A836:  BNC   A83E
0A838:  MOVF   x68,W
0A83A:  ANDLW  DF
0A83C:  BRA    A840
0A83E:  MOVF   x68,W
0A840:  MOVWF  x68
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
0A842:  MOVF   x68,W
0A844:  SUBLW  2F
0A846:  BC    A84E
0A848:  MOVF   x68,W
0A84A:  SUBLW  39
0A84C:  BC    A85A
0A84E:  MOVF   x68,W
0A850:  SUBLW  40
0A852:  BC    A8EA
0A854:  MOVF   x68,W
0A856:  SUBLW  46
0A858:  BNC   A8EA
....................          { 
....................             if (c >= '0' && c <= '9') 
0A85A:  MOVF   x68,W
0A85C:  SUBLW  2F
0A85E:  BC    A894
0A860:  MOVF   x68,W
0A862:  SUBLW  39
0A864:  BNC   A894
....................                result = (result << 4) + (c - '0'); 
0A866:  RLCF   x63,W
0A868:  MOVWF  x69
0A86A:  RLCF   x64,W
0A86C:  MOVWF  x6A
0A86E:  RLCF   x69,F
0A870:  RLCF   x6A,F
0A872:  RLCF   x69,F
0A874:  RLCF   x6A,F
0A876:  RLCF   x69,F
0A878:  RLCF   x6A,F
0A87A:  MOVLW  F0
0A87C:  ANDWF  x69,F
0A87E:  MOVLW  30
0A880:  SUBWF  x68,W
0A882:  ADDWF  x69,W
0A884:  MOVWF  01
0A886:  MOVLW  00
0A888:  ADDWFC x6A,W
0A88A:  MOVWF  03
0A88C:  MOVFF  01,363
0A890:  MOVWF  x64
0A892:  BRA    A8C0
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0A894:  RLCF   x63,W
0A896:  MOVWF  x69
0A898:  RLCF   x64,W
0A89A:  MOVWF  x6A
0A89C:  RLCF   x69,F
0A89E:  RLCF   x6A,F
0A8A0:  RLCF   x69,F
0A8A2:  RLCF   x6A,F
0A8A4:  RLCF   x69,F
0A8A6:  RLCF   x6A,F
0A8A8:  MOVLW  F0
0A8AA:  ANDWF  x69,F
0A8AC:  MOVLW  41
0A8AE:  SUBWF  x68,W
0A8B0:  ADDLW  0A
0A8B2:  ADDWF  x69,W
0A8B4:  MOVWF  01
0A8B6:  MOVLW  00
0A8B8:  ADDWFC x6A,W
0A8BA:  MOVFF  01,363
0A8BE:  MOVWF  x64
....................  
....................             c = s[index++];c = toupper(c); 
0A8C0:  MOVF   x67,W
0A8C2:  INCF   x67,F
0A8C4:  ADDWF  x61,W
0A8C6:  MOVWF  FE9
0A8C8:  MOVLW  00
0A8CA:  ADDWFC x62,W
0A8CC:  MOVWF  FEA
0A8CE:  MOVFF  FEF,368
0A8D2:  MOVF   x68,W
0A8D4:  SUBLW  60
0A8D6:  BC    A8E4
0A8D8:  MOVF   x68,W
0A8DA:  SUBLW  7A
0A8DC:  BNC   A8E4
0A8DE:  MOVF   x68,W
0A8E0:  ANDLW  DF
0A8E2:  BRA    A8E6
0A8E4:  MOVF   x68,W
0A8E6:  MOVWF  x68
0A8E8:  BRA    A842
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0A8EA:  MOVF   x66,W
0A8EC:  SUBLW  0A
0A8EE:  BNZ   A8FE
0A8F0:  DECFSZ x65,W
0A8F2:  BRA    A8FE
....................       result = -result; 
0A8F4:  COMF   x63,F
0A8F6:  COMF   x64,F
0A8F8:  INCF   x63,F
0A8FA:  BTFSC  FD8.2
0A8FC:  INCF   x64,F
....................  
....................    return(result); 
0A8FE:  MOVFF  363,01
0A902:  MOVFF  364,02
0A906:  MOVLB  0
0A908:  GOTO   BF84 (RETURN)
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
09DFA:  MOVLB  3
09DFC:  CLRF   x87
09DFE:  CLRF   x86
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
09E00:  MOVLW  30
09E02:  MOVWF  x89
09E04:  MOVLW  31
09E06:  MOVWF  x8A
09E08:  MOVLW  32
09E0A:  MOVWF  x8B
09E0C:  MOVLW  33
09E0E:  MOVWF  x8C
09E10:  MOVLW  34
09E12:  MOVWF  x8D
09E14:  MOVLW  35
09E16:  MOVWF  x8E
09E18:  MOVLW  36
09E1A:  MOVWF  x8F
09E1C:  MOVLW  37
09E1E:  MOVWF  x90
09E20:  MOVLW  38
09E22:  MOVWF  x91
09E24:  MOVLW  39
09E26:  MOVWF  x92
09E28:  MOVLW  61
09E2A:  MOVWF  x93
09E2C:  MOVLW  62
09E2E:  MOVWF  x94
09E30:  MOVLW  63
09E32:  MOVWF  x95
09E34:  MOVLW  64
09E36:  MOVWF  x96
09E38:  MOVLW  65
09E3A:  MOVWF  x97
09E3C:  MOVLW  66
09E3E:  MOVWF  x98
09E40:  MOVLW  67
09E42:  MOVWF  x99
09E44:  MOVLW  68
09E46:  MOVWF  x9A
09E48:  MOVLW  69
09E4A:  MOVWF  x9B
09E4C:  MOVLW  6A
09E4E:  MOVWF  x9C
09E50:  MOVLW  6B
09E52:  MOVWF  x9D
09E54:  MOVLW  6C
09E56:  MOVWF  x9E
09E58:  MOVLW  6D
09E5A:  MOVWF  x9F
09E5C:  MOVLW  6E
09E5E:  MOVWF  xA0
09E60:  MOVLW  6F
09E62:  MOVWF  xA1
09E64:  MOVLW  70
09E66:  MOVWF  xA2
09E68:  MOVLW  71
09E6A:  MOVWF  xA3
09E6C:  MOVLW  73
09E6E:  MOVWF  xA4
09E70:  MOVLW  74
09E72:  MOVWF  xA5
09E74:  MOVLW  75
09E76:  MOVWF  xA6
09E78:  MOVLW  76
09E7A:  MOVWF  xA7
09E7C:  MOVLW  77
09E7E:  MOVWF  xA8
09E80:  MOVLW  78
09E82:  MOVWF  xA9
09E84:  MOVLW  79
09E86:  MOVWF  xAA
09E88:  MOVLW  7A
09E8A:  MOVWF  xAB
09E8C:  CLRF   xAC
....................    for(sc=s;isspace(*sc);++sc); 
09E8E:  MOVFF  37C,381
09E92:  MOVFF  37B,380
09E96:  MOVFF  381,03
09E9A:  MOVFF  380,FE9
09E9E:  MOVFF  381,FEA
09EA2:  MOVF   FEF,W
09EA4:  SUBLW  20
09EA6:  BNZ   9EB0
09EA8:  INCF   x80,F
09EAA:  BTFSC  FD8.2
09EAC:  INCF   x81,F
09EAE:  BRA    9E96
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
09EB0:  MOVFF  381,03
09EB4:  MOVFF  380,FE9
09EB8:  MOVFF  381,FEA
09EBC:  MOVF   FEF,W
09EBE:  SUBLW  2D
09EC0:  BZ    9ED4
09EC2:  MOVFF  381,03
09EC6:  MOVFF  380,FE9
09ECA:  MOVFF  381,FEA
09ECE:  MOVF   FEF,W
09ED0:  SUBLW  2B
09ED2:  BNZ   9EEA
09ED4:  MOVFF  381,03
09ED8:  MOVF   x80,W
09EDA:  INCF   x80,F
09EDC:  BTFSC  FD8.2
09EDE:  INCF   x81,F
09EE0:  MOVWF  FE9
09EE2:  MOVFF  03,FEA
09EE6:  MOVF   FEF,W
09EE8:  BRA    9EEC
09EEA:  MOVLW  2B
09EEC:  MOVWF  x88
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
09EEE:  MOVF   x88,W
09EF0:  SUBLW  2D
09EF2:  BZ    9F08
09EF4:  BTFSC  x7F.7
09EF6:  BRA    9F08
09EF8:  DECFSZ x7F,W
09EFA:  BRA    9EFE
09EFC:  BRA    9F08
09EFE:  BTFSC  x7F.7
09F00:  BRA    9F0C
09F02:  MOVF   x7F,W
09F04:  SUBLW  24
09F06:  BC    9F0C
....................    goto StrtoulGO; 
09F08:  BRA    A124
09F0A:  BRA    A014
....................  
....................    else if (base) 
09F0C:  MOVF   x7F,F
09F0E:  BZ    9FA8
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
09F10:  MOVF   x7F,W
09F12:  SUBLW  10
09F14:  BNZ   9F54
09F16:  MOVFF  381,03
09F1A:  MOVFF  380,FE9
09F1E:  MOVFF  381,FEA
09F22:  MOVF   FEF,W
09F24:  SUBLW  30
09F26:  BNZ   9F54
09F28:  MOVLW  01
09F2A:  ADDWF  x80,W
09F2C:  MOVWF  FE9
09F2E:  MOVLW  00
09F30:  ADDWFC x81,W
09F32:  MOVWF  FEA
09F34:  MOVF   FEF,W
09F36:  SUBLW  78
09F38:  BZ    9F4C
09F3A:  MOVLW  01
09F3C:  ADDWF  x80,W
09F3E:  MOVWF  FE9
09F40:  MOVLW  00
09F42:  ADDWFC x81,W
09F44:  MOVWF  FEA
09F46:  MOVF   FEF,W
09F48:  SUBLW  58
09F4A:  BNZ   9F54
....................          sc+=2; 
09F4C:  MOVLW  02
09F4E:  ADDWF  x80,F
09F50:  MOVLW  00
09F52:  ADDWFC x81,F
....................       if(base==8 && *sc =='0') 
09F54:  MOVF   x7F,W
09F56:  SUBLW  08
09F58:  BNZ   9F74
09F5A:  MOVFF  381,03
09F5E:  MOVFF  380,FE9
09F62:  MOVFF  381,FEA
09F66:  MOVF   FEF,W
09F68:  SUBLW  30
09F6A:  BNZ   9F74
....................          sc+=1; 
09F6C:  MOVLW  01
09F6E:  ADDWF  x80,F
09F70:  MOVLW  00
09F72:  ADDWFC x81,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
09F74:  MOVF   x7F,W
09F76:  SUBLW  02
09F78:  BNZ   9FA6
09F7A:  MOVFF  381,03
09F7E:  MOVFF  380,FE9
09F82:  MOVFF  381,FEA
09F86:  MOVF   FEF,W
09F88:  SUBLW  30
09F8A:  BNZ   9FA6
09F8C:  MOVLW  01
09F8E:  ADDWF  x80,W
09F90:  MOVWF  FE9
09F92:  MOVLW  00
09F94:  ADDWFC x81,W
09F96:  MOVWF  FEA
09F98:  MOVF   FEF,W
09F9A:  SUBLW  62
09F9C:  BNZ   9FA6
....................          sc+=2; 
09F9E:  MOVLW  02
09FA0:  ADDWF  x80,F
09FA2:  MOVLW  00
09FA4:  ADDWFC x81,F
....................  
....................    } 
09FA6:  BRA    A014
....................    else if(*sc!='0') // base is 0, find base 
09FA8:  MOVFF  381,03
09FAC:  MOVFF  380,FE9
09FB0:  MOVFF  381,FEA
09FB4:  MOVF   FEF,W
09FB6:  SUBLW  30
09FB8:  BZ    9FC0
....................       base=10; 
09FBA:  MOVLW  0A
09FBC:  MOVWF  x7F
09FBE:  BRA    A014
....................    else if (sc[1]=='x' || sc[1]=='X') 
09FC0:  MOVLW  01
09FC2:  ADDWF  x80,W
09FC4:  MOVWF  FE9
09FC6:  MOVLW  00
09FC8:  ADDWFC x81,W
09FCA:  MOVWF  FEA
09FCC:  MOVF   FEF,W
09FCE:  SUBLW  78
09FD0:  BZ    9FE4
09FD2:  MOVLW  01
09FD4:  ADDWF  x80,W
09FD6:  MOVWF  FE9
09FD8:  MOVLW  00
09FDA:  ADDWFC x81,W
09FDC:  MOVWF  FEA
09FDE:  MOVF   FEF,W
09FE0:  SUBLW  58
09FE2:  BNZ   9FF2
....................       base =16,sc+=2; 
09FE4:  MOVLW  10
09FE6:  MOVWF  x7F
09FE8:  MOVLW  02
09FEA:  ADDWF  x80,F
09FEC:  MOVLW  00
09FEE:  ADDWFC x81,F
09FF0:  BRA    A014
....................    else if(sc[1]=='b') 
09FF2:  MOVLW  01
09FF4:  ADDWF  x80,W
09FF6:  MOVWF  FE9
09FF8:  MOVLW  00
09FFA:  ADDWFC x81,W
09FFC:  MOVWF  FEA
09FFE:  MOVF   FEF,W
0A000:  SUBLW  62
0A002:  BNZ   A010
....................       base=2,sc+=2; 
0A004:  MOVLW  02
0A006:  MOVWF  x7F
0A008:  ADDWF  x80,F
0A00A:  MOVLW  00
0A00C:  ADDWFC x81,F
0A00E:  BRA    A014
....................    else 
....................       base=8; 
0A010:  MOVLW  08
0A012:  MOVWF  x7F
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
0A014:  MOVFF  381,383
0A018:  MOVFF  380,382
0A01C:  MOVFF  381,03
0A020:  MOVFF  380,FE9
0A024:  MOVFF  381,FEA
0A028:  MOVF   FEF,W
0A02A:  SUBLW  30
0A02C:  BNZ   A036
0A02E:  INCF   x80,F
0A030:  BTFSC  FD8.2
0A032:  INCF   x81,F
0A034:  BRA    A01C
....................    sd=memchr(digits,tolower(*sc),base); 
0A036:  MOVFF  381,03
0A03A:  MOVFF  380,FE9
0A03E:  MOVFF  381,FEA
0A042:  MOVFF  FEF,3AD
0A046:  MOVF   xAD,W
0A048:  SUBLW  40
0A04A:  BC    A058
0A04C:  MOVF   xAD,W
0A04E:  SUBLW  5A
0A050:  BNC   A058
0A052:  MOVF   xAD,W
0A054:  IORLW  20
0A056:  BRA    A05A
0A058:  MOVF   xAD,W
0A05A:  MOVWF  xAD
0A05C:  MOVLW  03
0A05E:  MOVWF  xAF
0A060:  MOVLW  89
0A062:  MOVWF  xAE
0A064:  MOVFF  3AD,3B0
0A068:  CLRF   xB2
0A06A:  MOVFF  37F,3B1
0A06E:  MOVLB  0
0A070:  RCALL  9D58
0A072:  MOVFF  02,385
0A076:  MOVFF  01,384
....................    for(; sd!=0; ) 
0A07A:  MOVLB  3
0A07C:  MOVF   x84,F
0A07E:  BNZ   A084
0A080:  MOVF   x85,F
0A082:  BZ    A118
....................    { 
....................       x=x*base+(int16)(sd-digits); 
0A084:  CLRF   03
0A086:  MOVF   x7F,W
0A088:  MOVWF  00
0A08A:  BTFSC  FE8.7
0A08C:  DECF   03,F
0A08E:  MOVWF  xAD
0A090:  MOVFF  03,3AE
0A094:  MOVFF  387,3B0
0A098:  MOVFF  386,3AF
0A09C:  MOVFF  03,3B2
0A0A0:  MOVWF  xB1
0A0A2:  MOVLB  0
0A0A4:  RCALL  9DA6
0A0A6:  MOVFF  01,3AD
0A0AA:  MOVLW  89
0A0AC:  MOVLB  3
0A0AE:  SUBWF  x84,W
0A0B0:  MOVWF  00
0A0B2:  MOVLW  03
0A0B4:  SUBWFB x85,W
0A0B6:  MOVWF  03
0A0B8:  MOVF   00,W
0A0BA:  ADDWF  01,W
0A0BC:  MOVWF  01
0A0BE:  MOVF   02,W
0A0C0:  ADDWFC 03,F
0A0C2:  MOVFF  01,386
0A0C6:  MOVFF  03,387
....................       ++sc; 
0A0CA:  INCF   x80,F
0A0CC:  BTFSC  FD8.2
0A0CE:  INCF   x81,F
....................       sd=memchr(digits,tolower(*sc),base); 
0A0D0:  MOVFF  381,03
0A0D4:  MOVFF  380,FE9
0A0D8:  MOVFF  381,FEA
0A0DC:  MOVFF  FEF,3AD
0A0E0:  MOVF   xAD,W
0A0E2:  SUBLW  40
0A0E4:  BC    A0F2
0A0E6:  MOVF   xAD,W
0A0E8:  SUBLW  5A
0A0EA:  BNC   A0F2
0A0EC:  MOVF   xAD,W
0A0EE:  IORLW  20
0A0F0:  BRA    A0F4
0A0F2:  MOVF   xAD,W
0A0F4:  MOVWF  xAD
0A0F6:  MOVLW  03
0A0F8:  MOVWF  xAF
0A0FA:  MOVLW  89
0A0FC:  MOVWF  xAE
0A0FE:  MOVFF  3AD,3B0
0A102:  CLRF   xB2
0A104:  MOVFF  37F,3B1
0A108:  MOVLB  0
0A10A:  RCALL  9D58
0A10C:  MOVFF  02,385
0A110:  MOVFF  01,384
0A114:  BRA    A07A
0A116:  MOVLB  3
....................    } 
....................    if(s1==sc) 
0A118:  MOVF   x80,W
0A11A:  SUBWF  x82,W
0A11C:  BNZ   A144
0A11E:  MOVF   x81,W
0A120:  SUBWF  x83,W
0A122:  BNZ   A144
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
0A124:  MOVF   x7D,W
0A126:  IORWF  x7E,W
0A128:  BZ    A13C
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
0A12A:  MOVFF  37D,FE9
0A12E:  MOVFF  37E,FEA
0A132:  MOVFF  37C,FEC
0A136:  MOVF   FED,F
0A138:  MOVFF  37B,FEF
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
0A13C:  MOVLW  00
0A13E:  MOVWF  01
0A140:  MOVWF  02
0A142:  BRA    A164
....................    } 
....................    if (endptr) 
0A144:  MOVF   x7D,W
0A146:  IORWF  x7E,W
0A148:  BZ    A15C
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
0A14A:  MOVFF  37D,FE9
0A14E:  MOVFF  37E,FEA
0A152:  MOVFF  381,FEC
0A156:  MOVF   FED,F
0A158:  MOVFF  380,FEF
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
0A15C:  MOVFF  386,01
0A160:  MOVFF  387,02
0A164:  MOVLB  0
0A166:  GOTO   A2C0 (RETURN)
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
069A0:  MOVFF  4F,357
069A4:  MOVFF  4E,356
069A8:  MOVFF  4D,355
069AC:  MOVFF  4C,354
069B0:  MOVLW  41
069B2:  MOVLB  3
069B4:  MOVWF  x5B
069B6:  MOVLW  C6
069B8:  MOVWF  x5A
069BA:  MOVLW  4E
069BC:  MOVWF  x59
069BE:  MOVLW  6D
069C0:  MOVWF  x58
069C2:  MOVLB  0
069C4:  BRA    68FA
069C6:  MOVLW  39
069C8:  MOVLB  3
069CA:  ADDWF  00,W
069CC:  MOVWF  4C
069CE:  MOVLW  30
069D0:  ADDWFC 01,W
069D2:  MOVWF  4D
069D4:  MOVLW  00
069D6:  ADDWFC 02,W
069D8:  MOVWF  4E
069DA:  MOVLW  00
069DC:  ADDWFC 03,W
069DE:  MOVWF  4F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
069E0:  MOVFF  4E,00
069E4:  MOVFF  4F,01
069E8:  CLRF   02
069EA:  CLRF   03
069EC:  MOVFF  4F,356
069F0:  MOVFF  4E,355
069F4:  MOVFF  4F,358
069F8:  MOVFF  4E,357
069FC:  MOVLW  7F
069FE:  MOVWF  x5A
06A00:  SETF   x59
06A02:  MOVLB  0
06A04:  BRA    6958
06A06:  MOVFF  00,01
06A0A:  MOVFF  03,02
06A0E:  GOTO   6B1E (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
068E6:  MOVFF  357,4F
068EA:  MOVFF  356,4E
068EE:  MOVFF  355,4D
068F2:  MOVFF  354,4C
068F6:  GOTO   6B1C (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and 
....................  *                        btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *                  'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:         None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
06D9E:  MOVFF  400,401
....................     new.v[1]=v.v[0]; 
06DA2:  MOVFF  3FF,402
....................  
....................     return(new.Val); 
06DA6:  MOVLB  4
06DA8:  MOVFF  401,01
06DAC:  MOVFF  402,02
06DB0:  MOVLB  0
06DB2:  RETURN 0
.................... } 
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
07C9A:  MOVFF  3EB,3EC
....................     new.v[1]=v.v[2]; 
07C9E:  MOVFF  3EA,3ED
....................     new.v[2]=v.v[1]; 
07CA2:  MOVFF  3E9,3EE
....................     new.v[3]=v.v[0]; 
07CA6:  MOVFF  3E8,3EF
....................  
....................     return(new.Val); 
07CAA:  MOVFF  3EC,00
07CAE:  MOVFF  3ED,01
07CB2:  MOVFF  3EE,02
07CB6:  MOVFF  3EF,03
07CBA:  RETURN 0
.................... } 
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................  
....................    union 
....................    { 
....................       DWORD Val; 
....................       struct 
....................       { 
....................          WORD_VAL LSB; 
....................          WORD_VAL MSB; 
....................       } words; 
....................    } tempSum, sum; 
....................  
....................    sum.Val = 0; 
*
07A0A:  MOVLB  3
07A0C:  CLRF   xF1
07A0E:  CLRF   xF0
07A10:  CLRF   xEF
07A12:  CLRF   xEE
....................  
....................    i = count >> 1; 
07A14:  BCF    FD8.0
07A16:  RRCF   xE5,W
07A18:  MOVWF  xE7
07A1A:  RRCF   xE4,W
07A1C:  MOVWF  xE6
....................    val = (WORD *)buffer; 
07A1E:  MOVFF  3E3,3E9
07A22:  MOVFF  3E2,3E8
....................  
....................    while( i-- ) 
07A26:  MOVFF  3E7,03
07A2A:  MOVF   xE6,W
07A2C:  BTFSC  FD8.2
07A2E:  DECF   xE7,F
07A30:  DECF   xE6,F
07A32:  IORWF  03,W
07A34:  BZ    7A64
....................       sum.Val += *val++; 
07A36:  MOVFF  3E9,03
07A3A:  MOVFF  3E8,00
07A3E:  MOVLW  02
07A40:  ADDWF  xE8,F
07A42:  BTFSC  FD8.0
07A44:  INCF   xE9,F
07A46:  MOVFF  00,FE9
07A4A:  MOVFF  03,FEA
07A4E:  MOVFF  FEC,03
07A52:  MOVF   FED,F
07A54:  MOVF   FEF,W
07A56:  ADDWF  xEE,F
07A58:  MOVF   03,W
07A5A:  ADDWFC xEF,F
07A5C:  MOVLW  00
07A5E:  ADDWFC xF0,F
07A60:  ADDWFC xF1,F
07A62:  BRA    7A26
....................  
....................    if ( count & 1 ) 
07A64:  MOVF   xE4,W
07A66:  ANDLW  01
07A68:  MOVWF  00
07A6A:  CLRF   03
07A6C:  MOVF   00,W
07A6E:  IORWF  03,W
07A70:  BZ    7A86
....................       sum.Val += *(BYTE *)val; 
07A72:  MOVFF  3E8,FE9
07A76:  MOVFF  3E9,FEA
07A7A:  MOVF   FEF,W
07A7C:  ADDWF  xEE,F
07A7E:  MOVLW  00
07A80:  ADDWFC xEF,F
07A82:  ADDWFC xF0,F
07A84:  ADDWFC xF1,F
....................  
....................    tempSum.Val = sum.Val; 
07A86:  MOVFF  3F1,3ED
07A8A:  MOVFF  3F0,3EC
07A8E:  MOVFF  3EF,3EB
07A92:  MOVFF  3EE,3EA
....................  
....................    while( (i = tempSum.words.MSB.Val) != 0u ) 
07A96:  MOVFF  3ED,3E7
07A9A:  MOVFF  3EC,3E6
07A9E:  MOVF   xE6,F
07AA0:  BNZ   7AA6
07AA2:  MOVF   xE7,F
07AA4:  BZ    7AE4
....................    { 
....................       sum.words.MSB.Val = 0; 
07AA6:  CLRF   xF1
07AA8:  CLRF   xF0
....................       sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
07AAA:  CLRF   xF5
07AAC:  CLRF   xF4
07AAE:  MOVFF  3EF,3F3
07AB2:  MOVFF  3EE,3F2
07AB6:  CLRF   02
07AB8:  CLRF   03
07ABA:  MOVF   xE6,W
07ABC:  ADDWF  xEE,W
07ABE:  MOVWF  xEE
07AC0:  MOVF   xE7,W
07AC2:  ADDWFC xEF,W
07AC4:  MOVWF  xEF
07AC6:  MOVF   02,W
07AC8:  ADDWFC xF4,W
07ACA:  MOVWF  xF0
07ACC:  MOVF   03,W
07ACE:  ADDWFC xF5,W
07AD0:  MOVWF  xF1
....................       tempSum.Val = sum.Val; 
07AD2:  MOVFF  3F1,3ED
07AD6:  MOVFF  3F0,3EC
07ADA:  MOVFF  3EF,3EB
07ADE:  MOVFF  3EE,3EA
07AE2:  BRA    7A96
....................    } 
....................  
....................    return (~sum.words.LSB.Val); 
07AE4:  MOVFF  3EF,03
07AE8:  COMF   03,F
07AEA:  MOVF   xEE,W
07AEC:  XORLW  FF
07AEE:  MOVWF  01
07AF0:  MOVFF  03,02
07AF4:  MOVLB  0
07AF6:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
063EC:  MOVLW  83
063EE:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
063F0:  MOVLW  3C
063F2:  MOVWF  FD7
063F4:  MOVLW  AF
063F6:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
063F8:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
063FA:  MOVLW  C0
063FC:  IORWF  FF2,F
063FE:  GOTO   6CBC (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
08078:  BCF    FF2.5
....................     ret=TickCount; 
0807A:  MOVFF  52,3A4
0807E:  MOVFF  51,3A3
....................     enable_interrupts(INT_TIMER0); 
08082:  BSF    FF2.5
....................     return ret; 
08084:  MOVLB  3
08086:  MOVFF  3A3,01
0808A:  MOVFF  3A4,02
0808E:  MOVLB  0
08090:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
000AE:  INCF   51,F
000B0:  BTFSC  FD8.2
000B2:  INCF   52,F
....................  
....................         second_counter_intermediate++; 
000B4:  INCF   54,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
000B6:  MOVF   54,W
000B8:  SUBLW  09
000BA:  BC    00C0
....................             second_counter++; //increment this ever 1s 
000BC:  INCF   53,F
....................             second_counter_intermediate=0; 
000BE:  CLRF   54
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
000C0:  MOVLW  3C
000C2:  MOVWF  FD7
000C4:  MOVLW  AF
000C6:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_D7   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_D6   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_D5 
....................       #define PIN_ENC_MAC_CS  PIN_D4 
....................       #define PIN_ENC_MAC_RST PIN_D3 
....................       #define PIN_ENC_MAC_INT PIN_D2 
....................       #define PIN_ENC_MAC_WOL PIN_D1 
....................       #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       //#define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................       #define mac_enc_spi_tris_init()  *0xF95= (0b10000110); 
....................      #endif 
....................  
.................... #define SPISelectEthernet()      output_low(PIN_ENC_MAC_CS) //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS)   //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define   RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define   WCR (0b010<<5)         // Write Control Register command 
.................... #define BFS (0b100<<5)         // Bit Field Set command 
.................... #define   BFC (0b101<<5)         // Bit Field Clear command 
.................... #define   RCR (0b000<<5)         // Read Control Register command 
.................... #define RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define   WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define   SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
000C8:  BCF    FF2.2
000CA:  GOTO   0060
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................  
....................    #ifdef mac_enc_spi_tris_init 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
....................    #endif 
....................  
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
*
06402:  BCF    FC6.5
06404:  BCF    F94.5
06406:  BSF    F94.4
06408:  BCF    F94.3
0640A:  MOVLW  20
0640C:  MOVWF  FC6
0640E:  MOVLW  40
06410:  MOVWF  FC7
....................  #else 
....................     
....................    output_low(PIN_ENC_MAC_CLK); 
....................    output_float(PIN_ENC_MAC_SO); 
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
06412:  BCF    F93.6
06414:  BSF    F8A.6
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
06416:  BCF    F93.7
06418:  BSF    F8A.7
0641A:  GOTO   66FC (RETURN)
.................... } 
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
0641E:  MOVF   FC9,W
06420:  MOVFF  40A,FC9
06424:  RRCF   FC7,W
06426:  BNC   6424
06428:  MOVFF  FC9,01
....................  #else 
0642C:  RETURN 0
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
....................       output_high(PIN_ENC_MAC_CLK); 
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
....................       output_low(PIN_ENC_MAC_CLK); 
....................    } 
....................    return(in); 
....................  #endif 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
066FA:  BRA    6402
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
066FC:  MOVLW  1D
066FE:  MOVLB  3
06700:  MOVWF  xFF
06702:  MOVLB  0
06704:  RCALL  642E
06706:  MOVFF  01,351
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
0670A:  MOVLB  3
0670C:  BTFSS  x51.3
0670E:  BRA    6714
06710:  MOVLB  0
06712:  BRA    66FC
06714:  MOVF   x51,W
06716:  XORLW  FF
06718:  ANDLW  01
0671A:  BTFSC  FD8.2
0671C:  BRA    6722
0671E:  MOVLB  0
06720:  BRA    66FC
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
06722:  MOVLB  0
06724:  BRA    6458
....................     delay_ms(1); 
06726:  MOVLW  01
06728:  MOVLB  3
0672A:  MOVWF  x52
0672C:  MOVLB  0
0672E:  RCALL  637E
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
06730:  CLRF   50
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
06732:  BSF    59.0
....................    NextPacketLocation.Val = RXSTART; 
06734:  CLRF   56
06736:  CLRF   55
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
06738:  MOVLW  08
0673A:  MOVLB  4
0673C:  MOVWF  x05
0673E:  CLRF   x06
06740:  MOVLB  0
06742:  RCALL  646C
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
06744:  MOVLW  09
06746:  MOVLB  4
06748:  MOVWF  x05
0674A:  CLRF   x06
0674C:  MOVLB  0
0674E:  RCALL  646C
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
06750:  MOVLW  0C
06752:  MOVLB  4
06754:  MOVWF  x05
06756:  MOVLW  F7
06758:  MOVWF  x06
0675A:  MOVLB  0
0675C:  RCALL  646C
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
0675E:  MOVLW  0D
06760:  MOVLB  4
06762:  MOVWF  x05
06764:  MOVLW  1B
06766:  MOVWF  x06
06768:  MOVLB  0
0676A:  RCALL  646C
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
0676C:  MOVLW  0A
0676E:  MOVLB  4
06770:  MOVWF  x05
06772:  MOVLW  F7
06774:  MOVWF  x06
06776:  MOVLB  0
06778:  RCALL  646C
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
0677A:  MOVLW  0B
0677C:  MOVLB  4
0677E:  MOVWF  x05
06780:  MOVLW  1B
06782:  MOVWF  x06
06784:  MOVLB  0
06786:  RCALL  646C
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
06788:  MOVLW  04
0678A:  MOVLB  4
0678C:  MOVWF  x05
0678E:  MOVLW  F8
06790:  MOVWF  x06
06792:  MOVLB  0
06794:  RCALL  646C
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
06796:  MOVLW  05
06798:  MOVLB  4
0679A:  MOVWF  x05
0679C:  MOVLW  1B
0679E:  MOVWF  x06
067A0:  MOVLB  0
067A2:  RCALL  646C
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
067A4:  MOVLW  02
067A6:  MOVLB  4
067A8:  MOVWF  x03
067AA:  CLRF   x02
067AC:  MOVLB  0
067AE:  RCALL  64C6
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
067B0:  MOVLB  4
067B2:  CLRF   x05
067B4:  MOVLW  0D
067B6:  MOVWF  x06
067B8:  MOVLB  0
067BA:  RCALL  646C
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
067BC:  MOVLW  02
067BE:  MOVLB  4
067C0:  MOVWF  x05
067C2:  MOVLW  32
067C4:  MOVWF  x06
067C6:  MOVLB  0
067C8:  RCALL  646C
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
067CA:  MOVLW  03
067CC:  MOVLB  4
067CE:  MOVWF  x05
067D0:  MOVLW  40
067D2:  MOVWF  x06
067D4:  MOVLB  0
067D6:  RCALL  646C
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
067D8:  MOVLW  09
067DA:  MOVLB  4
067DC:  MOVWF  x05
067DE:  MOVLW  3F
067E0:  MOVWF  x06
067E2:  MOVLB  0
067E4:  RCALL  646C
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
067E6:  MOVLW  06
067E8:  MOVLB  4
067EA:  MOVWF  x05
067EC:  MOVLW  12
067EE:  MOVWF  x06
067F0:  MOVLB  0
067F2:  RCALL  646C
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
067F4:  MOVLW  07
067F6:  MOVLB  4
067F8:  MOVWF  x05
067FA:  MOVLW  0C
067FC:  MOVWF  x06
067FE:  MOVLB  0
06800:  RCALL  646C
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
06802:  MOVLW  0A
06804:  MOVLB  4
06806:  MOVWF  x05
06808:  MOVLW  EE
0680A:  MOVWF  x06
0680C:  MOVLB  0
0680E:  RCALL  646C
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
06810:  MOVLW  0B
06812:  MOVLB  4
06814:  MOVWF  x05
06816:  MOVLW  05
06818:  MOVWF  x06
0681A:  MOVLB  0
0681C:  RCALL  646C
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
0681E:  MOVLW  03
06820:  MOVLB  4
06822:  MOVWF  x03
06824:  MOVLW  04
06826:  MOVWF  x02
06828:  MOVLB  0
0682A:  RCALL  64C6
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
0682C:  MOVLW  04
0682E:  MOVLB  4
06830:  MOVWF  x05
06832:  MOVFF  1D,406
06836:  MOVLB  0
06838:  RCALL  646C
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0683A:  MOVLW  05
0683C:  MOVLB  4
0683E:  MOVWF  x05
06840:  MOVFF  1E,406
06844:  MOVLB  0
06846:  RCALL  646C
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
06848:  MOVLW  02
0684A:  MOVLB  4
0684C:  MOVWF  x05
0684E:  MOVFF  1F,406
06852:  MOVLB  0
06854:  RCALL  646C
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
06856:  MOVLW  03
06858:  MOVLB  4
0685A:  MOVWF  x05
0685C:  MOVFF  20,406
06860:  MOVLB  0
06862:  RCALL  646C
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
06864:  MOVLB  4
06866:  CLRF   x05
06868:  MOVFF  21,406
0686C:  MOVLB  0
0686E:  RCALL  646C
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
06870:  MOVLW  01
06872:  MOVLB  4
06874:  MOVWF  x05
06876:  MOVFF  22,406
0687A:  MOVLB  0
0687C:  RCALL  646C
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
0687E:  MOVLW  12
06880:  MOVLB  3
06882:  MOVWF  xFF
06884:  MOVLB  0
06886:  RCALL  642E
06888:  MOVFF  01,5A
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
0688C:  MOVLW  10
0688E:  MOVLB  3
06890:  MOVWF  x56
06892:  MOVLW  01
06894:  MOVWF  x58
06896:  CLRF   x57
06898:  MOVLB  0
0689A:  RCALL  652A
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
0689C:  MOVLW  14
0689E:  MOVLB  3
068A0:  MOVWF  x56
068A2:  MOVLW  04
068A4:  MOVWF  x58
068A6:  MOVLW  72
068A8:  MOVWF  x57
068AA:  MOVLB  0
068AC:  RCALL  652A
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
068AE:  MOVLB  3
068B0:  CLRF   x52
068B2:  MOVLB  0
068B4:  BRA    6658
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
068B6:  MOVLW  1F
068B8:  MOVLB  4
068BA:  MOVWF  x07
068BC:  MOVLW  04
068BE:  MOVWF  x08
068C0:  MOVLB  0
068C2:  RCALL  64A8
068C4:  GOTO   6CBE (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
08190:  MOVLW  1F
08192:  MOVLB  3
08194:  MOVWF  xFF
08196:  MOVLB  0
08198:  CALL   642E
0819C:  MOVFF  01,3E1
081A0:  MOVLW  00
081A2:  MOVLB  3
081A4:  BTFSC  01.3
081A6:  MOVLW  01
081A8:  XORLW  00
081AA:  BZ    81B0
081AC:  MOVLW  00
081AE:  BRA    81B2
081B0:  MOVLW  01
081B2:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
081B4:  MOVLB  0
081B6:  RETURN 0
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
07098:  MOVLW  1F
0709A:  MOVLB  3
0709C:  MOVWF  xFF
0709E:  MOVLB  0
070A0:  CALL   642E
070A4:  MOVFF  01,3E1
070A8:  MOVLW  00
070AA:  MOVLB  3
070AC:  BTFSC  01.3
070AE:  MOVLW  01
070B0:  XORLW  00
070B2:  BNZ   70B8
070B4:  MOVLW  00
070B6:  BRA    70BA
070B8:  MOVLW  FF
070BA:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
070BC:  MOVLB  0
070BE:  RETURN 0
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
00004:  RETURN 0
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
06CC8:  BTFSS  59.0
06CCA:  BRA    6CCE
....................       return; 
06CCC:  BRA    6D34
....................    WasDiscarded = TRUE; 
06CCE:  BSF    59.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
06CD0:  MOVLW  01
06CD2:  SUBWF  55,W
06CD4:  MOVLB  3
06CD6:  MOVWF  xA3
06CD8:  MOVLW  00
06CDA:  SUBWFB 56,W
06CDC:  MOVWF  xA4
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
06CDE:  MOVF   xA4,W
06CE0:  SUBLW  1A
06CE2:  BC    6CF6
06CE4:  XORLW  FF
06CE6:  BNZ   6CEE
06CE8:  MOVF   xA3,W
06CEA:  SUBLW  F7
06CEC:  BC    6CF6
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
06CEE:  MOVLW  1B
06CF0:  MOVWF  xA4
06CF2:  MOVLW  F7
06CF4:  MOVWF  xA3
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
06CF6:  MOVLW  1E
06CF8:  MOVLB  4
06CFA:  MOVWF  x07
06CFC:  MOVLW  40
06CFE:  MOVWF  x08
06D00:  MOVLB  0
06D02:  CALL   64A8
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
06D06:  MOVLB  4
06D08:  CLRF   x03
06D0A:  MOVLW  0C
06D0C:  MOVWF  x02
06D0E:  MOVLB  0
06D10:  CALL   64C6
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
06D14:  MOVLW  0C
06D16:  MOVLB  4
06D18:  MOVWF  x05
06D1A:  MOVFF  3A3,406
06D1E:  MOVLB  0
06D20:  CALL   646C
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
06D24:  MOVLW  0D
06D26:  MOVLB  4
06D28:  MOVWF  x05
06D2A:  MOVFF  3A4,406
06D2E:  MOVLB  0
06D30:  CALL   646C
06D34:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
081B8:  MOVLW  01
081BA:  MOVLB  4
081BC:  MOVWF  x03
081BE:  MOVLW  19
081C0:  MOVWF  x02
081C2:  MOVLB  0
081C4:  CALL   64C6
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
081C8:  MOVLW  19
081CA:  MOVLB  3
081CC:  MOVWF  xFF
081CE:  MOVLB  0
081D0:  CALL   642E
081D4:  MOVFF  01,3E0
....................  
....................       BankSel(ERXWRPTL); 
081D8:  MOVLB  4
081DA:  CLRF   x03
081DC:  MOVLW  0E
081DE:  MOVWF  x02
081E0:  MOVLB  0
081E2:  CALL   64C6
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
081E6:  MOVLW  0E
081E8:  MOVLB  3
081EA:  MOVWF  xFF
081EC:  MOVLB  0
081EE:  CALL   642E
081F2:  MOVFF  01,3E2
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
081F6:  MOVLW  0F
081F8:  MOVLB  3
081FA:  MOVWF  xFF
081FC:  MOVLB  0
081FE:  CALL   642E
08202:  MOVFF  01,3E3
....................  
....................       BankSel(EPKTCNT); 
08206:  MOVLW  01
08208:  MOVLB  4
0820A:  MOVWF  x03
0820C:  MOVLW  19
0820E:  MOVWF  x02
08210:  MOVLB  0
08212:  CALL   64C6
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
08216:  MOVLW  19
08218:  MOVLB  3
0821A:  MOVWF  xFF
0821C:  MOVLB  0
0821E:  CALL   642E
08222:  MOVFF  01,3E4
08226:  MOVLB  3
08228:  MOVF   xE0,W
0822A:  SUBWF  01,W
0822C:  BTFSC  FD8.2
0822E:  BRA    8234
08230:  MOVLB  0
08232:  BRA    81C8
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
08234:  MOVLB  4
08236:  CLRF   x03
08238:  MOVLW  0C
0823A:  MOVWF  x02
0823C:  MOVLB  0
0823E:  CALL   64C6
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
08242:  MOVLW  0C
08244:  MOVLB  3
08246:  MOVWF  xFF
08248:  MOVLB  0
0824A:  CALL   642E
0824E:  MOVFF  01,3E0
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
08252:  MOVLW  0D
08254:  MOVLB  3
08256:  MOVWF  xFF
08258:  MOVLB  0
0825A:  CALL   642E
0825E:  MOVFF  01,3E1
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
08262:  MOVLB  3
08264:  MOVF   xE1,W
08266:  SUBWF  xE3,W
08268:  BNC   8296
0826A:  BNZ   8272
0826C:  MOVF   xE2,W
0826E:  SUBWF  xE0,W
08270:  BC    8296
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
08272:  MOVF   xE0,W
08274:  SUBWF  xE2,W
08276:  MOVWF  00
08278:  MOVF   xE1,W
0827A:  SUBWFB xE3,W
0827C:  MOVWF  03
0827E:  MOVF   00,W
08280:  XORLW  FF
08282:  ADDLW  F8
08284:  MOVWF  00
08286:  MOVLW  1B
08288:  SUBFWB 03,F
0828A:  MOVFF  00,01
0828E:  MOVFF  03,02
08292:  BRA    82CC
....................    } 
08294:  BRA    82CC
....................    else if ( WritePT.Val == ReadPT.Val ) 
08296:  MOVF   xE0,W
08298:  SUBWF  xE2,W
0829A:  BNZ   82AE
0829C:  MOVF   xE1,W
0829E:  SUBWF  xE3,W
082A0:  BNZ   82AE
....................    { 
....................       return RXSIZE - 1; 
082A2:  MOVLW  F7
082A4:  MOVWF  01
082A6:  MOVLW  1B
082A8:  MOVWF  02
082AA:  BRA    82CC
....................    } 
082AC:  BRA    82CC
....................    else 
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
082AE:  MOVF   xE2,W
082B0:  SUBWF  xE0,W
082B2:  MOVWF  xE4
082B4:  MOVF   xE3,W
082B6:  SUBWFB xE1,W
082B8:  MOVWF  xE5
082BA:  MOVLW  01
082BC:  SUBWF  xE4,W
082BE:  MOVWF  00
082C0:  MOVLW  00
082C2:  SUBWFB xE5,W
082C4:  MOVWF  03
082C6:  MOVFF  00,01
082CA:  MOVWF  02
....................    } 
082CC:  MOVLB  0
082CE:  GOTO   8560 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
06DB4:  MOVLW  01
06DB6:  MOVLB  4
06DB8:  MOVWF  x03
06DBA:  MOVLW  19
06DBC:  MOVWF  x02
06DBE:  MOVLB  0
06DC0:  CALL   64C6
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
06DC4:  MOVLW  19
06DC6:  MOVLB  3
06DC8:  MOVWF  xFF
06DCA:  MOVLB  0
06DCC:  CALL   642E
06DD0:  MOVFF  01,36F
06DD4:  MOVLB  3
06DD6:  MOVF   x6F,F
06DD8:  BNZ   6DE0
....................       return FALSE; 
06DDA:  MOVLW  00
06DDC:  MOVWF  01
06DDE:  BRA    6EEE
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
06DE0:  BTFSC  59.0
06DE2:  BRA    6DF0
....................    { 
....................       MACDiscardRx(); 
06DE4:  MOVLB  0
06DE6:  RCALL  6CC8
....................       return FALSE; 
06DE8:  MOVLW  00
06DEA:  MOVWF  01
06DEC:  MOVLB  3
06DEE:  BRA    6EEE
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
06DF0:  MOVFF  56,58
06DF4:  MOVFF  55,57
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
06DF8:  MOVLB  4
06DFA:  CLRF   x03
06DFC:  CLRF   x02
06DFE:  MOVLB  0
06E00:  CALL   64C6
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
06E04:  MOVLB  4
06E06:  CLRF   x05
06E08:  MOVFF  55,406
06E0C:  MOVLB  0
06E0E:  CALL   646C
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
06E12:  MOVLW  01
06E14:  MOVLB  4
06E16:  MOVWF  x05
06E18:  MOVFF  56,406
06E1C:  MOVLB  0
06E1E:  CALL   646C
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
06E22:  MOVLW  03
06E24:  MOVLB  3
06E26:  MOVWF  x70
06E28:  MOVLW  5B
06E2A:  MOVWF  x6F
06E2C:  MOVFF  370,3EF
06E30:  MOVWF  xEE
06E32:  CLRF   xF1
06E34:  MOVLW  14
06E36:  MOVWF  xF0
06E38:  MOVLB  0
06E3A:  RCALL  6D36
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
06E3C:  MOVFF  36E,400
06E40:  MOVFF  36D,3FF
06E44:  RCALL  6D9E
06E46:  MOVFF  02,36E
06E4A:  MOVFF  01,36D
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
06E4E:  MOVLB  3
06E50:  MOVF   x5C,W
06E52:  SUBLW  1A
06E54:  BC    6E60
06E56:  XORLW  FF
06E58:  BNZ   6E8C
06E5A:  MOVF   x5B,W
06E5C:  SUBLW  F7
06E5E:  BNC   6E8C
06E60:  MOVLW  03
06E62:  MOVWF  x70
06E64:  MOVLW  5B
06E66:  MOVWF  FE9
06E68:  MOVFF  370,FEA
06E6C:  BTFSC  FEF.0
06E6E:  BRA    6E8C
06E70:  BTFSC  x60.7
06E72:  BRA    6E8C
06E74:  BTFSC  x5F.4
06E76:  BRA    6E8C
06E78:  MOVF   x5E,W
06E7A:  SUBLW  04
06E7C:  BC    6E88
06E7E:  XORLW  FF
06E80:  BNZ   6E8C
06E82:  MOVF   x5D,W
06E84:  SUBLW  EE
06E86:  BNC   6E8C
06E88:  BTFSC  x5F.7
06E8A:  BRA    6E8E
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
06E8C:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
06E8E:  MOVFF  35C,56
06E92:  MOVFF  35B,55
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
06E96:  MOVFF  358,03
06E9A:  MOVFF  357,36F
06E9E:  MOVFF  358,370
06EA2:  MOVFF  358,FEA
06EA6:  MOVFF  357,FE9
06EAA:  MOVLW  03
06EAC:  MOVWF  FE2
06EAE:  MOVLW  67
06EB0:  MOVWF  FE1
06EB2:  MOVLW  06
06EB4:  MOVWF  01
06EB6:  MOVFF  FE6,FEE
06EBA:  DECFSZ 01,F
06EBC:  BRA    6EB6
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
06EBE:  MOVFF  35A,03
06EC2:  MOVFF  359,FE9
06EC6:  MOVFF  03,FEA
06ECA:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
06ECC:  MOVF   x6E,W
06ECE:  SUBLW  08
06ED0:  BNZ   6EE8
06ED2:  MOVF   x6D,F
06ED4:  BZ    6EDC
06ED6:  MOVF   x6D,W
06ED8:  SUBLW  06
06EDA:  BNZ   6EE8
....................     { 
....................        *type = header.Type.v[0]; 
06EDC:  MOVFF  359,FE9
06EE0:  MOVFF  35A,FEA
06EE4:  MOVFF  36D,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
06EE8:  BCF    59.0
....................    return TRUE; 
06EEA:  MOVLW  01
06EEC:  MOVWF  01
06EEE:  MOVLB  0
06EF0:  GOTO   C72A (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
071D0:  MOVLB  4
071D2:  CLRF   x03
071D4:  MOVLW  02
071D6:  MOVWF  x02
071D8:  MOVLB  0
071DA:  CALL   64C6
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
071DE:  MOVLW  02
071E0:  MOVLB  4
071E2:  MOVWF  x05
071E4:  MOVLW  F8
071E6:  MOVWF  x06
071E8:  MOVLB  0
071EA:  CALL   646C
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
071EE:  MOVLW  03
071F0:  MOVLB  4
071F2:  MOVWF  x05
071F4:  MOVLW  1B
071F6:  MOVWF  x06
071F8:  MOVLB  0
071FA:  CALL   646C
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
071FE:  MOVLW  06
07200:  MOVLB  4
07202:  ADDWF  x00,F
07204:  MOVLW  1C
07206:  ADDWFC x01,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
07208:  MOVLW  04
0720A:  MOVWF  x03
0720C:  CLRF   x02
0720E:  MOVFF  402,FE9
07212:  MOVWF  FEA
07214:  MOVFF  FEF,406
07218:  MOVLW  06
0721A:  MOVWF  x05
0721C:  MOVLB  0
0721E:  CALL   646C
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
07222:  MOVLW  04
07224:  MOVLB  4
07226:  MOVWF  x03
07228:  CLRF   x02
0722A:  MOVLW  01
0722C:  ADDWF  x02,W
0722E:  MOVWF  FE9
07230:  MOVLW  00
07232:  ADDWFC x03,W
07234:  MOVWF  FEA
07236:  MOVFF  FEF,406
0723A:  MOVLW  07
0723C:  MOVWF  x05
0723E:  MOVLB  0
07240:  CALL   646C
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
07244:  MOVLB  4
07246:  CLRF   x03
07248:  MOVLB  0
0724A:  RCALL  7168
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
0724C:  MOVFF  3FE,405
07250:  MOVFF  3FD,404
07254:  MOVLB  4
07256:  CLRF   x07
07258:  MOVLW  06
0725A:  MOVWF  x06
0725C:  MOVLB  0
0725E:  RCALL  7186
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
07260:  MOVLB  4
07262:  CLRF   x03
07264:  MOVLW  1D
07266:  MOVWF  x02
07268:  MOVFF  403,405
0726C:  MOVWF  x04
0726E:  CLRF   x07
07270:  MOVLW  06
07272:  MOVWF  x06
07274:  MOVLB  0
07276:  RCALL  7186
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
07278:  MOVLW  08
0727A:  MOVLB  4
0727C:  MOVWF  x03
0727E:  MOVLB  0
07280:  RCALL  7168
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
07282:  MOVLB  3
07284:  MOVF   xFF,F
07286:  BNZ   728C
07288:  MOVLW  00
0728A:  BRA    728E
0728C:  MOVLW  06
0728E:  MOVLB  4
07290:  MOVWF  x02
07292:  MOVWF  x03
07294:  MOVLB  0
07296:  RCALL  7168
07298:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
0729A:  MOVLW  1C
0729C:  MOVLB  3
0729E:  MOVWF  xFF
072A0:  MOVLB  0
072A2:  CALL   642E
072A6:  MOVFF  01,3EC
072AA:  MOVLW  00
072AC:  MOVLB  3
072AE:  BTFSC  01.1
072B0:  MOVLW  01
072B2:  XORLW  00
072B4:  BZ    72D8
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
072B6:  MOVLW  1F
072B8:  MOVLB  4
072BA:  MOVWF  x07
072BC:  MOVLW  80
072BE:  MOVWF  x08
072C0:  MOVLB  0
072C2:  CALL   64A8
....................       BFCReg(ECON1, ECON1_TXRST); 
072C6:  MOVLW  1F
072C8:  MOVLB  4
072CA:  MOVWF  x04
072CC:  MOVLW  80
072CE:  MOVWF  x05
072D0:  MOVLB  0
072D2:  CALL   648A
072D6:  MOVLB  3
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
072D8:  MOVLW  1C
072DA:  MOVLB  4
072DC:  MOVWF  x04
072DE:  MOVLW  0A
072E0:  MOVWF  x05
072E2:  MOVLB  0
072E4:  CALL   648A
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
072E8:  MOVLW  1F
072EA:  MOVLB  4
072EC:  MOVWF  x07
072EE:  MOVLW  08
072F0:  MOVWF  x08
072F2:  MOVLB  0
072F4:  CALL   64A8
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
072F8:  MOVF   5A,W
072FA:  SUBLW  05
072FC:  BTFSS  FD8.2
072FE:  BRA    74CE
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
07300:  MOVLW  1C
07302:  MOVLB  3
07304:  MOVWF  xFF
07306:  MOVLB  0
07308:  CALL   642E
0730C:  MOVFF  01,3EC
07310:  MOVLB  3
07312:  MOVF   01,W
07314:  ANDLW  0A
07316:  BTFSS  FD8.2
07318:  BRA    731E
0731A:  MOVLB  0
0731C:  BRA    7300
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
0731E:  MOVLW  1C
07320:  MOVWF  xFF
07322:  MOVLB  0
07324:  CALL   642E
07328:  MOVFF  01,3EC
0732C:  MOVLW  00
0732E:  MOVLB  3
07330:  BTFSC  01.1
07332:  MOVLW  01
07334:  XORLW  00
07336:  BTFSC  FD8.2
07338:  BRA    74D0
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
0733A:  MOVLW  1F
0733C:  MOVLB  4
0733E:  MOVWF  x04
07340:  MOVLW  08
07342:  MOVWF  x05
07344:  MOVLB  0
07346:  CALL   648A
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
0734A:  MOVLB  4
0734C:  CLRF   x03
0734E:  CLRF   x02
07350:  MOVLB  0
07352:  CALL   64C6
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
07356:  MOVLB  3
07358:  CLRF   xFF
0735A:  MOVLB  0
0735C:  CALL   642E
07360:  MOVFF  01,3E0
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
07364:  MOVLW  01
07366:  MOVLB  3
07368:  MOVWF  xFF
0736A:  MOVLB  0
0736C:  CALL   642E
07370:  MOVFF  01,3E1
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
07374:  MOVLW  06
07376:  MOVLB  3
07378:  MOVWF  xFF
0737A:  MOVLB  0
0737C:  CALL   642E
07380:  MOVFF  01,3E2
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
07384:  MOVLW  07
07386:  MOVLB  3
07388:  MOVWF  xFF
0738A:  MOVLB  0
0738C:  CALL   642E
07390:  MOVFF  01,3E3
....................          TXEnd.Val++; 
07394:  MOVLB  3
07396:  INCF   xE2,F
07398:  BTFSC  FD8.2
0739A:  INCF   xE3,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
0739C:  MOVLB  4
0739E:  CLRF   x05
073A0:  MOVFF  3E2,406
073A4:  MOVLB  0
073A6:  CALL   646C
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
073AA:  MOVLW  01
073AC:  MOVLB  4
073AE:  MOVWF  x05
073B0:  MOVFF  3E3,406
073B4:  MOVLB  0
073B6:  CALL   646C
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
073BA:  MOVLW  03
073BC:  MOVLB  3
073BE:  MOVWF  xED
073C0:  MOVLW  E4
073C2:  MOVWF  xEC
073C4:  MOVFF  3ED,3EF
073C8:  MOVWF  xEE
073CA:  CLRF   xF1
073CC:  MOVLW  07
073CE:  MOVWF  xF0
073D0:  MOVLB  0
073D2:  RCALL  6D36
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
073D4:  MOVLB  3
073D6:  CLRF   xEB
073D8:  MOVF   xEB,W
073DA:  SUBLW  0F
073DC:  BNC   74B0
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
073DE:  MOVLW  1C
073E0:  MOVWF  xFF
073E2:  MOVLB  0
073E4:  CALL   642E
073E8:  MOVFF  01,3EC
073EC:  MOVLW  00
073EE:  MOVLB  3
073F0:  BTFSC  01.1
073F2:  MOVLW  01
073F4:  XORLW  00
073F6:  BZ    74A6
073F8:  BTFSS  xE7.5
073FA:  BRA    74A6
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
073FC:  MOVLW  1F
073FE:  MOVLB  4
07400:  MOVWF  x07
07402:  MOVLW  80
07404:  MOVWF  x08
07406:  MOVLB  0
07408:  CALL   64A8
....................                BFCReg(ECON1, ECON1_TXRST); 
0740C:  MOVLW  1F
0740E:  MOVLB  4
07410:  MOVWF  x04
07412:  MOVLW  80
07414:  MOVWF  x05
07416:  MOVLB  0
07418:  CALL   648A
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
0741C:  MOVLW  1C
0741E:  MOVLB  4
07420:  MOVWF  x04
07422:  MOVLW  0A
07424:  MOVWF  x05
07426:  MOVLB  0
07428:  CALL   648A
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
0742C:  MOVLW  1F
0742E:  MOVLB  4
07430:  MOVWF  x07
07432:  MOVLW  08
07434:  MOVWF  x08
07436:  MOVLB  0
07438:  CALL   64A8
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
0743C:  MOVLW  1C
0743E:  MOVLB  3
07440:  MOVWF  xFF
07442:  MOVLB  0
07444:  CALL   642E
07448:  MOVFF  01,3EC
0744C:  MOVLB  3
0744E:  MOVF   01,W
07450:  ANDLW  0A
07452:  BTFSS  FD8.2
07454:  BRA    745A
07456:  MOVLB  0
07458:  BRA    743C
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
0745A:  MOVLW  1F
0745C:  MOVLB  4
0745E:  MOVWF  x04
07460:  MOVLW  08
07462:  MOVWF  x05
07464:  MOVLB  0
07466:  CALL   648A
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
0746A:  MOVLB  4
0746C:  CLRF   x05
0746E:  MOVFF  3E2,406
07472:  MOVLB  0
07474:  CALL   646C
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
07478:  MOVLW  01
0747A:  MOVLB  4
0747C:  MOVWF  x05
0747E:  MOVFF  3E3,406
07482:  MOVLB  0
07484:  CALL   646C
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
07488:  MOVLW  03
0748A:  MOVLB  3
0748C:  MOVWF  xED
0748E:  MOVLW  E4
07490:  MOVWF  xEC
07492:  MOVFF  3ED,3EF
07496:  MOVWF  xEE
07498:  CLRF   xF1
0749A:  MOVLW  07
0749C:  MOVWF  xF0
0749E:  MOVLB  0
074A0:  RCALL  6D36
....................             } 
074A2:  BRA    74AA
074A4:  MOVLB  3
....................             else 
....................             { 
....................                break; 
074A6:  BRA    74B0
074A8:  MOVLB  0
....................             } 
074AA:  MOVLB  3
074AC:  INCF   xEB,F
074AE:  BRA    73D8
....................          } 
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
074B0:  MOVLB  4
074B2:  CLRF   x05
074B4:  MOVFF  3E0,406
074B8:  MOVLB  0
074BA:  CALL   646C
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
074BE:  MOVLW  01
074C0:  MOVLB  4
074C2:  MOVWF  x05
074C4:  MOVFF  3E1,406
074C8:  MOVLB  0
074CA:  CALL   646C
074CE:  MOVLB  3
....................       } 
....................    } 
074D0:  MOVLB  0
074D2:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
077E2:  MOVLW  14
077E4:  ADDWF  57,W
077E6:  MOVLB  3
077E8:  MOVWF  x8C
077EA:  MOVLW  00
077EC:  ADDWFC 58,W
077EE:  MOVWF  x8D
077F0:  MOVF   x88,W
077F2:  ADDWF  x8C,W
077F4:  MOVWF  x8A
077F6:  MOVF   x89,W
077F8:  ADDWFC x8D,W
077FA:  MOVWF  x8B
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
077FC:  MOVF   x8B,W
077FE:  SUBLW  1A
07800:  BC    7814
07802:  XORLW  FF
07804:  BNZ   780C
07806:  MOVF   x8A,W
07808:  SUBLW  F7
0780A:  BC    7814
....................       ReadPT.Val -= RXSIZE; 
0780C:  MOVLW  F8
0780E:  SUBWF  x8A,F
07810:  MOVLW  1B
07812:  SUBWFB x8B,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
07814:  MOVLB  4
07816:  CLRF   x03
07818:  CLRF   x02
0781A:  MOVLB  0
0781C:  CALL   64C6
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
07820:  MOVLB  4
07822:  CLRF   x05
07824:  MOVFF  38A,406
07828:  MOVLB  0
0782A:  CALL   646C
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
0782E:  MOVLW  01
07830:  MOVLB  4
07832:  MOVWF  x05
07834:  MOVFF  38B,406
07838:  MOVLB  0
0783A:  CALL   646C
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
0783E:  MOVLW  02
07840:  MOVLB  4
07842:  MOVWF  x05
07844:  MOVFF  38A,406
07848:  MOVLB  0
0784A:  CALL   646C
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
0784E:  MOVLW  03
07850:  MOVLB  4
07852:  MOVWF  x05
07854:  MOVFF  38B,406
07858:  MOVLB  0
0785A:  CALL   646C
0785E:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
070C0:  MOVFF  3F9,50
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
070C4:  MOVLW  07
070C6:  MOVLB  3
070C8:  ADDWF  xFA,F
070CA:  MOVLW  1C
070CC:  ADDWFC xFB,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
070CE:  MOVLB  4
070D0:  CLRF   x03
070D2:  MOVLW  02
070D4:  MOVWF  x02
070D6:  MOVLB  0
070D8:  CALL   64C6
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
070DC:  MOVLW  03
070DE:  MOVLB  3
070E0:  MOVWF  xFD
070E2:  MOVLW  FA
070E4:  MOVWF  xFC
070E6:  MOVWF  FE9
070E8:  MOVFF  3FD,FEA
070EC:  MOVFF  FEF,406
070F0:  MOVLB  4
070F2:  CLRF   x05
070F4:  MOVLB  0
070F6:  CALL   646C
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
070FA:  MOVLW  03
070FC:  MOVLB  3
070FE:  MOVWF  xFD
07100:  MOVLW  FA
07102:  MOVWF  xFC
07104:  MOVLW  01
07106:  ADDWF  xFC,W
07108:  MOVWF  FE9
0710A:  MOVLW  00
0710C:  ADDWFC xFD,W
0710E:  MOVWF  FEA
07110:  MOVFF  FEF,406
07114:  MOVLW  01
07116:  MOVLB  4
07118:  MOVWF  x05
0711A:  MOVLB  0
0711C:  CALL   646C
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
07120:  MOVLW  03
07122:  MOVLB  3
07124:  MOVWF  xFD
07126:  MOVLW  FA
07128:  MOVWF  xFC
0712A:  MOVWF  FE9
0712C:  MOVFF  3FD,FEA
07130:  MOVFF  FEF,406
07134:  MOVLW  02
07136:  MOVLB  4
07138:  MOVWF  x05
0713A:  MOVLB  0
0713C:  CALL   646C
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
07140:  MOVLW  03
07142:  MOVLB  3
07144:  MOVWF  xFD
07146:  MOVLW  FA
07148:  MOVWF  xFC
0714A:  MOVLW  01
0714C:  ADDWF  xFC,W
0714E:  MOVWF  FE9
07150:  MOVLW  00
07152:  ADDWFC xFD,W
07154:  MOVWF  FEA
07156:  MOVFF  FEF,406
0715A:  MOVLW  03
0715C:  MOVLB  4
0715E:  MOVWF  x05
07160:  MOVLB  0
07162:  CALL   646C
07166:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
076D6:  MOVLW  14
076D8:  ADDWF  57,W
076DA:  MOVLB  3
076DC:  MOVWF  xB6
076DE:  MOVLW  00
076E0:  ADDWFC 58,W
076E2:  MOVWF  xB7
076E4:  MOVF   xB0,W
076E6:  ADDWF  xB6,W
076E8:  MOVWF  xB4
076EA:  MOVF   xB1,W
076EC:  ADDWFC xB7,W
076EE:  MOVWF  xB5
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
076F0:  MOVF   xB5,W
076F2:  SUBLW  1A
076F4:  BC    7708
076F6:  XORLW  FF
076F8:  BNZ   7700
076FA:  MOVF   xB4,W
076FC:  SUBLW  F7
076FE:  BC    7708
....................    { 
....................       temp.Val -= RXSIZE; 
07700:  MOVLW  F8
07702:  SUBWF  xB4,F
07704:  MOVLW  1B
07706:  SUBWFB xB5,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
07708:  MOVLB  4
0770A:  CLRF   x03
0770C:  MOVLW  10
0770E:  MOVWF  x02
07710:  MOVLB  0
07712:  CALL   64C6
....................    WriteReg(EDMASTL, temp.v[0]); 
07716:  MOVLW  10
07718:  MOVLB  4
0771A:  MOVWF  x05
0771C:  MOVFF  3B4,406
07720:  MOVLB  0
07722:  CALL   646C
....................    WriteReg(EDMASTH, temp.v[1]); 
07726:  MOVLW  11
07728:  MOVLB  4
0772A:  MOVWF  x05
0772C:  MOVFF  3B5,406
07730:  MOVLB  0
07732:  CALL   646C
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
07736:  MOVLW  01
07738:  MOVLB  3
0773A:  SUBWF  xB2,W
0773C:  MOVWF  00
0773E:  MOVLW  00
07740:  SUBWFB xB3,W
07742:  MOVWF  03
07744:  MOVF   00,W
07746:  ADDWF  xB4,F
07748:  MOVF   03,W
0774A:  ADDWFC xB5,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
0774C:  MOVF   xB5,W
0774E:  SUBLW  1A
07750:  BC    7764
07752:  XORLW  FF
07754:  BNZ   775C
07756:  MOVF   xB4,W
07758:  SUBLW  F7
0775A:  BC    7764
....................    { 
....................       temp.Val -= RXSIZE; 
0775C:  MOVLW  F8
0775E:  SUBWF  xB4,F
07760:  MOVLW  1B
07762:  SUBWFB xB5,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
07764:  MOVLW  12
07766:  MOVLB  4
07768:  MOVWF  x05
0776A:  MOVFF  3B4,406
0776E:  MOVLB  0
07770:  CALL   646C
....................    WriteReg(EDMANDH, temp.v[1]); 
07774:  MOVLW  13
07776:  MOVLB  4
07778:  MOVWF  x05
0777A:  MOVFF  3B5,406
0777E:  MOVLB  0
07780:  CALL   646C
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
07784:  MOVLW  1F
07786:  MOVLB  4
07788:  MOVWF  x07
0778A:  MOVLW  30
0778C:  MOVWF  x08
0778E:  MOVLB  0
07790:  CALL   64A8
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
07794:  MOVLW  1F
07796:  MOVLB  3
07798:  MOVWF  xFF
0779A:  MOVLB  0
0779C:  CALL   642E
077A0:  MOVFF  01,3B6
077A4:  MOVLW  00
077A6:  MOVLB  3
077A8:  BTFSC  01.5
077AA:  MOVLW  01
077AC:  XORLW  00
077AE:  BTFSC  FD8.2
077B0:  BRA    77B6
077B2:  MOVLB  0
077B4:  BRA    7794
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
077B6:  MOVLW  16
077B8:  MOVWF  xFF
077BA:  MOVLB  0
077BC:  CALL   642E
077C0:  MOVFF  01,3B5
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
077C4:  MOVLW  17
077C6:  MOVLB  3
077C8:  MOVWF  xFF
077CA:  MOVLB  0
077CC:  CALL   642E
077D0:  MOVFF  01,3B4
....................    return temp.Val; 
077D4:  MOVLB  3
077D6:  MOVFF  3B4,01
077DA:  MOVFF  3B5,02
077DE:  MOVLB  0
077E0:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
082D2:  MOVLW  06
082D4:  MOVLB  3
082D6:  ADDWF  xF9,W
082D8:  MOVWF  xFF
082DA:  MOVLW  1C
082DC:  ADDWFC xFA,W
082DE:  MOVLB  4
082E0:  MOVWF  x00
082E2:  MOVLW  01
082E4:  MOVLB  3
082E6:  ADDWF  xFF,W
082E8:  MOVWF  xFD
082EA:  MOVLW  00
082EC:  MOVLB  4
082EE:  ADDWFC x00,W
082F0:  MOVLB  3
082F2:  MOVWF  xFE
.................... #endif 
....................    BankSel(EDMASTL); 
082F4:  MOVLB  4
082F6:  CLRF   x03
082F8:  MOVLW  10
082FA:  MOVWF  x02
082FC:  MOVLB  0
082FE:  CALL   64C6
....................    WriteReg(EDMASTL, temp.v[0]); 
08302:  MOVLW  10
08304:  MOVLB  4
08306:  MOVWF  x05
08308:  MOVFF  3FD,406
0830C:  MOVLB  0
0830E:  CALL   646C
....................    WriteReg(EDMASTH, temp.v[1]); 
08312:  MOVLW  11
08314:  MOVLB  4
08316:  MOVWF  x05
08318:  MOVFF  3FE,406
0831C:  MOVLB  0
0831E:  CALL   646C
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
08322:  MOVLW  01
08324:  MOVLB  3
08326:  SUBWF  xFB,W
08328:  MOVWF  00
0832A:  MOVLW  00
0832C:  SUBWFB xFC,W
0832E:  MOVWF  03
08330:  MOVF   00,W
08332:  ADDWF  xFD,F
08334:  MOVF   03,W
08336:  ADDWFC xFE,F
....................    WriteReg(EDMANDL, temp.v[0]); 
08338:  MOVLW  12
0833A:  MOVLB  4
0833C:  MOVWF  x05
0833E:  MOVFF  3FD,406
08342:  MOVLB  0
08344:  CALL   646C
....................    WriteReg(EDMANDH, temp.v[1]); 
08348:  MOVLW  13
0834A:  MOVLB  4
0834C:  MOVWF  x05
0834E:  MOVFF  3FE,406
08352:  MOVLB  0
08354:  CALL   646C
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
08358:  MOVLW  1F
0835A:  MOVLB  4
0835C:  MOVWF  x07
0835E:  MOVLW  30
08360:  MOVWF  x08
08362:  MOVLB  0
08364:  CALL   64A8
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
08368:  MOVLW  1F
0836A:  MOVLB  3
0836C:  MOVWF  xFF
0836E:  MOVLB  0
08370:  CALL   642E
08374:  MOVFF  01,3FF
08378:  MOVLW  00
0837A:  MOVLB  3
0837C:  BTFSC  01.5
0837E:  MOVLW  01
08380:  XORLW  00
08382:  BTFSC  FD8.2
08384:  BRA    838A
08386:  MOVLB  0
08388:  BRA    8368
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
0838A:  MOVLW  16
0838C:  MOVWF  xFF
0838E:  MOVLB  0
08390:  CALL   642E
08394:  MOVFF  01,3FE
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
08398:  MOVLW  17
0839A:  MOVLB  3
0839C:  MOVWF  xFF
0839E:  MOVLB  0
083A0:  CALL   642E
083A4:  MOVFF  01,3FD
....................    return temp.Val; 
083A8:  MOVLB  3
083AA:  MOVFF  3FD,01
083AE:  MOVFF  3FE,02
083B2:  MOVLB  0
083B4:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
07B24:  MOVLB  3
07B26:  MOVF   xE0,F
07B28:  BNZ   7B38
07B2A:  MOVF   xE1,F
07B2C:  BNZ   7B38
....................    { 
....................       return 0xFFFF; 
07B2E:  MOVLW  FF
07B30:  MOVWF  01
07B32:  MOVWF  02
07B34:  BRA    7C7C
....................    } 
07B36:  BRA    7B66
....................    else if(len == 1u) 
07B38:  DECFSZ xE0,W
07B3A:  BRA    7B66
07B3C:  MOVF   xE1,F
07B3E:  BNZ   7B66
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
07B40:  MOVLB  0
07B42:  RCALL  7AF8
07B44:  MOVLB  3
07B46:  CLRF   xE5
07B48:  MOVFF  01,3E4
07B4C:  MOVFF  01,03
07B50:  MOVLW  00
07B52:  CLRF   00
07B54:  DECF   00,F
07B56:  XORWF  00,F
07B58:  MOVLW  FF
07B5A:  XORWF  03,F
07B5C:  MOVFF  00,01
07B60:  MOVFF  03,02
07B64:  BRA    7C7C
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
07B66:  MOVLB  4
07B68:  CLRF   x03
07B6A:  CLRF   x02
07B6C:  MOVLB  0
07B6E:  CALL   64C6
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
07B72:  MOVLB  3
07B74:  CLRF   xFF
07B76:  MOVLB  0
07B78:  CALL   642E
07B7C:  MOVFF  01,3E2
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
07B80:  MOVLW  01
07B82:  MOVLB  3
07B84:  MOVWF  xFF
07B86:  MOVLB  0
07B88:  CALL   642E
07B8C:  MOVFF  01,3E3
....................    WriteReg(EDMASTL, temp.v[0]); 
07B90:  MOVLW  10
07B92:  MOVLB  4
07B94:  MOVWF  x05
07B96:  MOVFF  3E2,406
07B9A:  MOVLB  0
07B9C:  CALL   646C
....................    WriteReg(EDMASTH, temp.v[1]); 
07BA0:  MOVLW  11
07BA2:  MOVLB  4
07BA4:  MOVWF  x05
07BA6:  MOVFF  3E3,406
07BAA:  MOVLB  0
07BAC:  CALL   646C
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
07BB0:  MOVLB  3
07BB2:  MOVF   xE3,W
07BB4:  SUBLW  1B
07BB6:  BNC   7BEE
07BB8:  BNZ   7BC0
07BBA:  MOVF   xE2,W
07BBC:  SUBLW  F7
07BBE:  BNC   7BEE
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
07BC0:  MOVLW  01
07BC2:  SUBWF  xE0,W
07BC4:  MOVWF  00
07BC6:  MOVLW  00
07BC8:  SUBWFB xE1,W
07BCA:  MOVWF  03
07BCC:  MOVF   00,W
07BCE:  ADDWF  xE2,F
07BD0:  MOVF   03,W
07BD2:  ADDWFC xE3,F
....................       if(temp.Val > RXSTOP) 
07BD4:  MOVF   xE3,W
07BD6:  SUBLW  1A
07BD8:  BC    7BEC
07BDA:  XORLW  FF
07BDC:  BNZ   7BE4
07BDE:  MOVF   xE2,W
07BE0:  SUBLW  F7
07BE2:  BC    7BEC
....................       { 
....................          temp.Val -= RXSIZE; 
07BE4:  MOVLW  F8
07BE6:  SUBWF  xE2,F
07BE8:  MOVLW  1B
07BEA:  SUBWFB xE3,F
....................       } 
....................    } 
07BEC:  BRA    7C02
....................    else 
....................    { 
....................       temp.Val += len-1; 
07BEE:  MOVLW  01
07BF0:  SUBWF  xE0,W
07BF2:  MOVWF  00
07BF4:  MOVLW  00
07BF6:  SUBWFB xE1,W
07BF8:  MOVWF  03
07BFA:  MOVF   00,W
07BFC:  ADDWF  xE2,F
07BFE:  MOVF   03,W
07C00:  ADDWFC xE3,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
07C02:  MOVLW  12
07C04:  MOVLB  4
07C06:  MOVWF  x05
07C08:  MOVFF  3E2,406
07C0C:  MOVLB  0
07C0E:  CALL   646C
....................    WriteReg(EDMANDH, temp.v[1]); 
07C12:  MOVLW  13
07C14:  MOVLB  4
07C16:  MOVWF  x05
07C18:  MOVFF  3E3,406
07C1C:  MOVLB  0
07C1E:  CALL   646C
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
07C22:  MOVLW  1F
07C24:  MOVLB  4
07C26:  MOVWF  x07
07C28:  MOVLW  30
07C2A:  MOVWF  x08
07C2C:  MOVLB  0
07C2E:  CALL   64A8
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
07C32:  MOVLW  1F
07C34:  MOVLB  3
07C36:  MOVWF  xFF
07C38:  MOVLB  0
07C3A:  CALL   642E
07C3E:  MOVFF  01,3E4
07C42:  MOVLW  00
07C44:  MOVLB  3
07C46:  BTFSC  01.5
07C48:  MOVLW  01
07C4A:  XORLW  00
07C4C:  BTFSC  FD8.2
07C4E:  BRA    7C54
07C50:  MOVLB  0
07C52:  BRA    7C32
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
07C54:  MOVLW  16
07C56:  MOVWF  xFF
07C58:  MOVLB  0
07C5A:  CALL   642E
07C5E:  MOVFF  01,3E2
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
07C62:  MOVLW  17
07C64:  MOVLB  3
07C66:  MOVWF  xFF
07C68:  MOVLB  0
07C6A:  CALL   642E
07C6E:  MOVFF  01,3E3
....................    return temp.Val; 
07C72:  MOVLB  3
07C74:  MOVFF  3E2,01
07C78:  MOVFF  3E3,02
07C7C:  MOVLB  0
07C7E:  RETURN 0
.................... } 
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
07AF8:  BCF    F93.6
07AFA:  BCF    F8A.6
....................    ENCSPIXfer(RBM); 
07AFC:  MOVLW  3A
07AFE:  MOVLB  4
07B00:  MOVWF  x0A
07B02:  MOVLB  0
07B04:  CALL   641E
....................    c=ENCSPIXfer(0); 
07B08:  MOVLB  4
07B0A:  CLRF   x0A
07B0C:  MOVLB  0
07B0E:  CALL   641E
07B12:  MOVFF  01,3E4
....................    SPIUnselectEthernet(); 
07B16:  BCF    F93.6
07B18:  BSF    F8A.6
....................    return(c); 
07B1A:  MOVLB  3
07B1C:  MOVFF  3E4,01
07B20:  MOVLB  0
07B22:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
*
06D36:  MOVLB  3
06D38:  CLRF   xF3
06D3A:  CLRF   xF2
.................... { 
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
....................  
....................    SPISelectEthernet(); 
06D3C:  BCF    F93.6
06D3E:  BCF    F8A.6
....................    ENCSPIXfer(RBM); 
06D40:  MOVLW  3A
06D42:  MOVLB  4
06D44:  MOVWF  x0A
06D46:  MOVLB  0
06D48:  CALL   641E
....................    while(i<len) 
06D4C:  MOVLB  3
06D4E:  MOVF   xF3,W
06D50:  SUBWF  xF1,W
06D52:  BNC   6D8E
06D54:  BNZ   6D5C
06D56:  MOVF   xF0,W
06D58:  SUBWF  xF2,W
06D5A:  BC    6D8E
....................    { 
....................       *val=ENCSPIXfer(0); 
06D5C:  MOVFF  3EF,03
06D60:  MOVFF  3EE,3F4
06D64:  MOVFF  3EF,3F5
06D68:  MOVLB  4
06D6A:  CLRF   x0A
06D6C:  MOVLB  0
06D6E:  CALL   641E
06D72:  MOVFF  3F5,FEA
06D76:  MOVFF  3F4,FE9
06D7A:  MOVFF  01,FEF
....................       val++; 
06D7E:  MOVLB  3
06D80:  INCF   xEE,F
06D82:  BTFSC  FD8.2
06D84:  INCF   xEF,F
....................       i++; 
06D86:  INCF   xF2,F
06D88:  BTFSC  FD8.2
06D8A:  INCF   xF3,F
06D8C:  BRA    6D4E
....................    } 
....................    SPIUnselectEthernet(); 
06D8E:  BCF    F93.6
06D90:  BSF    F8A.6
....................  
....................    return(i); 
06D92:  MOVFF  3F2,01
06D96:  MOVFF  3F3,02
06D9A:  MOVLB  0
06D9C:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
07168:  BCF    F93.6
0716A:  BCF    F8A.6
....................    ENCSPIXfer(WBM); 
0716C:  MOVLW  7A
0716E:  MOVLB  4
07170:  MOVWF  x0A
07172:  MOVLB  0
07174:  CALL   641E
....................    ENCSPIXfer(val); 
07178:  MOVFF  403,40A
0717C:  CALL   641E
....................    SPIUnselectEthernet(); 
07180:  BCF    F93.6
07182:  BSF    F8A.6
07184:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
07186:  BCF    F93.6
07188:  BCF    F8A.6
....................    ENCSPIXfer(WBM); 
0718A:  MOVLW  7A
0718C:  MOVLB  4
0718E:  MOVWF  x0A
07190:  MOVLB  0
07192:  CALL   641E
....................    while(len--) 
07196:  MOVLB  4
07198:  MOVFF  407,03
0719C:  MOVF   x06,W
0719E:  BTFSC  FD8.2
071A0:  DECF   x07,F
071A2:  DECF   x06,F
071A4:  IORWF  03,W
071A6:  BZ    71C8
....................    { 
....................       ENCSPIXfer(*val); 
071A8:  MOVFF  405,03
071AC:  MOVFF  404,FE9
071B0:  MOVFF  405,FEA
071B4:  MOVFF  FEF,40A
071B8:  MOVLB  0
071BA:  CALL   641E
....................       val++; 
071BE:  MOVLB  4
071C0:  INCF   x04,F
071C2:  BTFSC  FD8.2
071C4:  INCF   x05,F
071C6:  BRA    7198
....................    } 
....................    SPIUnselectEthernet(); 
071C8:  BCF    F93.6
071CA:  BSF    F8A.6
071CC:  MOVLB  0
071CE:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
06458:  BCF    F93.6
0645A:  BCF    F8A.6
....................    ENCSPIXfer(SR); 
0645C:  MOVLB  4
0645E:  SETF   x0A
06460:  MOVLB  0
06462:  RCALL  641E
....................    SPIUnselectEthernet(); 
06464:  BCF    F93.6
06466:  BSF    F8A.6
06468:  GOTO   6726 (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
0642E:  BCF    F93.6
06430:  BCF    F8A.6
....................    ENCSPIXfer(RCR | Address); 
06432:  MOVFF  3FF,401
06436:  MOVFF  3FF,40A
0643A:  MOVLB  0
0643C:  RCALL  641E
....................    c=ENCSPIXfer(0); 
0643E:  MOVLB  4
06440:  CLRF   x0A
06442:  MOVLB  0
06444:  RCALL  641E
06446:  MOVFF  01,400
....................    SPIUnselectEthernet(); 
0644A:  BCF    F93.6
0644C:  BSF    F8A.6
....................    return(c); 
0644E:  MOVLB  4
06450:  MOVFF  400,01
06454:  MOVLB  0
06456:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
064F8:  BCF    F93.6
064FA:  BCF    F8A.6
....................  
....................    ENCSPIXfer(RCR | Address); 
064FC:  MOVFF  359,35B
06500:  MOVFF  359,40A
06504:  MOVLB  0
06506:  RCALL  641E
....................    ENCSPIXfer(0); 
06508:  MOVLB  4
0650A:  CLRF   x0A
0650C:  MOVLB  0
0650E:  RCALL  641E
....................    c=ENCSPIXfer(0); 
06510:  MOVLB  4
06512:  CLRF   x0A
06514:  MOVLB  0
06516:  RCALL  641E
06518:  MOVFF  01,35A
....................  
....................    SPIUnselectEthernet(); 
0651C:  BCF    F93.6
0651E:  BSF    F8A.6
....................  
....................    return(c); 
06520:  MOVLB  3
06522:  MOVFF  35A,01
06526:  MOVLB  0
06528:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
065BA:  MOVLW  02
065BC:  MOVLB  4
065BE:  MOVWF  x03
065C0:  MOVLW  14
065C2:  MOVWF  x02
065C4:  MOVLB  0
065C6:  RCALL  64C6
....................    WriteReg(MIREGADR, Register); 
065C8:  MOVLW  14
065CA:  MOVLB  4
065CC:  MOVWF  x05
065CE:  MOVFF  356,406
065D2:  MOVLB  0
065D4:  RCALL  646C
....................    WriteReg(MICMD, MICMD_MIIRD); 
065D6:  MOVLW  12
065D8:  MOVLB  4
065DA:  MOVWF  x05
065DC:  MOVLW  01
065DE:  MOVWF  x06
065E0:  MOVLB  0
065E2:  RCALL  646C
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
065E4:  MOVLW  03
065E6:  MOVLB  4
065E8:  MOVWF  x03
065EA:  MOVLW  0A
065EC:  MOVWF  x02
065EE:  MOVLB  0
065F0:  RCALL  64C6
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
065F2:  MOVLW  0A
065F4:  MOVLB  3
065F6:  MOVWF  x59
065F8:  MOVLB  0
065FA:  RCALL  64F8
065FC:  MOVFF  01,359
06600:  MOVLW  00
06602:  MOVLB  3
06604:  BTFSC  01.0
06606:  MOVLW  01
06608:  XORLW  00
0660A:  BTFSC  FD8.2
0660C:  BRA    6612
0660E:  MOVLB  0
06610:  BRA    65F2
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
06612:  MOVLW  02
06614:  MOVLB  4
06616:  MOVWF  x03
06618:  MOVLW  14
0661A:  MOVWF  x02
0661C:  MOVLB  0
0661E:  RCALL  64C6
....................    WriteReg(MICMD, 0x00); 
06620:  MOVLW  12
06622:  MOVLB  4
06624:  MOVWF  x05
06626:  CLRF   x06
06628:  MOVLB  0
0662A:  RCALL  646C
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
0662C:  MOVLW  18
0662E:  MOVLB  3
06630:  MOVWF  x59
06632:  MOVLB  0
06634:  RCALL  64F8
06636:  MOVFF  01,357
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
0663A:  MOVLW  19
0663C:  MOVLB  3
0663E:  MOVWF  x59
06640:  MOVLB  0
06642:  RCALL  64F8
06644:  MOVFF  01,358
....................    return Result; 
06648:  MOVLB  3
0664A:  MOVFF  357,01
0664E:  MOVFF  358,02
06652:  MOVLB  0
06654:  GOTO   666E (RETURN)
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0646C:  BCF    F93.6
0646E:  BCF    F8A.6
....................    ENCSPIXfer(WCR | Address); 
06470:  MOVLB  4
06472:  MOVF   x05,W
06474:  IORLW  40
06476:  MOVWF  x07
06478:  MOVWF  x0A
0647A:  MOVLB  0
0647C:  RCALL  641E
....................    ENCSPIXfer(Data); 
0647E:  MOVFF  406,40A
06482:  RCALL  641E
....................    SPIUnselectEthernet(); 
06484:  BCF    F93.6
06486:  BSF    F8A.6
06488:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
0648A:  BCF    F93.6
0648C:  BCF    F8A.6
....................    ENCSPIXfer(BFC | Address); 
0648E:  MOVLB  4
06490:  MOVF   x04,W
06492:  IORLW  A0
06494:  MOVWF  x06
06496:  MOVWF  x0A
06498:  MOVLB  0
0649A:  RCALL  641E
....................    ENCSPIXfer(Data); 
0649C:  MOVFF  405,40A
064A0:  RCALL  641E
....................    SPIUnselectEthernet(); 
064A2:  BCF    F93.6
064A4:  BSF    F8A.6
064A6:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
064A8:  BCF    F93.6
064AA:  BCF    F8A.6
....................    ENCSPIXfer(BFS | Address); 
064AC:  MOVLB  4
064AE:  MOVF   x07,W
064B0:  IORLW  80
064B2:  MOVWF  x09
064B4:  MOVWF  x0A
064B6:  MOVLB  0
064B8:  RCALL  641E
....................    ENCSPIXfer(Data); 
064BA:  MOVFF  408,40A
064BE:  RCALL  641E
....................    SPIUnselectEthernet(); 
064C0:  BCF    F93.6
064C2:  BSF    F8A.6
064C4:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
0652A:  MOVLW  02
0652C:  MOVLB  4
0652E:  MOVWF  x03
06530:  MOVLW  14
06532:  MOVWF  x02
06534:  MOVLB  0
06536:  RCALL  64C6
....................    WriteReg(MIREGADR, Register); 
06538:  MOVLW  14
0653A:  MOVLB  4
0653C:  MOVWF  x05
0653E:  MOVFF  356,406
06542:  MOVLB  0
06544:  RCALL  646C
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
06546:  MOVLW  03
06548:  MOVLB  3
0654A:  MOVWF  x5A
0654C:  MOVLW  57
0654E:  MOVWF  x59
06550:  MOVWF  FE9
06552:  MOVFF  35A,FEA
06556:  MOVFF  FEF,406
0655A:  MOVLW  16
0655C:  MOVLB  4
0655E:  MOVWF  x05
06560:  MOVLB  0
06562:  RCALL  646C
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
06564:  MOVLW  03
06566:  MOVLB  3
06568:  MOVWF  x5A
0656A:  MOVLW  57
0656C:  MOVWF  x59
0656E:  MOVLW  01
06570:  ADDWF  x59,W
06572:  MOVWF  FE9
06574:  MOVLW  00
06576:  ADDWFC x5A,W
06578:  MOVWF  FEA
0657A:  MOVFF  FEF,406
0657E:  MOVLW  17
06580:  MOVLB  4
06582:  MOVWF  x05
06584:  MOVLB  0
06586:  RCALL  646C
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
06588:  MOVLW  03
0658A:  MOVLB  4
0658C:  MOVWF  x03
0658E:  MOVLW  0A
06590:  MOVWF  x02
06592:  MOVLB  0
06594:  RCALL  64C6
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
06596:  MOVLW  0A
06598:  MOVLB  3
0659A:  MOVWF  x59
0659C:  MOVLB  0
0659E:  RCALL  64F8
065A0:  MOVFF  01,359
065A4:  MOVLW  00
065A6:  MOVLB  3
065A8:  BTFSC  01.0
065AA:  MOVLW  01
065AC:  XORLW  00
065AE:  BTFSC  FD8.2
065B0:  BRA    65B6
065B2:  MOVLB  0
065B4:  BRA    6596
065B6:  MOVLB  0
065B8:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
064C6:  MOVLW  1F
064C8:  MOVLB  4
064CA:  MOVWF  x04
064CC:  MOVLW  03
064CE:  MOVWF  x05
064D0:  MOVLB  0
064D2:  RCALL  648A
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
064D4:  MOVLW  04
064D6:  MOVLB  4
064D8:  MOVWF  x05
064DA:  MOVLW  02
064DC:  MOVWF  x04
064DE:  MOVLW  01
064E0:  ADDWF  x04,W
064E2:  MOVWF  FE9
064E4:  MOVLW  00
064E6:  ADDWFC x05,W
064E8:  MOVWF  FEA
064EA:  MOVFF  FEF,408
064EE:  MOVLW  1F
064F0:  MOVWF  x07
064F2:  MOVLB  0
064F4:  RCALL  64A8
064F6:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
06658:  MOVLW  1F
0665A:  MOVLB  4
0665C:  MOVWF  x04
0665E:  MOVLW  0C
06660:  MOVWF  x05
06662:  MOVLB  0
06664:  RCALL  648A
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
06666:  MOVLB  3
06668:  CLRF   x56
0666A:  MOVLB  0
0666C:  BRA    65BA
0666E:  MOVFF  02,355
06672:  MOVFF  01,354
....................    if(DuplexState == USE_PHY) 
06676:  MOVLB  3
06678:  MOVF   x52,W
0667A:  SUBLW  02
0667C:  BNZ   6686
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
0667E:  CLRF   x52
06680:  BTFSC  x55.0
06682:  INCF   x52,F
....................    } 
06684:  BRA    669C
....................    else 
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
06686:  BCF    x55.0
06688:  BTFSC  x52.0
0668A:  BSF    x55.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
0668C:  CLRF   x56
0668E:  MOVFF  355,358
06692:  MOVFF  354,357
06696:  MOVLB  0
06698:  RCALL  652A
0669A:  MOVLB  3
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
0669C:  MOVLW  02
0669E:  MOVLB  4
066A0:  MOVWF  x03
066A2:  MOVWF  x02
066A4:  MOVLB  0
066A6:  RCALL  64C6
....................    Register = ReadMACReg(MACON3); 
066A8:  MOVLW  02
066AA:  MOVLB  3
066AC:  MOVWF  x59
066AE:  MOVLB  0
066B0:  RCALL  64F8
066B2:  MOVFF  01,353
....................    Register.MACON3bits.FULDPX = DuplexState; 
066B6:  MOVLB  3
066B8:  BCF    x53.0
066BA:  BTFSC  x52.0
066BC:  BSF    x53.0
....................    WriteReg(MACON3, Register.Val); 
066BE:  MOVLW  02
066C0:  MOVLB  4
066C2:  MOVWF  x05
066C4:  MOVFF  353,406
066C8:  MOVLB  0
066CA:  RCALL  646C
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
066CC:  MOVLB  3
066CE:  MOVF   x52,F
066D0:  BZ    66D6
066D2:  MOVLW  15
066D4:  BRA    66D8
066D6:  MOVLW  12
066D8:  MOVWF  x56
066DA:  MOVLW  04
066DC:  MOVLB  4
066DE:  MOVWF  x05
066E0:  MOVFF  356,406
066E4:  MOVLB  0
066E6:  RCALL  646C
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
066E8:  MOVLW  1F
066EA:  MOVLB  4
066EC:  MOVWF  x07
066EE:  MOVLW  04
066F0:  MOVWF  x08
066F2:  MOVLB  0
066F4:  RCALL  64A8
066F6:  GOTO   68B6 (RETURN)
.................... }//end MACSetDuplex 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
07928:  MOVLW  03
0792A:  MOVLB  3
0792C:  MOVWF  x76
0792E:  MOVLW  61
07930:  MOVWF  x75
07932:  MOVFF  376,3EF
07936:  MOVWF  xEE
07938:  CLRF   xF1
0793A:  MOVLW  14
0793C:  MOVWF  xF0
0793E:  MOVLB  0
07940:  CALL   6D36
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
07944:  MOVLB  3
07946:  MOVF   x61,W
07948:  ANDLW  F0
0794A:  SUBLW  40
0794C:  BZ    7954
....................     	return FALSE; 
0794E:  MOVLW  00
07950:  MOVWF  01
07952:  BRA    7A04
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
07954:  MOVF   x61,W
07956:  ANDLW  0F
07958:  MOVWF  00
0795A:  RLCF   00,W
0795C:  MOVWF  5D
0795E:  RLCF   5D,F
07960:  MOVLW  FC
07962:  ANDWF  5D,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
07964:  CLRF   xB1
07966:  CLRF   xB0
07968:  CLRF   xB3
0796A:  MOVFF  5D,3B2
0796E:  MOVLB  0
07970:  RCALL  76D6
07972:  MOVFF  02,360
07976:  MOVFF  01,35F
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
0797A:  MOVLB  3
0797C:  CLRF   x89
0797E:  MOVFF  5D,388
07982:  MOVLB  0
07984:  RCALL  77E2
....................  
....................     if(CalcChecksum.Val) 
07986:  MOVLB  3
07988:  MOVF   x5F,W
0798A:  IORWF  x60,W
0798C:  BZ    7994
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
0798E:  MOVLW  00
07990:  MOVWF  01
07992:  BRA    7A04
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
07994:  MOVLW  03
07996:  MOVWF  xFA
07998:  MOVLW  61
0799A:  MOVWF  xF9
0799C:  MOVLB  0
0799E:  RCALL  7860
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
079A0:  MOVLB  3
079A2:  MOVF   x57,W
079A4:  IORWF  x58,W
079A6:  BZ    79C0
....................         localIP->Val    = header.DestAddress.Val; 
079A8:  MOVFF  357,FE9
079AC:  MOVFF  358,FEA
079B0:  MOVFF  371,FEF
079B4:  MOVFF  372,FEC
079B8:  MOVFF  373,FEC
079BC:  MOVFF  374,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
079C0:  MOVLW  06
079C2:  ADDWF  x59,W
079C4:  MOVWF  FE9
079C6:  MOVLW  00
079C8:  ADDWFC x5A,W
079CA:  MOVWF  FEA
079CC:  MOVFF  36D,FEF
079D0:  MOVFF  36E,FEC
079D4:  MOVFF  36F,FEC
079D8:  MOVFF  370,FEC
....................     *protocol           = header.Protocol; 
079DC:  MOVFF  35B,FE9
079E0:  MOVFF  35C,FEA
079E4:  MOVFF  36A,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
079E8:  MOVFF  35D,FE9
079EC:  MOVFF  35E,FEA
079F0:  MOVF   5D,W
079F2:  SUBWF  x63,W
079F4:  MOVWF  00
079F6:  MOVLW  00
079F8:  SUBWFB x64,W
079FA:  MOVFF  00,FEF
079FE:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
07A00:  MOVLW  01
07A02:  MOVWF  01
07A04:  MOVLB  0
07A06:  GOTO   C79A (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
083B6:  MOVLW  14
083B8:  MOVWF  5D
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
083BA:  MOVLW  45
083BC:  MOVLB  3
083BE:  MOVWF  xE5
....................     header.TypeOfService    = IP_SERVICE; 
083C0:  CLRF   xE6
....................     header.TotalLength      = sizeof(header) + len; 
083C2:  MOVLW  14
083C4:  ADDWF  xE3,W
083C6:  MOVWF  xE7
083C8:  MOVLW  00
083CA:  ADDWFC xE4,W
083CC:  MOVWF  xE8
....................     header.Identification   = ++_Identifier; 
083CE:  INCF   5B,F
083D0:  BTFSC  FD8.2
083D2:  INCF   5C,F
083D4:  MOVFF  5C,3EA
083D8:  MOVFF  5B,3E9
....................     header.FragmentInfo     = 0; 
083DC:  CLRF   xEC
083DE:  CLRF   xEB
....................     header.TimeToLive       = MY_IP_TTL; 
083E0:  MOVLW  64
083E2:  MOVWF  xED
....................     header.Protocol         = protocol; 
083E4:  MOVFF  3E2,3EE
....................     header.HeaderChecksum   = 0; 
083E8:  CLRF   xF0
083EA:  CLRF   xEF
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
083EC:  MOVFF  1C,3F4
083F0:  MOVFF  1B,3F3
083F4:  MOVFF  1A,3F2
083F8:  MOVFF  19,3F1
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
083FC:  MOVLW  06
083FE:  ADDWF  xE0,W
08400:  MOVWF  FE9
08402:  MOVLW  00
08404:  ADDWFC xE1,W
08406:  MOVWF  FEA
08408:  MOVFF  FEF,3F5
0840C:  MOVFF  FEC,3F6
08410:  MOVFF  FEC,3F7
08414:  MOVFF  FEC,3F8
....................  
....................     SwapIPHeader(&header); 
08418:  MOVLW  03
0841A:  MOVWF  xFA
0841C:  MOVLW  E5
0841E:  MOVWF  xF9
08420:  MOVLB  0
08422:  CALL   7860
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
08426:  MOVLB  3
08428:  MOVFF  3E0,01
0842C:  MOVFF  3E1,03
08430:  MOVFF  3E0,3F9
08434:  MOVFF  3E1,3FA
08438:  MOVLW  14
0843A:  ADDWF  xE3,W
0843C:  MOVWF  xFB
0843E:  MOVLW  00
08440:  ADDWFC xE4,W
08442:  MOVWF  xFC
08444:  MOVFF  3E1,3FE
08448:  MOVFF  3E0,3FD
0844C:  CLRF   xFF
0844E:  MOVFF  FE8,401
08452:  MOVFF  3FB,400
08456:  MOVLB  0
08458:  CALL   71D0
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
0845C:  MOVLW  03
0845E:  MOVLB  3
08460:  MOVWF  xFA
08462:  MOVLW  E5
08464:  MOVWF  xF9
08466:  MOVFF  3FA,405
0846A:  MOVFF  FE8,404
0846E:  MOVLB  4
08470:  CLRF   x07
08472:  MOVLW  14
08474:  MOVWF  x06
08476:  MOVLB  0
08478:  CALL   7186
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
0847C:  MOVLB  3
0847E:  CLRF   xFA
08480:  CLRF   xF9
08482:  CLRF   xFC
08484:  MOVLW  14
08486:  MOVWF  xFB
08488:  MOVLB  0
0848A:  RCALL  82D2
0848C:  MOVFF  02,3F0
08490:  MOVFF  01,3EF
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
08494:  MOVFF  50,3F9
08498:  MOVLB  3
0849A:  CLRF   xFB
0849C:  MOVLW  0A
0849E:  MOVWF  xFA
084A0:  MOVLB  0
084A2:  CALL   70C0
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
084A6:  MOVLW  03
084A8:  MOVLB  3
084AA:  MOVWF  xFA
084AC:  MOVLW  EF
084AE:  MOVWF  xF9
084B0:  MOVFF  3FA,405
084B4:  MOVFF  FE8,404
084B8:  MOVLB  4
084BA:  CLRF   x07
084BC:  MOVLW  02
084BE:  MOVWF  x06
084C0:  MOVLB  0
084C2:  CALL   7186
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
084C6:  MOVFF  50,3F9
084CA:  MOVLB  3
084CC:  CLRF   xFB
084CE:  MOVLW  14
084D0:  MOVWF  xFA
084D2:  MOVLB  0
084D4:  CALL   70C0
.................... #endif 
....................  
....................     return 0x0; 
084D8:  MOVLW  00
084DA:  MOVWF  01
084DC:  MOVWF  02
084DE:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
07C80:  MOVF   5D,W
07C82:  MOVLB  3
07C84:  ADDWF  x84,W
07C86:  MOVWF  x86
07C88:  MOVLW  00
07C8A:  ADDWFC x85,W
07C8C:  MOVWF  x87
07C8E:  MOVWF  x89
07C90:  MOVFF  386,388
07C94:  MOVLB  0
07C96:  RCALL  77E2
07C98:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
07860:  MOVLW  02
07862:  MOVLB  3
07864:  ADDWF  xF9,W
07866:  MOVWF  01
07868:  MOVLW  00
0786A:  ADDWFC xFA,W
0786C:  MOVWF  03
0786E:  MOVFF  01,3FB
07872:  MOVWF  xFC
07874:  MOVLW  02
07876:  ADDWF  xF9,W
07878:  MOVWF  FE9
0787A:  MOVLW  00
0787C:  ADDWFC xFA,W
0787E:  MOVWF  FEA
07880:  MOVFF  FEC,400
07884:  MOVF   FED,F
07886:  MOVFF  FEF,3FF
0788A:  MOVLB  0
0788C:  CALL   6D9E
07890:  MOVFF  3FC,FEA
07894:  MOVFF  3FB,FE9
07898:  MOVFF  02,FEC
0789C:  MOVF   FED,F
0789E:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
078A2:  MOVLW  04
078A4:  MOVLB  3
078A6:  ADDWF  xF9,W
078A8:  MOVWF  01
078AA:  MOVLW  00
078AC:  ADDWFC xFA,W
078AE:  MOVWF  03
078B0:  MOVFF  01,3FB
078B4:  MOVWF  xFC
078B6:  MOVLW  04
078B8:  ADDWF  xF9,W
078BA:  MOVWF  FE9
078BC:  MOVLW  00
078BE:  ADDWFC xFA,W
078C0:  MOVWF  FEA
078C2:  MOVFF  FEC,400
078C6:  MOVF   FED,F
078C8:  MOVFF  FEF,3FF
078CC:  MOVLB  0
078CE:  CALL   6D9E
078D2:  MOVFF  3FC,FEA
078D6:  MOVFF  3FB,FE9
078DA:  MOVFF  02,FEC
078DE:  MOVF   FED,F
078E0:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
078E4:  MOVLW  0A
078E6:  MOVLB  3
078E8:  ADDWF  xF9,W
078EA:  MOVWF  01
078EC:  MOVLW  00
078EE:  ADDWFC xFA,W
078F0:  MOVWF  03
078F2:  MOVFF  01,3FB
078F6:  MOVWF  xFC
078F8:  MOVLW  0A
078FA:  ADDWF  xF9,W
078FC:  MOVWF  FE9
078FE:  MOVLW  00
07900:  ADDWFC xFA,W
07902:  MOVWF  FEA
07904:  MOVFF  FEC,400
07908:  MOVF   FED,F
0790A:  MOVFF  FEF,3FF
0790E:  MOVLB  0
07910:  CALL   6D9E
07914:  MOVFF  3FC,FEA
07918:  MOVFF  3FB,FE9
0791C:  MOVFF  02,FEC
07920:  MOVF   FED,F
07922:  MOVFF  01,FEF
07926:  RETURN 0
.................... } 
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
.................... 	TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
.................... 	WORD RemoteWindow; 
.................... 	 
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
06A12:  MOVLB  3
06A14:  CLRF   x51
06A16:  MOVF   x51,W
06A18:  SUBLW  04
06A1A:  BNC   6AE8
....................     { 
....................         ps = &TCB[s]; 
06A1C:  MOVF   x51,W
06A1E:  MULLW  24
06A20:  MOVF   FF3,W
06A22:  CLRF   03
06A24:  ADDLW  60
06A26:  MOVWF  01
06A28:  MOVLW  00
06A2A:  ADDWFC 03,F
06A2C:  MOVFF  01,352
06A30:  MOVFF  03,353
....................  
....................         ps->smState             = TCP_CLOSED; 
06A34:  MOVFF  352,FE9
06A38:  MOVFF  353,FEA
06A3C:  MOVLW  0A
06A3E:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
06A40:  MOVLW  23
06A42:  ADDWF  x52,W
06A44:  MOVWF  FE9
06A46:  MOVLW  00
06A48:  ADDWFC x53,W
06A4A:  MOVWF  FEA
06A4C:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
06A4E:  MOVLW  23
06A50:  ADDWF  x52,W
06A52:  MOVWF  FE9
06A54:  MOVLW  00
06A56:  ADDWFC x53,W
06A58:  MOVWF  FEA
06A5A:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
06A5C:  MOVLW  23
06A5E:  ADDWF  x52,W
06A60:  MOVWF  FE9
06A62:  MOVLW  00
06A64:  ADDWFC x53,W
06A66:  MOVWF  FEA
06A68:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
06A6A:  MOVLW  23
06A6C:  ADDWF  x52,W
06A6E:  MOVWF  FE9
06A70:  MOVLW  00
06A72:  ADDWFC x53,W
06A74:  MOVWF  FEA
06A76:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
06A78:  MOVLW  23
06A7A:  ADDWF  x52,W
06A7C:  MOVWF  FE9
06A7E:  MOVLW  00
06A80:  ADDWFC x53,W
06A82:  MOVWF  FEA
06A84:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
06A86:  MOVLW  0F
06A88:  ADDWF  x52,W
06A8A:  MOVWF  FE9
06A8C:  MOVLW  00
06A8E:  ADDWFC x53,W
06A90:  MOVWF  FEA
06A92:  INCFSZ FEF,W
06A94:  BRA    6A98
06A96:  BRA    6ABE
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
06A98:  MOVLW  0F
06A9A:  ADDWF  x52,W
06A9C:  MOVWF  FE9
06A9E:  MOVLW  00
06AA0:  ADDWFC x53,W
06AA2:  MOVWF  FEA
06AA4:  MOVFF  FEF,3A4
06AA8:  MOVLB  0
06AAA:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
06AAE:  MOVLW  0F
06AB0:  MOVLB  3
06AB2:  ADDWF  x52,W
06AB4:  MOVWF  FE9
06AB6:  MOVLW  00
06AB8:  ADDWFC x53,W
06ABA:  MOVWF  FEA
06ABC:  SETF   FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
06ABE:  MOVLW  21
06AC0:  ADDWF  x52,W
06AC2:  MOVWF  FE9
06AC4:  MOVLW  00
06AC6:  ADDWFC x53,W
06AC8:  MOVWF  FEA
06ACA:  CLRF   FEC
06ACC:  MOVF   FED,F
06ACE:  MOVLW  1E
06AD0:  MOVWF  FEF
....................       ps->TxCount            = 0; 
06AD2:  MOVLW  10
06AD4:  ADDWF  x52,W
06AD6:  MOVWF  FE9
06AD8:  MOVLW  00
06ADA:  ADDWFC x53,W
06ADC:  MOVWF  FEA
06ADE:  CLRF   FEC
06AE0:  MOVF   FED,F
06AE2:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
06AE4:  INCF   x51,F
06AE6:  BRA    6A16
....................     TCPInit_RandSeed+=get_timer0(); 
06AE8:  MOVF   FD6,W
06AEA:  MOVLB  1
06AEC:  ADDWF  x14,F
06AEE:  MOVF   FD7,W
06AF0:  ADDWFC x15,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
06AF2:  MOVF   FCE,W
06AF4:  ADDWF  x14,F
06AF6:  MOVF   FCF,W
06AF8:  ADDWFC x15,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
06AFA:  MOVF   FCC,W
06AFC:  ADDWF  x14,F
06AFE:  MOVLW  00
06B00:  ADDWFC x15,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
06B02:  MOVF   FB2,W
06B04:  ADDWF  x14,F
06B06:  MOVF   FB3,W
06B08:  ADDWFC x15,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
06B0A:  MOVLB  3
06B0C:  CLRF   x57
06B0E:  CLRF   x56
06B10:  MOVFF  115,355
06B14:  MOVFF  114,354
06B18:  MOVLB  0
06B1A:  BRA    68E6
....................     _NextPort=rand(); 
06B1C:  BRA    69A0
06B1E:  MOVFF  02,5F
06B22:  MOVFF  01,5E
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
06B26:  MOVLW  04
06B28:  ADDWF  5F,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
06B2A:  MOVF   5F,W
06B2C:  SUBLW  12
06B2E:  BC    6B44
06B30:  XORLW  FF
06B32:  BNZ   6B3A
06B34:  MOVF   5E,W
06B36:  SUBLW  87
06B38:  BC    6B44
06B3A:  MOVLW  88
06B3C:  SUBWF  5E,F
06B3E:  MOVLW  13
06B40:  SUBWFB 5F,F
06B42:  BRA    6B2A
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
06B44:  MOVF   5F,W
06B46:  SUBLW  03
06B48:  BNC   6B4E
06B4A:  MOVLW  04
06B4C:  ADDWF  5F,F
06B4E:  GOTO   6CC2 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
06B52:  MOVLB  3
06B54:  CLRF   x56
06B56:  MOVF   x56,W
06B58:  SUBLW  04
06B5A:  BNC   6C3E
....................    { 
....................       ps = &TCB[s]; 
06B5C:  MOVF   x56,W
06B5E:  MULLW  24
06B60:  MOVF   FF3,W
06B62:  CLRF   03
06B64:  ADDLW  60
06B66:  MOVWF  01
06B68:  MOVLW  00
06B6A:  ADDWFC 03,F
06B6C:  MOVFF  01,357
06B70:  MOVFF  03,358
....................  
....................       if(ps->smState == TCP_CLOSED) 
06B74:  MOVFF  357,FE9
06B78:  MOVFF  358,FEA
06B7C:  MOVF   FEF,W
06B7E:  SUBLW  0A
06B80:  BNZ   6C3A
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
06B82:  MOVFF  357,FE9
06B86:  MOVFF  358,FEA
06B8A:  CLRF   FEF
....................          ps->localPort           = port; 
06B8C:  MOVLW  0B
06B8E:  ADDWF  x57,W
06B90:  MOVWF  FE9
06B92:  MOVLW  00
06B94:  ADDWFC x58,W
06B96:  MOVWF  FEA
06B98:  MOVFF  355,FEC
06B9C:  MOVF   FED,F
06B9E:  MOVFF  354,FEF
....................          ps->remotePort          = 0; 
06BA2:  MOVLW  0D
06BA4:  ADDWF  x57,W
06BA6:  MOVWF  FE9
06BA8:  MOVLW  00
06BAA:  ADDWFC x58,W
06BAC:  MOVWF  FEA
06BAE:  CLRF   FEC
06BB0:  MOVF   FED,F
06BB2:  CLRF   FEF
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
06BB4:  MOVLW  07
06BB6:  ADDWF  x57,W
06BB8:  MOVWF  FE9
06BBA:  MOVLW  00
06BBC:  ADDWFC x58,W
06BBE:  MOVWF  FEA
06BC0:  MOVF   FEE,F
06BC2:  MOVF   FEE,F
06BC4:  CLRF   FEC
06BC6:  MOVF   FED,F
06BC8:  CLRF   FEF
06BCA:  MOVF   FED,F
06BCC:  CLRF   FEF
06BCE:  MOVF   FED,F
06BD0:  CLRF   FEF
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
06BD2:  MOVLW  23
06BD4:  ADDWF  x57,W
06BD6:  MOVWF  FE9
06BD8:  MOVLW  00
06BDA:  ADDWFC x58,W
06BDC:  MOVWF  FEA
06BDE:  BSF    FEF.0
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
06BE0:  MOVLW  23
06BE2:  ADDWF  x57,W
06BE4:  MOVWF  FE9
06BE6:  MOVLW  00
06BE8:  ADDWFC x58,W
06BEA:  MOVWF  FEA
06BEC:  BCF    FEF.3
....................          if(ps->TxBuffer != INVALID_BUFFER) 
06BEE:  MOVLW  0F
06BF0:  ADDWF  x57,W
06BF2:  MOVWF  FE9
06BF4:  MOVLW  00
06BF6:  ADDWFC x58,W
06BF8:  MOVWF  FEA
06BFA:  INCFSZ FEF,W
06BFC:  BRA    6C00
06BFE:  BRA    6C26
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
06C00:  MOVLW  0F
06C02:  ADDWF  x57,W
06C04:  MOVWF  FE9
06C06:  MOVLW  00
06C08:  ADDWFC x58,W
06C0A:  MOVWF  FEA
06C0C:  MOVFF  FEF,3A4
06C10:  MOVLB  0
06C12:  CALL   0004
....................             ps->TxBuffer        = INVALID_BUFFER; 
06C16:  MOVLW  0F
06C18:  MOVLB  3
06C1A:  ADDWF  x57,W
06C1C:  MOVWF  FE9
06C1E:  MOVLW  00
06C20:  ADDWFC x58,W
06C22:  MOVWF  FEA
06C24:  SETF   FEF
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
06C26:  MOVLW  23
06C28:  ADDWF  x57,W
06C2A:  MOVWF  FE9
06C2C:  MOVLW  00
06C2E:  ADDWFC x58,W
06C30:  MOVWF  FEA
06C32:  BSF    FEF.1
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
06C34:  MOVFF  356,01
06C38:  BRA    6C42
....................       } 
06C3A:  INCF   x56,F
06C3C:  BRA    6B56
....................    } 
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
06C3E:  MOVLW  FE
06C40:  MOVWF  01
06C42:  MOVLB  0
06C44:  GOTO   6C6E (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          lbFound = TRUE; 
....................          break; 
....................       } 
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
....................       return INVALID_SOCKET; 
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
....................    ps->SND_ACK = 0; 
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
....................  
....................    ps->smState = TCP_SYN_SENT; 
....................    ps->SND_SEQ++; 
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
*
099B8:  MOVLB  3
099BA:  MOVF   x5F,W
099BC:  MULLW  24
099BE:  MOVF   FF3,W
099C0:  CLRF   x61
099C2:  MOVWF  x60
099C4:  MOVLW  60
099C6:  ADDWF  x60,W
099C8:  MOVWF  FE9
099CA:  MOVLW  00
099CC:  ADDWFC x61,W
099CE:  MOVWF  FEA
099D0:  MOVF   FEF,W
099D2:  SUBLW  03
099D4:  BZ    99DA
099D6:  MOVLW  00
099D8:  BRA    99DC
099DA:  MOVLW  01
099DC:  MOVWF  01
099DE:  MOVLB  0
099E0:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
0B9B2:  MOVLB  3
0B9B4:  MOVF   x5F,W
0B9B6:  MULLW  24
0B9B8:  MOVF   FF3,W
0B9BA:  CLRF   03
0B9BC:  ADDLW  60
0B9BE:  MOVWF  01
0B9C0:  MOVLW  00
0B9C2:  ADDWFC 03,F
0B9C4:  MOVFF  01,360
0B9C8:  MOVFF  03,361
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
0B9CC:  MOVFF  360,FE9
0B9D0:  MOVFF  361,FEA
0B9D4:  MOVF   FEF,W
0B9D6:  SUBLW  03
0B9D8:  BZ    B9FA
0B9DA:  MOVFF  360,FE9
0B9DE:  MOVFF  361,FEA
0B9E2:  MOVF   FEF,W
0B9E4:  SUBLW  02
0B9E6:  BZ    B9FA
....................    { 
....................       CloseSocket(ps); 
0B9E8:  MOVFF  361,3A2
0B9EC:  MOVFF  360,3A1
0B9F0:  MOVLB  0
0B9F2:  CALL   8092
....................       return; 
0B9F6:  BRA    BABA
0B9F8:  MOVLB  3
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
0B9FA:  MOVFF  35F,362
0B9FE:  MOVLB  0
0BA00:  CALL   A90C
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
0BA04:  MOVLW  01
0BA06:  MOVLB  3
0BA08:  ADDWF  x60,W
0BA0A:  MOVWF  01
0BA0C:  MOVLW  00
0BA0E:  ADDWFC x61,W
0BA10:  MOVWF  03
0BA12:  MOVFF  01,362
0BA16:  MOVWF  x63
0BA18:  MOVLW  0B
0BA1A:  ADDWF  x60,W
0BA1C:  MOVWF  FE9
0BA1E:  MOVLW  00
0BA20:  ADDWFC x61,W
0BA22:  MOVWF  FEA
0BA24:  MOVFF  FEC,3AB
0BA28:  MOVF   FED,F
0BA2A:  MOVFF  FEF,3AA
0BA2E:  MOVLW  0D
0BA30:  ADDWF  x60,W
0BA32:  MOVWF  FE9
0BA34:  MOVLW  00
0BA36:  ADDWFC x61,W
0BA38:  MOVWF  FEA
0BA3A:  MOVFF  FEC,3AD
0BA3E:  MOVF   FED,F
0BA40:  MOVFF  FEF,3AC
0BA44:  MOVLW  16
0BA46:  ADDWF  x60,W
0BA48:  MOVWF  FE9
0BA4A:  MOVLW  00
0BA4C:  ADDWFC x61,W
0BA4E:  MOVWF  FEA
0BA50:  MOVFF  FEF,3AE
0BA54:  MOVFF  FEC,3AF
0BA58:  MOVFF  FEC,3B0
0BA5C:  MOVFF  FEC,3B1
0BA60:  MOVLW  1A
0BA62:  ADDWF  x60,W
0BA64:  MOVWF  FE9
0BA66:  MOVLW  00
0BA68:  ADDWFC x61,W
0BA6A:  MOVWF  FEA
0BA6C:  MOVFF  FEF,3B2
0BA70:  MOVFF  FEC,3B3
0BA74:  MOVFF  FEC,3B4
0BA78:  MOVFF  FEC,3B5
0BA7C:  MOVFF  03,3A9
0BA80:  MOVFF  01,3A8
0BA84:  MOVLW  11
0BA86:  MOVWF  xB6
0BA88:  SETF   xB7
0BA8A:  CLRF   xB9
0BA8C:  CLRF   xB8
0BA8E:  MOVLB  0
0BA90:  CALL   84E0
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
0BA94:  MOVLW  16
0BA96:  MOVLB  3
0BA98:  ADDWF  x60,W
0BA9A:  MOVWF  FE9
0BA9C:  MOVLW  00
0BA9E:  ADDWFC x61,W
0BAA0:  MOVWF  FEA
0BAA2:  MOVLW  01
0BAA4:  ADDWF  FEE,F
0BAA6:  MOVLW  00
0BAA8:  ADDWFC FEE,F
0BAAA:  ADDWFC FEE,F
0BAAC:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
0BAAE:  MOVFF  360,FE9
0BAB2:  MOVFF  361,FEA
0BAB6:  MOVLW  04
0BAB8:  MOVWF  FEF
0BABA:  MOVLB  0
....................  
....................    return; 
0BABC:  GOTO   C6C8 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
0A9FE:  MOVLB  3
0AA00:  MOVF   x94,W
0AA02:  MULLW  24
0AA04:  MOVF   FF3,W
0AA06:  CLRF   03
0AA08:  ADDLW  60
0AA0A:  MOVWF  01
0AA0C:  MOVLW  00
0AA0E:  ADDWFC 03,F
0AA10:  MOVFF  01,395
0AA14:  MOVFF  03,396
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
0AA18:  MOVLW  0F
0AA1A:  ADDWF  x95,W
0AA1C:  MOVWF  FE9
0AA1E:  MOVLW  00
0AA20:  ADDWFC x96,W
0AA22:  MOVWF  FEA
0AA24:  INCFSZ FEF,W
0AA26:  BRA    AA2E
....................       return FALSE; 
0AA28:  MOVLW  00
0AA2A:  MOVWF  01
0AA2C:  BRA    AB88
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
0AA2E:  MOVLW  23
0AA30:  ADDWF  x95,W
0AA32:  MOVWF  FE9
0AA34:  MOVLW  00
0AA36:  ADDWFC x96,W
0AA38:  MOVWF  FEA
0AA3A:  MOVFF  FEF,00
0AA3E:  RRCF   00,W
0AA40:  ANDLW  01
0AA42:  BNZ   AA4A
....................       return FALSE; 
0AA44:  MOVLW  00
0AA46:  MOVWF  01
0AA48:  BRA    AB88
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
0AA4A:  MOVLW  01
0AA4C:  ADDWF  x95,W
0AA4E:  MOVWF  01
0AA50:  MOVLW  00
0AA52:  ADDWFC x96,W
0AA54:  MOVWF  03
0AA56:  MOVFF  01,397
0AA5A:  MOVWF  x98
0AA5C:  MOVLW  0B
0AA5E:  ADDWF  x95,W
0AA60:  MOVWF  FE9
0AA62:  MOVLW  00
0AA64:  ADDWFC x96,W
0AA66:  MOVWF  FEA
0AA68:  MOVFF  FEC,3AB
0AA6C:  MOVF   FED,F
0AA6E:  MOVFF  FEF,3AA
0AA72:  MOVLW  0D
0AA74:  ADDWF  x95,W
0AA76:  MOVWF  FE9
0AA78:  MOVLW  00
0AA7A:  ADDWFC x96,W
0AA7C:  MOVWF  FEA
0AA7E:  MOVFF  FEC,3AD
0AA82:  MOVF   FED,F
0AA84:  MOVFF  FEF,3AC
0AA88:  MOVLW  16
0AA8A:  ADDWF  x95,W
0AA8C:  MOVWF  FE9
0AA8E:  MOVLW  00
0AA90:  ADDWFC x96,W
0AA92:  MOVWF  FEA
0AA94:  MOVFF  FEF,3AE
0AA98:  MOVFF  FEC,3AF
0AA9C:  MOVFF  FEC,3B0
0AAA0:  MOVFF  FEC,3B1
0AAA4:  MOVLW  1A
0AAA6:  ADDWF  x95,W
0AAA8:  MOVWF  FE9
0AAAA:  MOVLW  00
0AAAC:  ADDWFC x96,W
0AAAE:  MOVWF  FEA
0AAB0:  MOVFF  FEF,3B2
0AAB4:  MOVFF  FEC,3B3
0AAB8:  MOVFF  FEC,3B4
0AABC:  MOVFF  FEC,3B5
0AAC0:  MOVLW  0F
0AAC2:  ADDWF  x95,W
0AAC4:  MOVWF  FE9
0AAC6:  MOVLW  00
0AAC8:  ADDWFC x96,W
0AACA:  MOVWF  FEA
0AACC:  MOVFF  FEF,3B7
0AAD0:  MOVLW  10
0AAD2:  ADDWF  x95,W
0AAD4:  MOVWF  FE9
0AAD6:  MOVLW  00
0AAD8:  ADDWFC x96,W
0AADA:  MOVWF  FEA
0AADC:  MOVFF  FEC,3B9
0AAE0:  MOVF   FED,F
0AAE2:  MOVFF  FEF,3B8
0AAE6:  MOVFF  03,3A9
0AAEA:  MOVFF  01,3A8
0AAEE:  MOVLW  18
0AAF0:  MOVWF  xB6
0AAF2:  MOVLB  0
0AAF4:  CALL   84E0
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
0AAF8:  MOVLW  16
0AAFA:  MOVLB  3
0AAFC:  ADDWF  x95,W
0AAFE:  MOVWF  01
0AB00:  MOVLW  00
0AB02:  ADDWFC x96,W
0AB04:  MOVWF  03
0AB06:  MOVFF  01,397
0AB0A:  MOVWF  x98
0AB0C:  MOVWF  FEA
0AB0E:  MOVFF  01,FE9
0AB12:  MOVFF  FEF,399
0AB16:  MOVFF  FEC,39A
0AB1A:  MOVFF  FEC,39B
0AB1E:  MOVFF  FEC,39C
0AB22:  MOVLW  10
0AB24:  ADDWF  x95,W
0AB26:  MOVWF  FE9
0AB28:  MOVLW  00
0AB2A:  ADDWFC x96,W
0AB2C:  MOVWF  FEA
0AB2E:  MOVFF  FEC,03
0AB32:  MOVF   FED,F
0AB34:  MOVFF  FEF,00
0AB38:  MOVFF  03,01
0AB3C:  CLRF   02
0AB3E:  CLRF   03
0AB40:  MOVF   x99,W
0AB42:  ADDWF  00,F
0AB44:  MOVF   x9A,W
0AB46:  ADDWFC 01,F
0AB48:  MOVF   x9B,W
0AB4A:  ADDWFC 02,F
0AB4C:  MOVF   x9C,W
0AB4E:  ADDWFC 03,F
0AB50:  MOVFF  398,FEA
0AB54:  MOVFF  397,FE9
0AB58:  MOVFF  00,FEF
0AB5C:  MOVFF  01,FEC
0AB60:  MOVFF  02,FEC
0AB64:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
0AB68:  MOVLW  23
0AB6A:  ADDWF  x95,W
0AB6C:  MOVWF  FE9
0AB6E:  MOVLW  00
0AB70:  ADDWFC x96,W
0AB72:  MOVWF  FEA
0AB74:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
0AB76:  MOVLW  23
0AB78:  ADDWF  x95,W
0AB7A:  MOVWF  FE9
0AB7C:  MOVLW  00
0AB7E:  ADDWFC x96,W
0AB80:  MOVWF  FEA
0AB82:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
0AB84:  MOVLW  01
0AB86:  MOVWF  01
0AB88:  MOVLB  0
0AB8A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
0A95A:  MOVLB  3
0A95C:  MOVF   x82,W
0A95E:  MULLW  24
0A960:  MOVF   FF3,W
0A962:  CLRF   x84
0A964:  MOVWF  x83
0A966:  MOVLW  14
0A968:  ADDWF  x83,W
0A96A:  MOVWF  01
0A96C:  MOVLW  00
0A96E:  ADDWFC x84,W
0A970:  MOVWF  03
0A972:  MOVF   01,W
0A974:  ADDLW  60
0A976:  MOVWF  FE9
0A978:  MOVLW  00
0A97A:  ADDWFC 03,W
0A97C:  MOVWF  FEA
0A97E:  MOVFF  FEC,384
0A982:  MOVF   FED,F
0A984:  MOVFF  FEF,383
0A988:  MOVF   x83,F
0A98A:  BNZ   A996
0A98C:  MOVF   x84,F
0A98E:  BNZ   A996
....................       return FALSE; 
0A990:  MOVLW  00
0A992:  MOVWF  01
0A994:  BRA    A9F2
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
0A996:  MOVF   x82,W
0A998:  MULLW  24
0A99A:  MOVF   FF3,W
0A99C:  CLRF   x84
0A99E:  MOVWF  x83
0A9A0:  MOVLW  0F
0A9A2:  ADDWF  x83,W
0A9A4:  MOVWF  01
0A9A6:  MOVLW  00
0A9A8:  ADDWFC x84,W
0A9AA:  MOVWF  03
0A9AC:  MOVF   01,W
0A9AE:  ADDLW  60
0A9B0:  MOVWF  FE9
0A9B2:  MOVLW  00
0A9B4:  ADDWFC 03,W
0A9B6:  MOVWF  FEA
0A9B8:  INCFSZ FEF,W
0A9BA:  BRA    A9CC
....................       return IPIsTxReady(FALSE); 
0A9BC:  CLRF   xE0
0A9BE:  MOVLB  0
0A9C0:  CALL   8190
0A9C4:  MOVF   01,W
0A9C6:  MOVLB  3
0A9C8:  BRA    A9F2
0A9CA:  BRA    A9F2
....................    else 
....................       return TCB[s].Flags.bIsPutReady; 
0A9CC:  MOVF   x82,W
0A9CE:  MULLW  24
0A9D0:  MOVF   FF3,W
0A9D2:  CLRF   x84
0A9D4:  MOVWF  x83
0A9D6:  MOVLW  23
0A9D8:  ADDWF  x83,F
0A9DA:  MOVLW  00
0A9DC:  ADDWFC x84,F
0A9DE:  MOVLW  60
0A9E0:  ADDWF  x83,W
0A9E2:  MOVWF  FE9
0A9E4:  MOVLW  00
0A9E6:  ADDWFC x84,W
0A9E8:  MOVWF  FEA
0A9EA:  MOVLW  00
0A9EC:  BTFSC  FEF.1
0A9EE:  MOVLW  01
0A9F0:  MOVWF  01
0A9F2:  MOVLB  0
0A9F4:  RETURN 0
.................... } 
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
*
0AE14:  MOVFF  37D,382
0AE18:  RCALL  A95A
0AE1A:  MOVF   01,F
0AE1C:  BNZ   AE26
....................       return(0); 
0AE1E:  MOVLW  00
0AE20:  MOVWF  01
0AE22:  MOVWF  02
0AE24:  BRA    AF0A
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
0AE26:  MOVLB  3
0AE28:  MOVF   x7D,W
0AE2A:  MULLW  24
0AE2C:  MOVF   FF3,W
0AE2E:  CLRF   x83
0AE30:  MOVWF  x82
0AE32:  MOVLW  0F
0AE34:  ADDWF  x82,W
0AE36:  MOVWF  01
0AE38:  MOVLW  00
0AE3A:  ADDWFC x83,W
0AE3C:  MOVWF  03
0AE3E:  MOVF   01,W
0AE40:  ADDLW  60
0AE42:  MOVWF  FE9
0AE44:  MOVLW  00
0AE46:  ADDWFC 03,W
0AE48:  MOVWF  FEA
0AE4A:  INCFSZ FEF,W
0AE4C:  BRA    AE54
....................       txCount = 0; 
0AE4E:  CLRF   x7F
0AE50:  CLRF   x7E
0AE52:  BRA    AE80
....................    else 
....................       txCount = TCB[s].TxCount; 
0AE54:  MOVF   x7D,W
0AE56:  MULLW  24
0AE58:  MOVF   FF3,W
0AE5A:  CLRF   x83
0AE5C:  MOVWF  x82
0AE5E:  MOVLW  10
0AE60:  ADDWF  x82,W
0AE62:  MOVWF  01
0AE64:  MOVLW  00
0AE66:  ADDWFC x83,W
0AE68:  MOVWF  03
0AE6A:  MOVF   01,W
0AE6C:  ADDLW  60
0AE6E:  MOVWF  FE9
0AE70:  MOVLW  00
0AE72:  ADDWFC 03,W
0AE74:  MOVWF  FEA
0AE76:  MOVFF  FEC,37F
0AE7A:  MOVF   FED,F
0AE7C:  MOVFF  FEF,37E
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
0AE80:  MOVLW  CA
0AE82:  BSF    FD8.0
0AE84:  SUBFWB x7E,W
0AE86:  MOVWF  x80
0AE88:  MOVLW  03
0AE8A:  SUBFWB x7F,W
0AE8C:  MOVWF  x81
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
0AE8E:  MOVF   x7D,W
0AE90:  MULLW  24
0AE92:  MOVF   FF3,W
0AE94:  CLRF   x83
0AE96:  MOVWF  x82
0AE98:  MOVLW  14
0AE9A:  ADDWF  x82,W
0AE9C:  MOVWF  01
0AE9E:  MOVLW  00
0AEA0:  ADDWFC x83,W
0AEA2:  MOVWF  03
0AEA4:  MOVF   01,W
0AEA6:  ADDLW  60
0AEA8:  MOVWF  FE9
0AEAA:  MOVLW  00
0AEAC:  ADDWFC 03,W
0AEAE:  MOVWF  FEA
0AEB0:  MOVFF  FEC,03
0AEB4:  MOVF   FED,F
0AEB6:  MOVFF  FEF,01
0AEBA:  MOVF   03,W
0AEBC:  SUBWF  x81,W
0AEBE:  BNC   AEF4
0AEC0:  BNZ   AEC8
0AEC2:  MOVF   x80,W
0AEC4:  SUBWF  01,W
0AEC6:  BC    AEF4
0AEC8:  MOVF   x7D,W
0AECA:  MULLW  24
0AECC:  MOVF   FF3,W
0AECE:  CLRF   x83
0AED0:  MOVWF  x82
0AED2:  MOVLW  14
0AED4:  ADDWF  x82,W
0AED6:  MOVWF  01
0AED8:  MOVLW  00
0AEDA:  ADDWFC x83,W
0AEDC:  MOVWF  03
0AEDE:  MOVF   01,W
0AEE0:  ADDLW  60
0AEE2:  MOVWF  FE9
0AEE4:  MOVLW  00
0AEE6:  ADDWFC 03,W
0AEE8:  MOVWF  FEA
0AEEA:  MOVFF  FEC,03
0AEEE:  MOVF   FED,F
0AEF0:  MOVF   FEF,W
0AEF2:  BRA    AEFA
0AEF4:  MOVFF  381,03
0AEF8:  MOVF   x80,W
0AEFA:  MOVWF  x80
0AEFC:  MOVFF  03,381
....................  
....................    return(txAvail); 
0AF00:  MOVFF  380,01
0AF04:  MOVFF  381,02
0AF08:  MOVLB  0
0AF0A:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return 0; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return 0; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    while (n--) 
....................    { 
....................       MACPut(*ptr++); 
....................       ps->RemoteWindow -= 1; 
....................       ps->TxCount += 1; 
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return(len); 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
*
0AB8C:  MOVLB  3
0AB8E:  MOVF   x8E,W
0AB90:  MULLW  24
0AB92:  MOVF   FF3,W
0AB94:  CLRF   03
0AB96:  ADDLW  60
0AB98:  MOVWF  01
0AB9A:  MOVLW  00
0AB9C:  ADDWFC 03,F
0AB9E:  MOVFF  01,390
0ABA2:  MOVFF  03,391
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
0ABA6:  MOVLW  14
0ABA8:  ADDWF  x90,W
0ABAA:  MOVWF  FE9
0ABAC:  MOVLW  00
0ABAE:  ADDWFC x91,W
0ABB0:  MOVWF  FEA
0ABB2:  MOVFF  FEC,395
0ABB6:  MOVF   FED,F
0ABB8:  MOVFF  FEF,394
0ABBC:  MOVF   x94,F
0ABBE:  BNZ   ABCA
0ABC0:  MOVF   x95,F
0ABC2:  BNZ   ABCA
....................       return FALSE; 
0ABC4:  MOVLW  00
0ABC6:  MOVWF  01
0ABC8:  BRA    ACC8
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
0ABCA:  MOVLW  0F
0ABCC:  ADDWF  x90,W
0ABCE:  MOVWF  FE9
0ABD0:  MOVLW  00
0ABD2:  ADDWFC x91,W
0ABD4:  MOVWF  FEA
0ABD6:  INCFSZ FEF,W
0ABD8:  BRA    AC48
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
0ABDA:  MOVLW  0F
0ABDC:  ADDWF  x90,W
0ABDE:  MOVWF  01
0ABE0:  MOVLW  00
0ABE2:  ADDWFC x91,W
0ABE4:  MOVWF  03
0ABE6:  MOVFF  01,394
0ABEA:  MOVWF  x95
0ABEC:  CLRF   xE0
0ABEE:  MOVLB  0
0ABF0:  CALL   7098
0ABF4:  MOVFF  395,FEA
0ABF8:  MOVFF  394,FE9
0ABFC:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
0AC00:  MOVLW  0F
0AC02:  MOVLB  3
0AC04:  ADDWF  x90,W
0AC06:  MOVWF  FE9
0AC08:  MOVLW  00
0AC0A:  ADDWFC x91,W
0AC0C:  MOVWF  FEA
0AC0E:  INCFSZ FEF,W
0AC10:  BRA    AC18
....................          return FALSE; 
0AC12:  MOVLW  00
0AC14:  MOVWF  01
0AC16:  BRA    ACC8
....................  
....................       ps->TxCount = 0; 
0AC18:  MOVLW  10
0AC1A:  ADDWF  x90,W
0AC1C:  MOVWF  FE9
0AC1E:  MOVLW  00
0AC20:  ADDWFC x91,W
0AC22:  MOVWF  FEA
0AC24:  CLRF   FEC
0AC26:  MOVF   FED,F
0AC28:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
0AC2A:  MOVLW  0F
0AC2C:  ADDWF  x90,W
0AC2E:  MOVWF  FE9
0AC30:  MOVLW  00
0AC32:  ADDWFC x91,W
0AC34:  MOVWF  FEA
0AC36:  MOVFF  FEF,3F9
0AC3A:  CLRF   xFB
0AC3C:  MOVLW  28
0AC3E:  MOVWF  xFA
0AC40:  MOVLB  0
0AC42:  CALL   70C0
0AC46:  MOVLB  3
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
0AC48:  MOVLW  23
0AC4A:  ADDWF  x90,W
0AC4C:  MOVWF  FE9
0AC4E:  MOVLW  00
0AC50:  ADDWFC x91,W
0AC52:  MOVWF  FEA
0AC54:  BSF    FEF.4
....................  
....................    MACPut(byte); 
0AC56:  MOVFF  38F,403
0AC5A:  MOVLB  0
0AC5C:  CALL   7168
....................    ps->RemoteWindow--; 
0AC60:  MOVLW  14
0AC62:  MOVLB  3
0AC64:  ADDWF  x90,W
0AC66:  MOVWF  FE9
0AC68:  MOVLW  00
0AC6A:  ADDWFC x91,W
0AC6C:  MOVWF  FEA
0AC6E:  MOVLW  FF
0AC70:  ADDWF  FEF,F
0AC72:  BC    AC78
0AC74:  MOVF   FEE,F
0AC76:  DECF   FED,F
....................  
....................    tempCount = ps->TxCount; 
0AC78:  MOVLW  10
0AC7A:  ADDWF  x90,W
0AC7C:  MOVWF  FE9
0AC7E:  MOVLW  00
0AC80:  ADDWFC x91,W
0AC82:  MOVWF  FEA
0AC84:  MOVFF  FEC,393
0AC88:  MOVF   FED,F
0AC8A:  MOVFF  FEF,392
....................    tempCount++; 
0AC8E:  INCF   x92,F
0AC90:  BTFSC  FD8.2
0AC92:  INCF   x93,F
....................    ps->TxCount = tempCount; 
0AC94:  MOVLW  10
0AC96:  ADDWF  x90,W
0AC98:  MOVWF  FE9
0AC9A:  MOVLW  00
0AC9C:  ADDWFC x91,W
0AC9E:  MOVWF  FEA
0ACA0:  MOVFF  393,FEC
0ACA4:  MOVF   FED,F
0ACA6:  MOVFF  392,FEF
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
0ACAA:  MOVF   x93,W
0ACAC:  SUBLW  02
0ACAE:  BC    ACC4
0ACB0:  XORLW  FF
0ACB2:  BNZ   ACBA
0ACB4:  MOVF   x92,W
0ACB6:  SUBLW  C9
0ACB8:  BC    ACC4
....................       TCPFlush(s); 
0ACBA:  MOVFF  38E,394
0ACBE:  MOVLB  0
0ACC0:  RCALL  A9FE
0ACC2:  MOVLB  3
....................  
....................    return TRUE; 
0ACC4:  MOVLW  01
0ACC6:  MOVWF  01
0ACC8:  MOVLB  0
0ACCA:  GOTO   ACD8 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
0A90C:  MOVLB  3
0A90E:  MOVF   x62,W
0A910:  MULLW  24
0A912:  MOVF   FF3,W
0A914:  CLRF   03
0A916:  ADDLW  60
0A918:  MOVWF  01
0A91A:  MOVLW  00
0A91C:  ADDWFC 03,F
0A91E:  MOVFF  01,363
0A922:  MOVFF  03,364
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
0A926:  MOVLW  23
0A928:  ADDWF  x63,W
0A92A:  MOVWF  FE9
0A92C:  MOVLW  00
0A92E:  ADDWFC x64,W
0A930:  MOVWF  FEA
0A932:  BTFSC  FEF.3
0A934:  BRA    A93C
....................         return FALSE; 
0A936:  MOVLW  00
0A938:  MOVWF  01
0A93A:  BRA    A956
....................  
....................     MACDiscardRx(); 
0A93C:  MOVLB  0
0A93E:  CALL   6CC8
....................     ps->Flags.bIsGetReady = FALSE; 
0A942:  MOVLW  23
0A944:  MOVLB  3
0A946:  ADDWF  x63,W
0A948:  MOVWF  FE9
0A94A:  MOVLW  00
0A94C:  ADDWFC x64,W
0A94E:  MOVWF  FEA
0A950:  BCF    FEF.3
....................  
....................     return TRUE; 
0A952:  MOVLW  01
0A954:  MOVWF  01
0A956:  MOVLB  0
0A958:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
09A0E:  MOVLB  3
09A10:  MOVF   x5F,W
09A12:  MULLW  24
09A14:  MOVF   FF3,W
09A16:  CLRF   03
09A18:  ADDLW  60
09A1A:  MOVWF  01
09A1C:  MOVLW  00
09A1E:  ADDWFC 03,F
09A20:  MOVFF  01,362
09A24:  MOVFF  03,363
....................  
....................     if ( ps->Flags.bIsGetReady ) 
09A28:  MOVLW  23
09A2A:  ADDWF  x62,W
09A2C:  MOVWF  FE9
09A2E:  MOVLW  00
09A30:  ADDWFC x63,W
09A32:  MOVWF  FEA
09A34:  BTFSS  FEF.3
09A36:  BRA    9ADA
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
09A38:  MOVLW  23
09A3A:  ADDWF  x62,W
09A3C:  MOVWF  FE9
09A3E:  MOVLW  00
09A40:  ADDWFC x63,W
09A42:  MOVWF  FEA
09A44:  BTFSS  FEF.2
09A46:  BRA    9A64
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
09A48:  CLRF   x85
09A4A:  MOVLW  14
09A4C:  MOVWF  x84
09A4E:  MOVLB  0
09A50:  CALL   7C80
....................  
....................             ps->Flags.bFirstRead = FALSE; 
09A54:  MOVLW  23
09A56:  MOVLB  3
09A58:  ADDWF  x62,W
09A5A:  MOVWF  FE9
09A5C:  MOVLW  00
09A5E:  ADDWFC x63,W
09A60:  MOVWF  FEA
09A62:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
09A64:  MOVLW  12
09A66:  ADDWF  x62,W
09A68:  MOVWF  FE9
09A6A:  MOVLW  00
09A6C:  ADDWFC x63,W
09A6E:  MOVWF  FEA
09A70:  MOVFF  FEC,365
09A74:  MOVF   FED,F
09A76:  MOVFF  FEF,364
09A7A:  MOVF   x64,F
09A7C:  BNZ   9A9E
09A7E:  MOVF   x65,F
09A80:  BNZ   9A9E
....................         { 
....................             MACDiscardRx(); 
09A82:  MOVLB  0
09A84:  CALL   6CC8
....................             ps->Flags.bIsGetReady = FALSE; 
09A88:  MOVLW  23
09A8A:  MOVLB  3
09A8C:  ADDWF  x62,W
09A8E:  MOVWF  FE9
09A90:  MOVLW  00
09A92:  ADDWFC x63,W
09A94:  MOVWF  FEA
09A96:  BCF    FEF.3
....................             return FALSE; 
09A98:  MOVLW  00
09A9A:  MOVWF  01
09A9C:  BRA    9ADE
....................         } 
....................  
....................          ps->RxCount--; 
09A9E:  MOVLW  12
09AA0:  ADDWF  x62,W
09AA2:  MOVWF  FE9
09AA4:  MOVLW  00
09AA6:  ADDWFC x63,W
09AA8:  MOVWF  FEA
09AAA:  MOVLW  FF
09AAC:  ADDWF  FEF,F
09AAE:  BC    9AB4
09AB0:  MOVF   FEE,F
09AB2:  DECF   FED,F
....................          *data = MACGet(); 
09AB4:  MOVFF  361,03
09AB8:  MOVFF  360,364
09ABC:  MOVFF  361,365
09AC0:  MOVLB  0
09AC2:  CALL   7AF8
09AC6:  MOVFF  365,FEA
09ACA:  MOVFF  364,FE9
09ACE:  MOVFF  01,FEF
....................         return TRUE; 
09AD2:  MOVLW  01
09AD4:  MOVWF  01
09AD6:  MOVLB  3
09AD8:  BRA    9ADE
....................     } 
....................     return FALSE; 
09ADA:  MOVLW  00
09ADC:  MOVWF  01
09ADE:  MOVLB  0
09AE0:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
099E2:  MOVLB  3
099E4:  MOVF   x5F,W
099E6:  MULLW  24
099E8:  MOVF   FF3,W
099EA:  CLRF   x61
099EC:  MOVWF  x60
099EE:  MOVLW  23
099F0:  ADDWF  x60,F
099F2:  MOVLW  00
099F4:  ADDWFC x61,F
099F6:  MOVLW  60
099F8:  ADDWF  x60,W
099FA:  MOVWF  FE9
099FC:  MOVLW  00
099FE:  ADDWFC x61,W
09A00:  MOVWF  FEA
09A02:  MOVLW  00
09A04:  BTFSC  FEF.3
09A06:  MOVLW  01
09A08:  MOVWF  01
09A0A:  MOVLB  0
09A0C:  RETURN 0
.................... } 
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
09548:  MOVLB  3
0954A:  CLRF   x62
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
0954C:  CLRF   x57
0954E:  MOVF   x57,W
09550:  SUBLW  04
09552:  BTFSS  FD8.0
09554:  BRA    9986
....................    { 
....................       ps = &TCB[s]; 
09556:  MOVF   x57,W
09558:  MULLW  24
0955A:  MOVF   FF3,W
0955C:  CLRF   03
0955E:  ADDLW  60
09560:  MOVWF  01
09562:  MOVLW  00
09564:  ADDWFC 03,F
09566:  MOVFF  01,35C
0956A:  MOVFF  03,35D
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
0956E:  MOVLW  23
09570:  ADDWF  x5C,W
09572:  MOVWF  FE9
09574:  MOVLW  00
09576:  ADDWFC x5D,W
09578:  MOVWF  FEA
0957A:  BTFSC  FEF.3
0957C:  BRA    958E
0957E:  MOVLW  23
09580:  ADDWF  x5C,W
09582:  MOVWF  FE9
09584:  MOVLW  00
09586:  ADDWFC x5D,W
09588:  MOVWF  FEA
0958A:  BTFSS  FEF.4
0958C:  BRA    9590
....................          continue; 
0958E:  BRA    9982
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
09590:  MOVFF  35C,FE9
09594:  MOVFF  35D,FEA
09598:  MOVF   FEF,W
0959A:  SUBLW  0A
0959C:  BZ    95BE
0959E:  MOVFF  35C,FE9
095A2:  MOVFF  35D,FEA
095A6:  MOVF   FEF,F
095A8:  BNZ   95C0
095AA:  MOVLW  23
095AC:  ADDWF  x5C,W
095AE:  MOVWF  FE9
095B0:  MOVLW  00
095B2:  ADDWFC x5D,W
095B4:  MOVWF  FEA
095B6:  MOVF   FEF,W
095B8:  ANDLW  01
095BA:  SUBLW  01
095BC:  BNZ   95C0
....................          continue; 
095BE:  BRA    9982
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
095C0:  MOVFF  35C,FE9
095C4:  MOVFF  35D,FEA
095C8:  MOVF   FEF,W
095CA:  SUBLW  03
095CC:  BNZ   95E4
095CE:  MOVLW  23
095D0:  ADDWF  x5C,W
095D2:  MOVWF  FE9
095D4:  MOVLW  00
095D6:  ADDWFC x5D,W
095D8:  MOVWF  FEA
095DA:  MOVF   FEF,W
095DC:  ANDLW  01
095DE:  SUBLW  01
095E0:  BNZ   95E4
....................          continue; 
095E2:  BRA    9982
....................  
....................  
....................       tick = TickGet(); 
095E4:  MOVLB  0
095E6:  CALL   8078
095EA:  MOVFF  02,35B
095EE:  MOVFF  01,35A
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
095F2:  MOVLW  1F
095F4:  MOVLB  3
095F6:  ADDWF  x5C,W
095F8:  MOVWF  FE9
095FA:  MOVLW  00
095FC:  ADDWFC x5D,W
095FE:  MOVWF  FEA
09600:  MOVFF  FEC,03
09604:  MOVF   FED,F
09606:  MOVFF  FEF,01
0960A:  MOVF   x5B,W
0960C:  SUBWF  03,W
0960E:  BNC   9618
09610:  BNZ   961C
09612:  MOVF   01,W
09614:  SUBWF  x5A,W
09616:  BNC   961C
09618:  MOVLW  00
0961A:  BRA    961E
0961C:  MOVLW  01
0961E:  CLRF   03
09620:  IORWF  03,W
09622:  BZ    965A
09624:  MOVLW  1F
09626:  ADDWF  x5C,W
09628:  MOVWF  FE9
0962A:  MOVLW  00
0962C:  ADDWFC x5D,W
0962E:  MOVWF  FEA
09630:  MOVFF  FEC,03
09634:  MOVF   FED,F
09636:  MOVF   FEF,W
09638:  SUBLW  FF
0963A:  MOVWF  x63
0963C:  MOVLW  FF
0963E:  SUBFWB 03,W
09640:  MOVWF  x64
09642:  MOVF   x5A,W
09644:  ADDWF  x63,F
09646:  MOVF   x5B,W
09648:  ADDWFC x64,F
0964A:  MOVLW  01
0964C:  ADDWF  x63,W
0964E:  MOVWF  01
09650:  MOVLW  00
09652:  ADDWFC x64,W
09654:  MOVWF  03
09656:  MOVF   01,W
09658:  BRA    967A
0965A:  MOVLW  1F
0965C:  ADDWF  x5C,W
0965E:  MOVWF  FE9
09660:  MOVLW  00
09662:  ADDWFC x5D,W
09664:  MOVWF  FEA
09666:  MOVFF  FEC,03
0966A:  MOVF   FED,F
0966C:  MOVF   FEF,W
0966E:  SUBWF  x5A,W
09670:  MOVWF  00
09672:  MOVF   03,W
09674:  SUBWFB x5B,W
09676:  MOVWF  03
09678:  MOVF   00,W
0967A:  MOVWF  x58
0967C:  MOVFF  03,359
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
09680:  MOVLW  21
09682:  ADDWF  x5C,W
09684:  MOVWF  FE9
09686:  MOVLW  00
09688:  ADDWFC x5D,W
0968A:  MOVWF  FEA
0968C:  MOVFF  FEC,03
09690:  MOVF   FED,F
09692:  MOVFF  FEF,01
09696:  MOVF   x59,W
09698:  SUBWF  03,W
0969A:  BNC   96A6
0969C:  BNZ   96A4
0969E:  MOVF   x58,W
096A0:  SUBWF  01,W
096A2:  BNC   96A6
....................          continue; 
096A4:  BRA    9982
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
096A6:  MOVLW  01
096A8:  MOVWF  xE0
096AA:  MOVLB  0
096AC:  CALL   8190
096B0:  MOVF   01,F
096B2:  BNZ   96B6
....................          return; 
096B4:  BRA    9986
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
096B6:  MOVLW  1F
096B8:  MOVLB  3
096BA:  ADDWF  x5C,W
096BC:  MOVWF  01
096BE:  MOVLW  00
096C0:  ADDWFC x5D,W
096C2:  MOVWF  03
096C4:  MOVFF  01,363
096C8:  MOVWF  x64
096CA:  MOVLB  0
096CC:  CALL   8078
096D0:  MOVFF  364,FEA
096D4:  MOVFF  363,FE9
096D8:  MOVFF  02,FEC
096DC:  MOVF   FED,F
096DE:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
096E2:  MOVLW  21
096E4:  MOVLB  3
096E6:  ADDWF  x5C,W
096E8:  MOVWF  FE9
096EA:  MOVLW  00
096EC:  ADDWFC x5D,W
096EE:  MOVWF  FEA
096F0:  BCF    FD8.0
096F2:  RLCF   FEF,W
096F4:  MOVWF  02
096F6:  RLCF   FEC,W
096F8:  MOVWF  03
096FA:  MOVF   02,W
096FC:  MOVF   FED,F
096FE:  MOVWF  FEF
09700:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
09704:  MOVLW  1E
09706:  ADDWF  x5C,W
09708:  MOVWF  FE9
0970A:  MOVLW  00
0970C:  ADDWFC x5D,W
0970E:  MOVWF  FEA
09710:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
09712:  MOVFF  35C,FE9
09716:  MOVFF  35D,FEA
0971A:  MOVLW  01
0971C:  SUBWF  FEF,W
0971E:  ADDLW  F7
09720:  BTFSC  FD8.0
09722:  BRA    98AA
09724:  ADDLW  09
09726:  MOVLB  0
09728:  GOTO   998C
....................       { 
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
0972C:  MOVLW  02
0972E:  MOVLB  3
09730:  MOVWF  x62
....................          break; 
09732:  BRA    98AA
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
09734:  MOVLW  1E
09736:  MOVLB  3
09738:  ADDWF  x5C,W
0973A:  MOVWF  FE9
0973C:  MOVLW  00
0973E:  ADDWFC x5D,W
09740:  MOVWF  FEA
09742:  MOVF   FEF,W
09744:  SUBLW  03
09746:  BNC   974E
....................          { 
....................             flags = SYN | ACK; 
09748:  MOVLW  12
0974A:  MOVWF  x62
....................          } 
0974C:  BRA    977A
....................          else 
....................          { 
....................             if(ps->Flags.bServer) 
0974E:  MOVLW  23
09750:  ADDWF  x5C,W
09752:  MOVWF  FE9
09754:  MOVLW  00
09756:  ADDWFC x5D,W
09758:  MOVWF  FEA
0975A:  BTFSS  FEF.0
0975C:  BRA    976A
....................             { 
....................                ps->smState = TCP_LISTEN; 
0975E:  MOVFF  35C,FE9
09762:  MOVFF  35D,FEA
09766:  CLRF   FEF
....................             } 
09768:  BRA    977A
....................             else 
....................             { 
....................                flags = SYN; 
0976A:  MOVLW  02
0976C:  MOVWF  x62
....................                ps->smState = TCP_SYN_SENT; 
0976E:  MOVFF  35C,FE9
09772:  MOVFF  35D,FEA
09776:  MOVLW  01
09778:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
0977A:  BRA    98AA
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0977C:  MOVLW  1E
0977E:  MOVLB  3
09780:  ADDWF  x5C,W
09782:  MOVWF  FE9
09784:  MOVLW  00
09786:  ADDWFC x5D,W
09788:  MOVWF  FEA
0978A:  MOVF   FEF,W
0978C:  SUBLW  03
0978E:  BNC   97CE
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
09790:  MOVLW  0F
09792:  ADDWF  x5C,W
09794:  MOVWF  FE9
09796:  MOVLW  00
09798:  ADDWFC x5D,W
0979A:  MOVWF  FEA
0979C:  INCFSZ FEF,W
0979E:  BRA    97A2
097A0:  BRA    97C4
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
097A2:  MOVLW  0F
097A4:  ADDWF  x5C,W
097A6:  MOVWF  FE9
097A8:  MOVLW  00
097AA:  ADDWFC x5D,W
097AC:  MOVWF  FEA
097AE:  MOVFF  FEF,3F9
097B2:  CLRF   xFB
097B4:  CLRF   xFA
097B6:  MOVLB  0
097B8:  CALL   70C0
....................                MACFlush(); 
097BC:  CALL   729A
....................             } 
097C0:  BRA    97CA
097C2:  MOVLB  3
....................             else 
....................                flags = ACK; 
097C4:  MOVLW  10
097C6:  MOVWF  x62
097C8:  MOVLB  0
....................          } 
097CA:  BRA    9818
097CC:  MOVLB  3
....................          else 
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
097CE:  MOVLW  0F
097D0:  ADDWF  x5C,W
097D2:  MOVWF  FE9
097D4:  MOVLW  00
097D6:  ADDWFC x5D,W
097D8:  MOVWF  FEA
097DA:  INCFSZ FEF,W
097DC:  BRA    97E0
097DE:  BRA    9806
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
097E0:  MOVLW  0F
097E2:  ADDWF  x5C,W
097E4:  MOVWF  FE9
097E6:  MOVLW  00
097E8:  ADDWFC x5D,W
097EA:  MOVWF  FEA
097EC:  MOVFF  FEF,3A4
097F0:  MOVLB  0
097F2:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
097F6:  MOVLW  0F
097F8:  MOVLB  3
097FA:  ADDWF  x5C,W
097FC:  MOVWF  FE9
097FE:  MOVLW  00
09800:  ADDWFC x5D,W
09802:  MOVWF  FEA
09804:  SETF   FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
09806:  MOVLW  11
09808:  MOVWF  x62
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
0980A:  MOVFF  35C,FE9
0980E:  MOVFF  35D,FEA
09812:  MOVLW  04
09814:  MOVWF  FEF
09816:  MOVLB  0
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
09818:  MOVLB  3
0981A:  BRA    98AA
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0981C:  MOVLW  1E
0981E:  MOVLB  3
09820:  ADDWF  x5C,W
09822:  MOVWF  FE9
09824:  MOVLW  00
09826:  ADDWFC x5D,W
09828:  MOVWF  FEA
0982A:  MOVF   FEF,W
0982C:  SUBLW  03
0982E:  BNC   9836
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
09830:  MOVLW  01
09832:  MOVWF  x62
....................          } 
09834:  BRA    9846
....................          else 
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
09836:  MOVFF  35D,3A2
0983A:  MOVFF  35C,3A1
0983E:  MOVLB  0
09840:  CALL   8092
09844:  MOVLB  3
....................          } 
....................          break; 
09846:  BRA    98AA
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
09848:  MOVFF  35D,3A2
0984C:  MOVFF  35C,3A1
09850:  CALL   8092
....................          break; 
09854:  MOVLB  3
09856:  BRA    98AA
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
09858:  MOVFF  35D,3A2
0985C:  MOVFF  35C,3A1
09860:  CALL   8092
....................          break; 
09864:  MOVLB  3
09866:  BRA    98AA
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
09868:  MOVLW  01
0986A:  MOVLB  3
0986C:  MOVWF  x62
....................          ps->smState = TCP_LAST_ACK; 
0986E:  MOVFF  35C,FE9
09872:  MOVFF  35D,FEA
09876:  MOVLW  09
09878:  MOVWF  FEF
....................          break; 
0987A:  BRA    98AA
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0987C:  MOVLW  1E
0987E:  MOVLB  3
09880:  ADDWF  x5C,W
09882:  MOVWF  FE9
09884:  MOVLW  00
09886:  ADDWFC x5D,W
09888:  MOVWF  FEA
0988A:  MOVF   FEF,W
0988C:  SUBLW  03
0988E:  BNC   9896
....................             flags = FIN; 
09890:  MOVLW  01
09892:  MOVWF  x62
09894:  BRA    98A6
....................          else 
....................             CloseSocket(ps); 
09896:  MOVFF  35D,3A2
0989A:  MOVFF  35C,3A1
0989E:  MOVLB  0
098A0:  CALL   8092
098A4:  MOVLB  3
....................          break; 
098A6:  BRA    98AA
098A8:  MOVLB  3
....................       } 
....................  
....................  
....................       if(flags) 
098AA:  MOVF   x62,F
098AC:  BZ    9982
....................       { 
....................          if(flags & ACK) 
098AE:  BTFSS  x62.4
098B0:  BRA    98D0
....................             seq = ps->SND_SEQ; 
098B2:  MOVLW  16
098B4:  ADDWF  x5C,W
098B6:  MOVWF  FE9
098B8:  MOVLW  00
098BA:  ADDWFC x5D,W
098BC:  MOVWF  FEA
098BE:  MOVFF  FEF,35E
098C2:  MOVFF  FEC,35F
098C6:  MOVFF  FEC,360
098CA:  MOVFF  FEC,361
098CE:  BRA    98FE
....................          else 
....................             seq = ps->SND_SEQ++; 
098D0:  MOVLW  16
098D2:  ADDWF  x5C,W
098D4:  MOVWF  FE9
098D6:  MOVLW  00
098D8:  ADDWFC x5D,W
098DA:  MOVWF  FEA
098DC:  MOVF   FEE,F
098DE:  MOVF   FEE,F
098E0:  MOVF   FEE,F
098E2:  MOVFF  FED,361
098E6:  MOVFF  FED,360
098EA:  MOVFF  FED,35F
098EE:  MOVFF  FEF,35E
098F2:  MOVLW  01
098F4:  ADDWF  FEE,F
098F6:  MOVLW  00
098F8:  ADDWFC FEE,F
098FA:  ADDWFC FEE,F
098FC:  ADDWFC FED,F
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
098FE:  MOVLW  01
09900:  ADDWF  x5C,W
09902:  MOVWF  01
09904:  MOVLW  00
09906:  ADDWFC x5D,W
09908:  MOVWF  03
0990A:  MOVFF  01,363
0990E:  MOVWF  x64
09910:  MOVLW  0B
09912:  ADDWF  x5C,W
09914:  MOVWF  FE9
09916:  MOVLW  00
09918:  ADDWFC x5D,W
0991A:  MOVWF  FEA
0991C:  MOVFF  FEC,3AB
09920:  MOVF   FED,F
09922:  MOVFF  FEF,3AA
09926:  MOVLW  0D
09928:  ADDWF  x5C,W
0992A:  MOVWF  FE9
0992C:  MOVLW  00
0992E:  ADDWFC x5D,W
09930:  MOVWF  FEA
09932:  MOVFF  FEC,3AD
09936:  MOVF   FED,F
09938:  MOVFF  FEF,3AC
0993C:  MOVLW  1A
0993E:  ADDWF  x5C,W
09940:  MOVWF  FE9
09942:  MOVLW  00
09944:  ADDWFC x5D,W
09946:  MOVWF  FEA
09948:  MOVFF  FEF,3B2
0994C:  MOVFF  FEC,3B3
09950:  MOVFF  FEC,3B4
09954:  MOVFF  FEC,3B5
09958:  MOVFF  364,3A9
0995C:  MOVFF  363,3A8
09960:  MOVFF  361,3B1
09964:  MOVFF  360,3B0
09968:  MOVFF  35F,3AF
0996C:  MOVFF  35E,3AE
09970:  MOVFF  362,3B6
09974:  SETF   xB7
09976:  CLRF   xB9
09978:  CLRF   xB8
0997A:  MOVLB  0
0997C:  CALL   84E0
09980:  MOVLB  3
....................       } 
09982:  INCF   x57,F
09984:  BRA    954E
09986:  MOVLB  0
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
09988:  GOTO   C8C4 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
09104:  MOVLW  06
09106:  MOVLB  3
09108:  ADDWF  x57,W
0910A:  MOVWF  FE9
0910C:  MOVLW  00
0910E:  ADDWFC x58,W
09110:  MOVWF  FEA
09112:  MOVFF  FEF,371
09116:  MOVFF  FEC,372
0911A:  MOVFF  FEC,373
0911E:  MOVFF  FEC,374
....................    pseudoHeader.DestAddress        = *localIP; 
09122:  MOVFF  359,FE9
09126:  MOVFF  35A,FEA
0912A:  MOVFF  FEF,375
0912E:  MOVFF  FEC,376
09132:  MOVFF  FEC,377
09136:  MOVFF  FEC,378
....................    pseudoHeader.Zero               = 0x0; 
0913A:  CLRF   x79
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
0913C:  MOVLW  06
0913E:  MOVWF  x7A
....................    pseudoHeader.TCPLength          = len; 
09140:  MOVFF  35C,37C
09144:  MOVFF  35B,37B
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
09148:  MOVFF  37C,400
0914C:  MOVFF  37B,3FF
09150:  MOVLB  0
09152:  CALL   6D9E
09156:  MOVFF  02,37C
0915A:  MOVFF  01,37B
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
0915E:  MOVLW  03
09160:  MOVLB  3
09162:  MOVWF  x84
09164:  MOVLW  71
09166:  MOVWF  x83
09168:  MOVFF  384,3E3
0916C:  MOVWF  xE2
0916E:  CLRF   xE5
09170:  MOVLW  0C
09172:  MOVWF  xE4
09174:  MOVLB  0
09176:  CALL   7A0A
0917A:  MOVFF  01,37E
0917E:  MOVLB  3
09180:  COMF   x7E,F
09182:  MOVFF  02,37F
09186:  COMF   x7F,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
09188:  MOVFF  35C,3E1
0918C:  MOVFF  35B,3E0
09190:  MOVLB  0
09192:  CALL   7B24
09196:  MOVFF  02,381
0919A:  MOVFF  01,380
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
0919E:  MOVLB  3
091A0:  MOVF   x81,W
091A2:  SUBWF  x7E,W
091A4:  BNZ   91AC
091A6:  MOVF   x80,W
091A8:  SUBWF  x7F,W
091AA:  BZ    91BA
....................    { 
....................       MACDiscardRx(); 
091AC:  MOVLB  0
091AE:  CALL   6CC8
....................       return TRUE; 
091B2:  MOVLW  01
091B4:  MOVWF  01
091B6:  BRA    928E
091B8:  MOVLB  3
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
091BA:  CLRF   x85
091BC:  CLRF   x84
091BE:  MOVLB  0
091C0:  CALL   7C80
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
091C4:  MOVLW  03
091C6:  MOVLB  3
091C8:  MOVWF  x84
091CA:  MOVLW  5D
091CC:  MOVWF  x83
091CE:  MOVFF  384,3EF
091D2:  MOVWF  xEE
091D4:  CLRF   xF1
091D6:  MOVLW  14
091D8:  MOVWF  xF0
091DA:  MOVLB  0
091DC:  CALL   6D36
....................    SwapTCPHeader(&TCPHeader); 
091E0:  MOVLW  03
091E2:  MOVLB  3
091E4:  MOVWF  xE1
091E6:  MOVLW  5D
091E8:  MOVWF  xE0
091EA:  MOVLB  0
091EC:  CALL   7CBC
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
091F0:  MOVLB  3
091F2:  SWAPF  x69,W
091F4:  ANDLW  0F
091F6:  MOVWF  00
091F8:  RLCF   00,F
091FA:  RLCF   00,F
091FC:  MOVLW  FC
091FE:  ANDWF  00,F
09200:  MOVF   00,W
09202:  ADDLW  EC
09204:  MOVWF  x82
....................    len = len - optionsSize - sizeof(TCPHeader); 
09206:  MOVF   x82,W
09208:  SUBWF  x5B,W
0920A:  MOVWF  x83
0920C:  MOVLW  00
0920E:  SUBWFB x5C,W
09210:  MOVWF  x84
09212:  MOVLW  14
09214:  SUBWF  x83,W
09216:  MOVWF  x5B
09218:  MOVLW  00
0921A:  SUBWFB x84,W
0921C:  MOVWF  x5C
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
0921E:  SWAPF  x69,W
09220:  ANDLW  0F
09222:  MOVWF  00
09224:  RLCF   00,W
09226:  MOVWF  x83
09228:  RLCF   x83,F
0922A:  MOVLW  FC
0922C:  ANDWF  x83,F
0922E:  CLRF   x85
09230:  MOVFF  383,384
09234:  MOVLB  0
09236:  CALL   7C80
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
0923A:  MOVLW  03
0923C:  MOVLB  3
0923E:  MOVWF  x84
09240:  MOVLW  5D
09242:  MOVWF  x83
09244:  MOVFF  358,386
09248:  MOVFF  357,385
0924C:  MOVLB  0
0924E:  GOTO   7E9A
09252:  MOVFF  01,37D
....................    if(socket != INVALID_SOCKET) 
09256:  MOVLB  3
09258:  MOVF   x7D,W
0925A:  SUBLW  FE
0925C:  BZ    9284
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
0925E:  MOVFF  37D,383
09262:  MOVFF  358,385
09266:  MOVFF  357,384
0926A:  MOVLW  03
0926C:  MOVWF  x87
0926E:  MOVLW  5D
09270:  MOVWF  x86
09272:  MOVFF  35C,389
09276:  MOVFF  35B,388
0927A:  MOVLB  0
0927C:  GOTO   870C
....................    } 
09280:  BRA    928A
09282:  MOVLB  3
....................    else 
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
09284:  MOVLB  0
09286:  CALL   6CC8
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
0928A:  MOVLW  01
0928C:  MOVWF  01
0928E:  GOTO   C7FA (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
084E0:  MOVLW  01
084E2:  MOVLB  3
084E4:  MOVWF  xE0
084E6:  MOVLB  0
084E8:  RCALL  8190
084EA:  MOVF   01,F
084EC:  BZ    84E0
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
084EE:  MOVLB  3
084F0:  INCFSZ xB7,W
084F2:  BRA    8504
....................       buff = MACGetTxBuffer(TRUE); 
084F4:  MOVLW  01
084F6:  MOVWF  xE0
084F8:  MOVLB  0
084FA:  CALL   7098
084FE:  MOVFF  01,3B7
08502:  MOVLB  3
....................  
....................    if(buff == INVALID_BUFFER) 
08504:  INCFSZ xB7,W
08506:  BRA    850A
....................       return; 
08508:  BRA    8708
....................  
....................    IPSetTxBuffer(buff, 0); 
0850A:  MOVFF  3B7,3F9
0850E:  CLRF   xFB
08510:  MOVLW  14
08512:  MOVWF  xFA
08514:  MOVLB  0
08516:  CALL   70C0
....................  
....................    header.SourcePort           = localPort; 
0851A:  MOVFF  3AB,3BD
0851E:  MOVFF  3AA,3BC
....................    header.DestPort             = remotePort; 
08522:  MOVFF  3AD,3BF
08526:  MOVFF  3AC,3BE
....................    header.SeqNumber            = tseq; 
0852A:  MOVFF  3B1,3C3
0852E:  MOVFF  3B0,3C2
08532:  MOVFF  3AF,3C1
08536:  MOVFF  3AE,3C0
....................    header.AckNumber            = tack; 
0853A:  MOVFF  3B5,3C7
0853E:  MOVFF  3B4,3C6
08542:  MOVFF  3B3,3C5
08546:  MOVFF  3B2,3C4
....................    header.Flags.bits.Reserved2 = 0; 
0854A:  MOVLW  3F
0854C:  MOVLB  3
0854E:  ANDWF  xC9,W
08550:  MOVWF  xC9
....................    header.DataOffset.Reserved3 = 0; 
08552:  MOVLW  F0
08554:  ANDWF  xC8,W
08556:  MOVWF  xC8
....................    header.Flags.b              = flags; 
08558:  MOVFF  3B6,3C9
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
0855C:  MOVLB  0
0855E:  BRA    81B8
08560:  MOVFF  02,3CB
08564:  MOVFF  01,3CA
.................... #if !defined(STACK_USE_SLIP) 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
08568:  MOVLB  3
0856A:  MOVF   xCB,F
0856C:  BNZ   8574
0856E:  MOVF   xCA,W
08570:  SUBLW  28
08572:  BC    857E
....................    { 
....................       header.Window -= 40; 
08574:  MOVLW  28
08576:  SUBWF  xCA,F
08578:  MOVLW  00
0857A:  SUBWFB xCB,F
....................    } 
0857C:  BRA    8582
....................    else 
....................       header.Window = 0; 
0857E:  CLRF   xCB
08580:  CLRF   xCA
.................... #endif 
....................  
....................    header.Checksum             = 0; 
08582:  CLRF   xCD
08584:  CLRF   xCC
....................    header.UrgentPointer        = 0; 
08586:  CLRF   xCF
08588:  CLRF   xCE
....................  
....................    SwapTCPHeader(&header); 
0858A:  MOVLW  03
0858C:  MOVWF  xE1
0858E:  MOVLW  BC
08590:  MOVWF  xE0
08592:  MOVLB  0
08594:  CALL   7CBC
....................  
....................    len += sizeof(header); 
08598:  MOVLW  14
0859A:  MOVLB  3
0859C:  ADDWF  xB8,F
0859E:  MOVLW  00
085A0:  ADDWFC xB9,F
....................  
....................    if ( flags & SYN ) 
085A2:  BTFSS  xB6.1
085A4:  BRA    85C4
....................    { 
....................       len += sizeof(options); 
085A6:  MOVLW  04
085A8:  ADDWF  xB8,F
085AA:  MOVLW  00
085AC:  ADDWFC xB9,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
085AE:  MOVLW  02
085B0:  MOVWF  xD0
....................       options.Length = 0x04; 
085B2:  MOVLW  04
085B4:  MOVWF  xD1
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
085B6:  MOVWF  xD2
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
085B8:  CLRF   xD3
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
085BA:  MOVLW  0F
085BC:  ANDWF  xC8,W
085BE:  IORLW  60
085C0:  MOVWF  xC8
....................    } 
085C2:  BRA    85CC
....................    else 
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
085C4:  MOVLW  0F
085C6:  ANDWF  xC8,W
085C8:  IORLW  50
085CA:  MOVWF  xC8
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
085CC:  MOVFF  1C,3D7
085D0:  MOVFF  1B,3D6
085D4:  MOVFF  1A,3D5
085D8:  MOVFF  19,3D4
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
085DC:  MOVLW  06
085DE:  ADDWF  xA8,W
085E0:  MOVWF  FE9
085E2:  MOVLW  00
085E4:  ADDWFC xA9,W
085E6:  MOVWF  FEA
085E8:  MOVFF  FEF,3D8
085EC:  MOVFF  FEC,3D9
085F0:  MOVFF  FEC,3DA
085F4:  MOVFF  FEC,3DB
....................    pseudoHeader.Zero           = 0x0; 
085F8:  CLRF   xDC
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
085FA:  MOVLW  06
085FC:  MOVWF  xDD
....................    pseudoHeader.TCPLength      = len; 
085FE:  MOVFF  3B9,3DF
08602:  MOVFF  3B8,3DE
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
08606:  MOVFF  3DF,400
0860A:  MOVFF  3DE,3FF
0860E:  MOVLB  0
08610:  CALL   6D9E
08614:  MOVFF  02,3DF
08618:  MOVFF  01,3DE
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
0861C:  MOVLW  03
0861E:  MOVLB  3
08620:  MOVWF  xE1
08622:  MOVLW  D4
08624:  MOVWF  xE0
08626:  MOVFF  3E1,3E3
0862A:  MOVWF  xE2
0862C:  CLRF   xE5
0862E:  MOVLW  0C
08630:  MOVWF  xE4
08632:  MOVLB  0
08634:  CALL   7A0A
08638:  MOVFF  01,3CC
0863C:  MOVLB  3
0863E:  COMF   xCC,F
08640:  MOVFF  02,3CD
08644:  COMF   xCD,F
....................    checkSum.Val = header.Checksum; 
08646:  MOVFF  3CD,3BB
0864A:  MOVFF  3CC,3BA
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
0864E:  MOVFF  3A9,3E1
08652:  MOVFF  3A8,3E0
08656:  MOVLW  06
08658:  MOVWF  xE2
0865A:  MOVFF  3B9,3E4
0865E:  MOVFF  3B8,3E3
08662:  MOVLB  0
08664:  RCALL  83B6
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
08666:  MOVLW  03
08668:  MOVLB  3
0866A:  MOVWF  xE1
0866C:  MOVLW  BC
0866E:  MOVWF  xE0
08670:  MOVFF  3E1,405
08674:  MOVFF  FE8,404
08678:  MOVLB  4
0867A:  CLRF   x07
0867C:  MOVLW  14
0867E:  MOVWF  x06
08680:  MOVLB  0
08682:  CALL   7186
....................  
....................    if ( flags & SYN ) 
08686:  MOVLB  3
08688:  BTFSS  xB6.1
0868A:  BRA    86AC
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
0868C:  MOVLW  03
0868E:  MOVWF  xE1
08690:  MOVLW  D0
08692:  MOVWF  xE0
08694:  MOVFF  3E1,405
08698:  MOVFF  FE8,404
0869C:  MOVLB  4
0869E:  CLRF   x07
086A0:  MOVLW  04
086A2:  MOVWF  x06
086A4:  MOVLB  0
086A6:  CALL   7186
086AA:  MOVLB  3
....................  
....................    IPSetTxBuffer(buff, 0); 
086AC:  MOVFF  3B7,3F9
086B0:  CLRF   xFB
086B2:  MOVLW  14
086B4:  MOVWF  xFA
086B6:  MOVLB  0
086B8:  CALL   70C0
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
086BC:  MOVFF  3B9,3E1
086C0:  MOVFF  3B8,3E0
086C4:  CALL   7B24
086C8:  MOVFF  02,3BB
086CC:  MOVFF  01,3BA
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
086D0:  MOVFF  3B7,3F9
086D4:  MOVLB  3
086D6:  CLRF   xFB
086D8:  MOVLW  24
086DA:  MOVWF  xFA
086DC:  MOVLB  0
086DE:  CALL   70C0
....................    MACPut(checkSum.v[1]); 
086E2:  MOVFF  3BB,403
086E6:  CALL   7168
....................    MACPut(checkSum.v[0]); 
086EA:  MOVFF  3BA,403
086EE:  CALL   7168
....................    MACSetTxBuffer(buff, 0); 
086F2:  MOVFF  3B7,3F9
086F6:  MOVLB  3
086F8:  CLRF   xFB
086FA:  CLRF   xFA
086FC:  MOVLB  0
086FE:  CALL   70C0
....................  
....................    MACFlush(); 
08702:  CALL   729A
08706:  MOVLB  3
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
08708:  MOVLB  0
0870A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
07E9A:  MOVLW  FE
07E9C:  MOVLB  3
07E9E:  MOVWF  x8A
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
07EA0:  CLRF   x89
07EA2:  MOVF   x89,W
07EA4:  SUBLW  04
07EA6:  BTFSS  FD8.0
07EA8:  BRA    7F9E
....................    { 
....................       ps = &TCB[s]; 
07EAA:  MOVF   x89,W
07EAC:  MULLW  24
07EAE:  MOVF   FF3,W
07EB0:  CLRF   03
07EB2:  ADDLW  60
07EB4:  MOVWF  01
07EB6:  MOVLW  00
07EB8:  ADDWFC 03,F
07EBA:  MOVFF  01,387
07EBE:  MOVFF  03,388
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
07EC2:  MOVFF  387,FE9
07EC6:  MOVFF  388,FEA
07ECA:  MOVF   FEF,W
07ECC:  SUBLW  0A
07ECE:  BZ    7F9A
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
07ED0:  MOVLW  0B
07ED2:  ADDWF  x87,W
07ED4:  MOVWF  FE9
07ED6:  MOVLW  00
07ED8:  ADDWFC x88,W
07EDA:  MOVWF  FEA
07EDC:  MOVFF  FEC,38C
07EE0:  MOVF   FED,F
07EE2:  MOVFF  FEF,38B
07EE6:  MOVLW  02
07EE8:  ADDWF  x83,W
07EEA:  MOVWF  FE9
07EEC:  MOVLW  00
07EEE:  ADDWFC x84,W
07EF0:  MOVWF  FEA
07EF2:  MOVFF  FEC,03
07EF6:  MOVF   FED,F
07EF8:  MOVF   FEF,W
07EFA:  SUBWF  x8B,W
07EFC:  BNZ   7F9A
07EFE:  MOVF   03,W
07F00:  SUBWF  x8C,W
07F02:  BNZ   7F9A
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
07F04:  MOVFF  387,FE9
07F08:  MOVFF  388,FEA
07F0C:  MOVF   FEF,F
07F0E:  BNZ   7F14
....................                partialMatch = s; 
07F10:  MOVFF  389,38A
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
07F14:  MOVLW  0D
07F16:  ADDWF  x87,W
07F18:  MOVWF  FE9
07F1A:  MOVLW  00
07F1C:  ADDWFC x88,W
07F1E:  MOVWF  FEA
07F20:  MOVFF  FEC,38C
07F24:  MOVF   FED,F
07F26:  MOVFF  FEF,38B
07F2A:  MOVFF  383,FE9
07F2E:  MOVFF  384,FEA
07F32:  MOVFF  FEC,03
07F36:  MOVF   FED,F
07F38:  MOVF   FEF,W
07F3A:  SUBWF  x8B,W
07F3C:  BNZ   7F9A
07F3E:  MOVF   03,W
07F40:  SUBWF  x8C,W
07F42:  BNZ   7F9A
07F44:  MOVLW  07
07F46:  ADDWF  x87,W
07F48:  MOVWF  FE9
07F4A:  MOVLW  00
07F4C:  ADDWFC x88,W
07F4E:  MOVWF  FEA
07F50:  MOVFF  FEF,38B
07F54:  MOVFF  FEC,38C
07F58:  MOVFF  FEC,38D
07F5C:  MOVFF  FEC,38E
07F60:  MOVLW  06
07F62:  ADDWF  x85,W
07F64:  MOVWF  FE9
07F66:  MOVLW  00
07F68:  ADDWFC x86,W
07F6A:  MOVWF  FEA
07F6C:  MOVFF  FEF,00
07F70:  MOVFF  FEC,01
07F74:  MOVFF  FEC,02
07F78:  MOVFF  FEC,03
07F7C:  MOVF   00,W
07F7E:  SUBWF  x8B,W
07F80:  BNZ   7F9A
07F82:  MOVF   01,W
07F84:  SUBWF  x8C,W
07F86:  BNZ   7F9A
07F88:  MOVF   02,W
07F8A:  SUBWF  x8D,W
07F8C:  BNZ   7F9A
07F8E:  MOVF   03,W
07F90:  SUBWF  x8E,W
07F92:  BNZ   7F9A
....................             { 
....................                return s; 
07F94:  MOVFF  389,01
07F98:  BRA    8072
....................             } 
....................          } 
....................       } 
07F9A:  INCF   x89,F
07F9C:  BRA    7EA2
....................    } 
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
07F9E:  MOVF   x8A,W
07FA0:  SUBLW  FE
07FA2:  BNZ   7FAA
....................       return INVALID_SOCKET; 
07FA4:  MOVLW  FE
07FA6:  MOVWF  01
07FA8:  BRA    8072
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
07FAA:  MOVF   x8A,W
07FAC:  MULLW  24
07FAE:  MOVF   FF3,W
07FB0:  CLRF   03
07FB2:  ADDLW  60
07FB4:  MOVWF  01
07FB6:  MOVLW  00
07FB8:  ADDWFC 03,F
07FBA:  MOVFF  01,387
07FBE:  MOVFF  03,388
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
07FC2:  MOVLW  01
07FC4:  ADDWF  x87,W
07FC6:  MOVWF  01
07FC8:  MOVLW  00
07FCA:  ADDWFC x88,W
07FCC:  MOVWF  03
07FCE:  MOVFF  01,38B
07FD2:  MOVWF  x8C
07FD4:  MOVWF  FEA
07FD6:  MOVFF  01,FE9
07FDA:  MOVFF  386,FE2
07FDE:  MOVFF  385,FE1
07FE2:  MOVLW  0A
07FE4:  MOVWF  01
07FE6:  MOVFF  FE6,FEE
07FEA:  DECFSZ 01,F
07FEC:  BRA    7FE6
....................    ps->remotePort          = h->SourcePort; 
07FEE:  MOVLW  0D
07FF0:  ADDWF  x87,W
07FF2:  MOVWF  01
07FF4:  MOVLW  00
07FF6:  ADDWFC x88,W
07FF8:  MOVFF  383,FE9
07FFC:  MOVFF  384,FEA
08000:  MOVFF  FEC,03
08004:  MOVF   FED,F
08006:  MOVFF  FEF,38D
0800A:  MOVWF  FEA
0800C:  MOVFF  01,FE9
08010:  MOVFF  03,FEC
08014:  MOVF   FED,F
08016:  MOVFF  38D,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
0801A:  MOVLW  23
0801C:  ADDWF  x87,W
0801E:  MOVWF  FE9
08020:  MOVLW  00
08022:  ADDWFC x88,W
08024:  MOVWF  FEA
08026:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
08028:  MOVLW  0F
0802A:  ADDWF  x87,W
0802C:  MOVWF  FE9
0802E:  MOVLW  00
08030:  ADDWFC x88,W
08032:  MOVWF  FEA
08034:  INCFSZ FEF,W
08036:  BRA    803A
08038:  BRA    8060
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
0803A:  MOVLW  0F
0803C:  ADDWF  x87,W
0803E:  MOVWF  FE9
08040:  MOVLW  00
08042:  ADDWFC x88,W
08044:  MOVWF  FEA
08046:  MOVFF  FEF,3A4
0804A:  MOVLB  0
0804C:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
08050:  MOVLW  0F
08052:  MOVLB  3
08054:  ADDWF  x87,W
08056:  MOVWF  FE9
08058:  MOVLW  00
0805A:  ADDWFC x88,W
0805C:  MOVWF  FEA
0805E:  SETF   FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
08060:  MOVLW  23
08062:  ADDWF  x87,W
08064:  MOVWF  FE9
08066:  MOVLW  00
08068:  ADDWFC x88,W
0806A:  MOVWF  FEA
0806C:  BSF    FEF.1
....................  
....................    return partialMatch; 
0806E:  MOVFF  38A,01
08072:  MOVLB  0
08074:  GOTO   9252 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
07CBC:  MOVLB  3
07CBE:  MOVFF  3E0,01
07CC2:  MOVFF  3E1,03
07CC6:  MOVFF  3E0,3E2
07CCA:  MOVFF  3E1,3E3
07CCE:  MOVFF  3E0,FE9
07CD2:  MOVFF  3E1,FEA
07CD6:  MOVFF  FEC,400
07CDA:  MOVF   FED,F
07CDC:  MOVFF  FEF,3FF
07CE0:  MOVLB  0
07CE2:  CALL   6D9E
07CE6:  MOVFF  3E3,FEA
07CEA:  MOVFF  3E2,FE9
07CEE:  MOVFF  02,FEC
07CF2:  MOVF   FED,F
07CF4:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
07CF8:  MOVLW  02
07CFA:  MOVLB  3
07CFC:  ADDWF  xE0,W
07CFE:  MOVWF  01
07D00:  MOVLW  00
07D02:  ADDWFC xE1,W
07D04:  MOVWF  03
07D06:  MOVFF  01,3E2
07D0A:  MOVWF  xE3
07D0C:  MOVLW  02
07D0E:  ADDWF  xE0,W
07D10:  MOVWF  FE9
07D12:  MOVLW  00
07D14:  ADDWFC xE1,W
07D16:  MOVWF  FEA
07D18:  MOVFF  FEC,400
07D1C:  MOVF   FED,F
07D1E:  MOVFF  FEF,3FF
07D22:  MOVLB  0
07D24:  CALL   6D9E
07D28:  MOVFF  3E3,FEA
07D2C:  MOVFF  3E2,FE9
07D30:  MOVFF  02,FEC
07D34:  MOVF   FED,F
07D36:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
07D3A:  MOVLW  04
07D3C:  MOVLB  3
07D3E:  ADDWF  xE0,W
07D40:  MOVWF  01
07D42:  MOVLW  00
07D44:  ADDWFC xE1,W
07D46:  MOVWF  03
07D48:  MOVFF  01,3E2
07D4C:  MOVWF  xE3
07D4E:  MOVLW  04
07D50:  ADDWF  xE0,W
07D52:  MOVWF  FE9
07D54:  MOVLW  00
07D56:  ADDWFC xE1,W
07D58:  MOVWF  FEA
07D5A:  MOVFF  FEF,3E8
07D5E:  MOVFF  FEC,3E9
07D62:  MOVFF  FEC,3EA
07D66:  MOVFF  FEC,3EB
07D6A:  MOVLB  0
07D6C:  RCALL  7C9A
07D6E:  MOVFF  3E3,FEA
07D72:  MOVFF  3E2,FE9
07D76:  MOVFF  00,FEF
07D7A:  MOVFF  01,FEC
07D7E:  MOVFF  02,FEC
07D82:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
07D86:  MOVLW  08
07D88:  MOVLB  3
07D8A:  ADDWF  xE0,W
07D8C:  MOVWF  01
07D8E:  MOVLW  00
07D90:  ADDWFC xE1,W
07D92:  MOVWF  03
07D94:  MOVFF  01,3E2
07D98:  MOVWF  xE3
07D9A:  MOVLW  08
07D9C:  ADDWF  xE0,W
07D9E:  MOVWF  FE9
07DA0:  MOVLW  00
07DA2:  ADDWFC xE1,W
07DA4:  MOVWF  FEA
07DA6:  MOVFF  FEF,3E8
07DAA:  MOVFF  FEC,3E9
07DAE:  MOVFF  FEC,3EA
07DB2:  MOVFF  FEC,3EB
07DB6:  MOVLB  0
07DB8:  RCALL  7C9A
07DBA:  MOVFF  3E3,FEA
07DBE:  MOVFF  3E2,FE9
07DC2:  MOVFF  00,FEF
07DC6:  MOVFF  01,FEC
07DCA:  MOVFF  02,FEC
07DCE:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
07DD2:  MOVLW  0E
07DD4:  MOVLB  3
07DD6:  ADDWF  xE0,W
07DD8:  MOVWF  01
07DDA:  MOVLW  00
07DDC:  ADDWFC xE1,W
07DDE:  MOVWF  03
07DE0:  MOVFF  01,3E2
07DE4:  MOVWF  xE3
07DE6:  MOVLW  0E
07DE8:  ADDWF  xE0,W
07DEA:  MOVWF  FE9
07DEC:  MOVLW  00
07DEE:  ADDWFC xE1,W
07DF0:  MOVWF  FEA
07DF2:  MOVFF  FEC,400
07DF6:  MOVF   FED,F
07DF8:  MOVFF  FEF,3FF
07DFC:  MOVLB  0
07DFE:  CALL   6D9E
07E02:  MOVFF  3E3,FEA
07E06:  MOVFF  3E2,FE9
07E0A:  MOVFF  02,FEC
07E0E:  MOVF   FED,F
07E10:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
07E14:  MOVLW  10
07E16:  MOVLB  3
07E18:  ADDWF  xE0,W
07E1A:  MOVWF  01
07E1C:  MOVLW  00
07E1E:  ADDWFC xE1,W
07E20:  MOVWF  03
07E22:  MOVFF  01,3E2
07E26:  MOVWF  xE3
07E28:  MOVLW  10
07E2A:  ADDWF  xE0,W
07E2C:  MOVWF  FE9
07E2E:  MOVLW  00
07E30:  ADDWFC xE1,W
07E32:  MOVWF  FEA
07E34:  MOVFF  FEC,400
07E38:  MOVF   FED,F
07E3A:  MOVFF  FEF,3FF
07E3E:  MOVLB  0
07E40:  CALL   6D9E
07E44:  MOVFF  3E3,FEA
07E48:  MOVFF  3E2,FE9
07E4C:  MOVFF  02,FEC
07E50:  MOVF   FED,F
07E52:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
07E56:  MOVLW  12
07E58:  MOVLB  3
07E5A:  ADDWF  xE0,W
07E5C:  MOVWF  01
07E5E:  MOVLW  00
07E60:  ADDWFC xE1,W
07E62:  MOVWF  03
07E64:  MOVFF  01,3E2
07E68:  MOVWF  xE3
07E6A:  MOVLW  12
07E6C:  ADDWF  xE0,W
07E6E:  MOVWF  FE9
07E70:  MOVLW  00
07E72:  ADDWFC xE1,W
07E74:  MOVWF  FEA
07E76:  MOVFF  FEC,400
07E7A:  MOVF   FED,F
07E7C:  MOVFF  FEF,3FF
07E80:  MOVLB  0
07E82:  CALL   6D9E
07E86:  MOVFF  3E3,FEA
07E8A:  MOVFF  3E2,FE9
07E8E:  MOVFF  02,FEC
07E92:  MOVF   FED,F
07E94:  MOVFF  01,FEF
07E98:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
08092:  MOVLW  0F
08094:  MOVLB  3
08096:  ADDWF  xA1,W
08098:  MOVWF  FE9
0809A:  MOVLW  00
0809C:  ADDWFC xA2,W
0809E:  MOVWF  FEA
080A0:  INCFSZ FEF,W
080A2:  BRA    80A6
080A4:  BRA    80DA
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
080A6:  MOVLW  0F
080A8:  ADDWF  xA1,W
080AA:  MOVWF  FE9
080AC:  MOVLW  00
080AE:  ADDWFC xA2,W
080B0:  MOVWF  FEA
080B2:  MOVFF  FEF,3A4
080B6:  MOVLB  0
080B8:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
080BC:  MOVLW  0F
080BE:  MOVLB  3
080C0:  ADDWF  xA1,W
080C2:  MOVWF  FE9
080C4:  MOVLW  00
080C6:  ADDWFC xA2,W
080C8:  MOVWF  FEA
080CA:  SETF   FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
080CC:  MOVLW  23
080CE:  ADDWF  xA1,W
080D0:  MOVWF  FE9
080D2:  MOVLW  00
080D4:  ADDWFC xA2,W
080D6:  MOVWF  FEA
080D8:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
080DA:  MOVLW  07
080DC:  ADDWF  xA1,W
080DE:  MOVWF  FE9
080E0:  MOVLW  00
080E2:  ADDWFC xA2,W
080E4:  MOVWF  FEA
080E6:  MOVF   FEE,F
080E8:  MOVF   FEE,F
080EA:  CLRF   FEC
080EC:  MOVF   FED,F
080EE:  CLRF   FEF
080F0:  MOVF   FED,F
080F2:  CLRF   FEF
080F4:  MOVF   FED,F
080F6:  CLRF   FEF
....................     ps->remotePort = 0x00; 
080F8:  MOVLW  0D
080FA:  ADDWF  xA1,W
080FC:  MOVWF  FE9
080FE:  MOVLW  00
08100:  ADDWFC xA2,W
08102:  MOVWF  FEA
08104:  CLRF   FEC
08106:  MOVF   FED,F
08108:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
0810A:  MOVLW  23
0810C:  ADDWF  xA1,W
0810E:  MOVWF  FE9
08110:  MOVLW  00
08112:  ADDWFC xA2,W
08114:  MOVWF  FEA
08116:  BTFSS  FEF.3
08118:  BRA    8122
....................     { 
....................         MACDiscardRx(); 
0811A:  MOVLB  0
0811C:  CALL   6CC8
08120:  MOVLB  3
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
08122:  MOVLW  23
08124:  ADDWF  xA1,W
08126:  MOVWF  FE9
08128:  MOVLW  00
0812A:  ADDWFC xA2,W
0812C:  MOVWF  FEA
0812E:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
08130:  MOVLW  21
08132:  ADDWF  xA1,W
08134:  MOVWF  FE9
08136:  MOVLW  00
08138:  ADDWFC xA2,W
0813A:  MOVWF  FEA
0813C:  CLRF   FEC
0813E:  MOVF   FED,F
08140:  MOVLW  1E
08142:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
08144:  MOVLW  23
08146:  ADDWF  xA1,W
08148:  MOVWF  FE9
0814A:  MOVLW  00
0814C:  ADDWFC xA2,W
0814E:  MOVWF  FEA
08150:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
08152:  MOVLW  23
08154:  ADDWF  xA1,W
08156:  MOVWF  FE9
08158:  MOVLW  00
0815A:  ADDWFC xA2,W
0815C:  MOVWF  FEA
0815E:  BTFSS  FEF.0
08160:  BRA    816E
....................     { 
....................         ps->smState = TCP_LISTEN; 
08162:  MOVFF  3A1,FE9
08166:  MOVFF  3A2,FEA
0816A:  CLRF   FEF
....................     } 
0816C:  BRA    817A
....................     else 
....................     { 
....................         ps->smState = TCP_CLOSED; 
0816E:  MOVFF  3A1,FE9
08172:  MOVFF  3A2,FEA
08176:  MOVLW  0A
08178:  MOVWF  FEF
....................     } 
....................  
....................    ps->TxCount = 0; 
0817A:  MOVLW  10
0817C:  ADDWF  xA1,W
0817E:  MOVWF  FE9
08180:  MOVLW  00
08182:  ADDWFC xA2,W
08184:  MOVWF  FEA
08186:  CLRF   FEC
08188:  MOVF   FED,F
0818A:  CLRF   FEF
....................  
....................     return; 
0818C:  MOVLB  0
0818E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
0870C:  MOVLB  3
0870E:  MOVF   x83,W
08710:  MULLW  24
08712:  MOVF   FF3,W
08714:  CLRF   03
08716:  ADDLW  60
08718:  MOVWF  01
0871A:  MOVLW  00
0871C:  ADDWFC 03,F
0871E:  MOVFF  01,39A
08722:  MOVFF  03,39B
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
08726:  CLRF   x9C
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
08728:  MOVLW  1E
0872A:  ADDWF  x9A,W
0872C:  MOVWF  FE9
0872E:  MOVLW  00
08730:  ADDWFC x9B,W
08732:  MOVWF  FEA
08734:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
08736:  MOVLW  1F
08738:  ADDWF  x9A,W
0873A:  MOVWF  01
0873C:  MOVLW  00
0873E:  ADDWFC x9B,W
08740:  MOVWF  03
08742:  MOVFF  01,3A1
08746:  MOVWF  xA2
08748:  MOVLB  0
0874A:  RCALL  8078
0874C:  MOVFF  3A2,FEA
08750:  MOVFF  3A1,FE9
08754:  MOVFF  02,FEC
08758:  MOVF   FED,F
0875A:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
0875E:  MOVLW  21
08760:  MOVLB  3
08762:  ADDWF  x9A,W
08764:  MOVWF  FE9
08766:  MOVLW  00
08768:  ADDWFC x9B,W
0876A:  MOVWF  FEA
0876C:  CLRF   FEC
0876E:  MOVF   FED,F
08770:  MOVLW  1E
08772:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
08774:  MOVLW  0D
08776:  ADDWF  x86,W
08778:  MOVWF  FE9
0877A:  MOVLW  00
0877C:  ADDWFC x87,W
0877E:  MOVWF  FEA
08780:  BTFSS  FEF.2
08782:  BRA    87C0
....................    { 
....................       MACDiscardRx(); 
08784:  MOVLB  0
08786:  CALL   6CC8
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
0878A:  MOVLB  3
0878C:  MOVFF  39A,01
08790:  MOVFF  39B,03
08794:  MOVFF  39A,3A1
08798:  MOVFF  39B,3A2
0879C:  MOVLW  23
0879E:  ADDWF  x9A,W
087A0:  MOVWF  FE9
087A2:  MOVLW  00
087A4:  ADDWFC x9B,W
087A6:  MOVWF  FEA
087A8:  BTFSS  FEF.0
087AA:  BRA    87B0
087AC:  MOVLW  00
087AE:  BRA    87B2
087B0:  MOVLW  01
087B2:  MOVFF  3A2,FEA
087B6:  MOVFF  3A1,FE9
087BA:  MOVWF  FEF
....................       return; 
087BC:  GOTO   90FE
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
087C0:  MOVLW  16
087C2:  ADDWF  x9A,W
087C4:  MOVWF  FE9
087C6:  MOVLW  00
087C8:  ADDWFC x9B,W
087CA:  MOVWF  FEA
087CC:  MOVFF  FEF,38E
087D0:  MOVFF  FEC,38F
087D4:  MOVFF  FEC,390
087D8:  MOVFF  FEC,391
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
087DC:  MOVLW  0E
087DE:  ADDWF  x86,W
087E0:  MOVWF  FE9
087E2:  MOVLW  00
087E4:  ADDWFC x87,W
087E6:  MOVWF  FEA
087E8:  MOVFF  FEC,3A2
087EC:  MOVF   FED,F
087EE:  MOVFF  FEF,3A1
087F2:  CLRF   xA3
087F4:  CLRF   xA4
087F6:  MOVLW  08
087F8:  ADDWF  x86,W
087FA:  MOVWF  FE9
087FC:  MOVLW  00
087FE:  ADDWFC x87,W
08800:  MOVWF  FEA
08802:  MOVFF  FEF,00
08806:  MOVFF  FEC,01
0880A:  MOVFF  FEC,02
0880E:  MOVFF  FEC,03
08812:  MOVF   00,W
08814:  SUBWF  x8E,W
08816:  MOVWF  00
08818:  MOVF   01,W
0881A:  SUBWFB x8F,W
0881C:  MOVWF  01
0881E:  MOVF   02,W
08820:  SUBWFB x90,W
08822:  MOVWF  02
08824:  MOVF   03,W
08826:  SUBWFB x91,W
08828:  MOVWF  03
0882A:  MOVF   00,W
0882C:  SUBWF  xA1,F
0882E:  MOVF   01,W
08830:  SUBWFB xA2,F
08832:  MOVF   02,W
08834:  SUBWFB xA3,F
08836:  MOVF   03,W
08838:  SUBWFB xA4,F
0883A:  MOVLW  10
0883C:  ADDWF  x9A,W
0883E:  MOVWF  FE9
08840:  MOVLW  00
08842:  ADDWFC x9B,W
08844:  MOVWF  FEA
08846:  MOVFF  FEC,03
0884A:  MOVF   FED,F
0884C:  MOVFF  FEF,00
08850:  MOVFF  03,01
08854:  CLRF   02
08856:  CLRF   03
08858:  MOVF   00,W
0885A:  SUBWF  xA1,W
0885C:  MOVWF  x9D
0885E:  MOVF   01,W
08860:  SUBWFB xA2,W
08862:  MOVWF  x9E
08864:  MOVF   02,W
08866:  SUBWFB xA3,W
08868:  MOVWF  x9F
0886A:  MOVF   03,W
0886C:  SUBWFB xA4,W
0886E:  MOVWF  xA0
....................    if(temp < 0) 
08870:  BTFSS  xA0.7
08872:  BRA    8888
....................    { 
....................       ps->RemoteWindow = 0; 
08874:  MOVLW  14
08876:  ADDWF  x9A,W
08878:  MOVWF  FE9
0887A:  MOVLW  00
0887C:  ADDWFC x9B,W
0887E:  MOVWF  FEA
08880:  CLRF   FEC
08882:  MOVF   FED,F
08884:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
08886:  BRA    889C
....................    else 
....................    { 
....................       ps->RemoteWindow = ack; 
08888:  MOVLW  14
0888A:  ADDWF  x9A,W
0888C:  MOVWF  FE9
0888E:  MOVLW  00
08890:  ADDWFC x9B,W
08892:  MOVWF  FEA
08894:  MOVFF  38A,FEF
08898:  MOVFF  38B,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
0889C:  MOVFF  39A,FE9
088A0:  MOVFF  39B,FEA
088A4:  DECFSZ FEF,W
088A6:  BRA    8A12
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
088A8:  MOVLW  0D
088AA:  ADDWF  x86,W
088AC:  MOVWF  FE9
088AE:  MOVLW  00
088B0:  ADDWFC x87,W
088B2:  MOVWF  FEA
088B4:  BTFSC  FEF.1
088B6:  BRA    88DC
....................       { 
....................          MACDiscardRx(); 
088B8:  MOVLB  0
088BA:  CALL   6CC8
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
088BE:  MOVLW  0D
088C0:  MOVLB  3
088C2:  ADDWF  x86,W
088C4:  MOVWF  FE9
088C6:  MOVLW  00
088C8:  ADDWFC x87,W
088CA:  MOVWF  FEA
088CC:  BTFSS  FEF.4
088CE:  BRA    88D8
....................           { 
....................             flags = RST; 
088D0:  MOVLW  04
088D2:  MOVWF  x9C
....................             goto SendTCPControlPacket; 
088D4:  GOTO   9098
....................            } 
....................  
....................          return; 
088D8:  GOTO   90FE
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
088DC:  MOVLW  1A
088DE:  ADDWF  x9A,W
088E0:  MOVWF  01
088E2:  MOVLW  00
088E4:  ADDWFC x9B,W
088E6:  MOVFF  01,3A1
088EA:  MOVWF  xA2
088EC:  MOVLW  04
088EE:  ADDWF  x86,W
088F0:  MOVWF  FE9
088F2:  MOVLW  00
088F4:  ADDWFC x87,W
088F6:  MOVWF  FEA
088F8:  MOVFF  FEF,3A3
088FC:  MOVFF  FEC,3A4
08900:  MOVFF  FEC,3A5
08904:  MOVFF  FEC,3A6
08908:  MOVF   x88,W
0890A:  ADDWF  xA3,F
0890C:  MOVF   x89,W
0890E:  ADDWFC xA4,F
08910:  MOVLW  00
08912:  ADDWFC xA5,F
08914:  ADDWFC xA6,F
08916:  MOVLW  01
08918:  ADDWF  xA3,W
0891A:  MOVWF  00
0891C:  MOVLW  00
0891E:  ADDWFC xA4,W
08920:  MOVWF  01
08922:  MOVLW  00
08924:  ADDWFC xA5,W
08926:  MOVWF  02
08928:  MOVLW  00
0892A:  ADDWFC xA6,W
0892C:  MOVFF  3A2,FEA
08930:  MOVFF  3A1,FE9
08934:  MOVFF  00,FEF
08938:  MOVFF  01,FEC
0893C:  MOVFF  02,FEC
08940:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
08942:  MOVLW  1A
08944:  ADDWF  x9A,W
08946:  MOVWF  FE9
08948:  MOVLW  00
0894A:  ADDWFC x9B,W
0894C:  MOVWF  FEA
0894E:  MOVFF  FEF,38A
08952:  MOVFF  FEC,38B
08956:  MOVFF  FEC,38C
0895A:  MOVFF  FEC,38D
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
0895E:  MOVLW  0D
08960:  ADDWF  x86,W
08962:  MOVWF  FE9
08964:  MOVLW  00
08966:  ADDWFC x87,W
08968:  MOVWF  FEA
0896A:  BTFSC  FEF.4
0896C:  BRA    8988
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
0896E:  MOVFF  39A,FE9
08972:  MOVFF  39B,FEA
08976:  MOVLW  02
08978:  MOVWF  FEF
....................          MACDiscardRx(); 
0897A:  MOVLB  0
0897C:  CALL   6CC8
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
08980:  MOVLW  12
08982:  MOVLB  3
08984:  MOVWF  x9C
....................          goto SendTCPControlPacket; 
08986:  BRA    9098
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
08988:  MOVFF  39A,FE9
0898C:  MOVFF  39B,FEA
08990:  MOVLW  03
08992:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
08994:  MOVLW  10
08996:  MOVWF  x9C
....................  
....................       ps->RemoteWindow = h->Window; 
08998:  MOVLW  14
0899A:  ADDWF  x9A,W
0899C:  MOVWF  01
0899E:  MOVLW  00
089A0:  ADDWFC x9B,W
089A2:  MOVWF  03
089A4:  MOVWF  xA2
089A6:  MOVLW  0E
089A8:  ADDWF  x86,W
089AA:  MOVWF  FE9
089AC:  MOVLW  00
089AE:  ADDWFC x87,W
089B0:  MOVWF  FEA
089B2:  MOVFF  FEC,03
089B6:  MOVF   FED,F
089B8:  MOVFF  FEF,3A3
089BC:  MOVFF  3A2,FEA
089C0:  MOVFF  01,FE9
089C4:  MOVFF  03,FEC
089C8:  MOVF   FED,F
089CA:  MOVFF  3A3,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
089CE:  MOVF   x88,W
089D0:  IORWF  x89,W
089D2:  BZ    8A08
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
089D4:  MOVLW  23
089D6:  ADDWF  x9A,W
089D8:  MOVWF  FE9
089DA:  MOVLW  00
089DC:  ADDWFC x9B,W
089DE:  MOVWF  FEA
089E0:  BSF    FEF.3
....................          ps->RxCount             = len; 
089E2:  MOVLW  12
089E4:  ADDWF  x9A,W
089E6:  MOVWF  FE9
089E8:  MOVLW  00
089EA:  ADDWFC x9B,W
089EC:  MOVWF  FEA
089EE:  MOVFF  389,FEC
089F2:  MOVF   FED,F
089F4:  MOVFF  388,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
089F8:  MOVLW  23
089FA:  ADDWF  x9A,W
089FC:  MOVWF  FE9
089FE:  MOVLW  00
08A00:  ADDWFC x9B,W
08A02:  MOVWF  FEA
08A04:  BSF    FEF.2
....................       } 
08A06:  BRA    8A10
....................       else   // No application data in this packet 
....................       { 
....................          MACDiscardRx(); 
08A08:  MOVLB  0
08A0A:  CALL   6CC8
08A0E:  MOVLB  3
....................       } 
....................       goto SendTCPControlPacket; 
08A10:  BRA    9098
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
08A12:  MOVFF  39A,FE9
08A16:  MOVFF  39B,FEA
08A1A:  MOVF   FEF,F
08A1C:  BTFSS  FD8.2
08A1E:  BRA    8B8E
....................    { 
....................       MACDiscardRx(); 
08A20:  MOVLB  0
08A22:  CALL   6CC8
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
08A26:  MOVLW  0D
08A28:  MOVLB  3
08A2A:  ADDWF  x86,W
08A2C:  MOVWF  FE9
08A2E:  MOVLW  00
08A30:  ADDWFC x87,W
08A32:  MOVWF  FEA
08A34:  BTFSC  FEF.1
08A36:  BRA    8A3E
....................       { 
....................          flags = RST; 
08A38:  MOVLW  04
08A3A:  MOVWF  x9C
....................          goto SendTCPControlPacket; 
08A3C:  BRA    9098
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
08A3E:  MOVLW  1A
08A40:  ADDWF  x9A,W
08A42:  MOVWF  01
08A44:  MOVLW  00
08A46:  ADDWFC x9B,W
08A48:  MOVFF  01,3A1
08A4C:  MOVWF  xA2
08A4E:  MOVLW  04
08A50:  ADDWF  x86,W
08A52:  MOVWF  FE9
08A54:  MOVLW  00
08A56:  ADDWFC x87,W
08A58:  MOVWF  FEA
08A5A:  MOVFF  FEF,3A3
08A5E:  MOVFF  FEC,3A4
08A62:  MOVFF  FEC,3A5
08A66:  MOVFF  FEC,3A6
08A6A:  MOVF   x88,W
08A6C:  ADDWF  xA3,F
08A6E:  MOVF   x89,W
08A70:  ADDWFC xA4,F
08A72:  MOVLW  00
08A74:  ADDWFC xA5,F
08A76:  ADDWFC xA6,F
08A78:  MOVLW  01
08A7A:  ADDWF  xA3,W
08A7C:  MOVWF  00
08A7E:  MOVLW  00
08A80:  ADDWFC xA4,W
08A82:  MOVWF  01
08A84:  MOVLW  00
08A86:  ADDWFC xA5,W
08A88:  MOVWF  02
08A8A:  MOVLW  00
08A8C:  ADDWFC xA6,W
08A8E:  MOVFF  3A2,FEA
08A92:  MOVFF  3A1,FE9
08A96:  MOVFF  00,FEF
08A9A:  MOVFF  01,FEC
08A9E:  MOVFF  02,FEC
08AA2:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
08AA4:  MOVLW  14
08AA6:  ADDWF  x9A,W
08AA8:  MOVWF  01
08AAA:  MOVLW  00
08AAC:  ADDWFC x9B,W
08AAE:  MOVWF  03
08AB0:  MOVWF  xA2
08AB2:  MOVLW  0E
08AB4:  ADDWF  x86,W
08AB6:  MOVWF  FE9
08AB8:  MOVLW  00
08ABA:  ADDWFC x87,W
08ABC:  MOVWF  FEA
08ABE:  MOVFF  FEC,03
08AC2:  MOVF   FED,F
08AC4:  MOVFF  FEF,3A3
08AC8:  MOVFF  3A2,FEA
08ACC:  MOVFF  01,FE9
08AD0:  MOVFF  03,FEC
08AD4:  MOVF   FED,F
08AD6:  MOVFF  3A3,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
08ADA:  MOVLW  01
08ADC:  ADDWF  x9A,W
08ADE:  MOVWF  01
08AE0:  MOVLW  00
08AE2:  ADDWFC x9B,W
08AE4:  MOVWF  03
08AE6:  MOVFF  01,3A1
08AEA:  MOVWF  xA2
08AEC:  MOVWF  FEA
08AEE:  MOVFF  01,FE9
08AF2:  MOVFF  385,FE2
08AF6:  MOVFF  384,FE1
08AFA:  MOVLW  0A
08AFC:  MOVWF  01
08AFE:  MOVFF  FE6,FEE
08B02:  DECFSZ 01,F
08B04:  BRA    8AFE
....................       ps->remotePort = h->SourcePort; 
08B06:  MOVLW  0D
08B08:  ADDWF  x9A,W
08B0A:  MOVWF  01
08B0C:  MOVLW  00
08B0E:  ADDWFC x9B,W
08B10:  MOVFF  386,FE9
08B14:  MOVFF  387,FEA
08B18:  MOVFF  FEC,03
08B1C:  MOVF   FED,F
08B1E:  MOVFF  FEF,3A3
08B22:  MOVWF  FEA
08B24:  MOVFF  01,FE9
08B28:  MOVFF  03,FEC
08B2C:  MOVF   FED,F
08B2E:  MOVFF  3A3,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
08B32:  MOVFF  39A,FE9
08B36:  MOVFF  39B,FEA
08B3A:  MOVLW  02
08B3C:  MOVWF  FEF
....................       seq = ps->SND_SEQ++; 
08B3E:  MOVLW  16
08B40:  ADDWF  x9A,W
08B42:  MOVWF  FE9
08B44:  MOVLW  00
08B46:  ADDWFC x9B,W
08B48:  MOVWF  FEA
08B4A:  MOVF   FEE,F
08B4C:  MOVF   FEE,F
08B4E:  MOVF   FEE,F
08B50:  MOVFF  FED,391
08B54:  MOVFF  FED,390
08B58:  MOVFF  FED,38F
08B5C:  MOVFF  FEF,38E
08B60:  MOVLW  01
08B62:  ADDWF  FEE,F
08B64:  MOVLW  00
08B66:  ADDWFC FEE,F
08B68:  ADDWFC FEE,F
08B6A:  ADDWFC FED,F
....................       ack =  ps->SND_ACK; 
08B6C:  MOVLW  1A
08B6E:  ADDWF  x9A,W
08B70:  MOVWF  FE9
08B72:  MOVLW  00
08B74:  ADDWFC x9B,W
08B76:  MOVWF  FEA
08B78:  MOVFF  FEF,38A
08B7C:  MOVFF  FEC,38B
08B80:  MOVFF  FEC,38C
08B84:  MOVFF  FEC,38D
....................       flags = SYN | ACK; 
08B88:  MOVLW  12
08B8A:  MOVWF  x9C
....................       goto SendTCPControlPacket; 
08B8C:  BRA    9098
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
08B8E:  MOVLW  1A
08B90:  ADDWF  x9A,W
08B92:  MOVWF  FE9
08B94:  MOVLW  00
08B96:  ADDWFC x9B,W
08B98:  MOVWF  FEA
08B9A:  MOVFF  FEF,392
08B9E:  MOVFF  FEC,393
08BA2:  MOVFF  FEC,394
08BA6:  MOVFF  FEC,395
....................    prevSeq = ps->SND_SEQ; 
08BAA:  MOVLW  16
08BAC:  ADDWF  x9A,W
08BAE:  MOVWF  FE9
08BB0:  MOVLW  00
08BB2:  ADDWFC x9B,W
08BB4:  MOVWF  FEA
08BB6:  MOVFF  FEF,396
08BBA:  MOVFF  FEC,397
08BBE:  MOVFF  FEC,398
08BC2:  MOVFF  FEC,399
....................  
....................    ack = h->SeqNumber; 
08BC6:  MOVLW  04
08BC8:  ADDWF  x86,W
08BCA:  MOVWF  FE9
08BCC:  MOVLW  00
08BCE:  ADDWFC x87,W
08BD0:  MOVWF  FEA
08BD2:  MOVFF  FEF,38A
08BD6:  MOVFF  FEC,38B
08BDA:  MOVFF  FEC,38C
08BDE:  MOVFF  FEC,38D
....................    ack += (DWORD)len; 
08BE2:  CLRF   02
08BE4:  CLRF   03
08BE6:  MOVF   x88,W
08BE8:  ADDWF  x8A,F
08BEA:  MOVF   x89,W
08BEC:  ADDWFC x8B,F
08BEE:  MOVF   02,W
08BF0:  ADDWFC x8C,F
08BF2:  MOVF   03,W
08BF4:  ADDWFC x8D,F
....................    seq = ps->SND_SEQ; 
08BF6:  MOVLW  16
08BF8:  ADDWF  x9A,W
08BFA:  MOVWF  FE9
08BFC:  MOVLW  00
08BFE:  ADDWFC x9B,W
08C00:  MOVWF  FEA
08C02:  MOVFF  FEF,38E
08C06:  MOVFF  FEC,38F
08C0A:  MOVFF  FEC,390
08C0E:  MOVFF  FEC,391
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
08C12:  MOVLW  04
08C14:  ADDWF  x86,W
08C16:  MOVWF  FE9
08C18:  MOVLW  00
08C1A:  ADDWFC x87,W
08C1C:  MOVWF  FEA
08C1E:  MOVFF  FEF,3A1
08C22:  MOVFF  FEC,3A2
08C26:  MOVFF  FEC,3A3
08C2A:  MOVFF  FEC,3A4
08C2E:  MOVF   x92,W
08C30:  SUBWF  xA1,W
08C32:  BTFSS  FD8.2
08C34:  BRA    907C
08C36:  MOVF   x93,W
08C38:  SUBWF  xA2,W
08C3A:  BTFSS  FD8.2
08C3C:  BRA    907C
08C3E:  MOVF   x94,W
08C40:  SUBWF  xA3,W
08C42:  BTFSS  FD8.2
08C44:  BRA    907C
08C46:  MOVF   x95,W
08C48:  SUBWF  xA4,W
08C4A:  BTFSS  FD8.2
08C4C:  BRA    907C
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
08C4E:  MOVFF  39A,FE9
08C52:  MOVFF  39B,FEA
08C56:  MOVF   FEF,W
08C58:  SUBLW  02
08C5A:  BNZ   8CE2
....................          { 
....................             if(h->Flags.bits.flagACK) 
08C5C:  MOVLW  0D
08C5E:  ADDWF  x86,W
08C60:  MOVWF  FE9
08C62:  MOVLW  00
08C64:  ADDWFC x87,W
08C66:  MOVWF  FEA
08C68:  BTFSS  FEF.4
08C6A:  BRA    8CD8
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
08C6C:  MOVLW  1A
08C6E:  ADDWF  x9A,W
08C70:  MOVWF  FE9
08C72:  MOVLW  00
08C74:  ADDWFC x9B,W
08C76:  MOVWF  FEA
08C78:  MOVFF  38A,FEF
08C7C:  MOVFF  38B,FEC
08C80:  MOVFF  38C,FEC
08C84:  MOVFF  38D,FEC
....................                ps->smState = TCP_ESTABLISHED; 
08C88:  MOVFF  39A,FE9
08C8C:  MOVFF  39B,FEA
08C90:  MOVLW  03
08C92:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
08C94:  MOVF   x88,W
08C96:  IORWF  x89,W
08C98:  BZ    8CCE
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
08C9A:  MOVLW  23
08C9C:  ADDWF  x9A,W
08C9E:  MOVWF  FE9
08CA0:  MOVLW  00
08CA2:  ADDWFC x9B,W
08CA4:  MOVWF  FEA
08CA6:  BSF    FEF.3
....................                   ps->RxCount             = len; 
08CA8:  MOVLW  12
08CAA:  ADDWF  x9A,W
08CAC:  MOVWF  FE9
08CAE:  MOVLW  00
08CB0:  ADDWFC x9B,W
08CB2:  MOVWF  FEA
08CB4:  MOVFF  389,FEC
08CB8:  MOVF   FED,F
08CBA:  MOVFF  388,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
08CBE:  MOVLW  23
08CC0:  ADDWF  x9A,W
08CC2:  MOVWF  FE9
08CC4:  MOVLW  00
08CC6:  ADDWFC x9B,W
08CC8:  MOVWF  FEA
08CCA:  BSF    FEF.2
....................                } 
08CCC:  BRA    8CD6
....................                else 
....................                   MACDiscardRx(); 
08CCE:  MOVLB  0
08CD0:  CALL   6CC8
08CD4:  MOVLB  3
....................             } 
08CD6:  BRA    8CE0
....................             else   // No ACK to our SYN 
....................             { 
....................                MACDiscardRx(); 
08CD8:  MOVLB  0
08CDA:  CALL   6CC8
08CDE:  MOVLB  3
....................             } 
....................          } 
08CE0:  BRA    907A
....................          // Connection is established, closing, or otherwise 
....................          else 
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
08CE2:  MOVLW  1A
08CE4:  ADDWF  x9A,W
08CE6:  MOVWF  FE9
08CE8:  MOVLW  00
08CEA:  ADDWFC x9B,W
08CEC:  MOVWF  FEA
08CEE:  MOVFF  38A,FEF
08CF2:  MOVFF  38B,FEC
08CF6:  MOVFF  38C,FEC
08CFA:  MOVFF  38D,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
08CFE:  MOVFF  39A,FE9
08D02:  MOVFF  39B,FEA
08D06:  MOVF   FEF,W
08D08:  SUBLW  03
08D0A:  BTFSS  FD8.2
08D0C:  BRA    8EAC
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
08D0E:  MOVLW  0D
08D10:  ADDWF  x86,W
08D12:  MOVWF  FE9
08D14:  MOVLW  00
08D16:  ADDWFC x87,W
08D18:  MOVWF  FEA
08D1A:  BTFSS  FEF.4
08D1C:  BRA    8D74
08D1E:  MOVLW  23
08D20:  ADDWF  x9A,W
08D22:  MOVWF  FE9
08D24:  MOVLW  00
08D26:  ADDWFC x9B,W
08D28:  MOVWF  FEA
08D2A:  BTFSC  FEF.1
08D2C:  BRA    8D74
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
08D2E:  MOVLW  0F
08D30:  ADDWF  x9A,W
08D32:  MOVWF  FE9
08D34:  MOVLW  00
08D36:  ADDWFC x9B,W
08D38:  MOVWF  FEA
08D3A:  INCFSZ FEF,W
08D3C:  BRA    8D40
08D3E:  BRA    8D74
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
08D40:  MOVLW  0F
08D42:  ADDWF  x9A,W
08D44:  MOVWF  FE9
08D46:  MOVLW  00
08D48:  ADDWFC x9B,W
08D4A:  MOVWF  FEA
08D4C:  MOVFF  FEF,3A4
08D50:  MOVLB  0
08D52:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
08D56:  MOVLW  0F
08D58:  MOVLB  3
08D5A:  ADDWF  x9A,W
08D5C:  MOVWF  FE9
08D5E:  MOVLW  00
08D60:  ADDWFC x9B,W
08D62:  MOVWF  FEA
08D64:  SETF   FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
08D66:  MOVLW  23
08D68:  ADDWF  x9A,W
08D6A:  MOVWF  FE9
08D6C:  MOVLW  00
08D6E:  ADDWFC x9B,W
08D70:  MOVWF  FEA
08D72:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
08D74:  MOVLW  0D
08D76:  ADDWF  x86,W
08D78:  MOVWF  FE9
08D7A:  MOVLW  00
08D7C:  ADDWFC x87,W
08D7E:  MOVWF  FEA
08D80:  BTFSS  FEF.0
08D82:  BRA    8E14
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
08D84:  MOVLW  11
08D86:  MOVWF  x9C
....................                   seq = ps->SND_SEQ++; 
08D88:  MOVLW  16
08D8A:  ADDWF  x9A,W
08D8C:  MOVWF  FE9
08D8E:  MOVLW  00
08D90:  ADDWFC x9B,W
08D92:  MOVWF  FEA
08D94:  MOVF   FEE,F
08D96:  MOVF   FEE,F
08D98:  MOVF   FEE,F
08D9A:  MOVFF  FED,391
08D9E:  MOVFF  FED,390
08DA2:  MOVFF  FED,38F
08DA6:  MOVFF  FEF,38E
08DAA:  MOVLW  01
08DAC:  ADDWF  FEE,F
08DAE:  MOVLW  00
08DB0:  ADDWFC FEE,F
08DB2:  ADDWFC FEE,F
08DB4:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
08DB6:  MOVLW  1A
08DB8:  ADDWF  x9A,W
08DBA:  MOVWF  FE9
08DBC:  MOVLW  00
08DBE:  ADDWFC x9B,W
08DC0:  MOVWF  FEA
08DC2:  MOVLW  01
08DC4:  ADDWF  FEF,W
08DC6:  MOVWF  00
08DC8:  MOVLW  00
08DCA:  ADDWFC FEC,W
08DCC:  MOVWF  01
08DCE:  MOVLW  00
08DD0:  ADDWFC FEC,W
08DD2:  MOVWF  02
08DD4:  MOVLW  00
08DD6:  ADDWFC FEC,W
08DD8:  MOVF   FED,F
08DDA:  MOVF   FED,F
08DDC:  MOVF   FED,F
08DDE:  MOVFF  00,FEF
08DE2:  MOVFF  01,FEC
08DE6:  MOVFF  02,FEC
08DEA:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
08DEC:  MOVLW  1A
08DEE:  ADDWF  x9A,W
08DF0:  MOVWF  FE9
08DF2:  MOVLW  00
08DF4:  ADDWFC x9B,W
08DF6:  MOVWF  FEA
08DF8:  MOVFF  FEF,38A
08DFC:  MOVFF  FEC,38B
08E00:  MOVFF  FEC,38C
08E04:  MOVFF  FEC,38D
....................                   ps->smState = TCP_LAST_ACK; 
08E08:  MOVFF  39A,FE9
08E0C:  MOVFF  39B,FEA
08E10:  MOVLW  09
08E12:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
08E14:  MOVF   x88,W
08E16:  IORWF  x89,W
08E18:  BZ    8EA2
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
08E1A:  MOVLW  23
08E1C:  ADDWF  x9A,W
08E1E:  MOVWF  FE9
08E20:  MOVLW  00
08E22:  ADDWFC x9B,W
08E24:  MOVWF  FEA
08E26:  BTFSC  FEF.3
08E28:  BRA    8E60
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
08E2A:  MOVLW  23
08E2C:  ADDWF  x9A,W
08E2E:  MOVWF  FE9
08E30:  MOVLW  00
08E32:  ADDWFC x9B,W
08E34:  MOVWF  FEA
08E36:  BSF    FEF.3
....................                      ps->RxCount             = len; 
08E38:  MOVLW  12
08E3A:  ADDWF  x9A,W
08E3C:  MOVWF  FE9
08E3E:  MOVLW  00
08E40:  ADDWFC x9B,W
08E42:  MOVWF  FEA
08E44:  MOVFF  389,FEC
08E48:  MOVF   FED,F
08E4A:  MOVFF  388,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
08E4E:  MOVLW  23
08E50:  ADDWF  x9A,W
08E52:  MOVWF  FE9
08E54:  MOVLW  00
08E56:  ADDWFC x9B,W
08E58:  MOVWF  FEA
08E5A:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
08E5C:  BSF    x9C.4
....................                   } 
08E5E:  BRA    8EA0
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
08E60:  MOVLW  16
08E62:  ADDWF  x9A,W
08E64:  MOVWF  FE9
08E66:  MOVLW  00
08E68:  ADDWFC x9B,W
08E6A:  MOVWF  FEA
08E6C:  MOVFF  396,FEF
08E70:  MOVFF  397,FEC
08E74:  MOVFF  398,FEC
08E78:  MOVFF  399,FEC
....................                      ps->SND_ACK = prevAck; 
08E7C:  MOVLW  1A
08E7E:  ADDWF  x9A,W
08E80:  MOVWF  FE9
08E82:  MOVLW  00
08E84:  ADDWFC x9B,W
08E86:  MOVWF  FEA
08E88:  MOVFF  392,FEF
08E8C:  MOVFF  393,FEC
08E90:  MOVFF  394,FEC
08E94:  MOVFF  395,FEC
....................  
....................                      MACDiscardRx(); 
08E98:  MOVLB  0
08E9A:  CALL   6CC8
08E9E:  MOVLB  3
....................                   } 
....................                } 
08EA0:  BRA    8EAA
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
....................                { 
....................                   MACDiscardRx(); 
08EA2:  MOVLB  0
08EA4:  CALL   6CC8
08EA8:  MOVLB  3
....................                } 
....................             } 
08EAA:  BRA    907A
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
08EAC:  MOVFF  39A,FE9
08EB0:  MOVFF  39B,FEA
08EB4:  MOVF   FEF,W
08EB6:  SUBLW  09
08EB8:  BNZ   8EE4
....................             { 
....................                MACDiscardRx(); 
08EBA:  MOVLB  0
08EBC:  CALL   6CC8
....................  
....................                if(h->Flags.bits.flagACK) 
08EC0:  MOVLW  0D
08EC2:  MOVLB  3
08EC4:  ADDWF  x86,W
08EC6:  MOVWF  FE9
08EC8:  MOVLW  00
08ECA:  ADDWFC x87,W
08ECC:  MOVWF  FEA
08ECE:  BTFSS  FEF.4
08ED0:  BRA    8EE2
....................                { 
....................                   CloseSocket(ps); 
08ED2:  MOVFF  39B,3A2
08ED6:  MOVFF  39A,3A1
08EDA:  MOVLB  0
08EDC:  CALL   8092
08EE0:  MOVLB  3
....................                } 
....................             } 
08EE2:  BRA    907A
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
08EE4:  MOVFF  39A,FE9
08EE8:  MOVFF  39B,FEA
08EEC:  MOVF   FEF,W
08EEE:  SUBLW  04
08EF0:  BNZ   8FB6
....................             { 
....................                MACDiscardRx(); 
08EF2:  MOVLB  0
08EF4:  CALL   6CC8
....................  
....................                if(h->Flags.bits.flagFIN) 
08EF8:  MOVLW  0D
08EFA:  MOVLB  3
08EFC:  ADDWF  x86,W
08EFE:  MOVWF  FE9
08F00:  MOVLW  00
08F02:  ADDWFC x87,W
08F04:  MOVWF  FEA
08F06:  BTFSS  FEF.0
08F08:  BRA    8F94
....................                { 
....................                   flags = ACK; 
08F0A:  MOVLW  10
08F0C:  MOVWF  x9C
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
08F0E:  MOVLW  1A
08F10:  ADDWF  x9A,W
08F12:  MOVWF  FE9
08F14:  MOVLW  00
08F16:  ADDWFC x9B,W
08F18:  MOVWF  FEA
08F1A:  MOVLW  01
08F1C:  ADDWF  FEF,W
08F1E:  MOVWF  00
08F20:  MOVLW  00
08F22:  ADDWFC FEC,W
08F24:  MOVWF  01
08F26:  MOVLW  00
08F28:  ADDWFC FEC,W
08F2A:  MOVWF  02
08F2C:  MOVLW  00
08F2E:  ADDWFC FEC,W
08F30:  MOVF   FED,F
08F32:  MOVF   FED,F
08F34:  MOVF   FED,F
08F36:  MOVFF  00,FEF
08F3A:  MOVFF  01,FEC
08F3E:  MOVFF  02,FEC
08F42:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
08F44:  MOVLW  1A
08F46:  ADDWF  x9A,W
08F48:  MOVWF  FE9
08F4A:  MOVLW  00
08F4C:  ADDWFC x9B,W
08F4E:  MOVWF  FEA
08F50:  MOVFF  FEF,38A
08F54:  MOVFF  FEC,38B
08F58:  MOVFF  FEC,38C
08F5C:  MOVFF  FEC,38D
....................                   if(h->Flags.bits.flagACK) 
08F60:  MOVLW  0D
08F62:  ADDWF  x86,W
08F64:  MOVWF  FE9
08F66:  MOVLW  00
08F68:  ADDWFC x87,W
08F6A:  MOVWF  FEA
08F6C:  BTFSS  FEF.4
08F6E:  BRA    8F82
....................                   { 
....................                      CloseSocket(ps); 
08F70:  MOVFF  39B,3A2
08F74:  MOVFF  39A,3A1
08F78:  MOVLB  0
08F7A:  CALL   8092
....................                   } 
08F7E:  BRA    8F90
08F80:  MOVLB  3
....................                   else 
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
08F82:  MOVFF  39A,FE9
08F86:  MOVFF  39B,FEA
08F8A:  MOVLW  06
08F8C:  MOVWF  FEF
08F8E:  MOVLB  0
....................                   } 
....................                } 
08F90:  BRA    8FB2
08F92:  MOVLB  3
....................                else if(h->Flags.bits.flagACK) 
08F94:  MOVLW  0D
08F96:  ADDWF  x86,W
08F98:  MOVWF  FE9
08F9A:  MOVLW  00
08F9C:  ADDWFC x87,W
08F9E:  MOVWF  FEA
08FA0:  BTFSS  FEF.4
08FA2:  BRA    8FB0
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
08FA4:  MOVFF  39A,FE9
08FA8:  MOVFF  39B,FEA
08FAC:  MOVLW  05
08FAE:  MOVWF  FEF
08FB0:  MOVLB  0
....................                } 
....................             } 
08FB2:  BRA    9078
08FB4:  MOVLB  3
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
08FB6:  MOVFF  39A,FE9
08FBA:  MOVFF  39B,FEA
08FBE:  MOVF   FEF,W
08FC0:  SUBLW  05
08FC2:  BNZ   9044
....................             { 
....................                MACDiscardRx(); 
08FC4:  MOVLB  0
08FC6:  CALL   6CC8
....................  
....................                if(h->Flags.bits.flagFIN) 
08FCA:  MOVLW  0D
08FCC:  MOVLB  3
08FCE:  ADDWF  x86,W
08FD0:  MOVWF  FE9
08FD2:  MOVLW  00
08FD4:  ADDWFC x87,W
08FD6:  MOVWF  FEA
08FD8:  BTFSS  FEF.0
08FDA:  BRA    9042
....................                { 
....................                   flags = ACK; 
08FDC:  MOVLW  10
08FDE:  MOVWF  x9C
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
08FE0:  MOVLW  1A
08FE2:  ADDWF  x9A,W
08FE4:  MOVWF  FE9
08FE6:  MOVLW  00
08FE8:  ADDWFC x9B,W
08FEA:  MOVWF  FEA
08FEC:  MOVLW  01
08FEE:  ADDWF  FEF,W
08FF0:  MOVWF  00
08FF2:  MOVLW  00
08FF4:  ADDWFC FEC,W
08FF6:  MOVWF  01
08FF8:  MOVLW  00
08FFA:  ADDWFC FEC,W
08FFC:  MOVWF  02
08FFE:  MOVLW  00
09000:  ADDWFC FEC,W
09002:  MOVF   FED,F
09004:  MOVF   FED,F
09006:  MOVF   FED,F
09008:  MOVFF  00,FEF
0900C:  MOVFF  01,FEC
09010:  MOVFF  02,FEC
09014:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
09016:  MOVLW  1A
09018:  ADDWF  x9A,W
0901A:  MOVWF  FE9
0901C:  MOVLW  00
0901E:  ADDWFC x9B,W
09020:  MOVWF  FEA
09022:  MOVFF  FEF,38A
09026:  MOVFF  FEC,38B
0902A:  MOVFF  FEC,38C
0902E:  MOVFF  FEC,38D
....................                   CloseSocket(ps); 
09032:  MOVFF  39B,3A2
09036:  MOVFF  39A,3A1
0903A:  MOVLB  0
0903C:  CALL   8092
09040:  MOVLB  3
....................                } 
....................             } 
09042:  BRA    907A
....................             else if ( ps->smState == TCP_CLOSING ) 
09044:  MOVFF  39A,FE9
09048:  MOVFF  39B,FEA
0904C:  MOVF   FEF,W
0904E:  SUBLW  06
09050:  BNZ   907A
....................             { 
....................                MACDiscardRx(); 
09052:  MOVLB  0
09054:  CALL   6CC8
....................  
....................                if ( h->Flags.bits.flagACK ) 
09058:  MOVLW  0D
0905A:  MOVLB  3
0905C:  ADDWF  x86,W
0905E:  MOVWF  FE9
09060:  MOVLW  00
09062:  ADDWFC x87,W
09064:  MOVWF  FEA
09066:  BTFSS  FEF.4
09068:  BRA    907A
....................                { 
....................                   CloseSocket(ps); 
0906A:  MOVFF  39B,3A2
0906E:  MOVFF  39A,3A1
09072:  MOVLB  0
09074:  CALL   8092
09078:  MOVLB  3
....................                } 
....................             } 
....................          } 
....................       } 
0907A:  BRA    9098
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
....................       { 
....................          MACDiscardRx(); 
0907C:  MOVLB  0
0907E:  CALL   6CC8
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
09082:  MOVLW  10
09084:  MOVLB  3
09086:  MOVWF  x9C
....................          ack = prevAck; 
09088:  MOVFF  395,38D
0908C:  MOVFF  394,38C
09090:  MOVFF  393,38B
09094:  MOVFF  392,38A
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
09098:  MOVF   x9C,F
0909A:  BZ    90FE
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
0909C:  MOVLW  02
0909E:  ADDWF  x86,W
090A0:  MOVWF  FE9
090A2:  MOVLW  00
090A4:  ADDWFC x87,W
090A6:  MOVWF  FEA
090A8:  MOVFF  FEC,3AB
090AC:  MOVF   FED,F
090AE:  MOVFF  FEF,3AA
090B2:  MOVFF  386,FE9
090B6:  MOVFF  387,FEA
090BA:  MOVFF  FEC,3AD
090BE:  MOVF   FED,F
090C0:  MOVFF  FEF,3AC
090C4:  MOVFF  385,3A9
090C8:  MOVFF  384,3A8
090CC:  MOVFF  391,3B1
090D0:  MOVFF  390,3B0
090D4:  MOVFF  38F,3AF
090D8:  MOVFF  38E,3AE
090DC:  MOVFF  38D,3B5
090E0:  MOVFF  38C,3B4
090E4:  MOVFF  38B,3B3
090E8:  MOVFF  38A,3B2
090EC:  MOVFF  39C,3B6
090F0:  SETF   xB7
090F2:  CLRF   xB9
090F4:  CLRF   xB8
090F6:  MOVLB  0
090F8:  CALL   84E0
090FC:  MOVLB  3
....................    } 
090FE:  MOVLB  0
09100:  GOTO   9280 (RETURN)
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #define debug_icmp 
.................... //#define debug_icmp   debug_printf 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
.................... //    debug_icmp("\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
0935A:  MOVLW  03
0935C:  MOVLB  3
0935E:  MOVWF  xB0
09360:  MOVLW  63
09362:  MOVWF  xAF
09364:  MOVFF  3B0,3EF
09368:  MOVWF  xEE
0936A:  CLRF   xF1
0936C:  MOVLW  08
0936E:  MOVWF  xF0
09370:  MOVLB  0
09372:  CALL   6D36
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
09376:  MOVLB  3
09378:  CLRF   xAE
0937A:  CLRF   xAD
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
0937C:  MOVFF  35E,03
09380:  MOVFF  35D,FE9
09384:  MOVFF  35E,FEA
09388:  MOVFF  FEF,3B2
0938C:  CLRF   xB1
0938E:  MOVLW  14
09390:  MOVWF  xB0
09392:  CLRF   xB3
09394:  MOVLB  0
09396:  CALL   76D6
0939A:  MOVFF  02,3AC
0939E:  MOVFF  01,3AB
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
093A2:  MOVLB  3
093A4:  MOVFF  35D,FE9
093A8:  MOVFF  35E,FEA
093AC:  MOVLW  08
093AE:  SUBWF  FEF,W
093B0:  MOVWF  FEF
....................     MACGetArray(data, *len); 
093B2:  MOVFF  35E,03
093B6:  MOVFF  35D,FE9
093BA:  MOVFF  35E,FEA
093BE:  MOVFF  FEF,3F0
093C2:  MOVFF  35C,3EF
093C6:  MOVFF  35B,3EE
093CA:  CLRF   xF1
093CC:  MOVLB  0
093CE:  CALL   6D36
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
093D2:  MOVLW  03
093D4:  MOVLB  3
093D6:  MOVWF  xB0
093D8:  MOVLW  63
093DA:  MOVWF  xAF
093DC:  MOVLB  0
093DE:  RCALL  9292
....................  
....................     *code = packet.Type; 
093E0:  MOVLB  3
093E2:  MOVFF  359,FE9
093E6:  MOVFF  35A,FEA
093EA:  MOVFF  363,FEF
....................     *id = packet.Identifier; 
093EE:  MOVFF  35F,FE9
093F2:  MOVFF  360,FEA
093F6:  MOVFF  368,FEC
093FA:  MOVF   FED,F
093FC:  MOVFF  367,FEF
....................     *seq = packet.SequenceNumber; 
09400:  MOVFF  361,FE9
09404:  MOVFF  362,FEA
09408:  MOVFF  36A,FEC
0940C:  MOVF   FED,F
0940E:  MOVFF  369,FEF
....................  
.................... //    debug_icmp("%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
09412:  MOVF   xAD,W
09414:  SUBWF  xAB,W
09416:  BNZ   941E
09418:  MOVF   xAE,W
0941A:  SUBWF  xAC,W
0941C:  BZ    9422
0941E:  MOVLW  00
09420:  BRA    9424
09422:  MOVLW  01
09424:  MOVWF  01
09426:  MOVLB  0
09428:  GOTO   C84E (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
0942C:  MOVLW  01
0942E:  MOVLB  3
09430:  MOVWF  xE0
09432:  MOVLB  0
09434:  CALL   7098
09438:  MOVFF  01,3AB
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
0943C:  MOVLB  3
0943E:  INCFSZ xAB,W
09440:  BRA    9444
....................       return; 
09442:  BRA    9542
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
09444:  MOVFF  3AB,3F9
09448:  CLRF   xFB
0944A:  MOVLW  14
0944C:  MOVWF  xFA
0944E:  MOVLB  0
09450:  CALL   70C0
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
09454:  CLRF   03
09456:  MOVLB  3
09458:  MOVF   x5C,W
0945A:  ADDLW  08
0945C:  MOVWF  xA9
0945E:  MOVLW  00
09460:  ADDWFC 03,W
09462:  MOVWF  xAA
....................  
....................     packet.Code             = 0; 
09464:  CLRF   x62
....................     packet.Type             = code; 
09466:  MOVFF  359,361
....................     packet.Checksum         = 0; 
0946A:  CLRF   x64
0946C:  CLRF   x63
....................     packet.Identifier       = id; 
0946E:  MOVFF  35E,366
09472:  MOVFF  35D,365
....................     packet.SequenceNumber   = seq; 
09476:  MOVFF  360,368
0947A:  MOVFF  35F,367
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
0947E:  MOVLW  03
09480:  MOVWF  FEA
09482:  MOVLW  69
09484:  MOVWF  FE9
09486:  MOVFF  35B,FE2
0948A:  MOVFF  35A,FE1
0948E:  MOVF   x5C,W
09490:  MOVWF  01
09492:  BZ    949C
09494:  MOVFF  FE6,FEE
09498:  DECFSZ 01,F
0949A:  BRA    9494
....................  
....................     SwapICMPPacket(&packet); 
0949C:  MOVLW  03
0949E:  MOVWF  xB0
094A0:  MOVLW  61
094A2:  MOVWF  xAF
094A4:  MOVLB  0
094A6:  RCALL  9292
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
094A8:  MOVLW  08
094AA:  MOVLB  3
094AC:  ADDWF  x5C,W
094AE:  CLRF   xAD
094B0:  MOVWF  xAC
094B2:  MOVFF  358,3E1
094B6:  MOVFF  357,3E0
094BA:  MOVLW  01
094BC:  MOVWF  xE2
094BE:  MOVFF  3AD,3E4
094C2:  MOVFF  3AC,3E3
094C6:  MOVLB  0
094C8:  CALL   83B6
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
094CC:  MOVLW  03
094CE:  MOVLB  3
094D0:  MOVWF  xAD
094D2:  MOVLW  61
094D4:  MOVWF  xAC
094D6:  MOVFF  3AD,405
094DA:  MOVFF  FE8,404
094DE:  MOVFF  3AA,407
094E2:  MOVFF  3A9,406
094E6:  MOVLB  0
094E8:  CALL   7186
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
094EC:  MOVLB  3
094EE:  CLRF   xFA
094F0:  MOVLW  14
094F2:  MOVWF  xF9
094F4:  MOVFF  3AA,3FC
094F8:  MOVFF  3A9,3FB
094FC:  MOVLB  0
094FE:  CALL   82D2
09502:  MOVFF  02,364
09506:  MOVFF  01,363
....................    IPSetTxBuffer(MyTxBuffer, 2); 
0950A:  MOVFF  3AB,3F9
0950E:  MOVLB  3
09510:  CLRF   xFB
09512:  MOVLW  16
09514:  MOVWF  xFA
09516:  MOVLB  0
09518:  CALL   70C0
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
0951C:  MOVLW  03
0951E:  MOVLB  3
09520:  MOVWF  xAD
09522:  MOVLW  63
09524:  MOVWF  xAC
09526:  MOVFF  3AD,405
0952A:  MOVFF  FE8,404
0952E:  MOVLB  4
09530:  CLRF   x07
09532:  MOVLW  02
09534:  MOVWF  x06
09536:  MOVLB  0
09538:  CALL   7186
.................... #endif 
....................  
....................  
....................     MACFlush(); 
0953C:  CALL   729A
09540:  MOVLB  3
09542:  MOVLB  0
09544:  GOTO   C8AC (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
09292:  MOVLW  04
09294:  MOVLB  3
09296:  ADDWF  xAF,W
09298:  MOVWF  01
0929A:  MOVLW  00
0929C:  ADDWFC xB0,W
0929E:  MOVWF  03
092A0:  MOVFF  01,3B1
092A4:  MOVWF  xB2
092A6:  MOVLW  04
092A8:  ADDWF  xAF,W
092AA:  MOVWF  FE9
092AC:  MOVLW  00
092AE:  ADDWFC xB0,W
092B0:  MOVWF  FEA
092B2:  MOVFF  FEC,400
092B6:  MOVF   FED,F
092B8:  MOVFF  FEF,3FF
092BC:  MOVLB  0
092BE:  CALL   6D9E
092C2:  MOVFF  3B2,FEA
092C6:  MOVFF  3B1,FE9
092CA:  MOVFF  02,FEC
092CE:  MOVF   FED,F
092D0:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
092D4:  MOVLW  06
092D6:  MOVLB  3
092D8:  ADDWF  xAF,W
092DA:  MOVWF  01
092DC:  MOVLW  00
092DE:  ADDWFC xB0,W
092E0:  MOVWF  03
092E2:  MOVFF  01,3B1
092E6:  MOVWF  xB2
092E8:  MOVLW  06
092EA:  ADDWF  xAF,W
092EC:  MOVWF  FE9
092EE:  MOVLW  00
092F0:  ADDWFC xB0,W
092F2:  MOVWF  FEA
092F4:  MOVFF  FEC,400
092F8:  MOVF   FED,F
092FA:  MOVFF  FEF,3FF
092FE:  MOVLB  0
09300:  CALL   6D9E
09304:  MOVFF  3B2,FEA
09308:  MOVFF  3B1,FE9
0930C:  MOVFF  02,FEC
09310:  MOVF   FED,F
09312:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
09316:  MOVLW  02
09318:  MOVLB  3
0931A:  ADDWF  xAF,W
0931C:  MOVWF  01
0931E:  MOVLW  00
09320:  ADDWFC xB0,W
09322:  MOVWF  03
09324:  MOVFF  01,3B1
09328:  MOVWF  xB2
0932A:  MOVLW  02
0932C:  ADDWF  xAF,W
0932E:  MOVWF  FE9
09330:  MOVLW  00
09332:  ADDWFC xB0,W
09334:  MOVWF  FEA
09336:  MOVFF  FEC,400
0933A:  MOVF   FED,F
0933C:  MOVFF  FEF,3FF
09340:  MOVLB  0
09342:  CALL   6D9E
09346:  MOVFF  3B2,FEA
0934A:  MOVFF  3B1,FE9
0934E:  MOVFF  02,FEC
09352:  MOVF   FED,F
09354:  MOVFF  01,FEF
09358:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
068C8:  BCF    59.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
068CA:  MOVLB  1
068CC:  SETF   x16
....................     Cache.MACAddr.v[1] = 0xff; 
068CE:  SETF   x17
....................     Cache.MACAddr.v[2] = 0xff; 
068D0:  SETF   x18
....................     Cache.MACAddr.v[3] = 0xff; 
068D2:  SETF   x19
....................     Cache.MACAddr.v[4] = 0xff; 
068D4:  SETF   x1A
....................     Cache.MACAddr.v[5] = 0xff; 
068D6:  SETF   x1B
....................  
....................     Cache.IPAddr.Val = 0x0; 
068D8:  CLRF   x1F
068DA:  CLRF   x1E
068DC:  CLRF   x1D
068DE:  CLRF   x1C
068E0:  MOVLB  0
068E2:  GOTO   6CC0 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
*
07646:  MOVLW  00
07648:  BTFSC  59.1
0764A:  MOVLW  01
0764C:  XORLW  00
0764E:  BZ    7652
07650:  BRA    76B0
....................     { 
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
07652:  MOVLW  03
07654:  MOVLB  3
07656:  MOVWF  x63
07658:  MOVLW  57
0765A:  MOVWF  x62
0765C:  MOVLW  03
0765E:  MOVWF  x65
07660:  MOVLW  61
07662:  MOVWF  x64
07664:  MOVLB  0
07666:  BRA    6FB0
07668:  MOVF   01,F
0766A:  BNZ   766E
....................             break; 
0766C:  BRA    76CE
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
0766E:  CALL   6CC8
....................  
....................         if ( opCode == ARP_REPLY ) 
07672:  MOVLB  3
07674:  MOVF   x61,F
07676:  BNZ   76AC
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
07678:  MOVLW  01
0767A:  MOVWF  FEA
0767C:  MOVLW  16
0767E:  MOVWF  FE9
07680:  MOVLW  03
07682:  MOVWF  FE2
07684:  MOVLW  57
07686:  MOVWF  FE1
07688:  MOVLW  06
0768A:  MOVWF  01
0768C:  MOVFF  FE6,FEE
07690:  DECFSZ 01,F
07692:  BRA    768C
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
07694:  MOVFF  360,11F
07698:  MOVFF  35F,11E
0769C:  MOVFF  35E,11D
076A0:  MOVFF  35D,11C
....................             break; 
076A4:  MOVLB  0
076A6:  BRA    76CE
....................         } 
076A8:  BRA    76B0
076AA:  MOVLB  3
....................         else 
....................             smARP = SM_ARP_REPLY; 
076AC:  BSF    59.1
076AE:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
076B0:  MOVLW  03
076B2:  MOVLB  3
076B4:  MOVWF  x63
076B6:  MOVLW  57
076B8:  MOVWF  x62
076BA:  CLRF   x64
076BC:  MOVLB  0
076BE:  BRA    74D4
076C0:  MOVF   01,F
076C2:  BZ    76C8
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
076C4:  BCF    59.1
.................... 		} 
076C6:  BRA    76CE
....................         else 
....................             return FALSE; 
076C8:  MOVLW  00
076CA:  MOVWF  01
076CC:  BRA    76D2
....................         break; 
....................  
....................     } 
....................     return TRUE; 
076CE:  MOVLW  01
076D0:  MOVWF  01
076D2:  GOTO   C764 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
....................     { 
....................         *MACAddr = Cache.MACAddr; 
....................         return TRUE; 
....................     } 
....................     return FALSE; 
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arp 
.................... //#define debug_arp debug_printf 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
06FB0:  MOVLW  03
06FB2:  MOVLB  3
06FB4:  MOVWF  xEF
06FB6:  MOVLW  66
06FB8:  MOVWF  xEE
06FBA:  CLRF   xF1
06FBC:  MOVLW  1C
06FBE:  MOVWF  xF0
06FC0:  MOVLB  0
06FC2:  RCALL  6D36
....................  
....................     MACDiscardRx(); 
06FC4:  RCALL  6CC8
....................  
....................     SwapARPPacket(&packet); 
06FC6:  MOVLW  03
06FC8:  MOVLB  3
06FCA:  MOVWF  x83
06FCC:  MOVLW  66
06FCE:  MOVWF  x82
06FD0:  MOVLB  0
06FD2:  RCALL  6EF4
....................  
....................    //debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................      // packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................      // packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................      // packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................      // packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
06FD4:  MOVLB  3
06FD6:  DECFSZ x66,W
06FD8:  BRA    6FEA
06FDA:  MOVF   x67,F
06FDC:  BNZ   6FEA
06FDE:  MOVF   x6A,W
06FE0:  SUBLW  06
06FE2:  BNZ   6FEA
06FE4:  MOVF   x6B,W
06FE6:  SUBLW  04
06FE8:  BZ    6FF0
....................          return FALSE; 
06FEA:  MOVLW  00
06FEC:  MOVWF  01
06FEE:  BRA    7092
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
06FF0:  MOVF   x6C,W
06FF2:  SUBLW  02
06FF4:  BNZ   700A
06FF6:  MOVF   x6D,F
06FF8:  BNZ   700A
....................         *opCode = ARP_REPLY; 
06FFA:  MOVFF  365,03
06FFE:  MOVFF  364,FE9
07002:  MOVFF  365,FEA
07006:  CLRF   FEF
07008:  BRA    7036
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
0700A:  DECFSZ x6C,W
0700C:  BRA    7024
0700E:  MOVF   x6D,F
07010:  BNZ   7024
....................         *opCode = ARP_REQUEST; 
07012:  MOVFF  365,03
07016:  MOVFF  364,FE9
0701A:  MOVFF  365,FEA
0701E:  MOVLW  01
07020:  MOVWF  FEF
07022:  BRA    7036
....................     else 
....................     { 
....................         *opCode = ARP_UNKNOWN; 
07024:  MOVFF  364,FE9
07028:  MOVFF  365,FEA
0702C:  MOVLW  02
0702E:  MOVWF  FEF
....................         return FALSE; 
07030:  MOVLW  00
07032:  MOVWF  01
07034:  BRA    7092
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
07036:  MOVF   19,W
07038:  SUBWF  x7E,W
0703A:  BNZ   708E
0703C:  MOVF   1A,W
0703E:  SUBWF  x7F,W
07040:  BNZ   708E
07042:  MOVF   1B,W
07044:  SUBWF  x80,W
07046:  BNZ   708E
07048:  MOVF   1C,W
0704A:  SUBWF  x81,W
0704C:  BNZ   708E
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
0704E:  MOVFF  362,FE9
07052:  MOVFF  363,FEA
07056:  MOVLW  03
07058:  MOVWF  FE2
0705A:  MOVLW  6E
0705C:  MOVWF  FE1
0705E:  MOVLW  06
07060:  MOVWF  01
07062:  MOVFF  FE6,FEE
07066:  DECFSZ 01,F
07068:  BRA    7062
....................         remote->IPAddr      = packet.SenderIPAddr; 
0706A:  MOVLW  06
0706C:  ADDWF  x62,W
0706E:  MOVWF  FE9
07070:  MOVLW  00
07072:  ADDWFC x63,W
07074:  MOVWF  FEA
07076:  MOVFF  374,FEF
0707A:  MOVFF  375,FEC
0707E:  MOVFF  376,FEC
07082:  MOVFF  377,FEC
....................         return TRUE; 
07086:  MOVLW  01
07088:  MOVWF  01
0708A:  BRA    7092
....................     } 
0708C:  BRA    7092
....................     else 
....................         return FALSE; 
0708E:  MOVLW  00
07090:  MOVWF  01
07092:  MOVLB  0
07094:  GOTO   7668 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
074D4:  MOVLW  01
074D6:  MOVLB  3
074D8:  MOVWF  xE0
074DA:  MOVLB  0
074DC:  RCALL  7098
074DE:  MOVFF  01,381
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
074E2:  MOVLB  3
074E4:  INCFSZ x81,W
074E6:  BRA    74EE
....................       return FALSE; 
074E8:  MOVLW  00
074EA:  MOVWF  01
074EC:  BRA    7640
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
074EE:  MOVFF  381,3F9
074F2:  CLRF   xFB
074F4:  CLRF   xFA
074F6:  MOVLB  0
074F8:  RCALL  70C0
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
074FA:  MOVLB  3
074FC:  CLRF   x66
074FE:  MOVLW  01
07500:  MOVWF  x65
....................     packet.Protocol                 = ARP_IP; 
07502:  MOVLW  08
07504:  MOVWF  x68
07506:  CLRF   x67
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
07508:  MOVLW  06
0750A:  MOVWF  x69
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
0750C:  MOVLW  04
0750E:  MOVWF  x6A
....................  
....................     if ( opCode == ARP_REQUEST ) 
07510:  DECFSZ x64,W
07512:  BRA    7528
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
07514:  CLRF   x6C
07516:  MOVLW  01
07518:  MOVWF  x6B
....................         packet.TargetMACAddr.v[0]   = 0xff; 
0751A:  SETF   x77
....................         packet.TargetMACAddr.v[1]   = 0xff; 
0751C:  SETF   x78
....................         packet.TargetMACAddr.v[2]   = 0xff; 
0751E:  SETF   x79
....................         packet.TargetMACAddr.v[3]   = 0xff; 
07520:  SETF   x7A
....................         packet.TargetMACAddr.v[4]   = 0xff; 
07522:  SETF   x7B
....................         packet.TargetMACAddr.v[5]   = 0xff; 
07524:  SETF   x7C
....................     } 
07526:  BRA    754A
....................     else 
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
07528:  CLRF   x6C
0752A:  MOVLW  02
0752C:  MOVWF  x6B
....................         packet.TargetMACAddr        = remote->MACAddr; 
0752E:  MOVFF  362,FE1
07532:  MOVFF  363,FE2
07536:  MOVLW  03
07538:  MOVWF  FEA
0753A:  MOVLW  77
0753C:  MOVWF  FE9
0753E:  MOVLW  06
07540:  MOVWF  01
07542:  MOVFF  FE6,FEE
07546:  DECFSZ 01,F
07548:  BRA    7542
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
0754A:  MOVLW  03
0754C:  MOVWF  FEA
0754E:  MOVLW  6D
07550:  MOVWF  FE9
07552:  CLRF   FE2
07554:  MOVLW  1D
07556:  MOVWF  FE1
07558:  MOVLW  06
0755A:  MOVWF  01
0755C:  MOVFF  FE6,FEE
07560:  DECFSZ 01,F
07562:  BRA    755C
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
07564:  MOVFF  1C,376
07568:  MOVFF  1B,375
0756C:  MOVFF  1A,374
07570:  MOVFF  19,373
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
07574:  MOVLW  06
07576:  ADDWF  x62,W
07578:  MOVWF  FE9
0757A:  MOVLW  00
0757C:  ADDWFC x63,W
0757E:  MOVWF  FEA
07580:  MOVFF  FEF,00
07584:  MOVFF  FEC,01
07588:  MOVFF  FEC,02
0758C:  MOVFF  FEC,03
07590:  MOVF   00,W
07592:  XORWF  x73,W
07594:  MOVWF  x82
07596:  MOVF   01,W
07598:  XORWF  x74,W
0759A:  MOVWF  x83
0759C:  MOVF   02,W
0759E:  XORWF  x75,W
075A0:  MOVWF  x84
075A2:  MOVF   03,W
075A4:  XORWF  x76,W
075A6:  MOVWF  x85
075A8:  MOVF   x82,W
075AA:  ANDWF  23,W
075AC:  MOVWF  00
075AE:  MOVF   x83,W
075B0:  ANDWF  24,W
075B2:  MOVWF  01
075B4:  MOVF   x84,W
075B6:  ANDWF  25,W
075B8:  MOVWF  02
075BA:  MOVF   x85,W
075BC:  ANDWF  26,W
075BE:  MOVWF  03
075C0:  MOVF   00,F
075C2:  BNZ   75D0
075C4:  MOVF   01,F
075C6:  BNZ   75D0
075C8:  MOVF   02,F
075CA:  BNZ   75D0
075CC:  MOVF   03,F
075CE:  BZ    75E2
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
075D0:  MOVFF  2A,380
075D4:  MOVFF  29,37F
075D8:  MOVFF  28,37E
075DC:  MOVFF  27,37D
....................     } 
075E0:  BRA    75FE
....................     else 
....................         packet.TargetIPAddr             = remote->IPAddr; 
075E2:  MOVLW  06
075E4:  ADDWF  x62,W
075E6:  MOVWF  FE9
075E8:  MOVLW  00
075EA:  ADDWFC x63,W
075EC:  MOVWF  FEA
075EE:  MOVFF  FEF,37D
075F2:  MOVFF  FEC,37E
075F6:  MOVFF  FEC,37F
075FA:  MOVFF  FEC,380
....................  
....................     SwapARPPacket(&packet); 
075FE:  MOVLW  03
07600:  MOVWF  x83
07602:  MOVLW  65
07604:  MOVWF  x82
07606:  MOVLB  0
07608:  RCALL  6EF4
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
0760A:  MOVLW  03
0760C:  MOVLB  3
0760E:  MOVWF  xFE
07610:  MOVLW  77
07612:  MOVWF  xFD
07614:  MOVLW  06
07616:  MOVWF  xFF
07618:  MOVLB  4
0761A:  CLRF   x01
0761C:  MOVLW  1C
0761E:  MOVWF  x00
07620:  MOVLB  0
07622:  RCALL  71D0
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
07624:  MOVLW  03
07626:  MOVLB  4
07628:  MOVWF  x05
0762A:  MOVLW  65
0762C:  MOVWF  x04
0762E:  CLRF   x07
07630:  MOVLW  1C
07632:  MOVWF  x06
07634:  MOVLB  0
07636:  RCALL  7186
....................  
....................     MACFlush(); 
07638:  RCALL  729A
....................     
....................    return TRUE; 
0763A:  MOVLW  01
0763C:  MOVWF  01
0763E:  MOVLB  3
07640:  MOVLB  0
07642:  GOTO   76C0 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
06EF4:  MOVLB  3
06EF6:  MOVFF  382,01
06EFA:  MOVFF  383,03
06EFE:  MOVFF  382,384
06F02:  MOVFF  383,385
06F06:  MOVFF  382,FE9
06F0A:  MOVFF  383,FEA
06F0E:  MOVFF  FEC,400
06F12:  MOVF   FED,F
06F14:  MOVFF  FEF,3FF
06F18:  MOVLB  0
06F1A:  RCALL  6D9E
06F1C:  MOVFF  385,FEA
06F20:  MOVFF  384,FE9
06F24:  MOVFF  02,FEC
06F28:  MOVF   FED,F
06F2A:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
06F2E:  MOVLW  02
06F30:  MOVLB  3
06F32:  ADDWF  x82,W
06F34:  MOVWF  01
06F36:  MOVLW  00
06F38:  ADDWFC x83,W
06F3A:  MOVWF  03
06F3C:  MOVFF  01,384
06F40:  MOVWF  x85
06F42:  MOVLW  02
06F44:  ADDWF  x82,W
06F46:  MOVWF  FE9
06F48:  MOVLW  00
06F4A:  ADDWFC x83,W
06F4C:  MOVWF  FEA
06F4E:  MOVFF  FEC,400
06F52:  MOVF   FED,F
06F54:  MOVFF  FEF,3FF
06F58:  MOVLB  0
06F5A:  RCALL  6D9E
06F5C:  MOVFF  385,FEA
06F60:  MOVFF  384,FE9
06F64:  MOVFF  02,FEC
06F68:  MOVF   FED,F
06F6A:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
06F6E:  MOVLW  06
06F70:  MOVLB  3
06F72:  ADDWF  x82,W
06F74:  MOVWF  01
06F76:  MOVLW  00
06F78:  ADDWFC x83,W
06F7A:  MOVWF  03
06F7C:  MOVFF  01,384
06F80:  MOVWF  x85
06F82:  MOVLW  06
06F84:  ADDWF  x82,W
06F86:  MOVWF  FE9
06F88:  MOVLW  00
06F8A:  ADDWFC x83,W
06F8C:  MOVWF  FEA
06F8E:  MOVFF  FEC,400
06F92:  MOVF   FED,F
06F94:  MOVFF  FEF,3FF
06F98:  MOVLB  0
06F9A:  RCALL  6D9E
06F9C:  MOVFF  385,FEA
06FA0:  MOVFF  384,FE9
06FA4:  MOVFF  02,FEC
06FA8:  MOVF   FED,F
06FAA:  MOVFF  01,FEF
06FAE:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///                              HTTP.C 
.................... /// 
.................... /// Simple webserver for the Microchip TCP/IP stack. 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES 
.................... /// 
.................... /// **** CONFIGURATION **** 
.................... /// 
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c 
.................... ///        in your application.  Defining this to be true will cause 
.................... ///        the stack to include the HTTP portion and execute the init 
.................... ///        and process any HTTP tasks. 
.................... /// 
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP 
.................... ///        connections. 
.................... /// 
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the 
.................... ///        HTTP server.  You probably will be fine with just 1.  The 
.................... ///        more sockets you use the more RAM is used to hold buffers 
.................... ///        and state configuration. 
.................... /// 
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several 
.................... ///        buffers.  This limits the size of your GET or POST requests 
.................... ///        and all CGI POST data: 
.................... ///            If using GET, then max amount of cgi data is this value 
.................... ///            minus everything else on the initial GET command (which 
.................... ///            also includes the filename).  I believe the max specified 
.................... ///            by W3C is 255. 
.................... ///            If using POST, then this is the maximum size for one 
.................... ///            key=value pair (including the '=' sign). 
.................... ///        These values do not inlude any escape characters. 
.................... /// 
.................... /// HTTP_USE_CHUNKS - Set to TRUE to make the HTTP server 1.1 compliant 
.................... ///      and will use Transfer-Encoding: chunked.  Default is FALSE. 
.................... /// 
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape 
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have 
.................... ///      two escape characters after the %.  An example of each: 
.................... ///         If FALSE: %A 
.................... ///         If TRUE: %0A 
.................... /// 
.................... /// HTTP_USE_CONTENT_TYPE - Set to TRUE if your http_get_page() has a third 
.................... ///      parameter which is the content-type of the requested page. 
.................... /// 
.................... /// **** HOW IT WORKS **** 
.................... /// 
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will 
.................... /// then listen for GET or POST requests.  When it gets a GET or POST 
.................... /// request it passes the page request to the callback function 
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or 
.................... /// a pointer to the constant memory area that holds the page in program 
.................... /// memory.  If it was a POST request it waits until the HTTP header is 
.................... /// done and then saves the POST data into a buffer, and passes the 
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will 
.................... /// parse the CGI post data and act upon it.  When done, the HTTP 
.................... /// server then responds by sending the page.  If the page is to have 
.................... /// variable data, it can be represented by an escape code - %0 or %1 
.................... /// for example.  When the HTTP stack sees such an escape code it calls 
.................... /// the callback function http_format_char() to format the escape code 
.................... /// into the needed variable data (such as ADC readings).  After the 
.................... /// HTTP stack is done sending the request it will close the port. 
.................... /// If the page didn't exist in program memory it will send a 404 File 
.................... /// not found error.  If there was a problem/timeout parsing the request 
.................... /// the HTTP stack will send a 500 Internal Server Error response. 
.................... /// 
.................... /// **** CALL BACK FUNCTIONS **** 
.................... /// 
.................... /// Your main application must provide the following callback functions to 
.................... /// fill application dependent needs: 
.................... /// 
.................... /// http_get_page(char *file); 
.................... ///    If HTTP_USE_CONTENT_TYPE is FALSE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is TRUE then see the next paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, returns address to page in 
.................... ///    program memory.  If it doesn't exist, returns 0. 
.................... /// 
.................... /// http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... ///    If HTTP_USE_CONTENT_TYPE is TRUE, this is the proper prototype.  Else, 
.................... ///    if HTTP_USE_CONTENT_TYPE is FALSE then see the previous paragraph. 
.................... ///    A call-back function provided by your application that finds the 
.................... ///    required file.  If the file exists, saves value to retAddress.  If 
.................... ///    the file doesn't exist, will save 0 to retAddress.  retStr is the 
.................... ///    content-type (text/html, text/xml, etc). 
.................... /// 
.................... /// http_exec_cgi(int32 file, char *key, char *val); 
.................... ///    A call-back function provided by your application that processes incoming 
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// int http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... ///    Given an escaped character in the program memory HTTP file, convert to 
.................... ///    variable data.  id is the escaped character, *str is where to save the 
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str. 
.................... ///    Returns the number of bytes written to *str.  file is 
.................... ///    the file address as returned by http_get_page(). 
.................... /// 
.................... /// **** LIMITATIONS **** 
.................... /// 
.................... /// When creating web pages with forms, keep your form names (keys) simple 
.................... /// because the HTTP stack does not format the escape characters.  For example, 
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord". 
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving 
.................... /// the value, but not the key.  Therefore keep your keys simple. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// * Author         Date           Comment 
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... /// 
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST 
.................... /// 
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix 
.................... ///                                 many bugs.  The biggest bug is that 
.................... ///                                 it can send pages and receive CGI that 
.................... ///                                 is larger than 1 TCP packet.  Also 
.................... ///                                 added the HTTP_USE_CHUNKS, 
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and 
.................... ///                                 HTTP_USE_CONTENT_TYPE paremeters. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "tcpip/http.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP.H                                 /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack.                    /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_CONTENT_TYPE 
.................... #define HTTP_USE_CONTENT_TYPE   FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... void HTTP_Init(void); 
.................... void HTTP_Task(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following three functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation above 
.................... /// for more help. 
....................  
.................... #if HTTP_USE_CONTENT_TYPE 
....................  void http_get_page(char *file_str, int32 *retAddress, char *retStr); 
.................... #else 
....................  int32 http_get_page(char *file_str); 
.................... #endif 
....................  
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret); 
.................... void http_exec_cgi(int32 file, char *key, char *val); 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
....................  
.................... //#define debug_http   debug_printf 
.................... #define debug_http(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  
.................... const char http_404_error[]="<HTML><BODY><H1>Error Password or Username/404 Error</H1><HR><P>Login/file Not found.</BODY></HTML> 
.................... <P><A HREF=\"/\">INICIO</A>  "; 
.................... const char http_500_error[]="<HTML><BODY><H1>500 Error</H1><HR><P>Internal Server Error</BODY></HTML>"; 
....................  
.................... //key=val pair string, & delimited 
.................... void http_parse_cgi_str(int32 file, char *cgistr); 
....................                                                                  
.................... int8 http_socket[HTTP_NUM_SOCKETS]={INVALID_SOCKET}; 
....................  
.................... enum { 
....................    HTTP_DISABLED = 0xFF, 
....................    HTTP_IGNORE, 
....................    HTTP_LISTEN_WAIT, 
....................    HTTP_CONNECTED,                                                            
....................    HTTP_GET_HEADERS, 
....................    HTTP_GET_POST, 
....................    HTTP_GET_POST_CONTINUE, 
....................    HTTP_SEND_RESPONSE, 
....................    HTTP_SEND_RESPONSE_CONTINUE, 
....................    HTTP_CLOSE, 
....................    HTTP_CLOSE_WAITING, 
....................    HTTP_CLOSED 
.................... } http_state[HTTP_NUM_SOCKETS]={HTTP_IGNORE}; 
....................  
.................... //strips out any escape characters that the HTTP client may have inserted. 
.................... // (+ is replaced with space) 
.................... // (%xx is replaced with character representation of xx) 
.................... char * http_escape_chars(char *str) 
.................... { 
....................    char *ostr; 
....................    char new[3]; 
....................    char c; 
....................    char val; 
....................  
....................    new[2]=0; 
*
0A250:  MOVLB  3
0A252:  CLRF   x78
....................  
....................    ostr = str; 
0A254:  MOVFF  373,375
0A258:  MOVFF  372,374
....................  
....................    while((c=*str) != 0) 
0A25C:  MOVFF  373,03
0A260:  MOVFF  372,FE9
0A264:  MOVFF  373,FEA
0A268:  MOVFF  FEF,379
0A26C:  MOVF   x79,F
0A26E:  BZ    A330
....................    { 
....................       if (c=='+') 
0A270:  MOVF   x79,W
0A272:  SUBLW  2B
0A274:  BNZ   A28E
....................          *str++=' '; 
0A276:  MOVFF  373,03
0A27A:  MOVF   x72,W
0A27C:  INCF   x72,F
0A27E:  BTFSC  FD8.2
0A280:  INCF   x73,F
0A282:  MOVWF  FE9
0A284:  MOVFF  03,FEA
0A288:  MOVLW  20
0A28A:  MOVWF  FEF
0A28C:  BRA    A32C
....................       else if (c=='%') 
0A28E:  MOVF   x79,W
0A290:  SUBLW  25
0A292:  BNZ   A326
....................       { 
....................          memcpy(new, str + 1, 2); 
0A294:  MOVLW  01
0A296:  ADDWF  x72,W
0A298:  MOVWF  x7B
0A29A:  MOVLW  00
0A29C:  ADDWFC x73,W
0A29E:  MOVWF  FE2
0A2A0:  MOVFF  37B,FE1
0A2A4:  MOVFF  FE6,376
0A2A8:  MOVFF  FE6,377
....................          val = strtoul(new, 0, 16); 
0A2AC:  MOVLW  03
0A2AE:  MOVWF  x7C
0A2B0:  MOVLW  76
0A2B2:  MOVWF  x7B
0A2B4:  CLRF   x7E
0A2B6:  CLRF   x7D
0A2B8:  MOVLW  10
0A2BA:  MOVWF  x7F
0A2BC:  MOVLB  0
0A2BE:  BRA    9DFA
0A2C0:  MOVFF  01,37A
....................          *str++ = val; 
0A2C4:  MOVLB  3
0A2C6:  MOVFF  373,03
0A2CA:  MOVF   x72,W
0A2CC:  INCF   x72,F
0A2CE:  BTFSC  FD8.2
0A2D0:  INCF   x73,F
0A2D2:  MOVWF  FE9
0A2D4:  MOVFF  03,FEA
0A2D8:  MOVFF  37A,FEF
....................          memmove(str, str + 2, strlen(str) - 1); 
0A2DC:  MOVLW  02
0A2DE:  ADDWF  x72,W
0A2E0:  MOVWF  x7B
0A2E2:  MOVLW  00
0A2E4:  ADDWFC x73,W
0A2E6:  MOVWF  x7C
0A2E8:  MOVFF  373,393
0A2EC:  MOVFF  372,392
0A2F0:  MOVLB  0
0A2F2:  RCALL  9BEC
0A2F4:  MOVFF  02,37E
0A2F8:  MOVFF  01,37D
0A2FC:  MOVLW  01
0A2FE:  MOVLB  3
0A300:  SUBWF  x7D,F
0A302:  MOVLW  00
0A304:  SUBWFB x7E,F
0A306:  MOVFF  373,380
0A30A:  MOVFF  372,37F
0A30E:  MOVFF  37C,382
0A312:  MOVFF  37B,381
0A316:  MOVFF  37E,384
0A31A:  MOVFF  37D,383
0A31E:  MOVLB  0
0A320:  BRA    A16A
....................       } 
0A322:  BRA    A32C
0A324:  MOVLB  3
....................       else 
....................          str++; 
0A326:  INCF   x72,F
0A328:  BTFSC  FD8.2
0A32A:  INCF   x73,F
0A32C:  MOVLB  3
0A32E:  BRA    A25C
....................    } 
....................  
....................    return(ostr); 
0A330:  MOVFF  374,01
0A334:  MOVFF  375,02
0A338:  MOVLB  0
0A33A:  RETURN 0
.................... } 
....................  
.................... void http_parse_cgi_string(int32 file, char *ptr) 
.................... { 
....................    char *pKey, *pValue, c; 
....................  
....................    pKey=ptr; 
*
0A67C:  MOVFF  36C,36E
0A680:  MOVFF  36B,36D
....................    pValue=0; 
0A684:  MOVLB  3
0A686:  CLRF   x70
0A688:  CLRF   x6F
....................  
....................    while(TRUE) 
....................    { 
....................       c = *ptr; 
0A68A:  MOVFF  36B,FE9
0A68E:  MOVFF  36C,FEA
0A692:  MOVFF  FEF,371
....................       if ((c=='&') || (c==0)) 
0A696:  MOVF   x71,W
0A698:  SUBLW  26
0A69A:  BZ    A6A0
0A69C:  MOVF   x71,F
0A69E:  BNZ   A6FC
....................       { 
....................          *ptr=0; 
0A6A0:  MOVFF  36B,FE9
0A6A4:  MOVFF  36C,FEA
0A6A8:  CLRF   FEF
....................          http_escape_chars(pKey); 
0A6AA:  MOVFF  36E,373
0A6AE:  MOVFF  36D,372
0A6B2:  MOVLB  0
0A6B4:  RCALL  A250
....................          http_escape_chars(pValue); 
0A6B6:  MOVFF  370,373
0A6BA:  MOVFF  36F,372
0A6BE:  RCALL  A250
....................          http_exec_cgi(file, pKey, pValue); 
0A6C0:  MOVFF  36A,375
0A6C4:  MOVFF  369,374
0A6C8:  MOVFF  368,373
0A6CC:  MOVFF  367,372
0A6D0:  MOVFF  36E,377
0A6D4:  MOVFF  36D,376
0A6D8:  MOVFF  370,379
0A6DC:  MOVFF  36F,378
0A6E0:  BRA    A51E
....................          pKey=ptr+1; 
0A6E2:  MOVLW  01
0A6E4:  MOVLB  3
0A6E6:  ADDWF  x6B,W
0A6E8:  MOVWF  x6D
0A6EA:  MOVLW  00
0A6EC:  ADDWFC x6C,W
0A6EE:  MOVWF  x6E
....................          pValue=0; 
0A6F0:  CLRF   x70
0A6F2:  CLRF   x6F
....................          if (c==0) 
0A6F4:  MOVF   x71,F
0A6F6:  BNZ   A6FA
....................             break; 
0A6F8:  BRA    A720
....................       } 
0A6FA:  BRA    A718
....................       else if (c=='=') 
0A6FC:  MOVF   x71,W
0A6FE:  SUBLW  3D
0A700:  BNZ   A718
....................       { 
....................          *ptr=0; 
0A702:  MOVFF  36B,FE9
0A706:  MOVFF  36C,FEA
0A70A:  CLRF   FEF
....................          pValue=ptr+1; 
0A70C:  MOVLW  01
0A70E:  ADDWF  x6B,W
0A710:  MOVWF  x6F
0A712:  MOVLW  00
0A714:  ADDWFC x6C,W
0A716:  MOVWF  x70
....................       } 
....................       ptr++; 
0A718:  INCF   x6B,F
0A71A:  BTFSC  FD8.2
0A71C:  INCF   x6C,F
0A71E:  BRA    A68A
....................    } 
0A720:  MOVLB  0
0A722:  RETURN 0
.................... } 
....................  
.................... int8 _httpPutcSocket; 
....................  
.................... #define tcp_http_tx_left()  TCPPutAvailable(_httpPutcSocket) 
....................  
.................... void set_tcp_http_putc(int8 newSocket) 
.................... { 
....................    _httpPutcSocket=newSocket; 
*
0A9F6:  MOVFF  36F,123
0A9FA:  GOTO   B662 (RETURN)
.................... } 
....................  
.................... int tcp_http_putc(char c) 
.................... { 
....................    return(TCPPut(_httpPutcSocket,c)); 
*
0ACCE:  MOVFF  123,38E
0ACD2:  MOVFF  38D,38F
0ACD6:  BRA    AB8C
0ACD8:  MOVF   01,W
0ACDA:  RETURN 0
.................... } 
....................  
.................... int32 lastHTTPPutConstPos[HTTP_NUM_SOCKETS]; 
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS]; 
....................  
.................... #if HTTP_USE_CHUNKS 
.................... void TCPPutFileChunkStart(int16 count) 
.................... { 
....................    printf(tcp_http_putc, "%04LX\r\n", count); 
.................... } 
....................  
.................... void TCPPutFileChunkStop(void) 
.................... { 
....................    tcp_http_putc('\r'); 
....................    tcp_http_putc('\n'); 
.................... } 
.................... #else 
....................  #define TCPPutFileChunkStart(x) 
....................  #define TCPPutFileChunkStop() 
.................... #endif 
....................  
.................... typedef enum 
.................... { 
....................    TCP_PUT_CONST_EC_FINISH = 0, 
....................    TCP_PUT_CONST_EC_CONTINUE, 
....................    TCP_PUT_CONST_EC_ESCAPE 
.................... } TCP_PUT_CONST_EC; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileVarChunk(ptr) 
.................... // 
.................... // send a chunked response from ram 
.................... // 
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated 
.................... //          with the continue position before exit. 
.................... // 
.................... // Returns a status code: 
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed 
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr) 
.................... //because of a compiler error i had to make this double pointer an int16, when 
.................... //it should be a char. 
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(int16 **retPtr) 
.................... { 
....................    int16 txLeft, n; 
....................    char *ptr, ec; 
....................  
....................    ptr=*retPtr; 
*
0AF0C:  MOVLB  3
0AF0E:  MOVFF  371,FE9
0AF12:  MOVFF  372,FEA
0AF16:  MOVFF  FEC,378
0AF1A:  MOVF   FED,F
0AF1C:  MOVFF  FEF,377
....................  
....................    n=strlen(ptr); 
0AF20:  MOVFF  378,393
0AF24:  MOVFF  377,392
0AF28:  MOVLB  0
0AF2A:  CALL   9BEC
0AF2E:  MOVFF  02,376
0AF32:  MOVFF  01,375
....................  
....................    if (!n) 
0AF36:  MOVLB  3
0AF38:  MOVF   x75,W
0AF3A:  IORWF  x76,W
0AF3C:  BNZ   AF44
....................       return(TCP_PUT_CONST_EC_FINISH); 
0AF3E:  MOVLW  00
0AF40:  MOVWF  01
0AF42:  BRA    AFC4
....................  
....................    txLeft = tcp_http_tx_left(); 
0AF44:  MOVFF  123,37D
0AF48:  MOVLB  0
0AF4A:  RCALL  AE14
0AF4C:  MOVFF  02,374
0AF50:  MOVFF  01,373
....................  
....................   #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................   #else 
....................    if (!txLeft) 
0AF54:  MOVLB  3
0AF56:  MOVF   x73,W
0AF58:  IORWF  x74,W
0AF5A:  BNZ   AF62
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
0AF5C:  MOVLW  01
0AF5E:  MOVWF  01
0AF60:  BRA    AFC4
....................   #endif 
....................  
....................    if (n > txLeft) 
0AF62:  MOVF   x74,W
0AF64:  SUBWF  x76,W
0AF66:  BNC   AF76
0AF68:  BNZ   AF70
0AF6A:  MOVF   x75,W
0AF6C:  SUBWF  x73,W
0AF6E:  BC    AF76
....................    { 
....................       ec = TCP_PUT_CONST_EC_CONTINUE; 
0AF70:  MOVLW  01
0AF72:  MOVWF  x79
....................    } 
0AF74:  BRA    AF80
....................    else 
....................    { 
....................       txLeft = n; 
0AF76:  MOVFF  376,374
0AF7A:  MOVFF  375,373
....................       ec = TCP_PUT_CONST_EC_FINISH; 
0AF7E:  CLRF   x79
....................    } 
....................  
....................    TCPPutFileChunkStart(txLeft); 
....................  
....................    while (txLeft--) 
0AF80:  MOVFF  374,03
0AF84:  MOVF   x73,W
0AF86:  BTFSC  FD8.2
0AF88:  DECF   x74,F
0AF8A:  DECF   x73,F
0AF8C:  IORWF  03,W
0AF8E:  BZ    AFAE
....................    { 
....................       tcp_http_putc(*ptr++); 
0AF90:  MOVFF  378,03
0AF94:  MOVF   x77,W
0AF96:  INCF   x77,F
0AF98:  BTFSC  FD8.2
0AF9A:  INCF   x78,F
0AF9C:  MOVWF  FE9
0AF9E:  MOVFF  03,FEA
0AFA2:  MOVFF  FEF,38D
0AFA6:  MOVLB  0
0AFA8:  RCALL  ACCE
0AFAA:  MOVLB  3
0AFAC:  BRA    AF80
....................    } 
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    *retPtr=ptr; 
0AFAE:  MOVFF  371,FE9
0AFB2:  MOVFF  372,FEA
0AFB6:  MOVFF  378,FEC
0AFBA:  MOVF   FED,F
0AFBC:  MOVFF  377,FEF
....................  
....................    return(ec); 
0AFC0:  MOVFF  379,01
0AFC4:  MOVLB  0
0AFC6:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileParseConst(addy, n, doSend) 
.................... // 
.................... // Reads file from Const memory.  Stops when it reaches an escape sequence, 
.................... // n chars or an end of file 
.................... // 
.................... // addy - data to read (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // n - max number of chars to read from file.  will save the total number 
.................... //    of chars passed to this pointer. 
.................... // 
.................... // doSend - if TRUE, then send data to TCP socket 
.................... // 
.................... // returns the last char read 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... char TCPPutFileParseConst(int32 *retAddy, int16 *n, int8 doSend) 
*
0AFE6:  MOVLB  3
0AFE8:  CLRF   x85
0AFEA:  CLRF   x84
0AFEC:  BSF    x8C.0
.................... { 
....................    char stopC, checkC; 
....................    int16 fileSize = 0, max; 
....................    int32 addy; 
....................    int1 premature = TRUE; 
....................  
....................    max = *n; 
0AFEE:  MOVFF  37F,FE9
0AFF2:  MOVFF  380,FEA
0AFF6:  MOVFF  FEC,387
0AFFA:  MOVF   FED,F
0AFFC:  MOVFF  FEF,386
....................    addy = *retAddy; 
0B000:  MOVFF  37D,FE9
0B004:  MOVFF  37E,FEA
0B008:  MOVFF  FEF,388
0B00C:  MOVFF  FEC,389
0B010:  MOVFF  FEC,38A
0B014:  MOVFF  FEC,38B
....................  
....................    while (TRUE) 
....................    { 
....................       read_program_memory(addy++, &stopC, 1); 
0B018:  MOVFF  38B,390
0B01C:  MOVFF  38A,02
0B020:  MOVFF  389,01
0B024:  MOVFF  388,00
0B028:  MOVLW  01
0B02A:  ADDWF  x88,F
0B02C:  BTFSC  FD8.0
0B02E:  INCF   x89,F
0B030:  BTFSC  FD8.2
0B032:  INCF   x8A,F
0B034:  BTFSC  FD8.2
0B036:  INCF   x8B,F
0B038:  MOVFF  02,38F
0B03C:  MOVFF  01,38E
0B040:  MOVFF  00,38D
0B044:  MOVFF  02,FF8
0B048:  MOVFF  01,FF7
0B04C:  MOVFF  00,FF6
0B050:  MOVLW  03
0B052:  MOVWF  FEA
0B054:  MOVLW  82
0B056:  MOVWF  FE9
0B058:  CLRF   x92
0B05A:  MOVLW  01
0B05C:  MOVWF  x91
0B05E:  MOVLB  0
0B060:  RCALL  AFC8
....................       if (stopC == '%') 
0B062:  MOVLB  3
0B064:  MOVF   x82,W
0B066:  SUBLW  25
0B068:  BNZ   B0E8
....................       { 
....................          read_program_memory(addy++, &checkC, 1); 
0B06A:  MOVFF  38B,390
0B06E:  MOVFF  38A,02
0B072:  MOVFF  389,01
0B076:  MOVFF  388,00
0B07A:  MOVLW  01
0B07C:  ADDWF  x88,F
0B07E:  BTFSC  FD8.0
0B080:  INCF   x89,F
0B082:  BTFSC  FD8.2
0B084:  INCF   x8A,F
0B086:  BTFSC  FD8.2
0B088:  INCF   x8B,F
0B08A:  MOVFF  02,38F
0B08E:  MOVFF  01,38E
0B092:  MOVFF  00,38D
0B096:  MOVFF  02,FF8
0B09A:  MOVFF  01,FF7
0B09E:  MOVFF  00,FF6
0B0A2:  MOVLW  03
0B0A4:  MOVWF  FEA
0B0A6:  MOVLW  83
0B0A8:  MOVWF  FE9
0B0AA:  CLRF   x92
0B0AC:  MOVLW  01
0B0AE:  MOVWF  x91
0B0B0:  MOVLB  0
0B0B2:  RCALL  AFC8
....................          if (checkC == '%') 
0B0B4:  MOVLB  3
0B0B6:  MOVF   x83,W
0B0B8:  SUBLW  25
0B0BA:  BNZ   B0E4
....................          { 
....................             if (fileSize < max) 
0B0BC:  MOVF   x85,W
0B0BE:  SUBWF  x87,W
0B0C0:  BNC   B0E0
0B0C2:  BNZ   B0CA
0B0C4:  MOVF   x86,W
0B0C6:  SUBWF  x84,W
0B0C8:  BC    B0E0
....................             { 
....................                if (doSend) 
0B0CA:  MOVF   x81,F
0B0CC:  BZ    B0D8
....................                   tcp_http_putc('%'); 
0B0CE:  MOVLW  25
0B0D0:  MOVWF  x8D
0B0D2:  MOVLB  0
0B0D4:  RCALL  ACCE
0B0D6:  MOVLB  3
....................                fileSize++; 
0B0D8:  INCF   x84,F
0B0DA:  BTFSC  FD8.2
0B0DC:  INCF   x85,F
....................             } 
0B0DE:  BRA    B0E2
....................             else 
....................                break; 
0B0E0:  BRA    B11A
....................          } 
0B0E2:  BRA    B0E6
....................          else 
....................             break;   //ESCAPE 
0B0E4:  BRA    B11A
....................       } 
0B0E6:  BRA    B118
....................       else if (stopC) 
0B0E8:  MOVF   x82,F
0B0EA:  BZ    B114
....................       { 
....................          if (fileSize < max) 
0B0EC:  MOVF   x85,W
0B0EE:  SUBWF  x87,W
0B0F0:  BNC   B110
0B0F2:  BNZ   B0FA
0B0F4:  MOVF   x86,W
0B0F6:  SUBWF  x84,W
0B0F8:  BC    B110
....................          { 
....................             if (doSend) 
0B0FA:  MOVF   x81,F
0B0FC:  BZ    B108
....................                tcp_http_putc(stopC); 
0B0FE:  MOVFF  382,38D
0B102:  MOVLB  0
0B104:  RCALL  ACCE
0B106:  MOVLB  3
....................             fileSize++; 
0B108:  INCF   x84,F
0B10A:  BTFSC  FD8.2
0B10C:  INCF   x85,F
....................          } 
0B10E:  BRA    B112
....................          else 
....................             break; 
0B110:  BRA    B11A
....................       } 
0B112:  BRA    B118
....................       else 
....................       { 
....................          premature = FALSE; 
0B114:  BCF    x8C.0
....................          break;   //EOF (stopC == 0) 
0B116:  BRA    B11A
....................       } 
0B118:  BRA    B018
....................    } 
....................  
....................    if (premature) 
0B11A:  BTFSS  x8C.0
0B11C:  BRA    B12E
....................       addy--; 
0B11E:  MOVLW  FF
0B120:  ADDWF  x88,F
0B122:  BTFSS  FD8.0
0B124:  ADDWF  x89,F
0B126:  BTFSS  FD8.0
0B128:  ADDWF  x8A,F
0B12A:  BTFSS  FD8.0
0B12C:  ADDWF  x8B,F
....................  
....................    *n = fileSize; 
0B12E:  MOVFF  37F,FE9
0B132:  MOVFF  380,FEA
0B136:  MOVFF  385,FEC
0B13A:  MOVF   FED,F
0B13C:  MOVFF  384,FEF
....................    *retAddy = addy; 
0B140:  MOVFF  37D,FE9
0B144:  MOVFF  37E,FEA
0B148:  MOVFF  388,FEF
0B14C:  MOVFF  389,FEC
0B150:  MOVFF  38A,FEC
0B154:  MOVFF  38B,FEC
....................  
....................    return(stopC); 
0B158:  MOVFF  382,01
0B15C:  MOVLB  0
0B15E:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileConstChunk(*addy) 
.................... // 
.................... // send a chunked response from constant memory 
.................... // 
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // returns a response: 
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue 
.................... //                            from this position on next call. 
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character 
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(int32 *retAddy) 
0B160:  MOVLB  3
0B162:  CLRF   x79
0B164:  CLRF   x78
.................... { 
....................    char stopC; 
....................    int32 addy; 
....................    int16 fileSize = 0, txLeft; 
....................    TCP_PUT_CONST_EC ec; 
....................  
....................    txLeft = tcp_http_tx_left(); 
0B166:  MOVFF  123,37D
0B16A:  MOVLB  0
0B16C:  RCALL  AE14
0B16E:  MOVFF  02,37B
0B172:  MOVFF  01,37A
....................  
....................  #if HTTP_USE_CHUNKS 
....................    if (txLeft > 8) 
....................       txLeft -= 8;   //save space for 2x CRLF and 4 chars 
....................    else 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................  #else 
....................    if (!txLeft) 
0B176:  MOVLB  3
0B178:  MOVF   x7A,W
0B17A:  IORWF  x7B,W
0B17C:  BNZ   B184
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
0B17E:  MOVLW  01
0B180:  MOVWF  01
0B182:  BRA    B220
....................  #endif 
....................  
....................    addy = *retAddy; 
0B184:  MOVFF  371,FE9
0B188:  MOVFF  372,FEA
0B18C:  MOVFF  FEF,374
0B190:  MOVFF  FEC,375
0B194:  MOVFF  FEC,376
0B198:  MOVFF  FEC,377
....................  
....................    fileSize = 0xFFFF; 
0B19C:  SETF   x79
0B19E:  SETF   x78
....................    stopC = TCPPutFileParseConst(&addy, &fileSize, FALSE); 
0B1A0:  MOVLW  03
0B1A2:  MOVWF  x7E
0B1A4:  MOVLW  74
0B1A6:  MOVWF  x7D
0B1A8:  MOVLW  03
0B1AA:  MOVWF  x80
0B1AC:  MOVLW  78
0B1AE:  MOVWF  x7F
0B1B0:  CLRF   x81
0B1B2:  MOVLB  0
0B1B4:  RCALL  AFE6
0B1B6:  MOVFF  01,373
....................  
....................    if (!fileSize && (stopC!='%')) 
0B1BA:  MOVLB  3
0B1BC:  MOVF   x78,W
0B1BE:  IORWF  x79,W
0B1C0:  BNZ   B1CE
0B1C2:  MOVF   x73,W
0B1C4:  SUBLW  25
0B1C6:  BZ    B1CE
....................       return(TCP_PUT_CONST_EC_FINISH); 
0B1C8:  MOVLW  00
0B1CA:  MOVWF  01
0B1CC:  BRA    B220
....................  
....................    //TODO: optimize 
....................    if (fileSize > txLeft) 
0B1CE:  MOVF   x7B,W
0B1D0:  SUBWF  x79,W
0B1D2:  BNC   B1EA
0B1D4:  BNZ   B1DC
0B1D6:  MOVF   x78,W
0B1D8:  SUBWF  x7A,W
0B1DA:  BC    B1EA
....................    { 
....................       fileSize = txLeft; 
0B1DC:  MOVFF  37B,379
0B1E0:  MOVFF  37A,378
.................... //      if (stopC == '%') 
.................... //         ec = TCP_PUT_CONST_EC_ESCAPE; 
.................... //      else 
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
0B1E4:  MOVLW  01
0B1E6:  MOVWF  x7C
....................    } 
0B1E8:  BRA    B202
....................    else 
....................    { 
....................       if (stopC == '%') 
0B1EA:  MOVF   x73,W
0B1EC:  SUBLW  25
0B1EE:  BNZ   B1F6
....................          ec = TCP_PUT_CONST_EC_ESCAPE; 
0B1F0:  MOVLW  02
0B1F2:  MOVWF  x7C
0B1F4:  BRA    B202
....................       else if (stopC) 
0B1F6:  MOVF   x73,F
0B1F8:  BZ    B200
....................          ec = TCP_PUT_CONST_EC_CONTINUE; 
0B1FA:  MOVLW  01
0B1FC:  MOVWF  x7C
0B1FE:  BRA    B202
....................       else 
....................          ec = TCP_PUT_CONST_EC_FINISH; 
0B200:  CLRF   x7C
....................    } 
....................  
....................    TCPPutFileChunkStart(fileSize); 
....................  
....................    TCPPutFileParseConst(retAddy, &fileSize, TRUE); 
0B202:  MOVFF  372,37E
0B206:  MOVFF  371,37D
0B20A:  MOVLW  03
0B20C:  MOVWF  x80
0B20E:  MOVLW  78
0B210:  MOVWF  x7F
0B212:  MOVLW  01
0B214:  MOVWF  x81
0B216:  MOVLB  0
0B218:  RCALL  AFE6
....................  
....................    TCPPutFileChunkStop(); 
....................  
....................    return(ec); 
0B21A:  MOVLB  3
0B21C:  MOVFF  37C,01
0B220:  MOVLB  0
0B222:  GOTO   B860 (RETURN)
.................... } 
....................  
.................... int TCPPutFileConstGetEscape(int32 addy) 
.................... { 
.................... #if HTTP_USE_DOUBLE_ESCAPE 
....................    char str[3]; 
....................    int ret; 
....................  
....................    read_program_memory(addy, &str[0], 2); 
....................    str[2] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #else 
....................    char ret; 
....................    read_program_memory(addy, &ret, 1); 
0B226:  MOVFF  375,FF8
0B22A:  MOVFF  374,FF7
0B22E:  MOVFF  373,FF6
0B232:  MOVLW  03
0B234:  MOVWF  FEA
0B236:  MOVLW  77
0B238:  MOVWF  FE9
0B23A:  MOVLB  3
0B23C:  CLRF   x92
0B23E:  MOVLW  01
0B240:  MOVWF  x91
0B242:  MOVLB  0
0B244:  RCALL  AFC8
.................... #endif 
....................  
....................    return(ret); 
0B246:  MOVLB  3
0B248:  MOVFF  377,01
0B24C:  MOVLB  0
0B24E:  GOTO   B894 (RETURN)
.................... } 
....................  
.................... int1 tcp_http_put_file(int8 which, int16 errorCode, int32 file, char *contentType) 
.................... { 
....................    static char str[40]; 
....................    int8 socket; 
....................    char ec; 
....................    int escaped; 
....................  
....................    static enum 
....................    { 
....................       HTTP_PUT_FILE_INIT = 0, 
....................       HTTP_PUT_FILE_CONTINUE, 
....................       HTTP_PUT_FILE_CHUNK_END, 
....................       HTTP_PUT_FILE_DONE 
....................    } status; 
....................  
....................    socket=http_socket[which]; 
*
0B644:  CLRF   03
0B646:  MOVLB  3
0B648:  MOVF   x63,W
0B64A:  ADDLW  20
0B64C:  MOVWF  FE9
0B64E:  MOVLW  01
0B650:  ADDWFC 03,W
0B652:  MOVWF  FEA
0B654:  MOVFF  FEF,36C
....................  
....................    set_tcp_http_putc(socket); 
0B658:  MOVFF  36C,36F
0B65C:  MOVLB  0
0B65E:  GOTO   A9F6
....................  
....................    if (lastHTTPPutConstPos[which] == 0) 
0B662:  MOVLB  3
0B664:  MOVF   x63,W
0B666:  MULLW  04
0B668:  MOVF   FF3,W
0B66A:  CLRF   03
0B66C:  ADDLW  24
0B66E:  MOVWF  FE9
0B670:  MOVLW  01
0B672:  ADDWFC 03,W
0B674:  MOVWF  FEA
0B676:  MOVFF  FEF,36F
0B67A:  MOVFF  FEC,370
0B67E:  MOVFF  FEC,371
0B682:  MOVFF  FEC,372
0B686:  MOVF   x6F,F
0B688:  BTFSS  FD8.2
0B68A:  BRA    B7CC
0B68C:  MOVF   x70,F
0B68E:  BTFSS  FD8.2
0B690:  BRA    B7CC
0B692:  MOVF   x71,F
0B694:  BTFSS  FD8.2
0B696:  BRA    B7CC
0B698:  MOVF   x72,F
0B69A:  BTFSS  FD8.2
0B69C:  BRA    B7CC
....................    { 
....................       lastHTTPPutVarPos[which] = 0; 
0B69E:  CLRF   03
0B6A0:  MOVFF  363,02
0B6A4:  BCF    FD8.0
0B6A6:  RLCF   02,F
0B6A8:  RLCF   03,F
0B6AA:  MOVF   02,W
0B6AC:  ADDLW  28
0B6AE:  MOVWF  FE9
0B6B0:  MOVLW  01
0B6B2:  ADDWFC 03,W
0B6B4:  MOVWF  FEA
0B6B6:  CLRF   FEC
0B6B8:  MOVF   FED,F
0B6BA:  CLRF   FEF
....................       lastHTTPPutConstPos[which] = file; 
0B6BC:  MOVF   x63,W
0B6BE:  MULLW  04
0B6C0:  MOVF   FF3,W
0B6C2:  CLRF   03
0B6C4:  ADDLW  24
0B6C6:  MOVWF  FE9
0B6C8:  MOVLW  01
0B6CA:  ADDWFC 03,W
0B6CC:  MOVWF  FEA
0B6CE:  MOVFF  366,FEF
0B6D2:  MOVFF  367,FEC
0B6D6:  MOVFF  368,FEC
0B6DA:  MOVFF  369,FEC
....................       status = HTTP_PUT_FILE_CONTINUE; 
0B6DE:  MOVLW  01
0B6E0:  MOVLB  1
0B6E2:  MOVWF  x52
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #else 
....................       printf(tcp_http_putc,"HTTP/1.0 %LU ", errorCode); 
0B6E4:  MOVLW  9A
0B6E6:  MOVWF  FF6
0B6E8:  MOVLW  01
0B6EA:  MOVWF  FF7
0B6EC:  MOVLW  09
0B6EE:  MOVLB  3
0B6F0:  MOVWF  x6F
0B6F2:  MOVLB  0
0B6F4:  GOTO   ACDC
0B6F8:  MOVLW  10
0B6FA:  MOVWF  FE9
0B6FC:  MOVFF  365,370
0B700:  MOVFF  364,36F
0B704:  GOTO   AD06
0B708:  MOVLW  20
0B70A:  MOVLB  3
0B70C:  MOVWF  x8D
0B70E:  MOVLB  0
0B710:  CALL   ACCE
....................     #endif 
....................  
....................       switch(errorCode) 
0B714:  MOVLB  3
0B716:  MOVF   x64,W
0B718:  MOVWF  00
0B71A:  MOVF   x65,W
0B71C:  MOVWF  03
0B71E:  MOVF   03,W
0B720:  BNZ   B72C
0B722:  MOVLW  C8
0B724:  SUBWF  00,W
0B726:  MOVLB  0
0B728:  BZ    B74E
0B72A:  MOVLB  3
0B72C:  MOVLW  01
0B72E:  SUBWF  03,W
0B730:  BNZ   B73C
0B732:  MOVLW  94
0B734:  SUBWF  00,W
0B736:  MOVLB  0
0B738:  BZ    B768
0B73A:  MOVLB  3
0B73C:  MOVLW  01
0B73E:  SUBWF  03,W
0B740:  BNZ   B74C
0B742:  MOVLW  F4
0B744:  SUBWF  00,W
0B746:  MOVLB  0
0B748:  BZ    B776
0B74A:  MOVLB  3
0B74C:  BRA    B786
....................       { 
....................          case 200: 
....................             printf(tcp_http_putc,"OK"); 
0B74E:  MOVLW  4F
0B750:  MOVLB  3
0B752:  MOVWF  x8D
0B754:  MOVLB  0
0B756:  CALL   ACCE
0B75A:  MOVLW  4B
0B75C:  MOVLB  3
0B75E:  MOVWF  x8D
0B760:  MOVLB  0
0B762:  CALL   ACCE
....................             break; 
0B766:  BRA    B788
....................          case 404: 
....................             printf(tcp_http_putc,"Not found"); 
0B768:  MOVLW  A8
0B76A:  MOVWF  FF6
0B76C:  MOVLW  01
0B76E:  MOVWF  FF7
0B770:  CALL   ADCE
....................             break; 
0B774:  BRA    B788
....................          case 500: 
....................             printf(tcp_http_putc,"Server Error"); 
0B776:  MOVLW  B2
0B778:  MOVWF  FF6
0B77A:  MOVLW  01
0B77C:  MOVWF  FF7
0B77E:  CALL   ADCE
....................             break; 
0B782:  BRA    B788
0B784:  MOVLB  3
....................          default: 
....................             break; 
0B786:  MOVLB  0
....................       } 
....................  
....................       printf(tcp_http_putc, "\r\nContent-Type: "); 
0B788:  MOVLW  C0
0B78A:  MOVWF  FF6
0B78C:  MOVLW  01
0B78E:  MOVWF  FF7
0B790:  CALL   ADCE
....................       if (contentType) 
0B794:  MOVLB  3
0B796:  MOVF   x6A,W
0B798:  IORWF  x6B,W
0B79A:  BZ    B7B0
....................          printf(tcp_http_putc, "%s", contentType); 
0B79C:  MOVFF  36B,FEA
0B7A0:  MOVFF  36A,FE9
0B7A4:  MOVLB  0
0B7A6:  GOTO   ADEE
0B7AA:  MOVLB  0
0B7AC:  BRA    B7BE
0B7AE:  MOVLB  3
....................       else 
....................          printf(tcp_http_putc,"text/html"); 
0B7B0:  MOVLW  D2
0B7B2:  MOVWF  FF6
0B7B4:  MOVLW  01
0B7B6:  MOVWF  FF7
0B7B8:  MOVLB  0
0B7BA:  CALL   ADCE
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc, "\r\nConnection: close"); 
....................       printf(tcp_http_putc, "\r\nTransfer-Encoding: chunked"); 
....................     #endif 
....................  
....................       printf(tcp_http_putc, "\r\n\r\n"); 
0B7BE:  MOVLW  DC
0B7C0:  MOVWF  FF6
0B7C2:  MOVLW  01
0B7C4:  MOVWF  FF7
0B7C6:  CALL   ADCE
0B7CA:  MOVLB  3
....................    } 
....................  
....................    if (lastHTTPPutVarPos[which]) 
0B7CC:  CLRF   03
0B7CE:  MOVFF  363,02
0B7D2:  BCF    FD8.0
0B7D4:  RLCF   02,F
0B7D6:  RLCF   03,F
0B7D8:  MOVF   02,W
0B7DA:  ADDLW  28
0B7DC:  MOVWF  FE9
0B7DE:  MOVLW  01
0B7E0:  ADDWFC 03,W
0B7E2:  MOVWF  FEA
0B7E4:  MOVF   FEF,F
0B7E6:  BZ    B834
....................    { 
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
0B7E8:  CLRF   03
0B7EA:  MOVFF  363,02
0B7EE:  BCF    FD8.0
0B7F0:  RLCF   02,F
0B7F2:  RLCF   03,F
0B7F4:  MOVF   02,W
0B7F6:  ADDLW  28
0B7F8:  MOVWF  01
0B7FA:  MOVLW  01
0B7FC:  ADDWFC 03,F
0B7FE:  MOVFF  01,36F
0B802:  MOVFF  03,370
0B806:  MOVFF  03,372
0B80A:  MOVFF  01,371
0B80E:  MOVLB  0
0B810:  CALL   AF0C
....................       lastHTTPPutVarPos[which] = 0; 
0B814:  CLRF   03
0B816:  MOVLB  3
0B818:  MOVFF  363,02
0B81C:  BCF    FD8.0
0B81E:  RLCF   02,F
0B820:  RLCF   03,F
0B822:  MOVF   02,W
0B824:  ADDLW  28
0B826:  MOVWF  FE9
0B828:  MOVLW  01
0B82A:  ADDWFC 03,W
0B82C:  MOVWF  FEA
0B82E:  CLRF   FEC
0B830:  MOVF   FED,F
0B832:  CLRF   FEF
....................    } 
....................  
....................    if (status == HTTP_PUT_FILE_CONTINUE) 
0B834:  MOVLB  1
0B836:  DECFSZ x52,W
0B838:  BRA    B98A
....................    { 
....................       do { 
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[which]); 
0B83A:  MOVLB  3
0B83C:  MOVF   x63,W
0B83E:  MULLW  04
0B840:  MOVF   FF3,W
0B842:  CLRF   03
0B844:  ADDLW  24
0B846:  MOVWF  01
0B848:  MOVLW  01
0B84A:  ADDWFC 03,F
0B84C:  MOVFF  01,36F
0B850:  MOVFF  03,370
0B854:  MOVFF  03,372
0B858:  MOVFF  01,371
0B85C:  MOVLB  0
0B85E:  BRA    B160
0B860:  MOVFF  01,36D
....................  
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE) 
0B864:  MOVLB  3
0B866:  MOVF   x6D,W
0B868:  SUBLW  02
0B86A:  BTFSS  FD8.2
0B86C:  BRA    B978
....................          { 
....................             escaped = TCPPutFileConstGetEscape(lastHTTPPutConstPos[which]); 
0B86E:  MOVF   x63,W
0B870:  MULLW  04
0B872:  MOVF   FF3,W
0B874:  CLRF   03
0B876:  ADDLW  24
0B878:  MOVWF  FE9
0B87A:  MOVLW  01
0B87C:  ADDWFC 03,W
0B87E:  MOVWF  FEA
0B880:  MOVFF  FEF,373
0B884:  MOVFF  FEC,374
0B888:  MOVFF  FEC,375
0B88C:  MOVFF  FEC,376
0B890:  MOVLB  0
0B892:  BRA    B226
0B894:  MOVFF  01,36E
....................            #if HTTP_USE_DOUBLE_ESCAPE 
....................             lastHTTPPutConstPos[which] += 2; 
....................            #else 
....................             lastHTTPPutConstPos[which] += 1; 
0B898:  MOVLB  3
0B89A:  MOVF   x63,W
0B89C:  MULLW  04
0B89E:  MOVF   FF3,W
0B8A0:  CLRF   03
0B8A2:  ADDLW  24
0B8A4:  MOVWF  FE9
0B8A6:  MOVLW  01
0B8A8:  ADDWFC 03,W
0B8AA:  MOVWF  FEA
0B8AC:  MOVLW  01
0B8AE:  ADDWF  FEF,W
0B8B0:  MOVWF  00
0B8B2:  MOVLW  00
0B8B4:  ADDWFC FEC,W
0B8B6:  MOVWF  01
0B8B8:  MOVLW  00
0B8BA:  ADDWFC FEC,W
0B8BC:  MOVWF  02
0B8BE:  MOVLW  00
0B8C0:  ADDWFC FEC,W
0B8C2:  MOVF   FED,F
0B8C4:  MOVF   FED,F
0B8C6:  MOVF   FED,F
0B8C8:  MOVFF  00,FEF
0B8CC:  MOVFF  01,FEC
0B8D0:  MOVFF  02,FEC
0B8D4:  MOVWF  FEC
....................            #endif 
....................             http_format_char(file, escaped, &str[0], sizeof(str)-1); 
0B8D6:  MOVFF  369,372
0B8DA:  MOVFF  368,371
0B8DE:  MOVFF  367,370
0B8E2:  MOVFF  366,36F
0B8E6:  MOVFF  36E,373
0B8EA:  MOVLW  01
0B8EC:  MOVWF  x75
0B8EE:  MOVLW  2A
0B8F0:  MOVWF  x74
0B8F2:  MOVLW  27
0B8F4:  MOVWF  x76
0B8F6:  MOVLB  0
0B8F8:  BRA    B45A
....................             lastHTTPPutVarPos[which] = &str[0]; 
0B8FA:  CLRF   03
0B8FC:  MOVLB  3
0B8FE:  MOVFF  363,02
0B902:  BCF    FD8.0
0B904:  RLCF   02,F
0B906:  RLCF   03,F
0B908:  MOVF   02,W
0B90A:  ADDLW  28
0B90C:  MOVWF  FE9
0B90E:  MOVLW  01
0B910:  ADDWFC 03,W
0B912:  MOVWF  FEA
0B914:  MOVLW  01
0B916:  MOVWF  FEC
0B918:  MOVF   FED,F
0B91A:  MOVLW  2A
0B91C:  MOVWF  FEF
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[which]); 
0B91E:  CLRF   03
0B920:  MOVFF  363,02
0B924:  BCF    FD8.0
0B926:  RLCF   02,F
0B928:  RLCF   03,F
0B92A:  MOVF   02,W
0B92C:  ADDLW  28
0B92E:  MOVWF  01
0B930:  MOVLW  01
0B932:  ADDWFC 03,F
0B934:  MOVFF  01,36F
0B938:  MOVFF  03,370
0B93C:  MOVFF  03,372
0B940:  MOVFF  01,371
0B944:  MOVLB  0
0B946:  CALL   AF0C
0B94A:  MOVFF  01,36D
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
0B94E:  MOVLB  3
0B950:  MOVF   x6D,F
0B952:  BNZ   B974
....................                lastHTTPPutVarPos[which] = 0; 
0B954:  CLRF   03
0B956:  MOVFF  363,02
0B95A:  BCF    FD8.0
0B95C:  RLCF   02,F
0B95E:  RLCF   03,F
0B960:  MOVF   02,W
0B962:  ADDLW  28
0B964:  MOVWF  FE9
0B966:  MOVLW  01
0B968:  ADDWFC 03,W
0B96A:  MOVWF  FEA
0B96C:  CLRF   FEC
0B96E:  MOVF   FED,F
0B970:  CLRF   FEF
0B972:  BRA    B976
....................             else 
....................                break; 
0B974:  BRA    B988
....................          } 
0B976:  BRA    B986
....................          else 
....................          { 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
0B978:  MOVF   x6D,F
0B97A:  BNZ   B984
....................                status = HTTP_PUT_FILE_CHUNK_END; 
0B97C:  MOVLW  02
0B97E:  MOVLB  1
0B980:  MOVWF  x52
0B982:  MOVLB  3
....................             break; 
0B984:  BRA    B988
....................          } 
....................       } while (TRUE); 
0B986:  BRA    B83C
0B988:  MOVLB  1
....................    } 
....................  
....................    if (status == HTTP_PUT_FILE_CHUNK_END) 
0B98A:  MOVF   x52,W
0B98C:  SUBLW  02
0B98E:  BNZ   B994
....................    { 
....................      #if HTTP_USE_CHUNKS 
....................       if (tcp_http_tx_left() > 8) 
....................       { 
....................          TCPPutFileChunkStart(0); 
....................          TCPPutFileChunkStop(); 
....................          status = HTTP_PUT_FILE_DONE; 
....................       } 
....................      #else 
....................       status = HTTP_PUT_FILE_DONE; 
0B990:  MOVLW  03
0B992:  MOVWF  x52
....................      #endif 
....................    } 
....................  
....................  
....................    TCPFlush(socket); 
0B994:  MOVFF  36C,394
0B998:  MOVLB  0
0B99A:  CALL   A9FE
....................  
....................    return(status == HTTP_PUT_FILE_DONE); 
0B99E:  MOVLB  1
0B9A0:  MOVF   x52,W
0B9A2:  SUBLW  03
0B9A4:  BZ    B9AA
0B9A6:  MOVLW  00
0B9A8:  BRA    B9AC
0B9AA:  MOVLW  01
0B9AC:  MOVWF  01
0B9AE:  MOVLB  0
0B9B0:  RETURN 0
.................... } 
....................  
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack 
.................... void HTTP_Init(void) { 
....................    int8 i; 
....................    debug_http("\r\nHTTP OPENING"); 
....................    if (HTTP_PORT != 0) 
....................    { 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
*
06C48:  MOVLB  3
06C4A:  CLRF   x51
06C4C:  MOVF   x51,F
06C4E:  BNZ   6CAC
....................       { 
....................          http_socket[i]=TCPListen(HTTP_PORT); 
06C50:  CLRF   03
06C52:  MOVF   x51,W
06C54:  ADDLW  20
06C56:  MOVWF  01
06C58:  MOVLW  01
06C5A:  ADDWFC 03,F
06C5C:  MOVFF  01,352
06C60:  MOVFF  03,353
06C64:  CLRF   x55
06C66:  MOVLW  50
06C68:  MOVWF  x54
06C6A:  MOVLB  0
06C6C:  BRA    6B52
06C6E:  MOVFF  353,FEA
06C72:  MOVFF  352,FE9
06C76:  MOVFF  01,FEF
....................          debug_http("\r\nHTTP SOCKET=%X", http_socket[i]); 
....................          if (http_socket[i]!=INVALID_SOCKET) 
06C7A:  CLRF   03
06C7C:  MOVLB  3
06C7E:  MOVF   x51,W
06C80:  ADDLW  20
06C82:  MOVWF  FE9
06C84:  MOVLW  01
06C86:  ADDWFC 03,W
06C88:  MOVWF  FEA
06C8A:  MOVF   FEF,W
06C8C:  SUBLW  FE
06C8E:  BZ    6CA8
....................          { 
....................             http_state[i]=HTTP_LISTEN_WAIT; 
06C90:  BCF    FD8.0
06C92:  RLCF   x51,W
06C94:  CLRF   03
06C96:  ADDLW  21
06C98:  MOVWF  FE9
06C9A:  MOVLW  01
06C9C:  ADDWFC 03,W
06C9E:  MOVWF  FEA
06CA0:  MOVLW  01
06CA2:  MOVWF  FEC
06CA4:  MOVF   FED,F
06CA6:  MOVWF  FEF
....................          } 
06CA8:  INCF   x51,F
06CAA:  BRA    6C4C
....................       } 
....................    } 
....................    else 
....................    { 
....................       debug_http("\r\nHTTP DISABLED"); 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
....................       { 
....................             http_state[i]=HTTP_DISABLED; 
....................       } 
....................    } 
06CAC:  MOVLB  0
06CAE:  GOTO   6CC4 (RETURN)
.................... } 
....................  
.................... void HTTP_Task(void) { 
....................    static char tokens_header[]=" "; 
....................    static char tokens_get[]="?"; 
....................    static char http_get_str[]="GET"; 
....................    static char http_post_str[]="POST"; 
....................    static char http_len_str[]="Content-Length:"; 
....................    //static char http_keepalive_str[]="keep-alive"; 
....................    //static char http_connection_str[]="Connection"; 
....................  
....................    static char buffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
....................  
....................    static int8 i[HTTP_NUM_SOCKETS]; 
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]={0}; 
....................    static int32 http_page_req[HTTP_NUM_SOCKETS]; 
....................    static int16 http_post_len[HTTP_NUM_SOCKETS]={0}; 
....................    static int16 http_timer[HTTP_NUM_SOCKETS]; 
....................  #if HTTP_USE_CONTENT_TYPE 
....................    static char contentType[HTTP_NUM_SOCKETS][12]; 
....................  #endif 
....................  
....................    int1 doneSend, postContinue; 
....................  
....................    char c, *pKey, *pValue; 
....................    int8 hs, currSocket; 
....................  
....................    for (hs=0; hs<HTTP_NUM_SOCKETS; hs++) 
*
0BAC0:  MOVLB  3
0BAC2:  CLRF   x5D
0BAC4:  MOVF   x5D,F
0BAC6:  BTFSS  FD8.2
0BAC8:  GOTO   C6F4
....................    { 
....................       if (http_state[hs]==HTTP_DISABLED) 
0BACC:  BCF    FD8.0
0BACE:  RLCF   x5D,W
0BAD0:  CLRF   03
0BAD2:  ADDLW  21
0BAD4:  MOVWF  FE9
0BAD6:  MOVLW  01
0BAD8:  ADDWFC 03,W
0BADA:  MOVWF  FEA
0BADC:  MOVFF  FEC,360
0BAE0:  MOVF   FED,F
0BAE2:  MOVFF  FEF,35F
0BAE6:  INCFSZ x5F,W
0BAE8:  BRA    BAF2
0BAEA:  MOVF   x60,F
0BAEC:  BNZ   BAF2
....................          return; 
0BAEE:  GOTO   C6F4
....................  
....................       currSocket=http_socket[hs]; 
0BAF2:  CLRF   03
0BAF4:  MOVF   x5D,W
0BAF6:  ADDLW  20
0BAF8:  MOVWF  FE9
0BAFA:  MOVLW  01
0BAFC:  ADDWFC 03,W
0BAFE:  MOVWF  FEA
0BB00:  MOVFF  FEF,35E
....................  
....................       if (!TCPIsConnected(currSocket)) 
0BB04:  MOVFF  35E,35F
0BB08:  MOVLB  0
0BB0A:  CALL   99B8
0BB0E:  MOVF   01,F
0BB10:  BNZ   BB2E
....................          http_state[hs]=HTTP_LISTEN_WAIT; 
0BB12:  BCF    FD8.0
0BB14:  MOVLB  3
0BB16:  RLCF   x5D,W
0BB18:  CLRF   03
0BB1A:  ADDLW  21
0BB1C:  MOVWF  FE9
0BB1E:  MOVLW  01
0BB20:  ADDWFC 03,W
0BB22:  MOVWF  FEA
0BB24:  MOVLW  01
0BB26:  MOVWF  FEC
0BB28:  MOVF   FED,F
0BB2A:  MOVWF  FEF
0BB2C:  MOVLB  0
....................  
....................       switch(http_state[hs]) 
0BB2E:  BCF    FD8.0
0BB30:  MOVLB  3
0BB32:  RLCF   x5D,W
0BB34:  CLRF   03
0BB36:  ADDLW  21
0BB38:  MOVWF  FE9
0BB3A:  MOVLW  01
0BB3C:  ADDWFC 03,W
0BB3E:  MOVWF  FEA
0BB40:  MOVF   FEF,W
0BB42:  MOVWF  00
0BB44:  MOVF   FEE,F
0BB46:  MOVF   FED,W
0BB48:  MOVWF  03
0BB4A:  MOVLW  01
0BB4C:  SUBWF  03,W
0BB4E:  BNZ   BB5A
0BB50:  MOVLW  01
0BB52:  SUBWF  00,W
0BB54:  MOVLB  0
0BB56:  BZ    BC08
0BB58:  MOVLB  3
0BB5A:  MOVLW  01
0BB5C:  SUBWF  03,W
0BB5E:  BNZ   BB6A
0BB60:  MOVLW  02
0BB62:  SUBWF  00,W
0BB64:  MOVLB  0
0BB66:  BZ    BC18
0BB68:  MOVLB  3
0BB6A:  MOVLW  01
0BB6C:  SUBWF  03,W
0BB6E:  BNZ   BB7C
0BB70:  MOVLW  03
0BB72:  SUBWF  00,W
0BB74:  MOVLB  0
0BB76:  BTFSC  FD8.2
0BB78:  BRA    BCC8
0BB7A:  MOVLB  3
0BB7C:  MOVLW  01
0BB7E:  SUBWF  03,W
0BB80:  BNZ   BB8E
0BB82:  MOVLW  04
0BB84:  SUBWF  00,W
0BB86:  MOVLB  0
0BB88:  BTFSC  FD8.2
0BB8A:  BRA    C11A
0BB8C:  MOVLB  3
0BB8E:  MOVLW  01
0BB90:  SUBWF  03,W
0BB92:  BNZ   BBA0
0BB94:  MOVLW  05
0BB96:  SUBWF  00,W
0BB98:  MOVLB  0
0BB9A:  BTFSC  FD8.2
0BB9C:  BRA    C178
0BB9E:  MOVLB  3
0BBA0:  MOVLW  01
0BBA2:  SUBWF  03,W
0BBA4:  BNZ   BBB4
0BBA6:  MOVLW  06
0BBA8:  SUBWF  00,W
0BBAA:  MOVLB  0
0BBAC:  BTFSC  FD8.2
0BBAE:  GOTO   C426
0BBB2:  MOVLB  3
0BBB4:  MOVLW  01
0BBB6:  SUBWF  03,W
0BBB8:  BNZ   BBC8
0BBBA:  MOVLW  07
0BBBC:  SUBWF  00,W
0BBBE:  MOVLB  0
0BBC0:  BTFSC  FD8.2
0BBC2:  GOTO   C468
0BBC6:  MOVLB  3
0BBC8:  MOVLW  01
0BBCA:  SUBWF  03,W
0BBCC:  BNZ   BBDC
0BBCE:  MOVLW  08
0BBD0:  SUBWF  00,W
0BBD2:  MOVLB  0
0BBD4:  BTFSC  FD8.2
0BBD6:  GOTO   C5A4
0BBDA:  MOVLB  3
0BBDC:  MOVLW  01
0BBDE:  SUBWF  03,W
0BBE0:  BNZ   BBF0
0BBE2:  MOVLW  09
0BBE4:  SUBWF  00,W
0BBE6:  MOVLB  0
0BBE8:  BTFSC  FD8.2
0BBEA:  GOTO   C5EE
0BBEE:  MOVLB  3
0BBF0:  MOVLW  01
0BBF2:  SUBWF  03,W
0BBF4:  BNZ   BC04
0BBF6:  MOVLW  0A
0BBF8:  SUBWF  00,W
0BBFA:  MOVLB  0
0BBFC:  BTFSC  FD8.2
0BBFE:  GOTO   C6E8
0BC02:  MOVLB  3
0BC04:  GOTO   C6EA
....................       { 
....................          case HTTP_LISTEN_WAIT: 
....................             if (!TCPIsConnected(currSocket)) 
0BC08:  MOVFF  35E,35F
0BC0C:  CALL   99B8
0BC10:  MOVF   01,F
0BC12:  BNZ   BC18
....................                break; 
0BC14:  GOTO   C6EC
....................             debug_http("HTTP %U CONNECTED\r\n", hs); 
....................  
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header 
....................          case HTTP_CONNECTED: 
....................             debug_http("HTTP %U LISTENING\r\n", hs); 
....................             buffer[hs][0]=0; 
0BC18:  MOVLB  3
0BC1A:  MOVF   x5D,W
0BC1C:  MULLW  FE
0BC1E:  MOVF   FF3,W
0BC20:  CLRF   x60
0BC22:  MOVWF  x5F
0BC24:  MOVLW  72
0BC26:  ADDWF  x5F,W
0BC28:  MOVWF  FE9
0BC2A:  MOVLW  01
0BC2C:  ADDWFC x60,W
0BC2E:  MOVWF  FEA
0BC30:  CLRF   FEF
....................             i[hs]=0; 
0BC32:  CLRF   03
0BC34:  MOVF   x5D,W
0BC36:  ADDLW  70
0BC38:  MOVWF  FE9
0BC3A:  MOVLW  02
0BC3C:  ADDWFC 03,W
0BC3E:  MOVWF  FEA
0BC40:  CLRF   FEF
....................             http_state[hs]=HTTP_GET_HEADERS; 
0BC42:  BCF    FD8.0
0BC44:  RLCF   x5D,W
0BC46:  CLRF   03
0BC48:  ADDLW  21
0BC4A:  MOVWF  FE9
0BC4C:  MOVLW  01
0BC4E:  ADDWFC 03,W
0BC50:  MOVWF  FEA
0BC52:  MOVLW  01
0BC54:  MOVWF  FEC
0BC56:  MOVF   FED,F
0BC58:  MOVLW  03
0BC5A:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
0BC5C:  BCF    FD8.0
0BC5E:  RLCF   x5D,W
0BC60:  CLRF   03
0BC62:  ADDLW  78
0BC64:  MOVWF  01
0BC66:  MOVLW  02
0BC68:  ADDWFC 03,F
0BC6A:  MOVFF  01,35F
0BC6E:  MOVFF  03,360
0BC72:  MOVLB  0
0BC74:  CALL   8078
0BC78:  MOVFF  360,FEA
0BC7C:  MOVFF  35F,FE9
0BC80:  MOVFF  02,FEC
0BC84:  MOVF   FED,F
0BC86:  MOVFF  01,FEF
....................             http_page_req[hs]=0; 
0BC8A:  MOVLB  3
0BC8C:  MOVF   x5D,W
0BC8E:  MULLW  04
0BC90:  MOVF   FF3,W
0BC92:  CLRF   03
0BC94:  ADDLW  72
0BC96:  MOVWF  FE9
0BC98:  MOVLW  02
0BC9A:  ADDWFC 03,W
0BC9C:  MOVWF  FEA
0BC9E:  MOVF   FEE,F
0BCA0:  MOVF   FEE,F
0BCA2:  CLRF   FEC
0BCA4:  MOVF   FED,F
0BCA6:  CLRF   FEF
0BCA8:  MOVF   FED,F
0BCAA:  CLRF   FEF
0BCAC:  MOVF   FED,F
0BCAE:  CLRF   FEF
....................             http_post_len[hs]=0; 
0BCB0:  BCF    FD8.0
0BCB2:  RLCF   x5D,W
0BCB4:  CLRF   03
0BCB6:  ADDLW  76
0BCB8:  MOVWF  FE9
0BCBA:  MOVLW  02
0BCBC:  ADDWFC 03,W
0BCBE:  MOVWF  FEA
0BCC0:  CLRF   FEC
0BCC2:  MOVF   FED,F
0BCC4:  CLRF   FEF
0BCC6:  MOVLB  0
....................             //http_got_headers[hs]=FALSE; 
....................             //http_isKeepAlive[hs]=FALSE; 
....................  
....................          case HTTP_GET_HEADERS: 
....................             postContinue=FALSE; 
0BCC8:  MOVLB  3
0BCCA:  BCF    x57.1
....................             while (TCPIsGetReady(currSocket) && TCPGet(currSocket, &c)) 
0BCCC:  MOVFF  35E,35F
0BCD0:  MOVLB  0
0BCD2:  CALL   99E2
0BCD6:  MOVF   01,F
0BCD8:  BTFSC  FD8.2
0BCDA:  BRA    C01E
0BCDC:  MOVFF  35E,35F
0BCE0:  MOVLW  03
0BCE2:  MOVLB  3
0BCE4:  MOVWF  x61
0BCE6:  MOVLW  58
0BCE8:  MOVWF  x60
0BCEA:  MOVLB  0
0BCEC:  CALL   9A0E
0BCF0:  MOVF   01,F
0BCF2:  BTFSC  FD8.2
0BCF4:  BRA    C01E
....................             { 
....................                //http_got_headers[hs]=TRUE; 
....................                if ( (c >= 0x20) && (i[hs] < HTTP_GET_PARAM_MAX_SIZE - 2) ) 
0BCF6:  MOVLB  3
0BCF8:  MOVF   x58,W
0BCFA:  SUBLW  1F
0BCFC:  BC    BD48
0BCFE:  CLRF   03
0BD00:  MOVF   x5D,W
0BD02:  ADDLW  70
0BD04:  MOVWF  FE9
0BD06:  MOVLW  02
0BD08:  ADDWFC 03,W
0BD0A:  MOVWF  FEA
0BD0C:  MOVF   FEF,W
0BD0E:  SUBLW  FB
0BD10:  BNC   BD48
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
0BD12:  MOVF   x5D,W
0BD14:  MULLW  FE
0BD16:  MOVF   FF3,W
0BD18:  CLRF   x60
0BD1A:  MOVWF  x5F
0BD1C:  CLRF   03
0BD1E:  MOVF   x5D,W
0BD20:  ADDLW  70
0BD22:  MOVWF  FE9
0BD24:  MOVLW  02
0BD26:  ADDWFC 03,W
0BD28:  MOVWF  FEA
0BD2A:  MOVF   FEF,W
0BD2C:  INCF   FEF,F
0BD2E:  CLRF   03
0BD30:  ADDWF  x5F,W
0BD32:  MOVWF  01
0BD34:  MOVF   x60,W
0BD36:  ADDWFC 03,F
0BD38:  MOVF   01,W
0BD3A:  ADDLW  72
0BD3C:  MOVWF  FE9
0BD3E:  MOVLW  01
0BD40:  ADDWFC 03,W
0BD42:  MOVWF  FEA
0BD44:  MOVFF  358,FEF
....................                } 
....................                if (c=='\n') 
0BD48:  MOVF   x58,W
0BD4A:  SUBLW  0A
0BD4C:  BTFSS  FD8.2
0BD4E:  BRA    C01A
....................                { 
....................                   buffer[hs][i[hs]]=0; 
0BD50:  MOVF   x5D,W
0BD52:  MULLW  FE
0BD54:  MOVF   FF3,W
0BD56:  CLRF   x60
0BD58:  MOVWF  x5F
0BD5A:  CLRF   03
0BD5C:  MOVF   x5D,W
0BD5E:  ADDLW  70
0BD60:  MOVWF  FE9
0BD62:  MOVLW  02
0BD64:  ADDWFC 03,W
0BD66:  MOVWF  FEA
0BD68:  CLRF   03
0BD6A:  MOVF   FEF,W
0BD6C:  ADDWF  x5F,W
0BD6E:  MOVWF  01
0BD70:  MOVF   x60,W
0BD72:  ADDWFC 03,F
0BD74:  MOVF   01,W
0BD76:  ADDLW  72
0BD78:  MOVWF  FE9
0BD7A:  MOVLW  01
0BD7C:  ADDWFC 03,W
0BD7E:  MOVWF  FEA
0BD80:  CLRF   FEF
....................                   if ( 
....................                        ( ( pKey = strtok(&buffer[hs][0], tokens_header) ) !=0 ) && 
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 ) 
0BD82:  MOVF   x5D,W
0BD84:  MULLW  FE
0BD86:  MOVF   FF3,W
0BD88:  CLRF   x60
0BD8A:  MOVWF  x5F
0BD8C:  MOVLW  72
0BD8E:  ADDWF  x5F,W
0BD90:  MOVWF  01
0BD92:  MOVLW  01
0BD94:  ADDWFC x60,W
0BD96:  MOVWF  03
0BD98:  MOVFF  01,361
0BD9C:  MOVWF  x62
0BD9E:  MOVWF  x64
0BDA0:  MOVFF  01,363
0BDA4:  MOVLW  01
0BDA6:  MOVWF  x66
0BDA8:  MOVLW  55
0BDAA:  MOVWF  x65
0BDAC:  MOVLB  0
0BDAE:  CALL   9C28
0BDB2:  MOVFF  02,35A
0BDB6:  MOVFF  01,359
0BDBA:  MOVLB  3
0BDBC:  MOVF   x59,F
0BDBE:  BNZ   BDC6
0BDC0:  MOVF   x5A,F
0BDC2:  BTFSC  FD8.2
0BDC4:  BRA    BF9A
0BDC6:  CLRF   x64
0BDC8:  CLRF   x63
0BDCA:  MOVLW  01
0BDCC:  MOVWF  x66
0BDCE:  MOVLW  55
0BDD0:  MOVWF  x65
0BDD2:  MOVLB  0
0BDD4:  CALL   9C28
0BDD8:  MOVFF  02,35C
0BDDC:  MOVFF  01,35B
0BDE0:  MOVLB  3
0BDE2:  MOVF   x5B,F
0BDE4:  BNZ   BDEC
0BDE6:  MOVF   x5C,F
0BDE8:  BTFSC  FD8.2
0BDEA:  BRA    BF9A
....................                      ) 
....................                   { 
....................                      debug_http("HTTP %U PAIR %s = %s\r\n", hs, pKey, pValue); 
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) ) 
0BDEC:  MOVFF  35A,360
0BDF0:  MOVFF  359,35F
0BDF4:  MOVLW  01
0BDF6:  MOVWF  x62
0BDF8:  MOVLW  59
0BDFA:  MOVWF  x61
0BDFC:  MOVLB  0
0BDFE:  CALL   9CE0
0BE02:  MOVF   01,F
0BE04:  BZ    BE24
0BE06:  MOVFF  35A,360
0BE0A:  MOVFF  359,35F
0BE0E:  MOVLW  01
0BE10:  MOVLB  3
0BE12:  MOVWF  x62
0BE14:  MOVLW  5D
0BE16:  MOVWF  x61
0BE18:  MOVLB  0
0BE1A:  CALL   9CE0
0BE1E:  MOVF   01,F
0BE20:  BTFSS  FD8.2
0BE22:  BRA    BF30
....................                      { 
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ? 
0BE24:  MOVFF  35C,364
0BE28:  MOVFF  35B,363
0BE2C:  MOVLW  01
0BE2E:  MOVLB  3
0BE30:  MOVWF  x66
0BE32:  MOVLW  57
0BE34:  MOVWF  x65
0BE36:  MOVLB  0
0BE38:  CALL   9C28
0BE3C:  MOVFF  02,35C
0BE40:  MOVFF  01,35B
....................                         http_escape_chars(pValue); 
0BE44:  MOVFF  35C,373
0BE48:  MOVFF  35B,372
0BE4C:  CALL   A250
....................                        #if HTTP_USE_CONTENT_TYPE 
....................                         http_get_page(pValue, &http_page_req[hs], &contentType[hs][0]); 
....................                        #else 
....................                         http_page_req[hs] = http_get_page(pValue); 
0BE50:  MOVLB  3
0BE52:  MOVF   x5D,W
0BE54:  MULLW  04
0BE56:  MOVF   FF3,W
0BE58:  CLRF   03
0BE5A:  ADDLW  72
0BE5C:  MOVWF  01
0BE5E:  MOVLW  02
0BE60:  ADDWFC 03,F
0BE62:  MOVFF  01,35F
0BE66:  MOVFF  03,360
0BE6A:  MOVFF  35C,362
0BE6E:  MOVFF  35B,361
0BE72:  MOVLB  0
0BE74:  GOTO   A444
0BE78:  MOVFF  360,FEA
0BE7C:  MOVFF  35F,FE9
0BE80:  MOVFF  00,FEF
0BE84:  MOVFF  01,FEC
0BE88:  MOVFF  02,FEC
0BE8C:  MOVFF  03,FEC
....................                        #endif 
....................                         debug_http("HTTP %U FILE %s = %lx\r\n", hs, pValue, http_page_req[hs]); 
....................                         pValue=strtok(0, tokens_get); 
0BE90:  MOVLB  3
0BE92:  CLRF   x64
0BE94:  CLRF   x63
0BE96:  MOVLW  01
0BE98:  MOVWF  x66
0BE9A:  MOVLW  57
0BE9C:  MOVWF  x65
0BE9E:  MOVLB  0
0BEA0:  CALL   9C28
0BEA4:  MOVFF  02,35C
0BEA8:  MOVFF  01,35B
....................                         if (pValue) 
0BEAC:  MOVLB  3
0BEAE:  MOVF   x5B,W
0BEB0:  IORWF  x5C,W
0BEB2:  BZ    BEE6
....................                            http_parse_cgi_string(http_page_req[hs], pValue); 
0BEB4:  MOVF   x5D,W
0BEB6:  MULLW  04
0BEB8:  MOVF   FF3,W
0BEBA:  CLRF   03
0BEBC:  ADDLW  72
0BEBE:  MOVWF  FE9
0BEC0:  MOVLW  02
0BEC2:  ADDWFC 03,W
0BEC4:  MOVWF  FEA
0BEC6:  MOVFF  FEF,367
0BECA:  MOVFF  FEC,368
0BECE:  MOVFF  FEC,369
0BED2:  MOVFF  FEC,36A
0BED6:  MOVFF  35C,36C
0BEDA:  MOVFF  35B,36B
0BEDE:  MOVLB  0
0BEE0:  CALL   A67C
0BEE4:  MOVLB  3
....................  
....................                         if (strcmp(pKey, http_get_str)==0) 
0BEE6:  MOVFF  35A,360
0BEEA:  MOVFF  359,35F
0BEEE:  MOVLW  01
0BEF0:  MOVWF  x62
0BEF2:  MOVLW  59
0BEF4:  MOVWF  x61
0BEF6:  MOVLB  0
0BEF8:  CALL   9CE0
0BEFC:  MOVF   01,F
0BEFE:  BNZ   BF18
....................                            http_cmd[hs]=HTTP_REQ_GET; 
0BF00:  CLRF   03
0BF02:  MOVLB  3
0BF04:  MOVF   x5D,W
0BF06:  ADDLW  71
0BF08:  MOVWF  FE9
0BF0A:  MOVLW  02
0BF0C:  ADDWFC 03,W
0BF0E:  MOVWF  FEA
0BF10:  MOVLW  01
0BF12:  MOVWF  FEF
0BF14:  BRA    BF2C
0BF16:  MOVLB  0
....................                         else 
....................                            http_cmd[hs]=HTTP_REQ_POST; 
0BF18:  CLRF   03
0BF1A:  MOVLB  3
0BF1C:  MOVF   x5D,W
0BF1E:  ADDLW  71
0BF20:  MOVWF  FE9
0BF22:  MOVLW  02
0BF24:  ADDWFC 03,W
0BF26:  MOVWF  FEA
0BF28:  MOVLW  02
0BF2A:  MOVWF  FEF
....................                      } 
0BF2C:  BRA    BF98
0BF2E:  MOVLB  0
....................                      else if (http_cmd[hs] != HTTP_REQ_UNKOWN)   //we processed a GET or POST 
0BF30:  CLRF   03
0BF32:  MOVLB  3
0BF34:  MOVF   x5D,W
0BF36:  ADDLW  71
0BF38:  MOVWF  FE9
0BF3A:  MOVLW  02
0BF3C:  ADDWFC 03,W
0BF3E:  MOVWF  FEA
0BF40:  MOVF   FEF,F
0BF42:  BZ    BF98
....................                      { 
....................                         //if you want to parse HTTP headers, do it here. 
....................                         //pKey and pVal hold the individual headers. 
....................  
....................                         //this driver only parses the Content-Length header. 
....................                         if (strcmp(pKey, http_len_str)==0) 
0BF44:  MOVFF  35A,360
0BF48:  MOVFF  359,35F
0BF4C:  MOVLW  01
0BF4E:  MOVWF  x62
0BF50:  MOVLW  62
0BF52:  MOVWF  x61
0BF54:  MOVLB  0
0BF56:  CALL   9CE0
0BF5A:  MOVF   01,F
0BF5C:  BNZ   BF96
....................                         { 
....................                            http_post_len[hs]=atol(pValue); 
0BF5E:  BCF    FD8.0
0BF60:  MOVLB  3
0BF62:  RLCF   x5D,W
0BF64:  CLRF   03
0BF66:  ADDLW  76
0BF68:  MOVWF  01
0BF6A:  MOVLW  02
0BF6C:  ADDWFC 03,F
0BF6E:  MOVFF  01,35F
0BF72:  MOVFF  03,360
0BF76:  MOVFF  35C,362
0BF7A:  MOVFF  35B,361
0BF7E:  MOVLB  0
0BF80:  GOTO   A724
0BF84:  MOVFF  360,FEA
0BF88:  MOVFF  35F,FE9
0BF8C:  MOVFF  02,FEC
0BF90:  MOVF   FED,F
0BF92:  MOVFF  01,FEF
0BF96:  MOVLB  3
....................                         } 
....................                      } 
....................                   } 
0BF98:  BRA    C00A
....................                   else if (i[hs] == 0) 
0BF9A:  CLRF   03
0BF9C:  MOVF   x5D,W
0BF9E:  ADDLW  70
0BFA0:  MOVWF  FE9
0BFA2:  MOVLW  02
0BFA4:  ADDWFC 03,W
0BFA6:  MOVWF  FEA
0BFA8:  MOVF   FEF,F
0BFAA:  BNZ   C00A
....................                   { 
....................                      //got a double \r\n 
....................                      debug_http("HTTP %U GET HEADER DONE\r\n", hs); 
....................                      if (http_cmd[hs] == HTTP_REQ_POST) 
0BFAC:  CLRF   03
0BFAE:  MOVF   x5D,W
0BFB0:  ADDLW  71
0BFB2:  MOVWF  FE9
0BFB4:  MOVLW  02
0BFB6:  ADDWFC 03,W
0BFB8:  MOVWF  FEA
0BFBA:  MOVF   FEF,W
0BFBC:  SUBLW  02
0BFBE:  BNZ   BFDE
....................                      { 
....................                         http_state[hs]=HTTP_GET_POST; 
0BFC0:  BCF    FD8.0
0BFC2:  RLCF   x5D,W
0BFC4:  CLRF   03
0BFC6:  ADDLW  21
0BFC8:  MOVWF  FE9
0BFCA:  MOVLW  01
0BFCC:  ADDWFC 03,W
0BFCE:  MOVWF  FEA
0BFD0:  MOVLW  01
0BFD2:  MOVWF  FEC
0BFD4:  MOVF   FED,F
0BFD6:  MOVLW  04
0BFD8:  MOVWF  FEF
....................                         postContinue=TRUE; 
0BFDA:  BSF    x57.1
....................                      } 
0BFDC:  BRA    C004
....................                      else 
....................                      { 
....................                         http_state[hs]=HTTP_SEND_RESPONSE; 
0BFDE:  BCF    FD8.0
0BFE0:  RLCF   x5D,W
0BFE2:  CLRF   03
0BFE4:  ADDLW  21
0BFE6:  MOVWF  FE9
0BFE8:  MOVLW  01
0BFEA:  ADDWFC 03,W
0BFEC:  MOVWF  FEA
0BFEE:  MOVLW  01
0BFF0:  MOVWF  FEC
0BFF2:  MOVF   FED,F
0BFF4:  MOVLW  06
0BFF6:  MOVWF  FEF
....................                         TCPDiscard(currSocket); 
0BFF8:  MOVFF  35E,362
0BFFC:  MOVLB  0
0BFFE:  CALL   A90C
0C002:  MOVLB  3
....................                      } 
....................                      break;   //break out of read from ethernet loop 
0C004:  MOVLB  0
0C006:  BRA    C01E
0C008:  MOVLB  3
....................                   } 
....................                   i[hs]=0; 
0C00A:  CLRF   03
0C00C:  MOVF   x5D,W
0C00E:  ADDLW  70
0C010:  MOVWF  FE9
0C012:  MOVLW  02
0C014:  ADDWFC 03,W
0C016:  MOVWF  FEA
0C018:  CLRF   FEF
....................                } 
0C01A:  BRA    BCCC
0C01C:  MOVLB  0
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
0C01E:  CALL   8078
0C022:  MOVFF  02,360
0C026:  MOVFF  01,35F
0C02A:  BCF    FD8.0
0C02C:  MOVLB  3
0C02E:  RLCF   x5D,W
0C030:  CLRF   03
0C032:  ADDLW  78
0C034:  MOVWF  FE9
0C036:  MOVLW  02
0C038:  ADDWFC 03,W
0C03A:  MOVWF  FEA
0C03C:  MOVFF  FEC,03
0C040:  MOVF   FED,F
0C042:  MOVFF  FEF,01
0C046:  MOVF   02,W
0C048:  SUBWF  03,W
0C04A:  BNC   C054
0C04C:  BNZ   C058
0C04E:  MOVF   01,W
0C050:  SUBWF  x5F,W
0C052:  BNC   C058
0C054:  MOVLW  00
0C056:  BRA    C05A
0C058:  MOVLW  01
0C05A:  CLRF   03
0C05C:  IORWF  03,W
0C05E:  BZ    C0A2
0C060:  BCF    FD8.0
0C062:  RLCF   x5D,W
0C064:  CLRF   03
0C066:  ADDLW  78
0C068:  MOVWF  FE9
0C06A:  MOVLW  02
0C06C:  ADDWFC 03,W
0C06E:  MOVWF  FEA
0C070:  MOVFF  FEC,03
0C074:  MOVF   FED,F
0C076:  MOVF   FEF,W
0C078:  SUBLW  FF
0C07A:  MOVWF  x5F
0C07C:  MOVLW  FF
0C07E:  SUBFWB 03,W
0C080:  MOVWF  x60
0C082:  MOVLB  0
0C084:  CALL   8078
0C088:  MOVF   01,W
0C08A:  MOVLB  3
0C08C:  ADDWF  x5F,F
0C08E:  MOVF   02,W
0C090:  ADDWFC x60,F
0C092:  MOVLW  01
0C094:  ADDWF  x5F,W
0C096:  MOVWF  01
0C098:  MOVLW  00
0C09A:  ADDWFC x60,W
0C09C:  MOVWF  03
0C09E:  MOVF   01,W
0C0A0:  BRA    C0D6
0C0A2:  MOVLB  0
0C0A4:  CALL   8078
0C0A8:  MOVFF  02,360
0C0AC:  MOVFF  01,35F
0C0B0:  BCF    FD8.0
0C0B2:  MOVLB  3
0C0B4:  RLCF   x5D,W
0C0B6:  CLRF   03
0C0B8:  ADDLW  78
0C0BA:  MOVWF  FE9
0C0BC:  MOVLW  02
0C0BE:  ADDWFC 03,W
0C0C0:  MOVWF  FEA
0C0C2:  MOVFF  FEC,03
0C0C6:  MOVF   FED,F
0C0C8:  MOVF   FEF,W
0C0CA:  SUBWF  01,W
0C0CC:  MOVWF  00
0C0CE:  MOVF   03,W
0C0D0:  SUBWFB 02,W
0C0D2:  MOVWF  03
0C0D4:  MOVF   00,W
0C0D6:  SUBLW  C8
0C0D8:  BC    C10E
....................             { 
....................                //if (http_got_headers[hs]) 
....................                //{ 
....................                   debug_http("HTTP %U GET HEADER TIMEOUT\r\n", hs); 
....................                   http_page_req[hs]=0xFFFFFFFF; 
0C0DA:  MOVF   x5D,W
0C0DC:  MULLW  04
0C0DE:  MOVF   FF3,W
0C0E0:  CLRF   03
0C0E2:  ADDLW  72
0C0E4:  MOVWF  FE9
0C0E6:  MOVLW  02
0C0E8:  ADDWFC 03,W
0C0EA:  MOVWF  FEA
0C0EC:  SETF   FEF
0C0EE:  SETF   FEC
0C0F0:  SETF   FEC
0C0F2:  SETF   FEC
....................                   http_state[hs]=HTTP_SEND_RESPONSE; 
0C0F4:  BCF    FD8.0
0C0F6:  RLCF   x5D,W
0C0F8:  CLRF   03
0C0FA:  ADDLW  21
0C0FC:  MOVWF  FE9
0C0FE:  MOVLW  01
0C100:  ADDWFC 03,W
0C102:  MOVWF  FEA
0C104:  MOVLW  01
0C106:  MOVWF  FEC
0C108:  MOVF   FED,F
0C10A:  MOVLW  06
0C10C:  MOVWF  FEF
....................                //} 
....................                //else 
....................                //{ 
....................                //   http_state[hs]=HTTP_CLOSE; 
....................                //} 
....................             } 
....................             if (!postContinue) 
0C10E:  BTFSC  x57.1
0C110:  BRA    C118
....................                break; 
0C112:  MOVLB  0
0C114:  BRA    C6EC
0C116:  MOVLB  3
0C118:  MOVLB  0
....................  
....................          case HTTP_GET_POST: 
....................             debug_http("HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]); 
....................             http_state[hs]=HTTP_GET_POST_CONTINUE; 
0C11A:  BCF    FD8.0
0C11C:  MOVLB  3
0C11E:  RLCF   x5D,W
0C120:  CLRF   03
0C122:  ADDLW  21
0C124:  MOVWF  FE9
0C126:  MOVLW  01
0C128:  ADDWFC 03,W
0C12A:  MOVWF  FEA
0C12C:  MOVLW  01
0C12E:  MOVWF  FEC
0C130:  MOVF   FED,F
0C132:  MOVLW  05
0C134:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
0C136:  BCF    FD8.0
0C138:  RLCF   x5D,W
0C13A:  CLRF   03
0C13C:  ADDLW  78
0C13E:  MOVWF  01
0C140:  MOVLW  02
0C142:  ADDWFC 03,F
0C144:  MOVFF  01,35F
0C148:  MOVFF  03,360
0C14C:  MOVLB  0
0C14E:  CALL   8078
0C152:  MOVFF  360,FEA
0C156:  MOVFF  35F,FE9
0C15A:  MOVFF  02,FEC
0C15E:  MOVF   FED,F
0C160:  MOVFF  01,FEF
....................             i[hs]=0; 
0C164:  CLRF   03
0C166:  MOVLB  3
0C168:  MOVF   x5D,W
0C16A:  ADDLW  70
0C16C:  MOVWF  FE9
0C16E:  MOVLW  02
0C170:  ADDWFC 03,W
0C172:  MOVWF  FEA
0C174:  CLRF   FEF
0C176:  MOVLB  0
....................  
....................          case HTTP_GET_POST_CONTINUE: 
....................             while ( 
....................                      TCPIsGetReady(currSocket) && 
....................                      TCPGet(currSocket, &c) && 
....................                      (http_post_len[hs] != 0) 
....................                   ) 
0C178:  MOVFF  35E,35F
0C17C:  CALL   99E2
0C180:  MOVF   01,F
0C182:  BTFSC  FD8.2
0C184:  BRA    C332
0C186:  MOVFF  35E,35F
0C18A:  MOVLW  03
0C18C:  MOVLB  3
0C18E:  MOVWF  x61
0C190:  MOVLW  58
0C192:  MOVWF  x60
0C194:  MOVLB  0
0C196:  CALL   9A0E
0C19A:  MOVF   01,F
0C19C:  BTFSC  FD8.2
0C19E:  BRA    C332
0C1A0:  BCF    FD8.0
0C1A2:  MOVLB  3
0C1A4:  RLCF   x5D,W
0C1A6:  CLRF   03
0C1A8:  ADDLW  76
0C1AA:  MOVWF  FE9
0C1AC:  MOVLW  02
0C1AE:  ADDWFC 03,W
0C1B0:  MOVWF  FEA
0C1B2:  MOVFF  FEC,360
0C1B6:  MOVF   FED,F
0C1B8:  MOVFF  FEF,35F
0C1BC:  MOVF   x5F,F
0C1BE:  BNZ   C1CA
0C1C0:  MOVF   x60,F
0C1C2:  BTFSS  FD8.2
0C1C4:  BRA    C1CA
0C1C6:  MOVLB  0
0C1C8:  BRA    C332
....................             { 
....................                http_post_len[hs] -= 1; 
0C1CA:  BCF    FD8.0
0C1CC:  RLCF   x5D,W
0C1CE:  CLRF   03
0C1D0:  ADDLW  76
0C1D2:  MOVWF  FE9
0C1D4:  MOVLW  02
0C1D6:  ADDWFC 03,W
0C1D8:  MOVWF  FEA
0C1DA:  MOVLW  01
0C1DC:  SUBWF  FEF,W
0C1DE:  MOVWF  00
0C1E0:  MOVLW  00
0C1E2:  SUBWFB FEC,W
0C1E4:  MOVWF  03
0C1E6:  MOVF   00,W
0C1E8:  MOVF   FED,F
0C1EA:  MOVWF  FEF
0C1EC:  MOVFF  03,FEC
....................  
....................                if (c!='&') 
0C1F0:  MOVF   x58,W
0C1F2:  SUBLW  26
0C1F4:  BZ    C22C
....................                { 
....................                   buffer[hs][i[hs]++]=c; 
0C1F6:  MOVF   x5D,W
0C1F8:  MULLW  FE
0C1FA:  MOVF   FF3,W
0C1FC:  CLRF   x60
0C1FE:  MOVWF  x5F
0C200:  CLRF   03
0C202:  MOVF   x5D,W
0C204:  ADDLW  70
0C206:  MOVWF  FE9
0C208:  MOVLW  02
0C20A:  ADDWFC 03,W
0C20C:  MOVWF  FEA
0C20E:  MOVF   FEF,W
0C210:  INCF   FEF,F
0C212:  CLRF   03
0C214:  ADDWF  x5F,W
0C216:  MOVWF  01
0C218:  MOVF   x60,W
0C21A:  ADDWFC 03,F
0C21C:  MOVF   01,W
0C21E:  ADDLW  72
0C220:  MOVWF  FE9
0C222:  MOVLW  01
0C224:  ADDWFC 03,W
0C226:  MOVWF  FEA
0C228:  MOVFF  358,FEF
....................                } 
....................  
....................                if ( (c=='&') || (http_post_len[hs] == 0) ) 
0C22C:  MOVF   x58,W
0C22E:  SUBLW  26
0C230:  BZ    C254
0C232:  BCF    FD8.0
0C234:  RLCF   x5D,W
0C236:  CLRF   03
0C238:  ADDLW  76
0C23A:  MOVWF  FE9
0C23C:  MOVLW  02
0C23E:  ADDWFC 03,W
0C240:  MOVWF  FEA
0C242:  MOVFF  FEC,360
0C246:  MOVF   FED,F
0C248:  MOVFF  FEF,35F
0C24C:  MOVF   x5F,F
0C24E:  BNZ   C32E
0C250:  MOVF   x60,F
0C252:  BNZ   C32E
....................                { 
....................                   buffer[hs][i[hs]]=0; 
0C254:  MOVF   x5D,W
0C256:  MULLW  FE
0C258:  MOVF   FF3,W
0C25A:  CLRF   x60
0C25C:  MOVWF  x5F
0C25E:  CLRF   03
0C260:  MOVF   x5D,W
0C262:  ADDLW  70
0C264:  MOVWF  FE9
0C266:  MOVLW  02
0C268:  ADDWFC 03,W
0C26A:  MOVWF  FEA
0C26C:  CLRF   03
0C26E:  MOVF   FEF,W
0C270:  ADDWF  x5F,W
0C272:  MOVWF  01
0C274:  MOVF   x60,W
0C276:  ADDWFC 03,F
0C278:  MOVF   01,W
0C27A:  ADDLW  72
0C27C:  MOVWF  FE9
0C27E:  MOVLW  01
0C280:  ADDWFC 03,W
0C282:  MOVWF  FEA
0C284:  CLRF   FEF
....................  
....................                   debug_http("%lu - %s\r\n", http_post_len[hs], &buffer[hs][0]); 
....................  
....................                   http_parse_cgi_string(http_page_req[hs], &buffer[hs][0]); 
0C286:  MOVF   x5D,W
0C288:  MULLW  04
0C28A:  MOVF   FF3,W
0C28C:  CLRF   03
0C28E:  ADDLW  72
0C290:  MOVWF  FE9
0C292:  MOVLW  02
0C294:  ADDWFC 03,W
0C296:  MOVWF  FEA
0C298:  MOVFF  FEF,367
0C29C:  MOVFF  FEC,368
0C2A0:  MOVFF  FEC,369
0C2A4:  MOVFF  FEC,36A
0C2A8:  MOVF   x5D,W
0C2AA:  MULLW  FE
0C2AC:  MOVF   FF3,W
0C2AE:  CLRF   x64
0C2B0:  MOVWF  x63
0C2B2:  MOVLW  72
0C2B4:  ADDWF  x63,W
0C2B6:  MOVWF  01
0C2B8:  MOVLW  01
0C2BA:  ADDWFC x64,W
0C2BC:  MOVWF  03
0C2BE:  MOVFF  01,365
0C2C2:  MOVWF  x66
0C2C4:  MOVWF  x6C
0C2C6:  MOVFF  01,36B
0C2CA:  MOVLB  0
0C2CC:  CALL   A67C
....................                   if (http_post_len[hs] == 0) 
0C2D0:  BCF    FD8.0
0C2D2:  MOVLB  3
0C2D4:  RLCF   x5D,W
0C2D6:  CLRF   03
0C2D8:  ADDLW  76
0C2DA:  MOVWF  FE9
0C2DC:  MOVLW  02
0C2DE:  ADDWFC 03,W
0C2E0:  MOVWF  FEA
0C2E2:  MOVFF  FEC,360
0C2E6:  MOVF   FED,F
0C2E8:  MOVFF  FEF,35F
0C2EC:  MOVF   x5F,F
0C2EE:  BNZ   C31E
0C2F0:  MOVF   x60,F
0C2F2:  BNZ   C31E
....................                   { 
....................                      http_state[hs]=HTTP_SEND_RESPONSE; 
0C2F4:  BCF    FD8.0
0C2F6:  RLCF   x5D,W
0C2F8:  CLRF   03
0C2FA:  ADDLW  21
0C2FC:  MOVWF  FE9
0C2FE:  MOVLW  01
0C300:  ADDWFC 03,W
0C302:  MOVWF  FEA
0C304:  MOVLW  01
0C306:  MOVWF  FEC
0C308:  MOVF   FED,F
0C30A:  MOVLW  06
0C30C:  MOVWF  FEF
....................                      TCPDiscard(currSocket); 
0C30E:  MOVFF  35E,362
0C312:  MOVLB  0
0C314:  CALL   A90C
....................                      break; 
0C318:  BRA    C332
....................                   } 
0C31A:  BRA    C330
0C31C:  MOVLB  3
....................                   else 
....................                      i[hs]=0; 
0C31E:  CLRF   03
0C320:  MOVF   x5D,W
0C322:  ADDLW  70
0C324:  MOVWF  FE9
0C326:  MOVLW  02
0C328:  ADDWFC 03,W
0C32A:  MOVWF  FEA
0C32C:  CLRF   FEF
0C32E:  MOVLB  0
....................                } 
0C330:  BRA    C178
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[hs]) > TICKS_PER_SECOND*20) 
0C332:  CALL   8078
0C336:  MOVFF  02,360
0C33A:  MOVFF  01,35F
0C33E:  BCF    FD8.0
0C340:  MOVLB  3
0C342:  RLCF   x5D,W
0C344:  CLRF   03
0C346:  ADDLW  78
0C348:  MOVWF  FE9
0C34A:  MOVLW  02
0C34C:  ADDWFC 03,W
0C34E:  MOVWF  FEA
0C350:  MOVFF  FEC,03
0C354:  MOVF   FED,F
0C356:  MOVFF  FEF,01
0C35A:  MOVF   02,W
0C35C:  SUBWF  03,W
0C35E:  BNC   C368
0C360:  BNZ   C36C
0C362:  MOVF   01,W
0C364:  SUBWF  x5F,W
0C366:  BNC   C36C
0C368:  MOVLW  00
0C36A:  BRA    C36E
0C36C:  MOVLW  01
0C36E:  CLRF   03
0C370:  IORWF  03,W
0C372:  BZ    C3B6
0C374:  BCF    FD8.0
0C376:  RLCF   x5D,W
0C378:  CLRF   03
0C37A:  ADDLW  78
0C37C:  MOVWF  FE9
0C37E:  MOVLW  02
0C380:  ADDWFC 03,W
0C382:  MOVWF  FEA
0C384:  MOVFF  FEC,03
0C388:  MOVF   FED,F
0C38A:  MOVF   FEF,W
0C38C:  SUBLW  FF
0C38E:  MOVWF  x5F
0C390:  MOVLW  FF
0C392:  SUBFWB 03,W
0C394:  MOVWF  x60
0C396:  MOVLB  0
0C398:  CALL   8078
0C39C:  MOVF   01,W
0C39E:  MOVLB  3
0C3A0:  ADDWF  x5F,F
0C3A2:  MOVF   02,W
0C3A4:  ADDWFC x60,F
0C3A6:  MOVLW  01
0C3A8:  ADDWF  x5F,W
0C3AA:  MOVWF  01
0C3AC:  MOVLW  00
0C3AE:  ADDWFC x60,W
0C3B0:  MOVWF  03
0C3B2:  MOVF   01,W
0C3B4:  BRA    C3EA
0C3B6:  MOVLB  0
0C3B8:  CALL   8078
0C3BC:  MOVFF  02,360
0C3C0:  MOVFF  01,35F
0C3C4:  BCF    FD8.0
0C3C6:  MOVLB  3
0C3C8:  RLCF   x5D,W
0C3CA:  CLRF   03
0C3CC:  ADDLW  78
0C3CE:  MOVWF  FE9
0C3D0:  MOVLW  02
0C3D2:  ADDWFC 03,W
0C3D4:  MOVWF  FEA
0C3D6:  MOVFF  FEC,03
0C3DA:  MOVF   FED,F
0C3DC:  MOVF   FEF,W
0C3DE:  SUBWF  01,W
0C3E0:  MOVWF  00
0C3E2:  MOVF   03,W
0C3E4:  SUBWFB 02,W
0C3E6:  MOVWF  03
0C3E8:  MOVF   00,W
0C3EA:  SUBLW  C8
0C3EC:  BC    C422
....................             { 
....................                debug_http("HTTP %U GET POST TIMEOUT\r\n", hs); 
....................                http_page_req[hs]=0xFFFFFFFF; 
0C3EE:  MOVF   x5D,W
0C3F0:  MULLW  04
0C3F2:  MOVF   FF3,W
0C3F4:  CLRF   03
0C3F6:  ADDLW  72
0C3F8:  MOVWF  FE9
0C3FA:  MOVLW  02
0C3FC:  ADDWFC 03,W
0C3FE:  MOVWF  FEA
0C400:  SETF   FEF
0C402:  SETF   FEC
0C404:  SETF   FEC
0C406:  SETF   FEC
....................                http_state[hs]=HTTP_SEND_RESPONSE; 
0C408:  BCF    FD8.0
0C40A:  RLCF   x5D,W
0C40C:  CLRF   03
0C40E:  ADDLW  21
0C410:  MOVWF  FE9
0C412:  MOVLW  01
0C414:  ADDWFC 03,W
0C416:  MOVWF  FEA
0C418:  MOVLW  01
0C41A:  MOVWF  FEC
0C41C:  MOVF   FED,F
0C41E:  MOVLW  06
0C420:  MOVWF  FEF
....................             } 
....................             break; 
0C422:  MOVLB  0
0C424:  BRA    C6EC
....................  
....................          case HTTP_SEND_RESPONSE: 
....................             debug_http("HTTP %U SEND RESPONSE\r\n", hs); 
....................             lastHTTPPutConstPos[hs]=0; 
0C426:  MOVLB  3
0C428:  MOVF   x5D,W
0C42A:  MULLW  04
0C42C:  MOVF   FF3,W
0C42E:  CLRF   03
0C430:  ADDLW  24
0C432:  MOVWF  FE9
0C434:  MOVLW  01
0C436:  ADDWFC 03,W
0C438:  MOVWF  FEA
0C43A:  MOVF   FEE,F
0C43C:  MOVF   FEE,F
0C43E:  CLRF   FEC
0C440:  MOVF   FED,F
0C442:  CLRF   FEF
0C444:  MOVF   FED,F
0C446:  CLRF   FEF
0C448:  MOVF   FED,F
0C44A:  CLRF   FEF
....................             http_state[hs]=HTTP_SEND_RESPONSE_CONTINUE; 
0C44C:  BCF    FD8.0
0C44E:  RLCF   x5D,W
0C450:  CLRF   03
0C452:  ADDLW  21
0C454:  MOVWF  FE9
0C456:  MOVLW  01
0C458:  ADDWFC 03,W
0C45A:  MOVWF  FEA
0C45C:  MOVLW  01
0C45E:  MOVWF  FEC
0C460:  MOVF   FED,F
0C462:  MOVLW  07
0C464:  MOVWF  FEF
0C466:  MOVLB  0
....................  
....................          case HTTP_SEND_RESPONSE_CONTINUE: 
....................             TCPDiscard(currSocket); 
0C468:  MOVFF  35E,362
0C46C:  CALL   A90C
....................             if (TCPIsPutReady(currSocket)) 
0C470:  MOVFF  35E,382
0C474:  CALL   A95A
0C478:  MOVF   01,F
0C47A:  BTFSC  FD8.2
0C47C:  BRA    C5A2
....................             { 
....................                debug_http("\r\nPUTTING HTTP SEG\r\n"); 
....................                if (http_page_req[hs]==0xFFFFFFFF) 
0C47E:  MOVLB  3
0C480:  MOVF   x5D,W
0C482:  MULLW  04
0C484:  MOVF   FF3,W
0C486:  CLRF   03
0C488:  ADDLW  72
0C48A:  MOVWF  FE9
0C48C:  MOVLW  02
0C48E:  ADDWFC 03,W
0C490:  MOVWF  FEA
0C492:  MOVFF  FEF,35F
0C496:  MOVFF  FEC,360
0C49A:  MOVFF  FEC,361
0C49E:  MOVFF  FEC,362
0C4A2:  INCFSZ x5F,W
0C4A4:  BRA    C4EA
0C4A6:  INCFSZ x60,W
0C4A8:  BRA    C4EA
0C4AA:  INCFSZ x61,W
0C4AC:  BRA    C4EA
0C4AE:  INCFSZ x62,W
0C4B0:  BRA    C4EA
....................                   doneSend=tcp_http_put_file(hs, 500, label_address(http_500_error), 0); 
0C4B2:  MOVLW  01
0C4B4:  MOVWF  03
0C4B6:  MOVLW  50
0C4B8:  MOVWF  x5F
0C4BA:  MOVFF  03,360
0C4BE:  MOVFF  35D,363
0C4C2:  MOVLW  01
0C4C4:  MOVWF  x65
0C4C6:  MOVLW  F4
0C4C8:  MOVWF  x64
0C4CA:  CLRF   x69
0C4CC:  CLRF   x68
0C4CE:  MOVFF  03,367
0C4D2:  MOVFF  35F,366
0C4D6:  CLRF   x6B
0C4D8:  CLRF   x6A
0C4DA:  MOVLB  0
0C4DC:  CALL   B644
0C4E0:  MOVLB  3
0C4E2:  BCF    x57.0
0C4E4:  BTFSC  01.0
0C4E6:  BSF    x57.0
0C4E8:  BRA    C582
....................                else if (http_page_req[hs]) 
....................                 #if HTTP_USE_CONTENT_TYPE 
0C4EA:  MOVF   x5D,W
0C4EC:  MULLW  04
0C4EE:  MOVF   FF3,W
0C4F0:  CLRF   03
0C4F2:  ADDLW  72
0C4F4:  MOVWF  FE9
0C4F6:  MOVLW  02
0C4F8:  ADDWFC 03,W
0C4FA:  MOVWF  FEA
0C4FC:  MOVF   FEF,F
0C4FE:  BNZ   C50C
0C500:  MOVF   FEC,F
0C502:  BNZ   C50C
0C504:  MOVF   FEC,F
0C506:  BNZ   C50C
0C508:  MOVF   FEC,F
0C50A:  BZ    C54C
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], &contentType[hs][0]); 
....................                 #else 
....................                   doneSend=tcp_http_put_file(hs, 200, http_page_req[hs], 0); 
0C50C:  MOVF   x5D,W
0C50E:  MULLW  04
0C510:  MOVF   FF3,W
0C512:  CLRF   03
0C514:  ADDLW  72
0C516:  MOVWF  FE9
0C518:  MOVLW  02
0C51A:  ADDWFC 03,W
0C51C:  MOVWF  FEA
0C51E:  MOVFF  FEF,366
0C522:  MOVFF  FEC,367
0C526:  MOVFF  FEC,368
0C52A:  MOVFF  FEC,369
0C52E:  MOVFF  35D,363
0C532:  CLRF   x65
0C534:  MOVLW  C8
0C536:  MOVWF  x64
0C538:  CLRF   x6B
0C53A:  CLRF   x6A
0C53C:  MOVLB  0
0C53E:  CALL   B644
0C542:  MOVLB  3
0C544:  BCF    x57.0
0C546:  BTFSC  01.0
0C548:  BSF    x57.0
....................                 #endif 
0C54A:  BRA    C582
....................                else 
....................                   doneSend=tcp_http_put_file(hs, 404, label_address(http_404_error), 0); 
0C54C:  MOVLW  00
0C54E:  MOVWF  03
0C550:  MOVLW  CE
0C552:  MOVWF  x5F
0C554:  MOVFF  03,360
0C558:  MOVFF  35D,363
0C55C:  MOVLW  01
0C55E:  MOVWF  x65
0C560:  MOVLW  94
0C562:  MOVWF  x64
0C564:  CLRF   x69
0C566:  CLRF   x68
0C568:  MOVFF  03,367
0C56C:  MOVFF  35F,366
0C570:  CLRF   x6B
0C572:  CLRF   x6A
0C574:  MOVLB  0
0C576:  CALL   B644
0C57A:  MOVLB  3
0C57C:  BCF    x57.0
0C57E:  BTFSC  01.0
0C580:  BSF    x57.0
....................  
....................                if (doneSend) 
0C582:  BTFSS  x57.0
0C584:  BRA    C5A0
....................                { 
....................                   //if (http_isKeepAlive[hs]) 
....................                   //   http_state[hs]=HTTP_CONNECTED; 
....................                   //else 
....................                   //   http_state[hs]=HTTP_CLOSE; 
....................                   http_state[hs] = HTTP_CLOSE; 
0C586:  BCF    FD8.0
0C588:  RLCF   x5D,W
0C58A:  CLRF   03
0C58C:  ADDLW  21
0C58E:  MOVWF  FE9
0C590:  MOVLW  01
0C592:  ADDWFC 03,W
0C594:  MOVWF  FEA
0C596:  MOVLW  01
0C598:  MOVWF  FEC
0C59A:  MOVF   FED,F
0C59C:  MOVLW  08
0C59E:  MOVWF  FEF
0C5A0:  MOVLB  0
....................                   debug_http("HTTP %U RESPONSE SENT\r\n", hs); 
....................                } 
....................             } 
....................             /*else 
....................             { 
....................                debug_http("\r\nNR => RW=%LX B=%X IS=%U\r\n", 
....................                      TCB[currSocket].RemoteWindow, 
....................                      TCB[currSocket].TxBuffer, 
....................                      TCB[currSocket].Flags.bIsPutReady 
....................                   ); 
....................                delay_ms(100); 
....................             }*/ 
....................             break; 
0C5A2:  BRA    C6EC
....................  
....................          case HTTP_CLOSE: 
....................             //since we set connection: close in the header, the client 
....................             //should automatically close.  but after so many seconds we 
....................             //shall kill the connection 
....................             http_state[hs]=HTTP_CLOSE_WAITING; 
0C5A4:  BCF    FD8.0
0C5A6:  MOVLB  3
0C5A8:  RLCF   x5D,W
0C5AA:  CLRF   03
0C5AC:  ADDLW  21
0C5AE:  MOVWF  FE9
0C5B0:  MOVLW  01
0C5B2:  ADDWFC 03,W
0C5B4:  MOVWF  FEA
0C5B6:  MOVLW  01
0C5B8:  MOVWF  FEC
0C5BA:  MOVF   FED,F
0C5BC:  MOVLW  09
0C5BE:  MOVWF  FEF
....................             http_timer[hs]=TickGet(); 
0C5C0:  BCF    FD8.0
0C5C2:  RLCF   x5D,W
0C5C4:  CLRF   03
0C5C6:  ADDLW  78
0C5C8:  MOVWF  01
0C5CA:  MOVLW  02
0C5CC:  ADDWFC 03,F
0C5CE:  MOVFF  01,35F
0C5D2:  MOVFF  03,360
0C5D6:  MOVLB  0
0C5D8:  CALL   8078
0C5DC:  MOVFF  360,FEA
0C5E0:  MOVFF  35F,FE9
0C5E4:  MOVFF  02,FEC
0C5E8:  MOVF   FED,F
0C5EA:  MOVFF  01,FEF
....................  
....................          case HTTP_CLOSE_WAITING: 
....................             TCPDiscard(currSocket); 
0C5EE:  MOVFF  35E,362
0C5F2:  CALL   A90C
....................             if (  TCPIsPutReady(currSocket) || 
....................                   (TickGetDiff(TickGet(),http_timer[hs]) > (TICKS_PER_SECOND*5)) 
0C5F6:  MOVFF  35E,382
0C5FA:  CALL   A95A
0C5FE:  MOVF   01,F
0C600:  BNZ   C6C0
0C602:  CALL   8078
0C606:  MOVFF  02,360
0C60A:  MOVFF  01,35F
0C60E:  BCF    FD8.0
0C610:  MOVLB  3
0C612:  RLCF   x5D,W
0C614:  CLRF   03
0C616:  ADDLW  78
0C618:  MOVWF  FE9
0C61A:  MOVLW  02
0C61C:  ADDWFC 03,W
0C61E:  MOVWF  FEA
0C620:  MOVFF  FEC,03
0C624:  MOVF   FED,F
0C626:  MOVFF  FEF,01
0C62A:  MOVF   02,W
0C62C:  SUBWF  03,W
0C62E:  BNC   C638
0C630:  BNZ   C63C
0C632:  MOVF   01,W
0C634:  SUBWF  x5F,W
0C636:  BNC   C63C
0C638:  MOVLW  00
0C63A:  BRA    C63E
0C63C:  MOVLW  01
0C63E:  CLRF   03
0C640:  IORWF  03,W
0C642:  BZ    C686
0C644:  BCF    FD8.0
0C646:  RLCF   x5D,W
0C648:  CLRF   03
0C64A:  ADDLW  78
0C64C:  MOVWF  FE9
0C64E:  MOVLW  02
0C650:  ADDWFC 03,W
0C652:  MOVWF  FEA
0C654:  MOVFF  FEC,03
0C658:  MOVF   FED,F
0C65A:  MOVF   FEF,W
0C65C:  SUBLW  FF
0C65E:  MOVWF  x5F
0C660:  MOVLW  FF
0C662:  SUBFWB 03,W
0C664:  MOVWF  x60
0C666:  MOVLB  0
0C668:  CALL   8078
0C66C:  MOVF   01,W
0C66E:  MOVLB  3
0C670:  ADDWF  x5F,F
0C672:  MOVF   02,W
0C674:  ADDWFC x60,F
0C676:  MOVLW  01
0C678:  ADDWF  x5F,W
0C67A:  MOVWF  01
0C67C:  MOVLW  00
0C67E:  ADDWFC x60,W
0C680:  MOVWF  03
0C682:  MOVF   01,W
0C684:  BRA    C6BA
0C686:  MOVLB  0
0C688:  CALL   8078
0C68C:  MOVFF  02,360
0C690:  MOVFF  01,35F
0C694:  BCF    FD8.0
0C696:  MOVLB  3
0C698:  RLCF   x5D,W
0C69A:  CLRF   03
0C69C:  ADDLW  78
0C69E:  MOVWF  FE9
0C6A0:  MOVLW  02
0C6A2:  ADDWFC 03,W
0C6A4:  MOVWF  FEA
0C6A6:  MOVFF  FEC,03
0C6AA:  MOVF   FED,F
0C6AC:  MOVF   FEF,W
0C6AE:  SUBWF  01,W
0C6B0:  MOVWF  00
0C6B2:  MOVF   03,W
0C6B4:  SUBWFB 02,W
0C6B6:  MOVWF  03
0C6B8:  MOVF   00,W
0C6BA:  SUBLW  32
0C6BC:  BC    C6E4
0C6BE:  MOVLB  0
....................                ) 
....................             { 
....................                debug_http("HTTP %U FORCE CLOSED\r\n", hs); 
....................                TCPDisconnect(currSocket); 
0C6C0:  MOVFF  35E,35F
0C6C4:  GOTO   B9B2
....................                http_state[hs]=HTTP_CLOSED; 
0C6C8:  BCF    FD8.0
0C6CA:  MOVLB  3
0C6CC:  RLCF   x5D,W
0C6CE:  CLRF   03
0C6D0:  ADDLW  21
0C6D2:  MOVWF  FE9
0C6D4:  MOVLW  01
0C6D6:  ADDWFC 03,W
0C6D8:  MOVWF  FEA
0C6DA:  MOVLW  01
0C6DC:  MOVWF  FEC
0C6DE:  MOVF   FED,F
0C6E0:  MOVLW  0A
0C6E2:  MOVWF  FEF
....................             } 
....................             break; 
0C6E4:  MOVLB  0
0C6E6:  BRA    C6EC
0C6E8:  MOVLB  3
....................  
....................          case HTTP_CLOSED: //do nothing until socket actually closes 
....................          default: 
....................             break; 
0C6EA:  MOVLB  0
....................       } 
0C6EC:  MOVLB  3
0C6EE:  INCF   x5D,F
0C6F0:  GOTO   BAC4
....................    } 
0C6F4:  MOVLB  0
0C6F6:  GOTO   C8C8 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
06CB2:  MOVLB  2
06CB4:  CLRF   x7A
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
06CB6:  MOVLB  0
06CB8:  GOTO   63EC
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
06CBC:  BRA    66FA
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
06CBE:  BRA    68C8
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
06CC0:  BRA    6A12
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Init(); 
06CC2:  BRA    6C48
.................... #endif 
06CC4:  GOTO   CAAE (RETURN)
.................... } 
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
*
0C6FA:  MOVLB  3
0C6FC:  BCF    x56.0
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
0C6FE:  BCF    x56.0
....................         switch(smStack) 
0C700:  MOVLB  2
0C702:  MOVF   x7A,W
0C704:  ADDLW  F9
0C706:  BTFSC  FD8.0
0C708:  BRA    C8B8
0C70A:  ADDLW  07
0C70C:  MOVLB  0
0C70E:  GOTO   C8CC
....................         { 
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
0C712:  MOVLW  02
0C714:  MOVLB  3
0C716:  MOVWF  x58
0C718:  MOVLW  7B
0C71A:  MOVWF  x57
0C71C:  MOVLW  03
0C71E:  MOVWF  x5A
0C720:  MOVLW  55
0C722:  MOVWF  x59
0C724:  MOVLB  0
0C726:  GOTO   6DB4
0C72A:  MOVF   01,F
0C72C:  BNZ   C734
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
0C72E:  MOVLB  2
0C730:  BRA    C8B8
0C732:  MOVLB  0
....................             } 
....................  
.................... //            debug_stack("\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
0C734:  MOVLB  3
0C736:  BSF    x56.0
....................             if ( type.MACFrameType == MAC_IP ) { 
0C738:  MOVF   x55,F
0C73A:  BNZ   C746
....................                 smStack = SM_STACK_IP; 
0C73C:  MOVLW  02
0C73E:  MOVLB  2
0C740:  MOVWF  x7A
.................... //                debug_stack("IP "); 
....................             } 
0C742:  BRA    C75E
0C744:  MOVLB  3
....................             else if ( type.MACFrameType == MAC_ARP ) { 
0C746:  MOVF   x55,W
0C748:  SUBLW  06
0C74A:  BNZ   C756
....................                 smStack = SM_STACK_ARP; 
0C74C:  MOVLW  05
0C74E:  MOVLB  2
0C750:  MOVWF  x7A
.................... //                debug_stack("ARP "); 
....................             } 
0C752:  BRA    C75E
0C754:  MOVLB  3
....................             else { 
....................                 MACDiscardRx(); 
0C756:  MOVLB  0
0C758:  CALL   6CC8
0C75C:  MOVLB  2
.................... //                debug_stack("DISCARD"); 
....................             } 
....................             break; 
0C75E:  BRA    C8B8
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
0C760:  GOTO   7646
0C764:  MOVF   01,F
0C766:  BZ    C76E
....................                 smStack = SM_STACK_IDLE; 
0C768:  MOVLB  2
0C76A:  CLRF   x7A
0C76C:  MOVLB  0
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
0C76E:  MOVLB  2
0C770:  BRA    C8B8
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
0C772:  MOVLW  03
0C774:  MOVLB  3
0C776:  MOVWF  x58
0C778:  MOVLW  51
0C77A:  MOVWF  x57
0C77C:  MOVLW  02
0C77E:  MOVWF  x5A
0C780:  MOVLW  7B
0C782:  MOVWF  x59
0C784:  MOVLW  03
0C786:  MOVWF  x5C
0C788:  MOVLW  55
0C78A:  MOVWF  x5B
0C78C:  MOVLW  02
0C78E:  MOVWF  x5E
0C790:  MOVLW  85
0C792:  MOVWF  x5D
0C794:  MOVLB  0
0C796:  GOTO   7928
0C79A:  MOVF   01,F
0C79C:  BZ    C7D0
....................             { 
....................                 lbContinue = TRUE; 
0C79E:  MOVLB  3
0C7A0:  BSF    x56.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
0C7A2:  DECFSZ x55,W
0C7A4:  BRA    C7B0
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
0C7A6:  MOVLW  03
0C7A8:  MOVLB  2
0C7AA:  MOVWF  x7A
.................... //                    debug_stack("ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
0C7AC:  BRA    C7CC
0C7AE:  MOVLB  3
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
0C7B0:  MOVF   x55,W
0C7B2:  SUBLW  06
0C7B4:  BNZ   C7C0
....................                     smStack = SM_STACK_TCP; 
0C7B6:  MOVLW  06
0C7B8:  MOVLB  2
0C7BA:  MOVWF  x7A
....................                     debug_stack("TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
0C7BC:  BRA    C7CC
0C7BE:  MOVLB  3
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
.................... //                    debug_stack("UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
....................                 { 
....................                     lbContinue = FALSE; 
0C7C0:  BCF    x56.0
....................                     MACDiscardRx(); 
0C7C2:  MOVLB  0
0C7C4:  CALL   6CC8
....................  
....................                     smStack = SM_STACK_IDLE; 
0C7C8:  MOVLB  2
0C7CA:  CLRF   x7A
.................... //                    debug_stack("UNKOWN-IP1 "); 
....................                 } 
....................             } 
0C7CC:  BRA    C7D8
0C7CE:  MOVLB  0
....................             else 
....................             { 
....................                 MACDiscardRx(); 
0C7D0:  CALL   6CC8
....................                 smStack = SM_STACK_IDLE; 
0C7D4:  MOVLB  2
0C7D6:  CLRF   x7A
.................... //                debug_stack("UNKOWN-IP2 "); 
....................             } 
....................             break; 
0C7D8:  BRA    C8B8
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
.................... //                debug_stack("\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
0C7DA:  MOVLW  02
0C7DC:  MOVLB  3
0C7DE:  MOVWF  x58
0C7E0:  MOVLW  7B
0C7E2:  MOVWF  x57
0C7E4:  MOVLW  03
0C7E6:  MOVWF  x5A
0C7E8:  MOVLW  51
0C7EA:  MOVWF  x59
0C7EC:  MOVFF  286,35C
0C7F0:  MOVFF  285,35B
0C7F4:  MOVLB  0
0C7F6:  GOTO   9104
0C7FA:  MOVF   01,F
0C7FC:  BZ    C804
....................             { 
....................                 debug_stack("\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
0C7FE:  MOVLB  2
0C800:  CLRF   x7A
0C802:  MOVLB  0
....................             } 
....................             break; 
0C804:  MOVLB  2
0C806:  BRA    C8B8
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
0C808:  MOVLB  2
0C80A:  CLRF   x7A
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
0C80C:  MOVF   x86,F
0C80E:  BNZ   C862
0C810:  MOVF   x85,W
0C812:  SUBLW  48
0C814:  BNC   C862
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
0C816:  MOVLW  02
0C818:  MOVLB  3
0C81A:  MOVWF  x58
0C81C:  MOVLW  85
0C81E:  MOVWF  x57
0C820:  MOVLW  03
0C822:  MOVWF  x5A
0C824:  MOVLW  55
0C826:  MOVWF  x59
0C828:  MOVLW  02
0C82A:  MOVWF  x5C
0C82C:  MOVLW  87
0C82E:  MOVWF  x5B
0C830:  MOVFF  358,35E
0C834:  MOVFF  357,35D
0C838:  MOVLW  02
0C83A:  MOVWF  x60
0C83C:  MOVLW  C7
0C83E:  MOVWF  x5F
0C840:  MOVLW  02
0C842:  MOVWF  x62
0C844:  MOVLW  C9
0C846:  MOVWF  x61
0C848:  MOVLB  0
0C84A:  GOTO   935A
0C84E:  MOVF   01,F
0C850:  BZ    C866
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
0C852:  MOVLB  3
0C854:  MOVF   x55,W
0C856:  SUBLW  08
0C858:  BNZ   C864
....................                     { 
.................... //                        debug_stack("\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
0C85A:  BSF    x56.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
0C85C:  MOVLW  04
0C85E:  MOVLB  2
0C860:  MOVWF  x7A
0C862:  MOVLB  3
0C864:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
0C866:  CALL   6CC8
....................             break; 
0C86A:  MOVLB  2
0C86C:  BRA    C8B8
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
0C86E:  MOVLW  01
0C870:  MOVLB  3
0C872:  MOVWF  xE0
0C874:  MOVLB  0
0C876:  CALL   8190
0C87A:  MOVF   01,F
0C87C:  BZ    C8B2
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
0C87E:  MOVLW  02
0C880:  MOVLB  3
0C882:  MOVWF  x58
0C884:  MOVLW  7B
0C886:  MOVWF  x57
0C888:  CLRF   x59
0C88A:  MOVLW  02
0C88C:  MOVWF  x5B
0C88E:  MOVLW  87
0C890:  MOVWF  x5A
0C892:  MOVFF  285,35C
0C896:  MOVFF  2C8,35E
0C89A:  MOVFF  2C7,35D
0C89E:  MOVFF  2CA,360
0C8A2:  MOVFF  2C9,35F
0C8A6:  MOVLB  0
0C8A8:  GOTO   942C
....................  
.................... //                debug_stack("\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
0C8AC:  MOVLB  2
0C8AE:  CLRF   x7A
0C8B0:  MOVLB  0
....................             } 
....................             break; 
0C8B2:  MOVLB  2
0C8B4:  BRA    C8B8
0C8B6:  MOVLB  2
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
0C8B8:  MOVLB  3
0C8BA:  BTFSC  x56.0
0C8BC:  BRA    C6FE
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
0C8BE:  MOVLB  0
0C8C0:  GOTO   9548
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
0C8C4:  GOTO   BAC0
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
0C8C8:  GOTO   CABC (RETURN)
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
....................  
....................  
.................... } 
....................  
....................  
.................... /*********************  PAGINA WEB A MOSTRAR **********************************/ 
.................... /* Página principal INDEX (/) */                                                        
.................... const char  HTML_INDEX_PAGE[]=" 
.................... <!DOCTYPE html> 
.................... <html lang=\"es\"> 
.................... <meta charset=\"UTF-8\"> 
.................... <meta name=\"MobileOptimized\" content=\"width\" /> 
.................... <meta name=\"HandheldFriendly\" content=\"true\" /> 
.................... <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> 
.................... <title>Embedded Server Altec</title>  
.................... <div style=\"text-align: center;\"> 
.................... <div style=\"box-sizing: border-box; display: inline-block; width: auto; max-width: 480px; background-color: #FFFFFF; border: 2px solid #0361A8; border-radius: 5px; box-shadow: 0px 0px 8px #0361A8; margin: 50px auto auto;\"> 
.................... <div style=\"background: #0361A8; border-radius: 5px 5px 0px 0px; padding: 15px;\"><span style=\"font-family: verdana,arial; color: #D4D4D4; font-size: 1.00em; font-weight:bold;\">Embed Server Altec</span></div>          
.................... <div style=\"background: ; padding: 15px\" id=\"ap_style\">                                                                                                                                                                                       
.................... <style type=\"text/css\" scoped>                           
.................... #ap_style td { text-align:left; font-family: verdana,arial; color: #064073; font-size: 1.00em; } 
.................... #ap_style input { border: 1px solid #CCCCCC; border-radius: 5px; color: #666666; display: inline-block; font-size: 1.00em;  padding: 5px; } 
.................... #ap_style input[type=\"text\"], input[type=\"password\"] { width: 100%; }                                                                                                                        
.................... #ap_style input[type=\"button\"], 
.................... #ap_style input[type=\"reset\"], 
.................... #ap_style input[type=\"submit\"] { height: auto; width: auto; cursor: pointer; box-shadow: 0px 0px 5px #0361A8; float: right; text-align:right; margin-top: 10px; margin-left:7px;} 
.................... #ap_style table.center { margin-left:auto; margin-right:auto; } 
.................... #ap_style .error { font-family: verdana,arial; color: #D41313; font-size: 1.00em; } 
.................... </style> 
.................... <p><img src=\"data:image/gif;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QAuRXhpZgAATU0AKgAAAAgAAlEAAAQAAAABAAAAAFEBAAMA 
.................... AAABAAEAAAAAAAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgK 
.................... CAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwM 
.................... DAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCAB5ARsDASIAAhEBAxEB/8QA 
.................... HwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQR 
.................... BRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdI 
.................... SUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2 
.................... t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEB 
.................... AQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMi 
.................... MoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpj 
.................... ZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbH 
.................... yMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKACiiigAoooo 
.................... AKKA2aN1ABRRmjNABRRmgHNABRQTRmgAooooAKKTdS55oAKKKKACignFGaACik3ilBzQAUUZozQA 
.................... UUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFBOKaJAaAAkUL1rj/jn8bvDf7Ofwr1rxn4u1KH 
.................... S/D+hwGe5nc/Meyoi9Xd2KqqjlmYAV8+f8EpP+Cik3/BQ/wj8RNYvLGDSH0DxIbfT7CMlpLfTZII 
.................... zbmVs/NKzpOWIwM8DgVtHD1HSdZL3U7XMXWgqnsnuz61ByKQsBQOK+Gf+CzP/BULxX/wTri8A2/g 
.................... 3SfDGr6j4sa+kul1iGeZYIoPIClRFLGcs0rdSfudKMPh516ipU9x1q0aUHOex9y53HvShsd6/DP/ 
.................... AIibvjj/ANCf8K//AAAv8/8ApXX6o/8ABNb9pHxZ+13+x34X+InjLT9F0vVvEj3TrbaXFLFbpDHc 
.................... ywodsju2WEe7O4ggjpXZjMpxOFip1kknpuc2HzClXly0z3r15oC5r4X/AOCy/wDwVG8W/wDBOceA 
.................... LXwfpPhnWNQ8VfbprtdYgnkWCKDyAmwRSxkFmlbOSfudq+Hf+Im745D/AJk/4Vf+AF//APJlaYXJ 
.................... cXXpqrTWj8ya+aUKU+Sb1P3Mor8M/wDiJw+OP/QnfCr/AMAL/wD+TKP+InD45f8AQnfCr/wAv/8A 
.................... 5Mrb/VvHfyr70Y/21he/4H7lH5fzoJz3r85/+CQH/BWj4pf8FDfj34i8P+KvDvgnS9A0HQm1B7jS 
.................... LW6juDcGeKOJCZZ5F2lWlPTPyD3rwv8Aas/4OJvip8IP2l/HvhLwz4X+Hd5oPhfXbzR7Se+tLyS4 
.................... nW3maIu7JcqpyUJGFHBHWueOS4mVZ0UveSu9e5tLMqKpqrfRn7HDpRX4Z/8AETf8cv8AoTvhV/4A 
.................... X/8A8mUf8ROHxy/6E74Vf+AF/wD/ACZXR/q3jv5V96M/7Yw3d/cfuUD81KGya/DM/wDBzZ8cN3/I 
.................... nfCvn/pwv/8A5Mr9sPhrquqaz8OtAvNdht7XW7rTreXUIoFZYYrholMioGLEKHLAAsTjGSetcOMy 
.................... 2thUnWVr+dzpw2Np121T6G3370E4rP8AFPi3SvAnh681fWtSsdI0nT4jNdXl7cLb29sg6s7uQqj3 
.................... Jr8+f2q/+Djv4VfCG9uNM+Huk6h8TNThJU3SSHT9LU9OJXRpJMH+7HtI6OQc1jhsDWxEuWlG5dfF 
.................... UqKvUdj9FvMx/SgkYr8D/in/AMHGX7QXji4l/sH/AIRDwXbnIjFjpQuplH+01y0qsfcIo9q9W/4J 
.................... H/8ABTj9oz9rf9u7wr4R8VfEGTV/CskF5eatajQ9Ng3xRW0hQb44Fdf3xhyVIOG9K9Wtw7iaVJ1q 
.................... jSUVfd3/ACscMM4ozqKnBO7/AK7n7ODpRSLwtJJMsSMzMqqoyxPQD1rwj1h1FZf/AAnGi/8AQY0v 
.................... /wACo/8AGj/hONF/6DGl/wDgVH/jQBqUVl/8Jxov/QY0v/wKj/xo/wCE40X/AKDGl/8AgVH/AI0A 
.................... alFZf/CcaL/0GNL/APAqP/Grmnara6vC0lpcQXUattLxSB1B64yPqKALFFFFABRRRQAUUZ4ozQAh 
.................... 61m+KfE2n+CfDuoaxrF9a6bpOl273V5d3MoihtokBZ3djwqqoJJJxWi0iqu5jgDue1fkF/wUx/ao 
.................... +J3/AAVI+Jd98E/2eND1bxF4D0O68vXdZsT5djrF0hDbXuWKxJbRsPly/wC9cbgGCoT2YHBuvU5L 
.................... 2j1b6I5sViFSjzWu+i8z5c/4K8/8FRL/APb7+Kq6RoM1zZ/C/wAMzt/Y9owMbapLyrX0yHncQSEU 
.................... jKIx4DM4PsH/AAbM/F5vCn7V/jLwZJII7Xxd4fF2iY/1lxZzAoP+/dxOfTj6V6B+zx/wbQRafpce 
.................... sfGb4iQ6fCgElxpfh7aqxL6PdzDAPYgREZ6N3r6K+EXhP9jX/gnv4gh1TwdaWeoeLbFHWPUbaafV 
.................... rw7kaN9spYwx7lJUhCgOTxya9vN+IsnweCeFU0lbfRK/fXc+cjGpTrLE4uah6tfcfeoO2vwo/wCD 
.................... lP4kf8JV+3PoegRybofC/he3ikQHlJ55ppWP4xmCv1h/Zf8A27NE/at8datpOg6Lq9nbaVaC6e5v 
.................... jEjMS4UKERmPPJzntX4O/wDBXT4lf8LX/wCCkHxc1JZPMW11ttJTHQCyjS04/GA/XJNcfBdaljK/ 
.................... 1ihLmik9V9x1ZpjaVbCqdF8yb/I+cgOP0wK/qK/YI+HH/Cpf2KvhT4eaLyZtO8K6eLlfSdrdHm/8 
.................... iM5r+Z/4FfDxvi78b/BvhSPdu8Ta7ZaSMdf39wkX/s9f1cWsC2sEccaqkcahVVRgKAMACva4urfw 
.................... 6fe7/Qjh+n8U/kfhV/wcj+Pp/GX7dulaHB50lt4U8MW0EiKpYJPNLLO59iY3hz7KK/Pae1ktgPMj 
.................... ePPTcpXNf1wMmTkj2z6V+L//AAdB/EVdR+Onwv8ACayc6Lodzq7KOxu5xED/AOSf4fjzWQ5w5uGD 
.................... UNEnrf8A4BOa5fyqWIcvlb/gn5d1JHZzTJuSKRlzjIUkfn+NRmv6Ov8Agip8Mv8AhWf/AATO+GME 
.................... key41azn1iVsY8z7TcyzRn/v00YyOuM17WbZn9Rpxny81/l/meZl+CeIqOCdrHyD/wAG1nheP4a/ 
.................... BH42fEjVIZobOKa2tDIy42JZ281xNj8J0J+gr8k/F3ia58aeK9U1i8O681a7lvJyO8kjl2/Umv6U 
.................... P+CrPxF/4VP/AME6fi/qm4xtN4fm0tGDYKveFbRcfjODxz6c1/M//npXBw/W+s1KuKkrczS9LI7M 
.................... 1p+xhCgtbDoYHuD+7RnxydozipP7NuP+fef/AL9mv0p/4NjPhw2tftSfEDxU0e6LQPDS6eGI4SS6 
.................... uY3U57HbbSY7EFq+5fHH/BYPS/BnjjWdIj8E3l7Hpd9NZrcLqSoJxHIUDgeWcBsZxk9eprzeJOOM 
.................... Jk1VQxNlfrd6u21kmcPscPSoxrYmpyKTstLn4YfspfCib4u/tO/Dzwu9rM8PiDxJp9hMDGxVY5Lm 
.................... NXJ4+6ELE+wNf0m/teftdeDv2JvgpqHjbxleNBZWv7q0tIcNc6ncEEpBCuRl2wTk4VQCzEAE1kfs 
.................... n/tY3f7T3h3Udcl8JTeGPD9jlY7+6vhIt24yX2DYvyoBy+cZ45w2Pwj/AOCsH7e99+3f+1BqGoW1 
.................... 1M3gfwzJJp3hi15VBAGAe5K/35mUOTgEKI1521y4PGR4jqQrwVqaXnr96W56tGtSwmG9rSlzc22l 
.................... vw7GP+3x/wAFLPiN+3940kn8RXzaX4VtZi+l+G7OVhY2ajIV3HHnTAHmRxnlgoRTtr54+6GP4k1J 
.................... YWM2p3sNrawy3FxcOscUUSFnkYnAVVHJJPGBX7Jf8E1v+DfLw/4d8Nab4y+O1m2s69dKlxb+FRKU 
.................... s9OHDKLooczSdMxgiNeQRJnj6zFYzC5dRUduyW/9eZ5lGhXxdVtO76vsfj74X8E6144v2tdF0jVN 
.................... YulG4w2Vq9xIB/uoCa/UD/g2+/Zg8VeC/wBpbxz4s8TeF9e0KPT/AA2mn2janp0toJWubhH3J5ij 
.................... dhbYjI6Bvev168D/AA70H4ZeG4NH8N6JpOg6TajENlp1pHa28X+6kYCj8BWt5e2vk8fxLLEUZUYw 
.................... sn5/8A9/C5OqVRVHK7RIv3a8p/bb8Zf8IJ+yl46vvM8tpNLks0OcYaciAY/7+Z/CvVlGFr5R/wCC 
.................... vXjE6J+zfp+ko6rJrmsxRupP3oo0dyceziP86+ZPbPzUBPTPt1r0DwF+yz8Q/id4d/tbQvCuqahp 
.................... 7I0scq7U89VOCYwxBkAPHyA88da4ANkf3u/P1zzX0n+xt8N9c8dfFXS/GY8S6Rq3iDw7Gt5p/h5N 
.................... XRNT1JYkwlupPyRRBBhlySqcbO4APnQ6TeDVfsP2a4+3eb9n+z7G83zM7dm3Gd2eMYzmuq8Rfs+e 
.................... M/CmiXuoX2h3Edvpbql+Emjll05mOFFxGjF4cngeYq5PHWvdPg/dXllYfG74361p6WHiTR5pLTTY 
.................... ChX+ztTu5ijuqnkPD5igBgfvNnoDWT/wTxt/7X1v4r3mqO02k/8ACDaj/aJlO9XLNG2Wz1O1ZDk+ 
.................... /qSQD5vBJ/8A11+q/wDwTE8Ff8Id+yBoMrJsm1ue41KUY67pCin8Y40NflQc4789D+Nftf8AA7wd 
.................... /wAK9+DPhTQ2Ty30nSLW1cf7aRKGJ9ywJoA6miiigAoozzRQA08U0thsc07PzfjXh37X37b3h39l 
.................... fRPJkMeseJ7pA9rpUcu1thOPMlbB8tOuMjLEEAHDEcuMxlLC0nWry5YrdnPisVTw9N1asuVI6/8A 
.................... aYtfCmqfCXULXxxrjaL4TuB5eqBbr7N/aEJzutWdf3myQfKViKu4yoOCQfjb4kf8FRNE+GHhu38J 
.................... /BfwjpWi6HpqGG2nlsxbW8S/9MbaPbjPXL8k9V718ufHP9oLxX+0R4qbVvFWpPdyISILdRstrJCc 
.................... 7Y4+gHTk/M2Bkt1rP8A/BzxZ8U5vL8OeG9a1n5the0tHkjjP+04G1fxIr8ozbjnG4t/V8rTjHule 
.................... T+XT5an5nmfFmJxVT2WAjZd7Xb/yJvid8cvGHxkv5LrxN4i1bWJGbzBHNKfJibttiUhE6n7oHfsa 
.................... 5X5SOCpXp14ra/ay+GXib9ibwZouvfEDQb/S7PXrp7WzWF4riR3VdxztfamFPAYgnBwDg4+f9S/b 
.................... d8Nw2gaz0zXJ7j+5OkcSdD/GHc+n8Pc+gz42G4N4izH99GhKV+r0/NnzNbL8fUnerF389H+J+r// 
.................... AAR70a18I/C34heMr2RYbRZ0tpJG6RJbQtM5z9Jhn/dFfgx498XXHxA8da3r15zea5fz6hOcdXlk 
.................... aRv1Y1+xP7MX7U+lz/8ABCP4xeLtNtZNLvbP+1dFug8obbeXEUEETqwA/gurfj1GK/GAdK/prw1y 
.................... Wpl+X+wxEeWcdGr313ex957P2WBoUH0V363Pqb/gi18Nf+Fof8FL/hjbSIzW+lXk+sTELnZ9ltpJ 
.................... oyfQeasa59WHev6QFGMV+H//AAbKfDVvEH7XHjbxQ8e6Hw34YNqjY4imuriPac+vlwTDHufSv3Ay 
.................... OKviirzYzk/lS/HU+mySny4fm7sGPH61/O5/wXg+I7fEP/gpr46iWQTW3h2Gx0eE7t2AlrG8g9sS 
.................... yyDHtnrX9ETNg1/K5+1n8Sv+Fx/tR/EXxYsgkj8Q+JNQv4SDkCOS4dowD3AQqB7CtuE6XNiJTfRf 
.................... mZZ9U/dRh3f5HAW0D3lxHHGpkkmZUVR1Yk9P1r+rv4I/D6P4TfBnwj4XjC+X4a0az0tMdAIIEiGP 
.................... wWv5nv2Bfht/wt39tn4VeHWjE1vqHimw+0rtyDAk6SS/+Q0b8fav6iQPlro4tre9Cn6sy4fp+7Op 
.................... 52Pz5/4OSPiS3hD9gew0OOQrL4t8T2lq6A9YYUluCffEkUPHqR6V+D44r9X/APg6M+JH2nxn8JfB 
.................... 8cjA2Nnf6xPHnh/OeKGIke3kzY+pr8oK9nhulyYJS7ts8/OKnNiWu1j9lv8Ag3Q8OR/DT9iH4ufE 
.................... KVUja61d4tzggNFY2aygk913XMg49CK539iz9kLVP2tPiKZLr7Rb+F7CXzNVv9u1pCefJjOMGRs8 
.................... /wB0HceoVvov/gmL+zlqF1/wRs8L+FdPnh03UvHNpcXd1cypuVIby7Yl9vG4/ZCuBkZIHIzkfXvw 
.................... e+D2i/A3wBY+G/D9sLfT7FMZY7pJ3PLSSN/EzHkn8AAABX47xbk/9q5wqlb+HBttd30XppqbVMj+ 
.................... tyoe1/hwV2u77Hz3/wAFXvHtv+yh/wAExPiB/wAI3DFpO/TIvD2nQ248vylu5Ut32HswikkYHrlc 
.................... 5zzX84/Sv6EP+DgHwreeJv8Agmf4ruLVC40XUdOv5lAy3li5SMkY9PNDE9gpPSv57/6dQO1fq3CN 
.................... OnHCtRXXb8rE53pWUErJLRH3n/wbx/s6aX8a/wBuOXX9ZhjurX4eaW2sWsL/ADK160qRQMV/2Nzy 
.................... A9nRD71++SdF9q/nZ/4Io/tr6P8AsWftiR3Xii4Wz8J+MLJtE1K7blNOZnV4bh+fuK67WPRUkdv4 
.................... cV/RBpuqW2sadb3lpcQ3VrdRrNDNC4eOWNhlWVhwQQQQRwRXh8URqfW+aXw2Vj1MjlD2FlvfUs0U 
.................... hcA0ua+dPaCvz7/4LN+MvtPjzwX4fDfLY2E+oOvr50gjB/DyG/Ov0EzX5R/8FMfGY8X/ALYPiREb 
.................... dDo8dvp8ZBzgpEGce3zu4x+PWgDyr4R/D61+KHjeHRrzxDo/hlbiOQx3upuY7YyhSURnH3dzADcT 
.................... gDnn7p9J+DOiW37K/wAZdO8VeKNc0K4Hh13ngsNF1SHUrnUZNrKiAxF0iQswLNIVIBOFYkCuH+Gf 
.................... wXm8dS6K11dTWFn4i1UaLp5gtvtE93cHYGKoXQbE82PcxcY8xQA3zY774Ufs9WlxJockl54c1ix8 
.................... WeIZ/D9sb+1ui0ZiaMCVFjljLbvNDtztVYzl+SrAG54O+MUfx0+AXxa8M317pem+KfFGvR+J7OC5 
.................... uUtYb1mkVpoUlkKqGVVBVWILA8ZPTEi8cWP7OX7M+veE7HUdN1Lxt8QpI11Z9PuEuodJ0+POIPOj 
.................... JjaWRmcMqsQFbBwQK5Lwf+zw3iTUtJsZtYhs77xJa3d5oym33pcRW/nYkmbcDCkjQOqkBz8pJULg 
.................... th+PPhS3w/8ACuh3t3dXEl5rttHfW8Ytf9GlgkTcGjnDHe6cJIm1Sjgj5sZoAPgD4M/4WF8cfCOh 
.................... uu6PVNYtreUEf8s2lXf+SZr9qq/K3/glz4MHiv8Aa90a4ZfMi0KzudRYfwj935Kn8GlX9K/VKgAo 
.................... oooAQnFIWxSk1meKtXk0Dw/eXkdtNey28bOlvCP3k7Y+VFzxljgZOAM5JAyamTsm2KTsrni/7c37 
.................... Zlh+yt4IWKz+z33i7V1I06zc5WFehuJQP4FPAGQXbgYAYr8W/B79g74ofteeIpPFniSabR7LWJft 
.................... M+q6srG4u84G6KDIZhtxtyUTaAFOABX2h8Jf2L7Z/iNefET4ita+JvGupTCaKFl8yx0RR/q4oFYf 
.................... MUGAJGAORkAElm94SPHYDjoK+RxGQzzSv7bMG/Zr4YL85eb8vvPmcRk9TMKvtMa7QW0F+bfd9vxP 
.................... n/4J/wDBNH4Y/B4Q3M2mN4n1OPB+1aviZQ2OSsQAjHsSpYf3q98sNMt9LtI4beGK3ghUIkcaBUQD 
.................... gAAdABVhRigda+iweX4bCw5cPBRXkj3MLgcPho8lCCivJHw//wAHCXwo/wCFkf8ABNvW9SVm87wV 
.................... rFhraIq7mkBk+yOPYBLp2Pslfz84xX9VX7UfwnPx4/Zt8feC0WMzeKfD99pcBkAKxyywOkb88ZVy 
.................... rA9iBX84X/Dtj9oI/wDNF/iX/wCE/c//ABFfo3C+Npwoyp1JJWel33PCzrDylVU4K+nQn+Fn7UP/ 
.................... AAg37BPxa+F0lxcbvGuu6JeWsIHyBIDPLcMSehLRWQHrtHpXhZ4r3C3/AOCaH7Ql3Msa/Bn4jhm6 
.................... b9BnVfxLKAKvf8Osf2iif+SOeOv/AAXNX0FPEYSm24zXvO+6PJlRrysnF6K2x7B/wTw/b/03/gnV 
.................... +xr8SNY0X7Lf/FL4havDpWjWcg3rYQWsBY3sy/8APMPdsEX/AJaOCOQjkcAP+Cz/AO09jj4tazj/ 
.................... AK8rP/4zXPf8Osf2iv8Aojnjv/wXN/k/y/lR/wAOsP2i/wDojfjr/wAFzVzRp5dzyqVHGTk762fp 
.................... ub8+LUVGCaS9T9Uv+Cav7XXxI8Zf8Eqfi18WviR4ovPEWqaT/bE2lTXCRQFIbWwRkVfLRRlrgyAH 
.................... BPTk9K/C/Oa/cLV/2X/iF8LP+Dfq3+GeieEtavPiBrVnGt1pVtblruJrnU/tEwdexWAsp9MV+Xf/ 
.................... AA6w/aLz/wAkb8df+C1q4Mmr4eE6021FOWmq2R05hTrSjThZtpa+p7H/AMG9Pwz/AOE9/wCCkWja 
.................... k0fmR+ENG1DVznopaMWik/jdjHv9K/oF3cD61+Wf/BvH+xB4+/Zz8c/EzxJ8QPB2seE7q5sLLTdM 
.................... GpW3lPco0kss+zvgGODPqSPSv1JLcfrxXzfEWIjWxjcHdJJaHtZPRdPDrmVm2fz9/wDBwn8S/wDh 
.................... PP8AgpRrmnq4ZPCOjafpCkZ4JiN0w9ODdH8Qa+Idm4e+MgD0/wAivtH9ub9gz9oT47/tjfEzxfZ/ 
.................... CPxxeafrfiO9msJl09istqJWSBvxiWOvKx/wSx/aKH/NG/HXb/mHN2/z+Ffa5fiMPTwsKftFokt0 
.................... fN4qjWnWlLler7H03+2P/wAFmPE3wp8M+BvhJ8BfETaLoPw10az0i+8QW8EMzazcW9ukLCEurr9n 
.................... XafmAzIxLA7QpfwUf8Fnv2nv+itaz6f8edn/APGa54f8Er/2ilH/ACRvx1/4LWoH/BK79ouR9v8A 
.................... wpzxxluPm09lH+eaypUsspws+V9b6NsqVTGSlrzLta5+5v7GvhfV/wBrL/gl/wCGdP8AixqF14lv 
.................... /iP4bnOrXcqpFNPBeGV4iNihVKQyRhSFyNoPXmvwI/bH/ZJ8VfsU/HfV/A/iq2kWSxkaSwvghEGq 
.................... 2pJ8q5iPTDAcjJ2tlTggiv6bPgx8Po/hN8H/AAn4Vt8CDw1o1ppMeOywQpEP0WuH/bG/Yf8Ah7+3 
.................... N8N/+Eb8eaR9p+z7n0/UrZhFf6XIwwXglwSucDKkFWwMqcDHyeW5x9Urzuvck9u3ax72My729GKv 
.................... 7yW5/LuOnoq45/r/AEyf07+9fswf8FNPjb+x/p0WneCfHGoW+hw7iukX0aXtgmeSEjlDeVk5J8sr 
.................... k8nqRX0L+1d/wbv/ABm+DOqXV54DNj8TPD6lmja1kS01SFMf8tIJGCsR0HlO5brtXpXx541/Za+J 
.................... nw3vHt/EHw78caJNH1W+0O5g49RuTke4JHvX3EcVgsZG3MpLs+nyZ826OJoTvqn/AF1R99/snf8A 
.................... Bcn9ob9pX9qH4b+BZpvCFnZ+IvENlZX8tpo+JmtWmTzyC7sA3lCQ5AGO1ftf2H0r8B/+CB/7O+u+ 
.................... IP8Agol4b1zUdB1a20zwrp9/qRnubKSOEyGE26DcwA3BrjIAOflr9+F5r4XiKnQp4hU6CSSXTqfT 
.................... ZPKrKk5Vd7hkIOvHWvxN+MXjI/ET4s+Jte3ZGsapc3qY7B5WZR+RAr9rryyjvrWSGRS0UyFHAYrk 
.................... HgjI5HXqOa8V/wCHcPwXP/Mkwf8Agxu//jteCesfnD8P/wBp/WvhxpXhi3sdN0WSbwlc3NzZXMsc 
.................... nnETbS8bEOBsLKpJUK5A27tuVNPQP2h9W8Pa94bvodP0dl8KwXcNpbmKRYWNy07tIwDg71M/y7So 
.................... Aij44O79Kv8Ah3B8Fv8AoSYf/Bjef/HaP+HcHwW/6EmH/wAGN5/8doA/NG7/AGgdWudJ0+NbPSrf 
.................... UtN0qTRIdUhidLhbSQyFkCh/KUlZpY9yoGCNgdM1n+PfitdeOdJtdNjsNP0XSLS6mvotPsPN+zxT 
.................... zLGsjqJZHK7vKX5VIVecAZr9Pv8Ah3B8Fv8AoSYf/Bjef/HaP+HcHwW/6EmH/wAGN5/8doA+df8A 
.................... gjJ4O87xH448QMqg29tb2ETHr+8Z3fn0/dRk/UV99CuQ+EHwJ8K/AXRrrT/CWkx6PZ3s/wBomjWa 
.................... SbfJtC5zIzHoAMZxXXjpQAUUUUANY8Vxfxm/aI8C/s7aPa6h468WaH4Tsr6Y29tPqd2luk0gXcVU 
.................... seSFGcegrtSM18xf8Fcy2r/sZX/haHB1D4ha9ovhW0GM7mu9St0dRyOsQkHUVpRhGc1GRnUk4xuj 
.................... 3j4UfGHwr8c/CEfiDwfr2meJNEmkeGO+0+YTQO6HDAOOCQeDTfhd8YPDvxo0O81Tw3qH9o2On6ld 
.................... 6TNN5EkSi5tZmhmQb1UsFkRhuXKnGQSOa+HfB/xb+IXxa/a48Xa9D40t/C3hP4X+N73S5tK/4SBY 
.................... Y7rSNOsnM9smliPM088mZjcSvhIwNgwteJ/BDxl8TvGvw1+HXwz8HeMLbweZfh+njL+0W8TrogOq 
.................... 6xql3N9rkxG8l5FBgp9nUBWklIc8Ljv/ALNvez899kcccbtdH655FKcV+cHxJ/ak8XWfw9/aA+JE 
.................... PxMvo/Gnw98Sz+CNC8OLfRW+l6Tarc2mmtqtxZY/eN5ty9z5kpZFxGoIUEVnQfFXx8nxW1b4eeBf 
.................... ix4v8QeG9Q+J/h3w1pfia6vk1K7jK6XcX2trHPtKSIgjhHlnciOWUqFyDksvb+0vx8v8zT67Hsz9 
.................... LHHb1NOO0ivy1+G/7QHxF8A2XgvxlN8SfGWv6PcW/wARtUh06/vBcRSaFpEdyto052hprj7S0LCZ 
.................... jnYFRcKCGh8U/tk+PL34UPZ+FfiFqura5oHwj8M6fd3cN6Zkm8T65qVrH5rSLkNLFDvwcnAdxyy8 
.................... U8tn0aZKx0eqP0w+KnxW8P8AwU8D3XiTxRqUek6HYyQxTXTRPII2mmSGIbUDMd0kiLwOrdhXQ45r 
.................... 84Lnx98QNI+KuoeG7P4j+OtasYPjpofhy2mmvFNxcRRaQt9rMLbFUCB8PiJcJGSuABkVT8L/ALTW 
.................... ueMP2a/h/wCOJvjBqdj4i+O3jC10XxDJFrUP9n+BNOke8uDDaQsNlpcfZ7TyBLIC+4u5JIyH/Z0t 
.................... LSCOOT6H6VblYVz3hz4s+HfFvxA8SeFdO1OO61/wiLVtXtFjcNZC5RpIMsVCneiscKTjHOMivzm/ 
.................... Z1+OevfFzxF4P8D6h8XvG2i/D/xn4g8W6tYa/d60LfWNT0+wuoLGwsIr2Rd4y/mzOB87fdzjIN9P 
.................... j34kvvjXeeCtW+KPiXw34D8TfFPxPY3Ouz6x9nvNP07RLCBzZW904/dLLeSS5K4by4WAbOaX9nyT 
.................... s35/1p+AfXVa6R+lZChu3TvS8Ada/JhP2lPix4y/Z3mv9W+JHjLRbXwX8GNQ8W3F1bTC3vtUurnV 
.................... LuPQzPJsyGa2t7d3YAM4Yg5Ej59U+H3xN+MHx4/atns7zx1D4Uh+G3iHRdOv7e48SJYR3FvBYwXO 
.................... pB9OVCbt7tpJQskjKkSICmGVsn9mztzcysg+uxvazP0S4x/T2oxk/pXyn/wTL8f6x4tvvippvizx 
.................... Lrnijxl4Z1/7Jqt+dWF/oNzHKJLm1k05UwkC/Z5o1eIDKmNd3Oa4T/gmD8YfH37RHji3TXPEmt32 
.................... lfCfTdT0TXftE5Latrs2r3SoJj0k+zWNtCQD0N4hHTNYywcved/htf5mscQmo6bn1fqX7S/w/wBI 
.................... +Mdr8O5/F2hr44vU3xaKLkNeEeW0o3IMlSY0ZwGwWVSRkVq/Cb4veG/jp8PdP8VeE9Vg1rw9qwkN 
.................... pexIyxziORonwHAPDow5Hb0r4a+JPxbh/Zf/AGo/jVa+F/FWm+KNA+KPg7W/G2oyaVeo2r+Cr7TL 
.................... JYSzSoWAhlIVIgwDJKpA+6S/PaF8YfGHw+8WeFIfHnj7xjq0eofBx9Y08aL4hEcmnapaaTJcam2p 
.................... W6/M7t58bwzPlUZI1C5roWA5tYvp1Mni2nqj9HdC8Raf4n09bzTb6z1CzZ3iWe2mWaIujmN13KSM 
.................... q6spHUMpB5Bq268/X8K/Jb4a3XjvSvhx8KfhB4H+IF3pC3/wti8cy6rdeM/7Kjg1bUpzCGM215Jr 
.................... a1kSVjaxgB5ZvnPavQPiV4/+LXjH4w6g+lfFbxXpp/4XBo3w40iGw8tbXMWlRPq91JAVKyKdksix 
.................... n92jhuCSCD+znfSSBY1fys/SsPuH0oD8/pX5ZWX7U/iKDwzb+F/EHxT8YaL4Jt7nxz4ji1ltW8nX 
.................... tbsdN1H7Hp2nx3jqZN7SmQ4Qb3CqgwBg+g/sv/FnxtJ8cP2bdP8AH3jbxJ4gtvHfgS3ubSDTtdEU 
.................... lvrKW0moznVbZcPNHJaSRBGYsqmLBX5t9TLLZRXM2gjjE3ax9o/GP9p34f8A7P8AfaVa+NPF2h+H 
.................... bvXH8uwt7y5CTXZyFOxBliAWUFsYBYAnkVY+M37Q/gb9nfSbPUPHXirQ/CdjfzfZrafVLpLeOaTB 
.................... OxS3VsAnFfMv7YnjK3+BH7evwy+I3h7xB4d1jXNcls/hj4g8JSzo2ofYbu5+0pd24BLxPEWEkgYB 
.................... HiCklcKa579sD402fxf/AG0fgHdeA/iV8PtDttC8P694rtte1jZfaRcCbyNOQLtuId7Ye5UYkBGG 
.................... ODtOFTwkZKF72abfy+X+ZU8Q1e3c+2fBPjPSfiP4U0/XtCv7PVtH1aBbmzvbVxJDcxMMq6N0KkYI 
.................... I61rKfxrD8IePNF8bvqVvpes6XrF1oF2dM1RbOZZPsV2iq7wyAE7HAdSUPI3Ctwfd/8Ar1wSVtjq 
.................... j5DqKB0ooKCiiigAooooAKKKKACiiigArO13wnpvij7J/aWn2OoCwuUvbUXMCy/Zp05jlTcDtkXP 
.................... DDBHYitGijYNzkz8C/BjeOrnxQ3hHwu3ie8iME+rnS4DfzRlNhRp9nmMpQlcE428dKqt+zd8PpF0                     
.................... bd4D8FsPDqldJB0W2xpYLF8QfJ+6G47vkxzz1rtqKrml3J9nHscvc/BXwhd6zrGoy+FfDcmoeIbf 
.................... 7Jqty+mwmbUoeB5U77d0qYAG1yRwOKl8O/CPwt4R07SLPSfDPh7S7Tw+7yaZBaafFDHprOrI5hVV 
.................... AjLKzKSuMhiD1NdHRRzS7hyx7HO2Hwn8M6XBbw23h3QbeGztpbK3SKwiVYLeUhpYUAUBY3IBZRwx 
.................... AJyaq6N8C/BnhzTobPT/AAj4XsbW3MDRQ2+lwRRxmCR5YSqqgAMckjumB8rOxGCTXWUUc0u4+Vdj 
.................... Bh+GPh221FLyPQdFjvI7yTUknWyjWRbqRPLknDbciVk+UvncV4JIrJP7Ofw/bTNQsj4F8HGz1a7W 
.................... /vrf+xrfy7y4UllmkXZh5ASSHYFgSea7Sijml3Fyx7HK6t8D/BviC102DUPCfhm+h0e6a90+OfS4 
.................... JEsbhn3vLEGU+XIzksWXBLHOc0zxF8B/BPi/QP7K1bwf4V1TTPtrakLO70mCe3F0zFmn2MhXzSzM 
.................... S+NxLE5ya62ijml3DlXY5/VPhZ4b1tb4Xnh/Q7z+04Ira8E1jFJ9siiJaKOTKncqMSVByFJJAzVT 
.................... UvgZ4M1jxo3iS88I+GbvxE0ZhbVJtLge9KFDHsMxQvtKErjONpI6cV1dFHPLuHJHscfF8IrPwR8M 
.................... tQ8P/D+20HwHLcRyGzlsNHi+y2c7jHnG3XYjkcHBIzjk1mfs0/s6aX+zN8LIfDem3NxqVxPdT6nq 
.................... up3QUXOsahcOZLi7l2jG+R2JwOFUKo4UV6HRR7SVrXD2cb3OP0T9n/wL4cttag0/wX4SsIPEalNV 
.................... jttIt4k1RTnInCoBLnc3389T6mrOn/BfwjpGv6nq1p4V8N2uqa1B9m1C8h02FJ76LAXZK4XdIuAB 
.................... hiRgCunoo5pdw5I9jh739mf4d6lZ6Lb3HgLwXcW/hssdIil0S2dNK3Nub7OpTEWTydmMnnrW3D8M 
.................... /D1tcxzRaDosc0d9JqaOtlGGS7kBWS4B2/611Zgz/eYMQTzW7RRzS7hyx7HJ3fwL8G31tpsM3hPw 
.................... xNDorzSafHJpcDLYtNkytENmIy5J3FcbsnOc1JoPwV8H+FfF03iDS/CvhvTteubdLSbUrXTIYbyW            
.................... FFVEiaVVDlFVEUKTgBQBjArqKKOZ2tcFTitUjmYvg54Uh8fyeLE8M+Hk8UTJ5cmsLp0I1B12hNpn 
.................... 2+YRtAXGcYAGMVnap+zZ8PdcisI73wH4Lu49JiFvYpNottItnFuLbIwU+RdzMdq4GST3NdvRRzS7                              
.................... hyR7Gfo3hfT/AA694+n6fY2MmpXDXd41vAsRupiFUySbQN7lVUFjyQoHQVoAYooqSgooooAKKKKA                                                                            
.................... CiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK                                      
.................... KKKACiiigAooooAKKKKACiiigAooooAKKKKAP//Z\"</p> 
.................... <form method=\"post\" action=\"/login\">      
.................... <input type=\"hidden\" name=\"action\" value=\"login\">                         
.................... <input type=\"hidden\" name=\"hide\" value=\"\">                                               
.................... <table class='center'>                                                                                                                                                                    
.................... <tr><td>Usuario:</td><td><input type=\"text\" name=\"user\"></td></tr> 
.................... <tr><td>Clave:</td><td><input type=\"password\" name=\"pass\"></td></tr>  
.................... <tr><td>&nbsp;</td><td><input type=\"submit\" value=\"Confirmar\"></td></tr>                                                                                                             
.................... <tr><td colspan=2>&nbsp;</td></tr>                                                                     
.................... </table>                                                                                                        
.................... </form>  
.................... </div></div></div>                                                                              
.................... ";                                                                          
....................    
.................... const char  HTML_LECTURAS_LOGIN[]="  
.................... <!DOCTYPE html> 
.................... <html lang=\"es\"> 
.................... <meta charset=\"UTF-8\"> 
.................... <meta name=\"MobileOptimized\" content=\"width\" /> 
.................... <meta name=\"HandheldFriendly\" content=\"true\" /> 
.................... <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> 
.................... <HTML><BODY BGCOLOR=#FFFFFF TEXT=#000000>                                     
.................... <P>                                                                                                                
.................... <P><A HREF=\"/lecturas\"><BR><center><H2>LOGIN</H2></CENTER></A>                                                                       
.................... </BODY></HTML> 
.................... ";                                 
....................                                              
.................... /* Página secundaria (\lecturas). Accesible desde la página principal */                                                                                                        
.................... const char  HTML_LECTURAS_PAGE[]=" 
.................... <!DOCTYPE html> 
.................... <html lang=\"es\"> 
.................... <meta charset=\"UTF-8\"> 
.................... <meta name=\"MobileOptimized\" content=\"width\" /> 
.................... <meta name=\"HandheldFriendly\" content=\"true\" /> 
.................... <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> 
....................    <title>Altec S.E.</title>                                                                                                              
.................... <body BGCOLOR=#71C7CE STYLE=\"background-color: #71C7CE;\"></body> 
.................... <meta name=\"GENERATOR\" content=\"Altec S.E.(http://www.altec.com.ar)\"> 
.................... <meta http-equiv=\"refresh\"content=\"30;url=//www.google.com.ar\"> 
.................... <title>Power distribution unit</title>                               
.................... <div style=\"text-align: center;\"> 
.................... <div style=\"box-sizing: border-box; display: inline-block; width: auto; max-width: auto; background-color: #FFFFFF; border: 2px solid #0361A8; border-radius: 5px; box-shadow: 0px 0px 8px #0361A8; margin: auto auto auto;\"> 
.................... <div style=\"background: #0361A8; border-radius: 5px 5px 0px 0px; padding: 15px;\"><span style=\"font-family: verdana,arial; color: #D4D4D4; font-size: 1.00em; font-weight:bold;\">Remote Embed Server Altec</span></div>          
.................... <div style=\"background: ; padding: 15px\" id=\"ap_style\">                                                                                                                                                                                       
.................... <style type=\"text/css\" scoped>                                                                                                                                     
.................... #ap_style td { text-align:left; font-family: verdana,arial; color: #064073; font-size: 1.00em; } 
.................... #ap_style input { border: 1px solid #CCCCCC; border-radius: 5px; color: #666666; display: inline-block; font-size: 1.00em;  padding: 5px; } 
.................... #ap_style table.center { margin-left:auto; margin-right:auto; } 
.................... #ap_style .error { font-family: verdana,arial; color: #D41313; font-size: 1.00em; } 
.................... </style> 
.................... </head>  
....................  
.................... <body>                                                                                                   
....................  
.................... <h1 align=\"center\"><font color=\"#000000\"><font color=\"#000000\">(PDU) Power distribution unit </font></font></h1> 
....................                                                      
....................                   <table align=\"center\" bgcolor=\"#00FF00\" border=\"2\" cellpadding=\"6\" cellspacing=\"1\" width=auto> 
....................                    
....................                   <tbody>                                         
....................                             
....................                   <tr>                                          
....................                   <th><p align=\"center\">Lecturas Pic ( 1 = ON ) ( 0 = OFF)</p></th>                   
....................                   <th><p align=\"center\">ON/OFF Relay Correspondiente (PRECAUCION)</p></th> 
....................                   <th><p align=\"center\">REBOOT Relay </p></th> 
....................                    
....................                   </tr> 
....................                                                            
....................                   <tr>                                                                                      
....................                   <td><b>Corriente: </b>%0</td> 
....................                   <FORM METHOD=POST><td>Pulse  ON/OFF = Interruptor Fuente 1 <input type=\"submit\" name=\"boton1\" value=\"Relay 1\"></td></FORM> 
....................                   <FORM METHOD=POST><td>Reboot = Fuente 1 <input type=\"submit\" name=\"reboot1\" value=\"Reboot Relay 1\"></td></FORM> 
....................                   </tr>                                                           
....................                                                                                                                                                                       
....................                   <tr> 
....................                   <td><b>Estado: </b>%1</td>                                                                                       
....................                   <FORM METHOD=POST><td>Pulse  ON/OFF = Interruptor Fuente 2 <input type=\"submit\" name=\"boton2\" value=\"Relay 2\"></td></FORM> 
....................                   <FORM METHOD=POST><td>Reboot = Fuente 2 <input type=\"submit\" name=\"reboot2\" value=\"Reboot Relay 2\"></td></FORM> 
....................                   </tr> 
....................                                                         
....................                   <tr> 
....................                   <td><b>Rele 1=</b>%2</td>                                                                                      
....................                   <FORM METHOD=POST><td>Pulse  ON/OFF = Interruptor Fuente 3 <input type=\"submit\" name=\"boton3\" value=\"Relay 3\"></td></FORM> 
....................                   <FORM METHOD=POST><td>Reboot = Fuente 3 <input type=\"submit\" name=\"reboot3\" value=\"Reboot Relay 3\"></td></FORM> 
....................                   </tr> 
....................  
....................                   <tr> 
....................                   <td><b>Rele 2=</b>%3</td> 
....................                   <FORM METHOD=POST><td>Pulse  ON/OFF = Interruptor Fuente 4 <input type=\"submit\" name=\"boton4\" value=\"Relay 4\"></td></FORM> 
....................                   <FORM METHOD=POST><td>Reboot = Fuente 4 <input type=\"submit\" name=\"reboot4\" value=\"Reboot Relay 4\"></td></FORM> 
....................                   </tr> 
....................                                                                                                         
....................                   <tr> 
....................                   <td><b>Relay 3=</b>%4</td> 
....................                   </tr>                                  
....................                                                                      
....................                   <tr> 
....................                   <td><b>Relay 4=</b>%5</td>                                                                                                                                                                           
....................                   </tr>            
....................                 </table> 
....................      </table>                                                                          
....................    </tbody> 
....................     
.................... <p align=\"center\"><font size=\"2\"><font size=\"2\"><font size=\"2\"><font size=\"2\"><font size=\"2\">Laboratorio de I+D. Power distribution unit </font><a href=\"http://www.altec.com.ar\" target=\"_blank\"><font size=\"4\"> Altec S.E.</font></a><font size=\"4\">&nbsp; </font></font></font></font></font></p> 
.................... <FORM> 
....................    <INPUT TYPE=\"submit\" onClick=\"history.go(0)\" VALUE=\"Refresh\"> 
.................... </FORM> 
.................... <P><A HREF=\"http://www.google.com.ar\">SALIR</A> 
.................... </body> 
.................... ";                                                     
....................  
.................... /* Elección de MAC. No puede haber 2 dispositivos con misma MAC en una misma red 
....................    Microchip Vendor ID  MAC: 00.04.A3.xx.xx.xx.  */ 
.................... void MACAddrInit(void) { 
....................    MY_MAC_BYTE1=0; 
*
063A6:  CLRF   1D
....................    MY_MAC_BYTE2=0x08; 
063A8:  MOVLW  08
063AA:  MOVWF  1E
....................    MY_MAC_BYTE3=0xdc; 
063AC:  MOVLW  DC
063AE:  MOVWF  1F
....................    MY_MAC_BYTE4=0x18; 
063B0:  MOVLW  18
063B2:  MOVWF  20
....................    MY_MAC_BYTE5=0x7c; 
063B4:  MOVLW  7C
063B6:  MOVWF  21
....................    MY_MAC_BYTE6=0x06; 
063B8:  MOVLW  06
063BA:  MOVWF  22
063BC:  GOTO   CAA6 (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void) { 
....................    //Elección de la dirección IP.  
....................    MY_IP_BYTE1=10; 
063C0:  MOVLW  0A
063C2:  MOVWF  19
....................    MY_IP_BYTE2=2; 
063C4:  MOVLW  02
063C6:  MOVWF  1A
....................    MY_IP_BYTE3=10; 
063C8:  MOVLW  0A
063CA:  MOVWF  1B
....................    MY_IP_BYTE4=200; 
063CC:  MOVLW  C8
063CE:  MOVWF  1C
....................  
....................    //Elección de la dirección de puerta de enlace.  
....................    MY_GATE_BYTE1=10; 
063D0:  MOVLW  0A
063D2:  MOVWF  27
....................    MY_GATE_BYTE2=2; 
063D4:  MOVLW  02
063D6:  MOVWF  28
....................    MY_GATE_BYTE3=10; 
063D8:  MOVLW  0A
063DA:  MOVWF  29
....................    MY_GATE_BYTE4=1; 
063DC:  MOVLW  01
063DE:  MOVWF  2A
....................  
....................    //Elección de la máscara de red.Si no se indica nada se tomará 255.255.255.0 
....................    MY_MASK_BYTE1=255; 
063E0:  SETF   23
....................    MY_MASK_BYTE2=255; 
063E2:  SETF   24
....................    MY_MASK_BYTE3=255;          
063E4:  SETF   25
....................    MY_MASK_BYTE4=0;                                    
063E6:  CLRF   26
063E8:  GOTO   CAAA (RETURN)
.................... }                                       
.................... ///// Variables Globales ///////////                                             
....................  static char valid_user[8]; 
....................  static char valid_pass[8];     
....................  static char memouser[]="charlie";                                                               
....................  static char memopass[]="1234"; 
....................   
....................  int1 elige_reboot1=0; 
....................  int1 elige_reboot2=0; 
....................  int1 elige_reboot3=0; 
....................  int1 elige_reboot4=0; 
....................  int32 reboot1=0; 
....................  int32 reboot2=0; 
....................  int32 reboot3=0; 
....................  int32 reboot4=0; 
....................  /////////////////////////////////// 
....................  /***************************  FUNCIÓN EXEC CGI   ******************************/ 
.................... /* Con la función http_exec_cgi interconectamos las variables virtuales de la                 
.................... página web con las variables del programa del PIC. Se encarga de recibir  
.................... los cambios producidos en la aplicación web y reflejarlos en el hardware del PIC.  
.................... Ejecuta, por tanto, la acción elegida según el valor de la variable virtual recibida  
.................... de la página web 
....................  
.................... key es la variable virtual que viene de la pagina web 
.................... val es el valor de una variable virtual de la página web                                                       
.................... file es la dirección de la página web devuelta por http_get_page () 
....................  
.................... */ 
....................  
.................... void http_exec_cgi(int32 file, char *key, char *val) { 
....................    static char boton1_key[]="boton1";                                     
....................    static char boton2_key[]="boton2"; 
....................    static char boton3_key[]="boton3"; 
....................    static char boton4_key[]="boton4"; 
....................    static char reboot1_key[]="reboot1";                                     
....................    static char reboot2_key[]="reboot2"; 
....................    static char reboot3_key[]="reboot3"; 
....................    static char reboot4_key[]="reboot4"; 
....................    static char lcd_user[]="user";                                                               
....................    static char lcd_pass[]="pass";                                    
....................  
....................    //printf(lcd_putc,"\fCGI FILE=%LD", file); 
....................    //printf(lcd_putc,"\nKEY=%S", key); 
....................    //printf(lcd_putc,"\nVAL=%S", val); 
....................  
....................    /* Se ejecutará al pulsar el botón "Botón 1" en la aplicación web */ 
....................    if (stricmp(key,boton1_key)==0)                                   
*
0A51E:  MOVFF  377,37B
0A522:  MOVFF  376,37A
0A526:  MOVLW  02
0A528:  MOVLB  3
0A52A:  MOVWF  x7D
0A52C:  MOVLW  F8
0A52E:  MOVWF  x7C
0A530:  MOVLB  0
0A532:  RCALL  A33C
0A534:  MOVF   01,F
0A536:  BNZ   A53C
....................    { 
....................       output_toggle(PIN_B0);                                                                     
0A538:  BCF    F93.0
0A53A:  BTG    F8A.0
....................    } 
....................    /* Se ejecutará al pulsar el botón "reboot 1" en la aplicación web */ 
....................    if (stricmp(key,reboot1_key)==0)                                   
0A53C:  MOVFF  377,37B
0A540:  MOVFF  376,37A
0A544:  MOVLW  03
0A546:  MOVLB  3
0A548:  MOVWF  x7D
0A54A:  MOVLW  14
0A54C:  MOVWF  x7C
0A54E:  MOVLB  0
0A550:  RCALL  A33C
0A552:  MOVF   01,F
0A554:  BNZ   A55C
....................    { 
....................       output_low(PIN_B0); 
0A556:  BCF    F93.0
0A558:  BCF    F8A.0
....................       elige_reboot1=1; 
0A55A:  BSF    59.2
....................          } 
....................    /* Se ejecutará al pulsar el botón "Botón 2" en la aplicación web */                             
....................    if (stricmp(key,boton2_key)==0) 
0A55C:  MOVFF  377,37B
0A560:  MOVFF  376,37A
0A564:  MOVLW  02
0A566:  MOVLB  3
0A568:  MOVWF  x7D
0A56A:  SETF   x7C
0A56C:  MOVLB  0
0A56E:  RCALL  A33C
0A570:  MOVF   01,F
0A572:  BNZ   A578
....................    { 
....................       output_toggle(PIN_B1); 
0A574:  BCF    F93.1
0A576:  BTG    F8A.1
....................    } 
....................    /* Se ejecutará al pulsar el botón "reboot 2" en la aplicación web */ 
....................    if (stricmp(key,reboot2_key)==0)                                   
0A578:  MOVFF  377,37B
0A57C:  MOVFF  376,37A
0A580:  MOVLW  03
0A582:  MOVLB  3
0A584:  MOVWF  x7D
0A586:  MOVLW  1C
0A588:  MOVWF  x7C
0A58A:  MOVLB  0
0A58C:  RCALL  A33C
0A58E:  MOVF   01,F
0A590:  BNZ   A598
....................    { 
....................       output_low(PIN_B1); 
0A592:  BCF    F93.1
0A594:  BCF    F8A.1
....................       elige_reboot2=1; 
0A596:  BSF    59.3
....................    } 
....................    /* Se ejecutará al pulsar el botón "Botón 3" en la aplicación web */ 
....................    if (stricmp(key,boton3_key)==0) 
0A598:  MOVFF  377,37B
0A59C:  MOVFF  376,37A
0A5A0:  MOVLW  03
0A5A2:  MOVLB  3
0A5A4:  MOVWF  x7D
0A5A6:  MOVLW  06
0A5A8:  MOVWF  x7C
0A5AA:  MOVLB  0
0A5AC:  RCALL  A33C
0A5AE:  MOVF   01,F
0A5B0:  BNZ   A5B6
....................    { 
....................       output_toggle(PIN_B2);                      
0A5B2:  BCF    F93.2
0A5B4:  BTG    F8A.2
....................    }  
....................    /* Se ejecutará al pulsar el botón "reboot 3" en la aplicación web */ 
....................    if (stricmp(key,reboot3_key)==0)                                   
0A5B6:  MOVFF  377,37B
0A5BA:  MOVFF  376,37A
0A5BE:  MOVLW  03
0A5C0:  MOVLB  3
0A5C2:  MOVWF  x7D
0A5C4:  MOVLW  24
0A5C6:  MOVWF  x7C
0A5C8:  MOVLB  0
0A5CA:  RCALL  A33C
0A5CC:  MOVF   01,F
0A5CE:  BNZ   A5D6
....................    { 
....................       output_low(PIN_B2); 
0A5D0:  BCF    F93.2
0A5D2:  BCF    F8A.2
....................       elige_reboot3=1; 
0A5D4:  BSF    59.4
....................    } 
....................    /* Se ejecutará al pulsar el botón "Botón 4" en la aplicación web */                                 
....................     if (stricmp(key,boton4_key)==0) 
0A5D6:  MOVFF  377,37B
0A5DA:  MOVFF  376,37A
0A5DE:  MOVLW  03
0A5E0:  MOVLB  3
0A5E2:  MOVWF  x7D
0A5E4:  MOVLW  0D
0A5E6:  MOVWF  x7C
0A5E8:  MOVLB  0
0A5EA:  RCALL  A33C
0A5EC:  MOVF   01,F
0A5EE:  BNZ   A5F4
....................     {                                                                                          
....................       output_toggle(PIN_B3);                     
0A5F0:  BCF    F93.3
0A5F2:  BTG    F8A.3
....................    }  
....................    /* Se ejecutará al pulsar el botón "reboot 4" en la aplicación web */  
....................    if (stricmp(key,reboot4_key)==0)                                   
0A5F4:  MOVFF  377,37B
0A5F8:  MOVFF  376,37A
0A5FC:  MOVLW  03
0A5FE:  MOVLB  3
0A600:  MOVWF  x7D
0A602:  MOVLW  2C
0A604:  MOVWF  x7C
0A606:  MOVLB  0
0A608:  RCALL  A33C
0A60A:  MOVF   01,F
0A60C:  BNZ   A614
....................    { 
....................       output_low(PIN_B3); 
0A60E:  BCF    F93.3
0A610:  BCF    F8A.3
....................       elige_reboot4=1; 
0A612:  BSF    59.5
....................    } 
....................    /* Se ejecutará al pulsar el botón "Enviar texto" en la aplicación web */   
....................    if (stricmp(key,lcd_user)==0)                                                           
0A614:  MOVFF  377,37B
0A618:  MOVFF  376,37A
0A61C:  MOVLW  03
0A61E:  MOVLB  3
0A620:  MOVWF  x7D
0A622:  MOVLW  34
0A624:  MOVWF  x7C
0A626:  MOVLB  0
0A628:  RCALL  A33C
0A62A:  MOVF   01,F
0A62C:  BNZ   A646
....................    { 
....................      // printf("\r\n%s",val);  //Muestra en el lcd el texto recibido  
....................       strcpy(valid_user,val);                                                                          
0A62E:  MOVLW  02
0A630:  MOVWF  FEA
0A632:  MOVLW  CB
0A634:  MOVWF  FE9
0A636:  MOVFF  379,FE2
0A63A:  MOVFF  378,FE1
0A63E:  MOVF   FE7,F
0A640:  MOVFF  FE6,FEE
0A644:  BNZ   A63E
....................    }  
....................     
....................    /* Se ejecutará al pulsar el botón "Enviar texto" en la aplicación web */                 
....................    if (stricmp(key,lcd_pass)==0) 
0A646:  MOVFF  377,37B
0A64A:  MOVFF  376,37A
0A64E:  MOVLW  03
0A650:  MOVLB  3
0A652:  MOVWF  x7D
0A654:  MOVLW  39
0A656:  MOVWF  x7C
0A658:  MOVLB  0
0A65A:  RCALL  A33C
0A65C:  MOVF   01,F
0A65E:  BNZ   A678
....................    {                     
....................      // printf("\r\n%s",val);  //Muestra en el lcd el texto recibido                                       
....................       strcpy(valid_pass,val);                                                          
0A660:  MOVLW  02
0A662:  MOVWF  FEA
0A664:  MOVLW  D3
0A666:  MOVWF  FE9
0A668:  MOVFF  379,FE2
0A66C:  MOVFF  378,FE1
0A670:  MOVF   FE7,F
0A672:  MOVFF  FE6,FEE
0A676:  BNZ   A670
....................    }                                                                                 
0A678:  GOTO   A6E2 (RETURN)
.................... }        
.................... /**************************  FUNCIÓN FORMAT CHAR  *****************************/ 
.................... /* Con  la función http_format_char  interconectamos las variables virtuales de  
.................... la página web con las variables del programa del PIC. Se encarga de enviar los  
.................... cambios producidos en la aplicación del PIC y reflejarlos en la aplicación web.  
.................... Muestra,por tanto, las lectura obtenidas por el PIC y las representa en la  
.................... aplicación de la página web       
....................  
.................... %0 es la variable virtual para representar el valor de la lectura del canal  
.................... analógico 
.................... %1 es la variable virtual para representar el valor de la lectura del bit 0 del  
.................... puerto E. 
.................... */                                                                                          
.................... int8 http_format_char(int32 file, char id, char *str, int8 max_ret) {            
*
0B45A:  MOVLB  3
0B45C:  CLRF   x8B
....................    char new_str[20]; 
....................    int8 len=0;                                             
....................    int8 AD0; 
....................    int8 RC0; 
....................    int8 RB0; 
....................    int8 RB1; 
....................    int8 RB2; 
....................    int8 RB3; 
....................                       
....................    *str=0; 
0B45E:  MOVFF  374,FE9
0B462:  MOVFF  375,FEA
0B466:  CLRF   FEF
....................  
....................    switch(id) { 
0B468:  MOVF   x73,W
0B46A:  XORLW  30
0B46C:  MOVLB  0
0B46E:  BZ    B48A
0B470:  XORLW  01
0B472:  BZ    B4EE
0B474:  XORLW  03
0B476:  BZ    B524
0B478:  XORLW  01
0B47A:  BZ    B55A
0B47C:  XORLW  07
0B47E:  BTFSC  FD8.2
0B480:  BRA    B590
0B482:  XORLW  01
0B484:  BTFSC  FD8.2
0B486:  BRA    B5C6
0B488:  BRA    B5FC
....................        case '0': 
....................        set_adc_channel(0); 
0B48A:  MOVLW  00
0B48C:  MOVWF  01
0B48E:  MOVF   FC2,W
0B490:  ANDLW  C3
0B492:  IORWF  01,W
0B494:  MOVWF  FC2
....................          delay_us(100); 
0B496:  MOVLW  64
0B498:  MOVLB  3
0B49A:  MOVWF  x92
0B49C:  MOVLB  0
0B49E:  BRA    B252
....................          AD0=read_adc(); 
0B4A0:  BSF    FC2.1
0B4A2:  BTFSC  FC2.1
0B4A4:  BRA    B4A2
0B4A6:  MOVFF  FC3,38C
0B4AA:  MOVLB  3
....................          sprintf(new_str,"0x%X",AD0);                        
0B4AC:  MOVLW  03
0B4AE:  MOVLB  1
0B4B0:  MOVWF  x54
0B4B2:  MOVLW  77
0B4B4:  MOVWF  x53
0B4B6:  MOVLW  30
0B4B8:  MOVLB  3
0B4BA:  MOVWF  x98
0B4BC:  MOVLB  0
0B4BE:  RCALL  B278
0B4C0:  MOVLW  78
0B4C2:  MOVLB  3
0B4C4:  MOVWF  x98
0B4C6:  MOVLB  0
0B4C8:  RCALL  B278
0B4CA:  MOVFF  38C,392
0B4CE:  MOVLW  37
0B4D0:  MOVLB  3
0B4D2:  MOVWF  x93
0B4D4:  MOVLB  0
0B4D6:  BRA    B29A
....................          len=strlen(new_str); 
0B4D8:  MOVLW  03
0B4DA:  MOVLB  3
0B4DC:  MOVWF  x93
0B4DE:  MOVLW  77
0B4E0:  MOVWF  x92
0B4E2:  MOVLB  0
0B4E4:  CALL   9BEC
0B4E8:  MOVFF  01,38B
....................       break; 
0B4EC:  BRA    B602
....................        case '1': 
....................          RC0=bit_test(portc,0); 
0B4EE:  MOVLB  3
0B4F0:  CLRF   x8D
0B4F2:  BTFSC  F82.0
0B4F4:  INCF   x8D,F
....................          sprintf(new_str,"%d",RC0);                     
0B4F6:  MOVLW  03
0B4F8:  MOVLB  1
0B4FA:  MOVWF  x54
0B4FC:  MOVLW  77
0B4FE:  MOVWF  x53
0B500:  MOVFF  38D,392
0B504:  MOVLW  18
0B506:  MOVLB  3
0B508:  MOVWF  x93
0B50A:  MOVLB  0
0B50C:  RCALL  B30E
....................          len=strlen(new_str); 
0B50E:  MOVLW  03
0B510:  MOVLB  3
0B512:  MOVWF  x93
0B514:  MOVLW  77
0B516:  MOVWF  x92
0B518:  MOVLB  0
0B51A:  CALL   9BEC
0B51E:  MOVFF  01,38B
....................       break; 
0B522:  BRA    B602
....................        case '2':                       
....................        RB0=bit_test(portb,0); 
0B524:  MOVLB  3
0B526:  CLRF   x8E
0B528:  BTFSC  F81.0
0B52A:  INCF   x8E,F
....................          //strcpy(user1,valid_user);    
....................          sprintf(new_str,"%d",RB0); 
0B52C:  MOVLW  03
0B52E:  MOVLB  1
0B530:  MOVWF  x54
0B532:  MOVLW  77
0B534:  MOVWF  x53
0B536:  MOVFF  38E,392
0B53A:  MOVLW  18
0B53C:  MOVLB  3
0B53E:  MOVWF  x93
0B540:  MOVLB  0
0B542:  RCALL  B30E
....................          len=strlen(new_str); 
0B544:  MOVLW  03
0B546:  MOVLB  3
0B548:  MOVWF  x93
0B54A:  MOVLW  77
0B54C:  MOVWF  x92
0B54E:  MOVLB  0
0B550:  CALL   9BEC
0B554:  MOVFF  01,38B
....................       break; 
0B558:  BRA    B602
....................        case '3':                                                              
....................        RB1=bit_test(portb,1); 
0B55A:  MOVLB  3
0B55C:  CLRF   x8F
0B55E:  BTFSC  F81.1
0B560:  INCF   x8F,F
....................          //strcpy(pass1,valid_pass);                                    
....................          sprintf(new_str,"%d",RB1); 
0B562:  MOVLW  03
0B564:  MOVLB  1
0B566:  MOVWF  x54
0B568:  MOVLW  77
0B56A:  MOVWF  x53
0B56C:  MOVFF  38F,392
0B570:  MOVLW  18
0B572:  MOVLB  3
0B574:  MOVWF  x93
0B576:  MOVLB  0
0B578:  RCALL  B30E
....................          len=strlen(new_str); 
0B57A:  MOVLW  03
0B57C:  MOVLB  3
0B57E:  MOVWF  x93
0B580:  MOVLW  77
0B582:  MOVWF  x92
0B584:  MOVLB  0
0B586:  CALL   9BEC
0B58A:  MOVFF  01,38B
....................       break;   
0B58E:  BRA    B602
....................        case '4': 
....................        RB2=bit_test(portb,2); 
0B590:  MOVLB  3
0B592:  CLRF   x90
0B594:  BTFSC  F81.2
0B596:  INCF   x90,F
....................          //strcpy(user1,valid_user);    
....................          sprintf(new_str,"%d",RB2); 
0B598:  MOVLW  03
0B59A:  MOVLB  1
0B59C:  MOVWF  x54
0B59E:  MOVLW  77
0B5A0:  MOVWF  x53
0B5A2:  MOVFF  390,392
0B5A6:  MOVLW  18
0B5A8:  MOVLB  3
0B5AA:  MOVWF  x93
0B5AC:  MOVLB  0
0B5AE:  RCALL  B30E
....................          len=strlen(new_str); 
0B5B0:  MOVLW  03
0B5B2:  MOVLB  3
0B5B4:  MOVWF  x93
0B5B6:  MOVLW  77
0B5B8:  MOVWF  x92
0B5BA:  MOVLB  0
0B5BC:  CALL   9BEC
0B5C0:  MOVFF  01,38B
....................       break;         
0B5C4:  BRA    B602
....................        case '5':                             
....................        RB3=bit_test(portb,3); 
0B5C6:  MOVLB  3
0B5C8:  CLRF   x91
0B5CA:  BTFSC  F81.3
0B5CC:  INCF   x91,F
....................          //strcpy(user1,valid_user);                                                                                                      
....................          sprintf(new_str,"%d",RB3); 
0B5CE:  MOVLW  03
0B5D0:  MOVLB  1
0B5D2:  MOVWF  x54
0B5D4:  MOVLW  77
0B5D6:  MOVWF  x53
0B5D8:  MOVFF  391,392
0B5DC:  MOVLW  18
0B5DE:  MOVLB  3
0B5E0:  MOVWF  x93
0B5E2:  MOVLB  0
0B5E4:  RCALL  B30E
....................          len=strlen(new_str); 
0B5E6:  MOVLW  03
0B5E8:  MOVLB  3
0B5EA:  MOVWF  x93
0B5EC:  MOVLW  77
0B5EE:  MOVWF  x92
0B5F0:  MOVLB  0
0B5F2:  CALL   9BEC
0B5F6:  MOVFF  01,38B
....................       break; 
0B5FA:  BRA    B602
....................       default: 
....................       len=0; 
0B5FC:  MOVLB  3
0B5FE:  CLRF   x8B
0B600:  MOVLB  0
....................    }                           
....................  
....................    if (len)strncpy(str, new_str, max_ret); 
0B602:  MOVLB  3
0B604:  MOVF   x8B,F
0B606:  BZ    B628
0B608:  MOVFF  375,393
0B60C:  MOVFF  374,392
0B610:  MOVLW  03
0B612:  MOVWF  x95
0B614:  MOVLW  77
0B616:  MOVWF  x94
0B618:  CLRF   x97
0B61A:  MOVFF  376,396
0B61E:  MOVLB  0
0B620:  BRA    B3CA
0B622:  MOVLB  0
0B624:  BRA    B638
0B626:  MOVLB  3
....................    else  *str=0; 
0B628:  MOVFF  375,03
0B62C:  MOVFF  374,FE9
0B630:  MOVFF  375,FEA
0B634:  CLRF   FEF
0B636:  MOVLB  0
....................     
....................    return(len); 
0B638:  MOVLB  3
0B63A:  MOVFF  38B,01
0B63E:  MOVLB  0
0B640:  GOTO   B8FA (RETURN)
.................... } 
....................  
....................                                       
.................... /***************************  FUNCIÓN GET PAGE   ******************************/ 
.................... /* Esta función devuelve la posición de memoria donde se encuentra la página web                           
.................... a mostrar. En este caso se trata de una web con 2 páginas. Una principal index(/)  
.................... y una secundaria(/lecturas)                                                   */ 
....................                                                           
.................... int32 http_get_page(char *file_str)  
*
0A444:  MOVLB  3
0A446:  CLRF   x66
0A448:  CLRF   x65
0A44A:  CLRF   x64
0A44C:  CLRF   x63
.................... {                                                                                                                          
....................    int32 file_loc=0; 
....................    static char index[]="/";                                                                                  
....................    static char login[]="/login"; 
....................    static char lecturas[]="/lecturas";                                                           
....................                                             
....................    //printf("\r\nRequest %s ",file_str);      //Muestra en lcd solicitud 
....................  
....................    /* Busca la posición de memoria donde se encuentra la página solicitada */ 
....................    if (stricmp(file_str,index)==0)                 //Si es la principal...   
0A44E:  MOVFF  362,37B
0A452:  MOVFF  361,37A
0A456:  MOVLW  03
0A458:  MOVWF  x7D
0A45A:  MOVLW  3E
0A45C:  MOVWF  x7C
0A45E:  MOVLB  0
0A460:  RCALL  A33C
0A462:  MOVF   01,F
0A464:  BNZ   A47A
....................    { 
....................       file_loc=label_address(HTML_INDEX_PAGE);     //...toma su posición en la memoria         
0A466:  MOVLW  01
0A468:  MOVWF  03
0A46A:  MOVLW  E2
0A46C:  MOVLB  3
0A46E:  MOVWF  x63
0A470:  MOVFF  03,364
0A474:  CLRF   x65
0A476:  CLRF   x66
....................    }                                                                                                                                               
0A478:  BRA    A508
....................    else if (stricmp(file_str,login)==0)         //O si es la secundaria...                                   
0A47A:  MOVFF  362,37B
0A47E:  MOVFF  361,37A
0A482:  MOVLW  03
0A484:  MOVLB  3
0A486:  MOVWF  x7D
0A488:  MOVLW  40
0A48A:  MOVWF  x7C
0A48C:  MOVLB  0
0A48E:  RCALL  A33C
0A490:  MOVF   01,F
0A492:  BNZ   A4A8
....................    {  
....................           file_loc=label_address(HTML_LECTURAS_LOGIN);    //...toma su posición en la memoria                                                                                                             
0A494:  MOVLW  49
0A496:  MOVWF  03
0A498:  MOVLW  AE
0A49A:  MOVLB  3
0A49C:  MOVWF  x63
0A49E:  MOVFF  03,364
0A4A2:  CLRF   x65
0A4A4:  CLRF   x66
....................    }     
0A4A6:  BRA    A508
....................    else if (stricmp(file_str,lecturas)==0)         //O si es la secundaria... 
0A4A8:  MOVFF  362,37B
0A4AC:  MOVFF  361,37A
0A4B0:  MOVLW  03
0A4B2:  MOVLB  3
0A4B4:  MOVWF  x7D
0A4B6:  MOVLW  47
0A4B8:  MOVWF  x7C
0A4BA:  MOVLB  0
0A4BC:  RCALL  A33C
0A4BE:  MOVF   01,F
0A4C0:  BNZ   A50A
....................    {                                                                                                 
....................  
....................  
....................        if ((stricmp(valid_user,memouser)==0) && (stricmp(valid_pass,memopass)==0)) 
0A4C2:  MOVLW  02
0A4C4:  MOVLB  3
0A4C6:  MOVWF  x7B
0A4C8:  MOVLW  CB
0A4CA:  MOVWF  x7A
0A4CC:  MOVLW  02
0A4CE:  MOVWF  x7D
0A4D0:  MOVLW  DB
0A4D2:  MOVWF  x7C
0A4D4:  MOVLB  0
0A4D6:  RCALL  A33C
0A4D8:  MOVF   01,F
0A4DA:  BNZ   A50A
0A4DC:  MOVLW  02
0A4DE:  MOVLB  3
0A4E0:  MOVWF  x7B
0A4E2:  MOVLW  D3
0A4E4:  MOVWF  x7A
0A4E6:  MOVLW  02
0A4E8:  MOVWF  x7D
0A4EA:  MOVLW  E3
0A4EC:  MOVWF  x7C
0A4EE:  MOVLB  0
0A4F0:  RCALL  A33C
0A4F2:  MOVF   01,F
0A4F4:  BNZ   A50A
....................     { 
....................      file_loc=label_address(HTML_LECTURAS_PAGE);    //...toma su posición en la memoria 
0A4F6:  MOVLW  4B
0A4F8:  MOVWF  03
0A4FA:  MOVLW  EE
0A4FC:  MOVLB  3
0A4FE:  MOVWF  x63
0A500:  MOVFF  03,364
0A504:  CLRF   x65
0A506:  CLRF   x66
0A508:  MOVLB  0
....................      //printf("\r\n(Entro Aqui Por clave y usuario)");       //...muestra en lcd mensaje  
....................     }     
....................                                                                                                               
....................    }                                                                                 
....................    /* Muestra en lcd la página solicitada */ 
....................    /*   
....................    if (file_loc) 
....................    {                                  //Si existe... 
....................       printf("\r\n(FILE=%LU)",file_loc);    //...muestra en lcd pos. de memoria 
....................    } 
....................    else 
....................    {                                           //Si no existe... 
....................       printf("\r\n(File Not Found)");       //...muestra en lcd mensaje 
....................    } 
....................    */ 
....................    /* Devuelve la posición en la memoria donde se encuentra la página a mostrar */ 
....................                                                                                         
....................     return(file_loc);                                                                                                                                                                     
0A50A:  MOVFF  363,00
0A50E:  MOVFF  364,01
0A512:  MOVFF  365,02
0A516:  MOVFF  366,03
0A51A:  GOTO   BE78 (RETURN)
.................... }   
....................                                                                                                              
....................                      
....................                                                                                 
.................... /************************** FUNCIÓN PRINCIPAL *********************************/ 
.................... void main(void) { 
*
0C8F4:  CLRF   FF8
0C8F6:  BCF    FD0.7
0C8F8:  BSF    07.7
0C8FA:  MOVLW  60
0C8FC:  MOVWF  FD3
0C8FE:  BSF    F9B.6
0C900:  BCF    F9B.7
0C902:  CLRF   52
0C904:  CLRF   51
0C906:  CLRF   53
0C908:  CLRF   54
0C90A:  CLRF   5C
0C90C:  CLRF   5B
0C90E:  MOVLW  04
0C910:  MOVWF  5F
0C912:  CLRF   5E
0C914:  MOVLB  1
0C916:  CLRF   x54
0C918:  CLRF   x53
0C91A:  BCF    59.2
0C91C:  BCF    59.3
0C91E:  BCF    59.4
0C920:  BCF    59.5
0C922:  MOVLB  2
0C924:  CLRF   xEB
0C926:  CLRF   xEA
0C928:  CLRF   xE9
0C92A:  CLRF   xE8
0C92C:  CLRF   xEF
0C92E:  CLRF   xEE
0C930:  CLRF   xED
0C932:  CLRF   xEC
0C934:  CLRF   xF3
0C936:  CLRF   xF2
0C938:  CLRF   xF1
0C93A:  CLRF   xF0
0C93C:  CLRF   xF7
0C93E:  CLRF   xF6
0C940:  CLRF   xF5
0C942:  CLRF   xF4
0C944:  MOVLW  00
0C946:  MOVWF  F7E
0C948:  BCF    FC1.4
0C94A:  BCF    FC1.5
0C94C:  MOVF   F7F,W
0C94E:  ANDLW  E0
0C950:  MOVWF  F7F
0C952:  BCF    F79.5
0C954:  BCF    F79.4
0C956:  CLRF   F7A
0C958:  CLRF   F7B
0C95A:  BCF    59.1
0C95C:  BRA    CA0A
0C95E:  DATA 02,00
0C960:  DATA 4A,00
0C962:  DATA 00,01
0C964:  DATA 00,5D
0C966:  DATA 00,0A
0C968:  DATA 41,16
0C96A:  DATA 00,03
0C96C:  DATA 80,FE
0C96E:  DATA 00,01
0C970:  DATA 29,41
0C972:  DATA 2A,00
0C974:  DATA 1C,01
0C976:  DATA 55,20
0C978:  DATA 00,3F
0C97A:  DATA 00,47
0C97C:  DATA 45,54
0C97E:  DATA 00,50
0C980:  DATA 4F,53
0C982:  DATA 54,00
0C984:  DATA 43,6F
0C986:  DATA 6E,74
0C988:  DATA 65,6E
0C98A:  DATA 74,2D
0C98C:  DATA 4C,65
0C98E:  DATA 6E,67
0C990:  DATA 74,68
0C992:  DATA 3A,FF
0C994:  DATA C0,00
0C996:  DATA 0B,C0
0C998:  DATA 00,56
0C99A:  DATA 42,85
0C99C:  DATA 00,0D
0C99E:  DATA 80,63
0C9A0:  DATA 68,61
0C9A2:  DATA 72,6C
0C9A4:  DATA 69,65
0C9A6:  DATA 00,31
0C9A8:  DATA 32,33
0C9AA:  DATA 34,00
0C9AC:  DATA 59,02
0C9AE:  DATA F8,62
0C9B0:  DATA 6F,74
0C9B2:  DATA 6F,6E
0C9B4:  DATA 31,00
0C9B6:  DATA 62,6F
0C9B8:  DATA 74,6F
0C9BA:  DATA 6E,32
0C9BC:  DATA 00,62
0C9BE:  DATA 6F,74
0C9C0:  DATA 6F,6E
0C9C2:  DATA 33,00
0C9C4:  DATA 62,6F
0C9C6:  DATA 74,6F
0C9C8:  DATA 6E,34
0C9CA:  DATA 00,72
0C9CC:  DATA 65,62
0C9CE:  DATA 6F,6F
0C9D0:  DATA 74,31
0C9D2:  DATA 00,72
0C9D4:  DATA 65,62
0C9D6:  DATA 6F,6F
0C9D8:  DATA 74,32
0C9DA:  DATA 00,72
0C9DC:  DATA 65,62
0C9DE:  DATA 6F,6F
0C9E0:  DATA 74,33
0C9E2:  DATA 00,72
0C9E4:  DATA 65,62
0C9E6:  DATA 6F,6F
0C9E8:  DATA 74,34
0C9EA:  DATA 00,75
0C9EC:  DATA 73,65
0C9EE:  DATA 72,00
0C9F0:  DATA 70,61
0C9F2:  DATA 73,73
0C9F4:  DATA 00,2F
0C9F6:  DATA 00,2F
0C9F8:  DATA 6C,6F
0C9FA:  DATA 67,69
0C9FC:  DATA 6E,00
0C9FE:  DATA 2F,6C
0CA00:  DATA 65,63
0CA02:  DATA 74,75
0CA04:  DATA 72,61
0CA06:  DATA 73,00
0CA08:  DATA 00,00
0CA0A:  MOVLW  00
0CA0C:  MOVWF  FF8
0CA0E:  MOVLW  C9
0CA10:  MOVWF  FF7
0CA12:  MOVLW  5E
0CA14:  MOVWF  FF6
0CA16:  TBLRD*+
0CA18:  MOVF   FF5,W
0CA1A:  MOVWF  00
0CA1C:  XORLW  00
0CA1E:  BZ    CA46
0CA20:  TBLRD*+
0CA22:  MOVF   FF5,W
0CA24:  MOVWF  01
0CA26:  BTFSC  FE8.7
0CA28:  BRA    CA34
0CA2A:  ANDLW  0F
0CA2C:  MOVWF  FEA
0CA2E:  TBLRD*+
0CA30:  MOVFF  FF5,FE9
0CA34:  BTFSC  01.6
0CA36:  TBLRD*+
0CA38:  BTFSS  01.6
0CA3A:  TBLRD*+
0CA3C:  MOVFF  FF5,FEE
0CA40:  DCFSNZ 00,F
0CA42:  BRA    CA16
0CA44:  BRA    CA38
0CA46:  CLRF   FF8
....................  
....................    /* Habilitación y configuración del canal analógico 0 */ 
....................    setup_adc(ADC_CLOCK_INTERNAL);//setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0);                                            
0CA48:  MOVF   FC0,W
0CA4A:  ANDLW  C0
0CA4C:  IORLW  07
0CA4E:  MOVWF  FC0
0CA50:  BSF    FC0.7
0CA52:  BSF    FC2.0
....................    setup_adc_ports(sAN0); 
0CA54:  MOVLW  01
0CA56:  MOVWF  F7E
0CA58:  BCF    FC1.4
0CA5A:  BCF    FC1.5
0CA5C:  MOVF   F7F,W
0CA5E:  ANDLW  E0
0CA60:  MOVWF  F7F
....................    set_adc_channel(0); 
0CA62:  MOVLW  00
0CA64:  MOVWF  01
0CA66:  MOVF   FC2,W
0CA68:  ANDLW  C3
0CA6A:  IORWF  01,W
0CA6C:  MOVWF  FC2
....................    delay_ms(1); 
0CA6E:  MOVLW  01
0CA70:  MOVLB  3
0CA72:  MOVWF  x52
0CA74:  MOVLB  0
0CA76:  CALL   637E
....................                                             
....................    /*Reset de las salidas */ 
....................    output_high(PIN_B0); 
0CA7A:  BCF    F93.0
0CA7C:  BSF    F8A.0
....................    output_high(PIN_B1); 
0CA7E:  BCF    F93.1
0CA80:  BSF    F8A.1
....................    output_high(PIN_B2); 
0CA82:  BCF    F93.2
0CA84:  BSF    F8A.2
....................    output_high(PIN_B3);             
0CA86:  BCF    F93.3
0CA88:  BSF    F8A.3
....................      
....................    /* Inicialización del lcd */ 
....................    //lcd_init(); 
....................    //printf("\r\nAltec WEB SERVER");   //Mensaje de inicio en lcd  
....................    delay_ms(1000); 
0CA8A:  MOVLW  04
0CA8C:  MOVLB  3
0CA8E:  MOVWF  x51
0CA90:  MOVLW  FA
0CA92:  MOVWF  x52
0CA94:  MOVLB  0
0CA96:  CALL   637E
0CA9A:  MOVLB  3
0CA9C:  DECFSZ x51,F
0CA9E:  BRA    CA90
....................    
....................    /* Inicialización del Stack */ 
....................    MACAddrInit(); //Se asigna la dirección MAC elegida  
0CAA0:  MOVLB  0
0CAA2:  GOTO   63A6
....................    IPAddrInit();  //Se asigna IP, mascara de red y puerta de enlace elegidos 
0CAA6:  GOTO   63C0
....................    StackInit();   //Inicializa el stack                                                                   
0CAAA:  GOTO   6CB2
....................     
....................    /* Muestra la IP elegida en lcd */ 
....................    //printf("\r\n IP: %u.%u.%u.%u", MY_IP_BYTE1, MY_IP_BYTE2, MY_IP_BYTE3, MY_IP_BYTE4); 
....................    //printf("\r\n Puerto: %u", HTTP_SOCKET);  
....................    delay_ms(10);                                       
0CAAE:  MOVLW  0A
0CAB0:  MOVLB  3
0CAB2:  MOVWF  x52
0CAB4:  MOVLB  0
0CAB6:  CALL   637E
....................     
....................                                           
....................       //fprintf(terminal,"Pass: %s", valid_pass); 
....................     
....................    while(TRUE) 
....................    {                                                                        
....................        /////////////////////////////////////////////////// 
....................        StackTask(); 
0CABA:  BRA    C6FA
....................        /////////////////////////////////////////////////// 
....................         
....................         
....................        //////////////////// REBOOT0 ////////////////////// 
....................        if (elige_reboot1) 
0CABC:  BTFSS  59.2
0CABE:  BRA    CAD4
....................        { 
....................          reboot1++; 
0CAC0:  MOVLW  01
0CAC2:  MOVLB  2
0CAC4:  ADDWF  xE8,F
0CAC6:  BTFSC  FD8.0
0CAC8:  INCF   xE9,F
0CACA:  BTFSC  FD8.2
0CACC:  INCF   xEA,F
0CACE:  BTFSC  FD8.2
0CAD0:  INCF   xEB,F
0CAD2:  MOVLB  0
....................        } 
....................         
....................        if(reboot1==100000) 
0CAD4:  MOVLB  2
0CAD6:  MOVF   xE8,W
0CAD8:  SUBLW  A0
0CADA:  BNZ   CAF8
0CADC:  MOVF   xE9,W
0CADE:  SUBLW  86
0CAE0:  BNZ   CAF8
0CAE2:  DECFSZ xEA,W
0CAE4:  BRA    CAF8
0CAE6:  MOVF   xEB,F
0CAE8:  BNZ   CAF8
....................        { 
....................          output_high(PIN_B0); 
0CAEA:  BCF    F93.0
0CAEC:  BSF    F8A.0
....................          elige_reboot1=0; 
0CAEE:  BCF    59.2
....................          reboot1=0; 
0CAF0:  CLRF   xEB
0CAF2:  CLRF   xEA
0CAF4:  CLRF   xE9
0CAF6:  CLRF   xE8
....................        } 
....................        //////////////////// FIN REBOOT0 ////////////////////// 
....................         
....................         
....................        //////////////////// REBOOT1 ////////////////////// 
....................         if (elige_reboot2) 
0CAF8:  BTFSS  59.3
0CAFA:  BRA    CB0C
....................        { 
....................          reboot2++; 
0CAFC:  MOVLW  01
0CAFE:  ADDWF  xEC,F
0CB00:  BTFSC  FD8.0
0CB02:  INCF   xED,F
0CB04:  BTFSC  FD8.2
0CB06:  INCF   xEE,F
0CB08:  BTFSC  FD8.2
0CB0A:  INCF   xEF,F
....................        } 
....................         
....................        if(reboot2==100000) 
0CB0C:  MOVF   xEC,W
0CB0E:  SUBLW  A0
0CB10:  BNZ   CB2E
0CB12:  MOVF   xED,W
0CB14:  SUBLW  86
0CB16:  BNZ   CB2E
0CB18:  DECFSZ xEE,W
0CB1A:  BRA    CB2E
0CB1C:  MOVF   xEF,F
0CB1E:  BNZ   CB2E
....................        { 
....................          output_high(PIN_B1); 
0CB20:  BCF    F93.1
0CB22:  BSF    F8A.1
....................          elige_reboot2=0; 
0CB24:  BCF    59.3
....................          reboot2=0; 
0CB26:  CLRF   xEF
0CB28:  CLRF   xEE
0CB2A:  CLRF   xED
0CB2C:  CLRF   xEC
....................        } 
....................        //////////////////// FIN REBOOT1 ////////////////////// 
....................         
....................         
....................        //////////////////// REBOOT2 ////////////////////// 
....................         if (elige_reboot3) 
0CB2E:  BTFSS  59.4
0CB30:  BRA    CB42
....................        { 
....................          reboot3++; 
0CB32:  MOVLW  01
0CB34:  ADDWF  xF0,F
0CB36:  BTFSC  FD8.0
0CB38:  INCF   xF1,F
0CB3A:  BTFSC  FD8.2
0CB3C:  INCF   xF2,F
0CB3E:  BTFSC  FD8.2
0CB40:  INCF   xF3,F
....................        } 
....................         
....................        if(reboot3==100000) 
0CB42:  MOVF   xF0,W
0CB44:  SUBLW  A0
0CB46:  BNZ   CB64
0CB48:  MOVF   xF1,W
0CB4A:  SUBLW  86
0CB4C:  BNZ   CB64
0CB4E:  DECFSZ xF2,W
0CB50:  BRA    CB64
0CB52:  MOVF   xF3,F
0CB54:  BNZ   CB64
....................        { 
....................          output_high(PIN_B2); 
0CB56:  BCF    F93.2
0CB58:  BSF    F8A.2
....................          elige_reboot3=0; 
0CB5A:  BCF    59.4
....................          reboot3=0; 
0CB5C:  CLRF   xF3
0CB5E:  CLRF   xF2
0CB60:  CLRF   xF1
0CB62:  CLRF   xF0
....................        } 
....................        //////////////////// FIN REBOOT2 ////////////////////// 
....................         
....................         
....................        //////////////////// REBOOT3 ////////////////////// 
....................         if (elige_reboot4) 
0CB64:  BTFSS  59.5
0CB66:  BRA    CB78
....................        { 
....................          reboot4++; 
0CB68:  MOVLW  01
0CB6A:  ADDWF  xF4,F
0CB6C:  BTFSC  FD8.0
0CB6E:  INCF   xF5,F
0CB70:  BTFSC  FD8.2
0CB72:  INCF   xF6,F
0CB74:  BTFSC  FD8.2
0CB76:  INCF   xF7,F
....................        } 
....................         
....................        if(reboot4==100000) 
0CB78:  MOVF   xF4,W
0CB7A:  SUBLW  A0
0CB7C:  BNZ   CB9A
0CB7E:  MOVF   xF5,W
0CB80:  SUBLW  86
0CB82:  BNZ   CB9A
0CB84:  DECFSZ xF6,W
0CB86:  BRA    CB9A
0CB88:  MOVF   xF7,F
0CB8A:  BNZ   CB9A
....................        { 
....................          output_high(PIN_B3); 
0CB8C:  BCF    F93.3
0CB8E:  BSF    F8A.3
....................          elige_reboot4=0; 
0CB90:  BCF    59.5
....................          reboot4=0; 
0CB92:  CLRF   xF7
0CB94:  CLRF   xF6
0CB96:  CLRF   xF5
0CB98:  CLRF   xF4
....................        } 
0CB9A:  MOVLB  0
0CB9C:  BRA    CABA
....................        //////////////////// FIN REBOOT3 ////////////////////// 
....................    }     
.................... }                                
....................  
0CB9E:  SLEEP 

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 1E19   NOPUT NOBROWNOUT BORV18 NOWDT WDT32768
   Word  3: 8F00   CCP2C1 PBADEN LPT1OSC HFOFST MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
